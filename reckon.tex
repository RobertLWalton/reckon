%  RECKON (Personal Reckoning Langauge)
%
% File:         reckon.tex
% Author:       Bob Walton (walton@deas.harvard.edu)
% Date:		See \date below.

% Possible alternative names:
%
%	CASTLE  Calculation and Simulation Total Language Environment
%	RECKON	Personal Reckoning Language
%	MFL	Multi-Facetted Language
%	ROPE	Really Omni Programming Environment
%	RIPE	Robert's Information Processing Environment
%	AGILE	Another Goofy Information Language and Environment
%	OMNI	Omni-Programming Language
%	OPL	Omni-Programming Language
%	OPE	Omni-Programming Environment
%	APE	A Programming Environment
%	RUG	Really Useful Gadget
%	RUCL	Really Useful Computer Language
  
\documentclass[12pt]{article}

\usepackage{makeidx}
\usepackage{pictex}

\makeindex

\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}
\raggedbottom

\setlength{\unitlength}{1in}

\pagestyle{headings}
\setlength{\parindent}{0.0in}
\setlength{\parskip}{1ex}

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}
\newcommand{\subsubsubsection}[1]{\paragraph[#1]{#1.}}
\newcommand{\subsubsubsubsection}[1]{\subparagraph[#1]{#1.}}

% Begin \tableofcontents surgery.

\newcount\AtCatcode
\AtCatcode=\catcode`@
\catcode `@=11	% @ is now a letter

\renewcommand{\contentsname}{}
\renewcommand\l@section{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\l@table{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\tableofcontents{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}}%
    \item\@starttoc{toc}%
    \end{list}}
\renewcommand\listoftables{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}%
	      }%
    \item\@starttoc{lot}%
    \end{list}}

\catcode `@=\AtCatcode	% @ is now restored

% End \tableofcontents surgery.

\newcommand{\CN}[2]%	Change Notice.
    {\hspace*{0in}\marginpar{\sloppy \raggedright \it \footnotesize
     $^{\mbox{#1}}$#2}}
    % Change notice.

\newcommand{\key}[1]{{\bf \em #1}\index{#1}}
\newcommand{\mkey}[2]{{\bf \em #1}\index{#1!#2}}
\newcommand{\skey}[2]{{\bf \em #1#2}\index{#1}}
\newcommand{\ikey}[2]{{\bf \em #1}\index{#2}}
\newcommand{\ttkey}[1]{{\tt \bf #1}\index{#1@{\tt #1}}}
% < and > do not work for \tt \bf, hence:
\newcommand{\ttnbkey}[1]{{\tt #1}\index{#1@{\tt #1}}}
\newcommand{\ttmnbkey}[2]{{\tt #1}\index{#1@{\tt #1}!#2}}
\newcommand{\ttmkey}[2]{{\tt \bf #1}\index{#1@{\tt #1}!#2}}
\newcommand{\ttdkey}[1]{{\tt \bf .#1}\index{#1@{\tt .#1}}}
\newcommand{\ttnbdkey}[1]{{\tt .#1}\index{#1@{\tt .#1}}}
\newcommand{\ttindex}[1]{\index{#1@{\tt #1}}}
\newcommand{\ttmindex}[2]{\index{#1@{\tt #1}!#2}}
\newcommand{\emkey}[1]{{\bf \em #1}\index{#1@{\em #1}}}
\newcommand{\emskey}[2]{{\bf \em #1#2}\index{#1@{\em #1}}}
\newcommand{\emikey}[2]{{\bf \em #1}\index{#2}}
\newcommand{\emindex}[1]{\index{#1@{\em #1}}}

\newcommand{\opt}{$^!$}

\newcommand{\itemref}[1]{\ref{#1}$\,^{p\,\pageref{#1}}$}
\newcommand{\secref}[1]{\ref{#1}$\,^{p\,\pageref{#1}}$}
\newcommand{\stepref}[1]{\ref{#1}\,$^{p\,\pageref{#1}}$}
\newcommand{\appref}[1]{\ref{#1}$\,^{p\,\pageref{#1}}$}
\newcommand{\figref}[1]{\ref{#1}$\,^{p\,\pageref{#1}}$}
\newcommand{\pagref}[1]{p\pageref{#1}}

\newcommand{\EOL}{\penalty \exhyphenpenalty}

\newcount\TildeCatcode
\TildeCatcode=\catcode`\~
\catcode`~=12
\newcommand{\Tilde}{~}
\catcode`~=\TildeCatcode

\newcount\CircumflexCatcode
\CircumflexCatcode=\catcode`\^
\catcode`^=12
\newcommand{\Circumflex}{^}
\catcode`^=\CircumflexCatcode

\newcount\BraCatcode
\BraCatcode=\catcode`\<
\catcode`<=12
\newcommand{\Bra}{<}
\catcode`<=\BraCatcode

\newcount\KetCatcode
\KetCatcode=\catcode`\>
\catcode`>=12
\newcommand{\Ket}{>}
\catcode`>=\KetCatcode

\newcount\CurlyBraCatcode
\newcount\CurlyKetCatcode
\newcount\SquareBraCatcode
\newcount\SquareKetCatcode
\CurlyBraCatcode=\catcode`{
\CurlyKetCatcode=\catcode`}
\SquareBraCatcode=\catcode`[
\SquareKetCatcode=\catcode`]

\catcode`{=\SquareBraCatcode
\catcode`}=\SquareKetCatcode
\catcode`[=\CurlyBraCatcode
\catcode`]=\CurlyKetCatcode

\newcommand[\CurlyBra][{]
\newcommand[\CurlyKet][}]

\catcode`{=\CurlyBraCatcode
\catcode`}=\CurlyKetCatcode
\catcode`[=\SquareBraCatcode
\catcode`]=\SquareKetCatcode

\newcommand{\ttbrackets}{%
    \renewcommand{\{}{\CurlyBra}%
    \renewcommand{\}}{\CurlyKet}}

\newsavebox{\TILDEBOX}
\begin{lrbox}{\TILDEBOX}
\verb|~|
\end{lrbox}
\newcommand{\TILDE}{\usebox{\TILDEBOX}}

\newsavebox{\BACKSLASHBOX}
\begin{lrbox}{\BACKSLASHBOX}
\verb|\|
\end{lrbox}
\newcommand{\BACKSLASH}{\usebox{\BACKSLASHBOX}}

\newsavebox{\LEFTBRACKETBOX}
\begin{lrbox}{\LEFTBRACKETBOX}
\verb|{|
\end{lrbox}
\newcommand{\LEFTBRACKET}{\usebox{\LEFTBRACKETBOX}}

\newsavebox{\RIGHTBRACKETBOX}
\begin{lrbox}{\RIGHTBRACKETBOX}
\verb|}|
\end{lrbox}
\newcommand{\RIGHTBRACKET}{\usebox{\RIGHTBRACKETBOX}}

\newsavebox{\UNDERLINEBOX}
\begin{lrbox}{\UNDERLINEBOX}
\verb|_|
\end{lrbox}
\newcommand{\UNDERLINE}{\usebox{\UNDERLINEBOX}}

\newsavebox{\CIRCUMFLEXBOX}
\begin{lrbox}{\CIRCUMFLEXBOX}
\verb|^|
\end{lrbox}
\newcommand{\CIRCUMFLEX}{\usebox{\CIRCUMFLEXBOX}}

\newsavebox{\BARBOX}
\begin{lrbox}{\BARBOX}
\verb/|/
\end{lrbox}
\newcommand{\BAR}{\usebox{\BARBOX}}

\newsavebox{\LESSTHANBOX}
\begin{lrbox}{\LESSTHANBOX}
\verb/</
\end{lrbox}
\newcommand{\LESSTHAN}{\usebox{\LESSTHANBOX}}

\newsavebox{\GREATERTHANBOX}
\begin{lrbox}{\GREATERTHANBOX}
\verb/>/
\end{lrbox}
\newcommand{\GREATERTHAN}{\usebox{\GREATERTHANBOX}}

\newlength{\figurewidth}
\setlength{\figurewidth}{\textwidth}
\addtolength{\figurewidth}{-0.40in}

\newsavebox{\figurebox}

\newenvironment{boxedfigure}[1][!btp]%
	{\begin{figure*}[#1]
	 \begin{lrbox}{\figurebox}
	 \begin{minipage}{\figurewidth}

	 \vspace*{1ex}}%
	{
	 \vspace*{1ex}

	 \end{minipage}
	 \end{lrbox}
	 \begin{center}
	 \fbox{\hspace*{0.1in}\usebox{\figurebox}\hspace*{0.1in}}
	 \end{center}
	 \end{figure*}}

\newenvironment{indpar}[1][0.3in]%
	{\begin{list}{}%
		     {\setlength{\itemsep}{0in}%
		      \setlength{\topsep}{0in}%
		      \setlength{\parsep}{1ex}%
		      \setlength{\labelwidth}{#1}%
		      \setlength{\leftmargin}{#1}%
		      \addtolength{\leftmargin}{\labelsep}}%
	 \item}%
	{\end{list}}

\newenvironment{labpar}[2][0.3in]%
	{\begin{list}{}%
		     {\setlength{\itemsep}{0in}%
		      \setlength{\topsep}{0in}%
		      \setlength{\parsep}{1ex}%
		      \setlength{\labelwidth}{#1}%
		      \setlength{\leftmargin}{#1}%
		      \addtolength{\leftmargin}{\labelsep}}%
	 \item[#2]}%
	{\end{list}}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{lemma}[theorem]{Lemma}

\begin{document}
        
\title{Personal Reckoning Lanauage\\[2ex]
       RECKON\\[2ex]
       (Draft 1b)}

\author{Robert L. Walton\thanks{Copyright 2008 Robert L. Walton.
Permission to copy this document verbatim is granted by the author
to the public.  This document was partly inspired
by teaching courses at Suffolk University, and by the work of Thomas
Cheatham and Stuart Shieber.}}

\date{April 17, 2009}
 
\maketitle

\newpage
\begin{center}
\large \bf Table of Contents
\end{center}

\bigskip

\tableofcontents 

\newpage

\section{Introduction}

This document describes the programming language RECKON.  RECKON,
for what its worth, stands for `Personal Reckoning Lnaguage',
which hints at its purpose.

RECKON is designed for naive programmers: that is, for people who may never
be able to program computers well.  It is a fairly simple language with
powerful data types that make it easier to write small programs
that do a variety of tasks a person might want to do.  Generally
the tasks fall into the categories of calculating things (taxes,
probabilities, statistics) or simulating things
(computer games, construction designs, mathematics demonstrations).
Included are:

\begin{center}
\begin{tabular}{l}
Calculations that might be done with a spreadsheet. \\
Drawing pictures. \\
Simulating popular board games and creating new ones. \\
Creating simple computer games, including dialog games. \\
Computing and analyzing documents. \\
Doing elementary algebra and calculus problems. \\
Doing matrix calculations. \\ 
Calculating basic probabilities and statistics. \\
Simulating two and three dimensional objects. \\
Simulating simple electrical, mechanical, chemical, and biological systems.\\
Solving problems in elementary logic. \\
\end{tabular}
\end{center}

There are many computer languages that have some powerful data type that adapts
them for a specific kind of computation.  RECKON tries to combine these.
Some previous computer languages that have influenced RECKON, and
the data types they particularly support, are:

\begin{center}
\begin{tabular}{l@{\hspace{0.5in}}l}
Various Spreadsheets		& Spreadsheets \\
Various Data Base Languages	& Data Bases \\
Various Script Languages	& Documents \\
MATLAB				& Matrices \\
Mathematica			& Mathematical Formulae \\
TCL				& Character Strings and Lists \\
Lisp				& Words and Phrases \\
PROLOG				& Logical Expressions \\
\end{tabular}
\end{center}

RECKON is \underline{not} designed to be a computer-efficient language.
It is designed to be person-efficient, and to do small calculations
rapidly enough with inexpensive modern computers.

\section{Remarks}

RECKON was created as an answer to the question: what programming language
should you teach beginning programming students who do not have the talent
or inclination to become serious programmers?  The initial answer, that it does
not matter provided you implement some powerful types of data in the
language you choose, has a flaw.  The flaw is that without the right powerful
data types, the language will be useless to the students after the course
is over.  So what is needed is a programming language that will be useful
to students after a first course in programming, and the essence of
such a language is the integration within it of many powerful and useful
data types.

The basic principles of the RECKON design were developed
by the author while teaching the intended customers of
RECKON.\footnote{Specifically, while teaching CS121 at Suffolk University
using the C programming language.}
The language should have as few parts as possible, to cut down
on the amount of detail that must be remembered to use the language, but
conversely, there is no limit to the conceptual complexity of any well-used
part.\footnote{There was no problem teaching recursion, but it was better
not to teach many different looping constructs.}
The language should have powerful data types, well integrated into
the syntax of the language.  As much as possible, statement executions
in the language should have visible effect.

The current version of RECKON is not stable, because it has not been
implemented, and because, unlike most programming languages, RECKON
has lots of subtle important interactions between its various features.  The
hope is that after implementation and experimentation a stable sensible
version of RECKON, integrating all its data types, can be achieved.

\section{Overview}

RECKON has two major kinds of data: expressions and blocks.  Numbers are
the simplest expressions.  More complex expressions are math
expressions or document expressions.  A block is a set of variables
and an piece of code.  Each variable can have a value, which is an expression.
The code contains expressions that can be evaluated under appropriate
circumstances to produce values for variables.

In RECKON a `description' is a block that has an associated `type'.  For
example, there may be a description `george' with type `person'.  All
descriptions of the same type have the same code,
and many of the same variables,
but typically have different variable values.

You can use RECKON as a calculator by typing into it expressions to
be evaluated, assignments of values to variables, and definitions
of functions and predicates.  Some examples involving numbers are:

\begin{indpar}\begin{verbatim}
> 9
9
> 9 + 8
17
> x = 9
9
> y = 9 + 8
17
> x + y
26
> f(b,c,x) = b*x + c
function(b,c,x) is (b*x + c)
> f(10,x,y)
179
\end{verbatim}\end{indpar}

Here the `\verb|> |' at the beginning of some lines is the RECKON \key{prompt}
that tells you its OK to input an expression to be evaluated.
Except for this prompt, lines beginning with `\verb|> |' are input lines to
a RECKON interpreter, and other lines are output lines.

At somewhat the opposite extreme from numbers are words, phrases, sentences,
and paragraphs.  You can calculate with these `\skey{document expression}s\,'.

\begin{indpar}
\verb|> g = `hello'| \\
\verb|`|hello\verb|'| \\
\verb|> `[g] there'| \\
\verb|`|hello there\verb|'| \\
\verb|> z = `I thought he said `[[g]]'.'| \\
\verb|`|I thought he said `hello'.\verb|'| \\
\verb/> notice = `|This document is meant to be read./ \\
\verb/+           |Reading this document is good, but.../ \\
\verb/+           |[z].'/ \\
\verb|`|This document is meant to be read. \\
\verb| |Reading this document is good, but\ldots \\
\verb| |I thought he said `hello'.\verb|'| \\
\verb|> `When you add [x] and [y] you get [x+y].'| \\
\verb|`|When you add 9 and 17 you get 26.\verb|'|
\end{indpar}

Modern math computes with expressions, and not just numbers.
You can compute with \skey{math expression}s in RECKON.

\begin{indpar}
\verb|> f = {10x^2 - 3.67x - 0.04}| \\
\verb|{|$10x^2-3.67x-0.04$\verb|}| \\
\verb|> h = (- 0.96 + 0.67x) in x| \\
\verb|{|$-0.96+0.67x$\verb|}| \\
\verb|> (f + h) in x| \\
\verb|{|$10x^2-3x-1$\verb|}| \\
\verb|> solve (f + h = 0) for x| \\
\verb|{|$x = (-0.2, 0.5)$\verb|}| \\
\verb|> (f + h) at (x = (3, 4, 5))| \\
\verb|(78.95, 145.28, 231.61)| \\
\verb|> g = {integral (x ^ 2 dx)}| \\
\verb|{|$\int x^2 dx$\verb|}| \\
\verb|> simplify g| \\
\verb|{|$\frac{1}{3} x^3$\verb|}| \\
\verb|> v = g from (x = 1) to (x = 5)| \\
\verb|41 1/3| \\
\verb|> out = `The value of {[[g]] from (x = 1) to (x = 5)} is [v].'| \\
\verb|`|The value of $\int_{x = 1}^{x = 5} x^2 dx$ is $41\frac{1}{3}$.\verb|'|
\end{indpar}

Another kind of datum you can compute with in RECKON is
the block.  A \key{block} contains a set of variables, each of which
can have a value which is an expression.  A block can also
have code, which contains expressions that are evaluated under appropriate
circumstances to produce values for the block's variables.

In RECKON a \key{description}
is a block that has an associated \key{type}.  For
example, there may be a description named `Jack' with type `person'.
All descriptions
of the same type have the same code, and many of the same variables,
but typically have different variable values.  For example:

\begin{indpar}
\verb|> a person:| \\
\verb|+     name = `Jack'| \\
\verb|+     weight = 123 lb| \\
\verb|+     height = 5 ft 9 in| \\
\verb|+     age = 23 yr 2 mo| \\
\begin{tabular}{|r|l|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf type} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000000 & person & Jack & \tt 123 lb & \tt 5 ft 9 in & \tt 23 yr 2 mo \\
\hline
\end{tabular} \\[0.5ex]
\verb|> a person:| \\
\verb|+     name = `Jill'| \\
\verb|+     weight = 110 lb| \\
\verb|+     height = 5 ft 7 in| \\
\verb|+     age = 21 yr 8 mo| \\
\begin{tabular}{|r|l|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf type} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000001 & person & Jill & \tt 110 lb & \tt 5 ft 7 in & \tt 21 yr 8 mo \\
\hline
\end{tabular} \\[0.5ex]
\verb|> all persons| \\
\begin{tabular}{|r|l|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf type} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000000 & person & Jack & \tt 123 lb & \tt 5 ft 9 in & \tt 23 yr 2 mo \\
\tt @1000001 & person & Jill & \tt 110 lb & \tt 5 ft 7 in & \tt 21 yr 8 mo \\
\hline
\end{tabular} \\[0.5ex]
\verb|> the person Jack| \\
\begin{tabular}{|r|l|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf type} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000000 & person & Jack & \tt 123 lb & \tt 5 ft 9 in & \tt 23 yr 2 mo \\
\hline
\end{tabular} \\[0.5ex]
\verb|> the person named Jack's height| \\
\verb|5 ft 9 in| \\
\verb|> the weight of the person named Jack| \\
\verb|123 lb| \\
\verb|> @1000001| \\
\begin{tabular}{|r|l|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf type} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000001 & person & Jill & \tt 110 lb & \tt 5 ft 7 in & \tt 21 yr 8 mo \\
\hline
\end{tabular} \\[0.5ex]
\verb|> the weight of @1000001| \\
\verb|110 lb|
\end{indpar}

It is possible to add code to a type such as `{\tt person}'.  This has
the affect of adding the code to all blocks that are descriptions of that type.
For example:

\begin{indpar}
\verb|> for every person:| \\
\verb|+     body mass index = 703.06958 * weight in lbs| \\
\verb|+                     / (height in inches)^2| \\
\verb|> all persons| \\
\begin{tabular}{|r|l|l|r|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf type} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} &
\multicolumn{1}{|c|}{\bf \shortstack{body mass\\index}} \\
\hline
\tt @1000000 & person & Jack
	     & \tt 123 lb & \tt 5 ft 9 in & \tt 23 yr 2 mo & \tt 18.163738 \\
\tt @1000001 & person & Jill
	     & \tt 110 lb & \tt 5 ft 7 in & \tt 21 yr 8 mo & \tt 17.228258 \\
\hline
\end{tabular}
\end{indpar}

One can use definitions to define expressions that compute values:

\begin{indpar}
\verb|> sum from X through Y <-- integer X, integer Y:| \\
\verb|+     `Sum of integers from X through Y.'| \\
\verb|+     if ( X > Y ):| \\
\verb|+         value = 0| \\
\verb|+     else:| \\
\verb|+         value = X + sum (X+1) through Y| \\
\verb|> sum from 5 through 10| \\
\verb|45| \\
\verb|> all (sums from X through Y)| \\
\begin{tabular}{|r|r|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf parent} &
\multicolumn{1}{|c}{\bf X} &
\multicolumn{1}{|c}{\bf Y} &
\multicolumn{1}{|c|}{\bf value} \\
\hline
\tt @1000002 & \tt @1		& \tt 5	& \tt	10	& \tt 45 \\
\tt @1000003 & \tt @1000002	& \tt 6	& \tt	10	& \tt 40 \\
\tt @1000004 & \tt @1000003	& \tt 7	& \tt	10	& \tt 34 \\
\tt @1000005 & \tt @1000004	& \tt 8	& \tt	10	& \tt 27 \\
\tt @1000006 & \tt @1000005	& \tt 9	& \tt	10	& \tt 19 \\
\tt @1000007 & \tt @1000006	& \tt 10	& \tt	10	& \tt 10 \\
\tt @1000008 & \tt @1000007	& \tt 11	& \tt	10	& \tt 0 \\
\hline
\end{tabular} \\[0.5ex]
\verb|> sum from 1 through 2| \\
\verb|3| \\
\verb|> all (sums from X through Y)| \\
\begin{tabular}{|r|r|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf parent} &
\multicolumn{1}{|c}{\bf X} &
\multicolumn{1}{|c}{\bf Y} &
\multicolumn{1}{|c|}{\bf value} \\
\hline
\tt @1000002 & \tt @1		& \tt 5		& \tt	10	& \tt 45 \\
\tt @1000003 & \tt @1000002	& \tt 6		& \tt	10	& \tt 40 \\
\tt @1000004 & \tt @1000003	& \tt 7		& \tt	10	& \tt 34 \\
\tt @1000005 & \tt @1000004	& \tt 8		& \tt	10	& \tt 27 \\
\tt @1000006 & \tt @1000005	& \tt 9		& \tt	10	& \tt 19 \\
\tt @1000007 & \tt @1000006	& \tt 10	& \tt	10	& \tt 10 \\
\tt @1000008 & \tt @1000007	& \tt 11	& \tt	10	& \tt 0 \\
\tt @1000009 & \tt @1		& \tt 1		& \tt	2	& \tt 3 \\
\tt @1000010 & \tt @1000009	& \tt 2		& \tt	2	& \tt 2 \\
\tt @1000011 & \tt @1000010	& \tt 3		& \tt	2	& \tt 0 \\
\hline
\end{tabular}
\end{indpar}

Executions can be examined in detail, because
when an expression is computed, the block that computes it is remembered
for some time.  However, as memory is finite, eventually these
computations are forgotten as they can always be regenerated if
needed.

The sum above was computed by recursion: to compute the sum of 5 through 10
one adds 5 to the sum of 6 through 10.  One can also compute sums by
iteration.

\begin{indpar}
\verb|> sum from X through Y <-- integer X, integer Y:| \\
\verb|+     `Sum of integers from X through Y.'| \\
\verb|+     first sum = 0| \\
\verb|+     if ( X <= Y ):| \\
\verb|+         next sum = sum + X| \\
\verb|+         next X = X + 1| \\
\verb|+     else:| \\
\verb|+         value = sum| \\
\verb|> sum from 5 through 10| \\
\verb|45| \\
\verb|> all (sums from X through Y)| \\
\begin{tabular}{|r|r|r|r|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf previous} &
\multicolumn{1}{|c}{\bf next} &
\multicolumn{1}{|c}{\bf X} &
\multicolumn{1}{|c}{\bf Y} &
\multicolumn{1}{|c}{\bf sum} &
\multicolumn{1}{|c|}{\bf value} \\
\hline
\tt @1000012 &              & \tt @1000013
	     & \tt 5	& \tt 10   & \tt 0	& \\
\tt @1000013 & \tt @1000012 & \tt @1000014
	     & \tt 6	& \tt 10   & \tt 5	& \\
\tt @1000014 & \tt @1000013 & \tt @1000015
	     & \tt 7	& \tt 10   & \tt 11	& \\
\tt @1000015 & \tt @1000014 & \tt @1000016
	     & \tt 8	& \tt 10   & \tt 18	& \\
\tt @1000016 & \tt @1000015 & \tt @1000017
	     & \tt 9	& \tt 10   & \tt 26	& \\
\tt @1000017 & \tt @1000016 & \tt @1000018
	     & \tt 10	& \tt 10   & \tt 35	& \\
\tt @1000018 & \tt @1000017 &
	     & \tt 11	& \tt 10   & \tt 45	& \tt 45 \\
\hline
\end{tabular}
\end{indpar}

One can also iterate over data.

\begin{indpar}
\verb|> average weight of X <-- list X of persons:| \\
\verb|+     first count = 0| \\
\verb|+     first sum = 0| \\
\verb|+     if X = ():| \\
\verb|+         if count = 0:| \\
\verb|+             value = error `Cannot average 0 things.'| \\
\verb|+         else:| \\
\verb|+             value = sum / count| \\
\verb|+     else:| \\
\verb|+         next count = count + 1| \\
\verb|+         next sum = sum + the weight of (first X)| \\
\verb|+         next X = rest X| \\
\verb|> average weight of (all persons)| \\
\verb|116.5 lbs| \\
\verb|> z = 10 + average weight of (all persons named Bill)| \\
\verb|error `Cannot average 0 things.'| \\
\verb|      occurred during: average weight of (all persons named Bill)| \\
\verb|      occurred during: 10 + ditto| \\
\verb|      occurred during: z = ditto|
\end{indpar}

In case you wonder how some of the above works, here are some hints.

RECKON tends to ignore word endings: thus `{\tt person}' and
`{\tt persons}' are to RECKON the same word.
RECKON can even be told that `{\tt person}'
and `{\tt people}' are the same word.
`{\tt Jack's}', on the other hand, is treated an abbreviation
of two separate words `{\tt Jack}' and `{\tt 's}', where `{\tt 's}' is
a separate word by itself.

Expressions are just strings of words and subexpressions.  Subexpressions
must be parenthesized unless they consist of a single word, or unless
they are delimited by operators.

Lists of values can be stored in \skey{list}s, which are computed by comma
separated lists in parentheses.  Thus

\begin{indpar}
\verb|> (the person named Jill, the person named Jack)| \\
\begin{tabular}{|r|l|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf type} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000001 & person & Jill & \tt 110 lb & \tt 5 ft 7 in & \tt 21 yr 8 mo \\
\tt @1000000 & person & Jack & \tt 123 lb & \tt 5 ft 9 in & \tt 23 yr 2 mo \\
\hline
\end{tabular} \\[0.5ex]
\verb|> (the person named Jack, the person named Jill)| \\
\begin{tabular}{|r|l|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf type} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000000 & person & Jack & \tt 123 lb & \tt 5 ft 9 in & \tt 23 yr 2 mo \\
\tt @1000001 & person & Jill & \tt 110 lb & \tt 5 ft 7 in & \tt 21 yr 8 mo \\
\hline
\end{tabular} \\[0.5ex]
\verb|> raw (all persons)| \\
\verb|(the person named Jack, the person named Jill)| \\
\verb|> really raw (all persons)| \\
\verb|(@1000000, @1000001)|
\end{indpar}

The `{\tt raw}' form of a value represents the value
as you could input it in a way that reveals its internal structure.  Thus
`{\tt raw(all~persons)}' denotes the list of all persons, and it is the list
structure that is revealed, not the structure of the elements of the list.

`{\tt the person named Jack}' is a printed representation of the
internal name of a description.  Such printed representations are chosen
automatically from the set of all possible representations, which
in this case include `{\tt the person weighing 123 lbs}' and
`{\tt the person named Jack weighing 123 lbs}'.

The `{\tt really raw}' form of a value identifies descriptions by their IDs.

A single non-list value is equivalent to a list with one element.
Lists cannot have other lists as elements; instead attempts to
compute such lists are \key{flattened}:

\begin{indpar}
\verb|> x = (1,(2,3),4)| \\
\verb|(1,2,3,4)| \\
\verb|> first x| \\
\verb|1| \\
\verb|> rest x| \\
\verb|(2,3,4)| \\
\verb|> rest (rest x)| \\
\verb|(3,4)| \\
\verb|> rest (rest (rest x))| \\
\verb|4| \\
\verb|> rest 4| \\
\verb|()|
\end{indpar}

For this reason RECKON lists are sometimes called `\skey{flat list}s'.

RECKON has different kinds of quotes or brackets.  The brackets
\verb|{|\ldots\verb|}| and \verb|`|\ldots\verb|'|
turn
evaluation off, while \verb|[|\ldots\verb|]| turns evaluation on.
The brackets \verb|`|\ldots\verb|'| turn
recognition of operators (e.g., \verb|+| and \verb|=|) off, and turn
recognition of phrase separators (e.g., `\verb|,|' and `\verb|;|') and
sentence terminators (e.g., `\verb|.|' and `\verb|?|') on, while
\verb|[|\ldots\verb|]| and \verb|{|\ldots\verb|}|
turn recognition of operators on, and turn recognition of phrase
separators and sentence terminators off.

RECKON can store information as expressions.  For example:

\begin{indpar}
\verb|> (a person named `Jack') is husband of (a person named `Jill') <--| \\
\verb|> Y is wife of X <-- X is husband of Y|
\end{indpar}

Here `\verb|<--|' means `is asserted' or `is asserted if'.
All the assertions that have been made can be queried:

\begin{indpar}
\verb|> (a person named `Jill') is wife of (a person named `Jack') ?| \\
\verb|true| \\
\verb|> (a person named `Jack') is wife of (a person named `Jill') ?| \\
\verb|false| \\
\verb|> (a person named X) is wife of (a person named `Jack') ?| \\
\verb|X = `|Jill\verb|'| \\
\verb|> X is wife of (a person named `Jack') ?| \\
\verb|X = (a person named `Jill')| \\
\verb|> @1000001 is wife of (a person named `Jack') ?| \\
\verb|true| \\
\verb|> @1000001 = (a person named `Jill') ?| \\
\verb|true| \\
\verb|> @1000001 = (a person named `Jack') ?| \\
\verb|false|
\end{indpar}

RECKON supports pictorial data
that are expressions displayed as pictures:

\begin{indpar}
\verb|> x = {circle 0.4}| \\[1ex]
\begin{picture}(0.4,0.4)
\put(0.2,0.2){\circle{0.4}}
\end{picture} \\
\verb|> y = {rectangle (0.4,0.2)}| \\[1ex]
\begin{picture}(0.4,0.2)
\put(0,0){\framebox(0.4,0.2){}}
\end{picture} \\
\verb|> z = {(circle 0.4) labeled `Jack'}| \\[1ex]
\begin{picture}(0.4,0.4)
\put(0.2,0.2){\circle{0.4}}
\put(0.0,0.0){\makebox(0.4,0.4){Jack}}
\end{picture} \\
\verb|> {([x] right of [y]) above [z]}| \\[1ex]
\begin{picture}(0.8,0.8)
\put(0.6,0.6){\circle{0.4}}
\put(0.0,0.5){\framebox(0.4,0.2){}}
\put(0.4,0.2){\circle{0.4}}
\put(0.2,0.0){\makebox(0.4,0.4){Jack}}
\end{picture} \\
\verb|> {row([x],[y],[z])}| \\[1ex]
\begin{picture}(1.4,0.4)
\put(0.2,0.2){\circle{0.4}}
\put(0.4,0.1){\framebox(0.4,0.2){}}
\put(1.0,0.2){\circle{0.4}}
\put(0.8,0.0){\makebox(0.4,0.4){Jack}}
\end{picture} \\
\verb|> p = {column (row([x],[y],[z]), row([z],[y],[x]))}| \\[1ex]
\begin{picture}(1.4,0.8)
\put(0.2,0.6){\circle{0.4}}
\put(0.4,0.5){\framebox(0.4,0.2){}}
\put(1.0,0.6){\circle{0.4}}
\put(0.8,0.4){\makebox(0.4,0.4){Jack}}
\put(1.0,0.2){\circle{0.4}}
\put(0.4,0.1){\framebox(0.4,0.2){}}
\put(0.2,0.2){\circle{0.4}}
\put(0.0,0.0){\makebox(0.4,0.4){Jack}}
\end{picture} \\
\verb|> raw x| \\
\verb|{circle 0.4}| \\
\verb|> raw p| \\
\verb|{column (row (circle 0.4,| \\
\verb|              rectangle (0.4,0.2),| \\
\verb|              (circle 0.4) labeled `Jack'),| \\
\verb|         row ((circle 0.4) labeled `Jack',| \\
\verb|              rectangle (0.4,0.2),| \\
\verb|              circle 0.4))}|
\end{indpar}

You can also change how an expression is displayed.

\begin{indpar}
\newlength{\ovalraise}
\setlength{\ovalraise}{-0.1in}
\addtolength{\ovalraise}{0.8ex}
\verb|> display ( P ) <-- person ( P ) has name ( X ):| \\
\verb|>     value = {oval (0.4,0.2) labeled [X]}| \\
\verb|> (a person named `Jack')| \\
\begin{picture}(0.4,0.2)
\put(0.2,0.1){\oval(0.4,0.2)}
\put(0.0,0.0){\makebox(0.4,0.2){Jack}}
\end{picture} \\
\verb|> `(a person named `Jill') is wife of (a person named `Jack')'| \\
\verb|`|
\raisebox{\ovalraise}{\begin{picture}(0.4,0.2)
\put(0.2,0.1){\oval(0.4,0.2)}
\put(0.0,0.0){\makebox(0.4,0.2){Jill}}
\end{picture}}
{is the wife of}
\raisebox{\ovalraise}{\begin{picture}(0.4,0.2)
\put(0.2,0.1){\oval(0.4,0.2)}
\put(0.0,0.0){\makebox(0.4,0.2){Jack}}
\end{picture}}
\verb|'|
\end{indpar}

Displays can be used to make demonstrations:

\begin{indpar}
\verb|> for every demo:| \\
\verb|>     on a demo with angle X:| \\
\verb|+         angle = X| \\
\verb|> x = a demo with angle 30 degrees| \\
\begin{tabular}{|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf type} &
\multicolumn{1}{|c|}{\bf angle} \\
\hline
\tt @1000043 & demo & 30 degrees \\
\hline
\end{tabular} \\[0.5ex]
\verb|> for every demo:| \\
\verb|+     on update THIS to X:|\\
\verb|+         next angle = X| \\
\verb|+     on increment THIS by X:| \\
\verb|+         next angle = angle + X| \\
\verb|> update x to 40 degrees| \\
\begin{tabular}{|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf type} &
\multicolumn{1}{|c|}{\bf angle} \\
\hline
\tt @1000044 & demo & 40 degrees \\
\hline
\end{tabular} \\[0.5ex]
\verb|> increment x by 5 degrees| \\
\begin{tabular}{|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf type} &
\multicolumn{1}{|c|}{\bf angle} \\
\hline
\tt @1000045 & demo & 45 degrees \\
\hline
\end{tabular} \\[0.5ex]
\verb|> display ( D ) <-- demo ( D ) with angle ( X ):| \\
\verb|+     c = {circle 1.0 dotted center (0.0,0.0)}| \\
\verb|+     x axis = {arrow from (-0.75,0.0) to (0.75,0.0)}| \\
\verb|+     y axis = {arrow from (0.0,-0.75) to (0.0,0.75)}| \\
\verb|+     line = {line from (0.0,0.0) to [(0.5*cos X, 0.5*sin X)]}| \\
\verb|+     arc = {arc arrow from (0.7,0.0) to [(0.3*cos X, 0.3*sin X)]}| \\
\verb|+     theta = {Greek th}| \\
\verb|+     value = {label (| \\
\verb|+                `Depiction of Angle [[theta]]=[[X]]',| \\
\verb|+                overlap (| \\
\verb|+                  [c],| \\
\verb|+                  [x axis] labeled `X Axis',| \\
\verb|+                  [y axis] labeled `Y Axis',| \\
\verb|+                  [line],| \\
\verb|+                  [arc] labeled `[[theta]]' ) ) }| \\
\verb|> show x| \\
See `Depiction of Angle $\theta=45^\circ$' \\
\verb|> increment x by -15 degrees| \\
See `Depiction of Angle $\theta=30^\circ$'
\end{indpar} 

\begin{center}
\newcommand{\anglestuff}{
    \put(1.0,0.95){\qbezier[40](0.5,0.0)(0.46,0.46)(0.0,0.5)}
    \put(1.0,0.95){\qbezier[40](0.0,0.5)(-0.46,0.46)(-0.5,0.0)}
    \put(1.0,0.95){\qbezier[40](-0.5,0.0)(-0.46,-0.46)(0.0,-0.5)}
    \put(1.0,0.95){\qbezier[40](0.0,-0.5)(0.46,-0.46)(0.5,0.0)}
    \put(1.0,0.2){\vector(0,1){1.5}}
    \put(0.0,1.7){\makebox(2.0,0.2){Y Axis}}
    \put(0.25,0.95){\vector(1,0){1.5}}
    \put(1.80,0.85){\makebox(0.7,0.2)[l]{X Axis}}
}
\begin{picture}(5.5,1.9)
\put(0,0){
    \anglestuff
    \put(1.0,0.95){\qbezier[1000](0,0)(0.1767765,0.1767765)(0.353553,0.353553)}
    \put(1.0,0.95){
	\qbezier[250](0.3,0.0)(0.3,0.124264)(0.212132,0.212132)
	\put(0.212132,0.212132){\vector(-1,1){0.00}}
	\put(0.31,0.1){$\theta$}}
    \put(0.0,0.0){\makebox(2.0,0.2){Depiction of Angle $\theta=45^\circ$}}
}
\put(3.0,0){
    \anglestuff
    \put(1.0,0.95){\qbezier[1000](0,0)(0.2165065,0.125)(0.433013,0.25)}
    \put(1.0,0.95){
	\qbezier[250](0.3,0.0)(0.32,0.0745584)(0.2598078,0.15)
	\put(0.2598078,0.15){\vector(-1,1){0.00}}
	\put(0.33,0.05){$\theta$}}
    \put(0.0,0.0){\makebox(2.0,0.2){Depiction of Angle $\theta=30^\circ$}}
}
\end{picture}

\end{center}

In this example we first define a `constructor'
of the form `{\tt a demo with angle X}' to make new {\tt demo} descriptions,
and then we define two `methods', namely `{\tt update THIS to X}' and
`{\tt in\-cre\-ment THIS by X}', to change a {\tt demo} description.  Changing
a {\tt demo} description is like iterating a loop to make a new description.

Next we define how to display a {\tt demo} description.  Then we use the
`{\tt show x}' command
to cause the {\tt demo} description value of {\tt x}
to be displayed in a separate window.
Every time this {\tt demo} description
changes, the window is updated, and every time the description
is to be printed,
`See `Depiction of Angle $\theta=\ldots^\circ$'\,'
is printed instead, where `Depiction \ldots' is the {\tt label} part of
the display.


TBD: example of a simple game.

The rest of this document is a reference manual for RECKON.

\begin{boxedfigure}

\begin{verbatim}
for every board:
    on a board of dimension S:
        `Make a board of size SxS.'
        size = S
        `Allowed vessels have lengths 2 (destroyer), 3 (cruiser),
         5 (battleship).  vessels(L) is number of length L.'
        array vessels of size 5 with initial element 0
        `maximum vessels(L) is maximum number of vessels of
         length L.'
        array maximum vessels of size 5 with initial element 0
        maximum vessels(2) = 5
        maximum vessels(3) = 2
        maximum vessels(5) = 1
        `state(I,J) is `none', `miss', or `hit' iff shell has not
         struck square (I,J), struck square (I,J) but that square
         had no ship, or struck square (I,J) and hit a ship at
         that square.'
        array hit of size (S,S) with initial element `none'
        `vessel(I,J) is the vessel at (I,J)'
        array vessel of size (S,S) with initial element `none'
\end{verbatim}

\caption{Code for the Battleship Game, Part I}
\label{CODE-FOR-BATTLESHIP-1}
\end{boxedfigure}


\begin{boxedfigure}

\begin{verbatim}
direction vector of D:
    `given a direction N, NE, E, SE, S, SW, W, NW, return a vector
     with unit components in the given direction.'
    if D == `N':
        value = (1,0)
    else if D == `NE':
        value = (1,1)
    else if D == `E':
        value = (1,0)
    else if D == `SE':
        value = (1,-1)
    else if D == `S':
        value = (0,-1)
    else if D == `SW':
        value = (-1,-1)
    else if D == `W':
        value = (-1,0)
    else if D == `NW':
        value = (-1,1)
\end{verbatim}

\caption{Code for the Battleship Game, Part II}
\label{CODE-FOR-BATTLESHIP-2}
\end{boxedfigure}

\begin{boxedfigure}

\begin{verbatim}
for every vessel:
    on a vessel of length L with direction D from (I,J) on B:
        `make a vessel of length L positioned in direction D
         from origin (I,J) on boards B; directions are N,
         NE, E, SE, S, SW, W, NW'
        length = L
        direction = D
        origin = (I,J)
        vector = direction vector of D
        destination = L * vector + origin
        board = B
        conflict =:
            first p = origin
            first k = 0
            next k = k + 1
            next p = p + vector
            TBD
        if L < 2 or L > 5:
            value = error `bad length [L]'
        else if maximum vessels(L) of B >= vessels(L) of B:
            value = error `two many vessels of length [L]
                           on board [B]'
        else:
            vessels(L) of B += 1
\end{verbatim}

\caption{Code for the Battleship Game, Part III}
\label{CODE-FOR-BATTLESHIP-3}
\end{boxedfigure}

\newpage

\section{Lexemes}

Input text is a sequence of characters.  This is scanned from
left to right and top to bottom to produce a sequence of lexemes,
which include words, marks, separators, numbers, and quoted strings.

For example, the input
\begin{center}
\verb|x = 7ft 1 3/4in;|
\end{center}
contains in order the following lexemes:
\begin{center}
\begin{tabular}{ll}
\tt x	& word \\
\tt =	& mark \\
\tt 7	& number \\
\tt ft	& word \\
\tt 1	& number \\
\tt 3/4	& number \\
\tt in	& word \\
\tt ;	& separator \\
\end{tabular}
\end{center}

\ikey{Lexemes}{lexeme} are defined more specifically as follows:

\begin{indpar}
\emkey{lexeme}
	::= {\em symbol} $|$ {\em number}
	\\[1ex]
\emkey{symbol}
	::= {\em word}
	$|$ {\em mark}
	$|$ {\em quoted-string}
	$|$ {\em separator}
\label{SYMBOL-LEXEME}
	\\[2ex]
\emkey{word} ::= {\em word-character} {\em word-character}\,$^\star$ \\[1ex]
\emkey{mark} ::= {\em mark-character} {\em mark-character}\,$^\star$ \\[1ex]
\emkey{number-lexeme} ::=
        {\em number-character} {\em number-character}\,$^\star$
\label{NUMBER-LEXEME}
\\[1ex]
\emkey{quoted-string} ::=
    \verb|"| {\em character-representative}\,$^\star$ \verb|"| \\[1ex]
\emkey{separator} ::= {\em separator-character}
\\[2ex]
\emkey{word-character} \begin{tabular}[t]{rl}
                     ::= & {\em letter} \\
		     $|$ & \verb|'| followed by a letter \\
		     \end{tabular}
		     \\[1ex]
\emkey{mark-character} \begin{tabular}[t]{rl}
		     ::= &      \verb|+|%
		             $|$\verb|-|%
		             $|$\verb|*|%
		             $|$\verb|/|%
		             $|$\verb|\|%
		             $|$\verb|~|%
		             $|$\verb|@|%
		             $|$\verb|#|%
		             $|$\verb|$|%
		             $|$\verb|%|%
		             $|$\verb|^|%
		             $|$\verb|&|%
		             $|$\verb|=|%
		             $|$\verb/|/%
		             $|$\verb|<|%
		             $|$\verb|>|%
		             $|$\verb|_|%
		             $|$\verb|!|%
		             $|$\verb|?|%
			     $|$\verb|:| \\
		     $|$ & \verb|.| not followed by a {\em digit} \\
		     $|$ & \verb|/| not surrounded by {\em digits} \\
			\end{tabular}\\[1ex]
\emkey{separator-character} \begin{tabular}[t]{rl}
		::= &   \verb|(|
	       	    $|$ \verb|)|
	       	    $|$ \verb|[|
	       	    $|$ \verb|]|
	       	    $|$ \verb|{|
	       	    $|$ \verb|}|
	       	    $|$ \verb|;|
	       	    $|$ \verb|`| \\
		$|$ & \verb|,| not surrounded by {\em digits} \\
		$|$ & \verb|'| not followed by a letter 
		    \end{tabular}\\[1ex]
\emkey{number-character} \begin{tabular}[t]{rl}
		::= &   {\em digit} \\
		$|$ & \verb|.| followed by by a {\em digit } \\
		$|$ & \verb|,| surrounded by {\em digits} \\
		$|$ & \verb|/| surrounded by {\em digits} \\
		    \end{tabular}\\[1ex]
\emkey{character-representative}
    ::= see Figure~\figref{CHARACTER-REPRESENTATIVES} \\[1ex]
\emkey{letter} ::= {\em lower-case-letter} $|$ {\em upper-case-letter} \\[1ex]
\emkey{lower-case-letter} ::=  \verb|a|%
			    $|$\verb|b|%
			    $|$\verb|c|%
			    $|$\verb|d|%
			    $|$\verb|e|%
			    $|$\verb|f|%
			    $|$\verb|g|%
			    $|$\verb|h|%
			    $|$\verb|i|%
			    $|$\verb|j|%
			    $|$\verb|k|%
			    $|$\verb|l|%
			    $|$\verb|m|%
			    $|$\verb|n|%
			    $|$\verb|o|%
			    $|$\verb|p|%
			    $|$\verb|q|%
			    $|$\verb|r|%
			    $|$\verb|s|%
			    $|$\verb|t|%
			    $|$\verb|u|%
			    $|$\verb|v|%
			    $|$\verb|w|%
			    $|$\verb|x|%
			    $|$\verb|y|%
			    $|$\verb|z|
			    \\[1ex]
\emkey{upper-case-letter} ::=  \verb|A|%
			    $|$\verb|B|%
			    $|$\verb|C|%
			    $|$\verb|D|%
			    $|$\verb|E|%
			    $|$\verb|F|%
			    $|$\verb|G|%
			    $|$\verb|H|%
			    $|$\verb|I|%
			    $|$\verb|J|%
			    $|$\verb|K|%
			    $|$\verb|L|%
			    $|$\verb|M|%
			    $|$\verb|N|%
			    $|$\verb|O|%
			    $|$\verb|p|%
			    $|$\verb|Q|%
			    $|$\verb|R|%
			    $|$\verb|S|%
			    $|$\verb|T|%
			    $|$\verb|U|%
			    $|$\verb|V|%
			    $|$\verb|W|%
			    $|$\verb|X|%
			    $|$\verb|Y|%
			    $|$\verb|Z|
			    \\[1ex]
\emkey{digit} ::=  \verb|0|%
		$|$\verb|1|%
		$|$\verb|2|%
		$|$\verb|3|%
		$|$\verb|4|%
		$|$\verb|5|%
		$|$\verb|6|%
		$|$\verb|7|%
		$|$\verb|8|%
		$|$\verb|9|
\end{indpar}

\begin{boxedfigure}[t]

\begin{center}
\begin{tabular}{lp{4in}}
\verb|\n| & new line \\
\verb|\r| & carriage return \\
\verb|\t| & horizontal tab \\
\verb|\b| & backspace \\
\verb|\f| & form feed \\
\verb|\v| & vertical tab \\
\verb|\\| & \verb|\| \\
\verb|\"| & \verb|"| \\[1ex]
\verb|\x|$hh$ & character with ASCII code $hh$ as a 2 digit
		hexadecimal number \\[1ex]
\verb|\|$ooo$ & character with ASCII code $ooo$ as a
		3 digit octal number \\[1ex]
\verb|\|{\em white-space}\verb|\|
		& the backslash, white space, and second backslash
		  are deleted; this allows continuation across
		  line ends
\end{tabular}
\end{center}%
\index{n@{\tt \BACKSLASH n}}%
\index{r@{\tt \BACKSLASH r}}%
\index{t@{\tt \BACKSLASH t}}%
\index{b@{\tt \BACKSLASH b}}%
\index{f@{\tt \BACKSLASH f}}%
\index{v@{\tt \BACKSLASH v}}%
\index{\\2@{\BACKSLASH\BACKSLASH}}%
\index{""2@{\tt \BACKSLASH""}}%
\index{space character 2@{\BACKSLASH{\em space}}}%
\index{x@{\tt \BACKSLASH x}$hh$}%
\index{digit@{\BACKSLASH{\em digit}}}%
\index{whitespace@{\BACKSLASH{\em white-space}\BACKSLASH}}

Characters that represent themselves:

\begin{indpar}
non-control, non-whitespace characters other than \verb|\| and \verb|"| \\
the single space character \\
\verb|\| when not followed by \verb|"|, \verb|\|, a digit,
    a lower case letter, or white-space
\end{indpar}


\caption{Character Representatives}
\label{CHARACTER-REPRESENTATIVES}
\end{boxedfigure}

A \key{word} is a sequence of letters that may include
a \verb|'| if it is followed by a letter.  A \key{mark} is a
sequence of mark characters (e.g., \verb|+| and \verb|-|).
A \key{separator} is a \underline{single} separator character.
A \key{number-lexeme} is a sequence of digits, decimal points
which are always followed by a digit, commas that are
both preceded and followed by digits, and slashes that are
both preceded and followed by digits.
A quoted string is
a sequence of \skey{character representative}s surrounded by
the double quote character (\ttnbkey{"}), where most characters
are their own representatives (\verb|A|, \verb|B|, \verb|0|, \verb|1|,
etc.) but other characters are represented by a sequences of
characters that begin with a backslash (e.g., \verb|\n| represents
a new line character).

A \ttnbkey{'} is a word character if it is followed by a letter,
and a separator character otherwise.
A \verb|.| is a number character (decimal point) if it
is followed by a digit, and a mark character otherwise.
A \ttnbkey{,} is a number character if surrounded by digits, and
a separator character otherwise.
A \ttnbkey{/} is a number character if surrounded by digits, and
a mark character otherwise.

Lexemes may be separated by \key{white-space}, which
is a sequence of white-space characters (single space, horizontal tab, form
feed, etc.), but is not itself a lexeme.

\begin{indpar}
\emkey{white-space} ::= {\em white-space-character}
                        {\em white-space-character}\,$^\star$ \\[1ex]
\emkey{white-space-character}
    \begin{tabular}[t]{rl}
    ::= & {\em horizontal-space-character} \\
    $|$ & {\em vertical-space-character}
    \end{tabular}
    \\[1ex]
\emkey{horizontal-space-character} ::=
    \key{space} $|$ \key{horizontal-tab} \\[1ex]
\emkey{vertical-space-character} ::=
    \key{line-feed} $|$ \key{vertical-tab} $|$ \key{form-feed}
\end{indpar}

Non-{\em white-space} control characters are ignored, as if they
did not exist, except that a warning message may be issued.  However
no warning is issued for \emskey{carriage-return}s that are next to
a {\em verical-space-character}.

Every {\em vertical-space-character} causes the current position to
return to the beginning of a new line.
{\em Horizontal-space-characters} before a {\em vertical-space-character}
are ignored, as if they did not exist.

Words, marks, quoted strings, and separators are called \skey{symbol}s,
to distinguish them from numbers.  Inside the computer symbols are
stored as character strings, while numbers are stored as strings of binary
digits.  When a number is input, stored, and then output,
it may not be represented in output by the same sequence of characters
as it was represented on input.  Thus the input \verb|007| may be output
as \verb|7| and the input \verb|7.0| may also be output as \verb|7|.

Symbols, however, are output in a manner more
faithful to their input, though they can have differences
related to quoting.
An unquoted symbol is stored exactly as it is represented.
A quoted symbol not containing \BACKSLASH{}
is similarly stored.  Thus an unquoted symbol not containing \BACKSLASH{}
is stored in exactly the same way as the same symbol surrounded by
quotes.  For example, \verb|fie| and \verb|"fie"| store the same
thing, as do \verb|+| and \verb|"+"|.

However, some symbols are recognized and treated specially by the parser.
These \skey{special-symbol}s
\label{SPECIAL-SYMBOL}
must be quoted if you want to prevent such
special recognition and treatment.  Thus in \verb|2 + 2| the \verb|+| is
a {\em special-symbol}
recognized by the parser as an operator, and the parser rewrites the expression
as \verb|+ 2 2|.  But in \verb|2 "+" 2| the \verb|"+"| is not specially
recognized and is not a {\em special-symbol}, and the parser does
not rewrite the expression.

A \emkey{name}\label{NAME} is
a sequence of {\em non-special-symbols}
and {\em decimal-naturals}  containing at least one
{\em non-special-symbol}.  {\em Decimal-naturals}
(\pagref{DECIMAL-NATURAL})
are sequences of digits and commas denoting natural numbers
(i.e., non-negative integers).
{\em Names} are used to name things, such
as functions and variables.

\begin{indpar}
\emkey{name} ::=
        {\em name-component}\,$^\star$
        {\em non-special-symbol}
        {\em name-component}\,$^\star$
\\[1ex]
\emkey{name-component} ::= {\em non-special-symbol} $|$ {\em decimal-natural}
\label{NAME-COMPONENT}
\\[1ex]
\emkey{symbol} ::= {\em word} $|$ {\em mark } $|$ {\em quote-string}
                              $|$ {\em separator }
\label{SYMBOL}
\\[1ex]
\emkey{non-special-symbol} ::= {\em symbol} that is \underline{not}
				specially treated by the parser
\\[1ex]
\emkey{decimal-natural} ::= {\em number-lexeme} that contains only
			{\em digits} and {\em commas}
\end{indpar}

In order to indicate spacing, each lexeme is
tagged with the column, line, and page number of its first character.
This can be used to determine the indentation and extent of the lexeme.
Using this information, {\em indented-subexpressions} are recognized
which are lists of lines with the same indentation.
{\em Indented-subexpressions} (\pagref{INDENTED-SUBEXPRESSION})
are introduced by {\em indentation-marks}
(\secref{INDENTATION-MARKS}), which are lexemes.
Lines in an {\em indented-subexpression} are separated by implicit
\skey{indentation-separator}s\label{INDENTATION-SEPARATOR}
that are placed at the beginning of each
line but the first.
An implicit \key{indentation-beginning}\label{INDENTATION-BEGINNING}
is placed after the {\em indentation-mark}
and before the first the line in an {\em indented-subexpression}.
An implicit \key{indentation-end}\label{INDENTATION-END}
is placed after
all the lines in an {\em indented-subexpression}.
Although {\em indentation-marks} are lexemes,
{\em indentation-separators}, {\em indentation-beginnings},
and {\em indentation-ends} are syntax categories but not lexemes.
Their presence is implied by indentation, and they have no characters
of their own.
Details are in Section~\secref{EXPLICIT-SUBEXPRESSION-RECOGNITION}.

\begin{indpar}
\emkey{indentation-beginning} ::= see text, \pagref{INDENTATION-BEGINNING}
				and \pagref{INDENTATION-BEGINNING2} \\[1ex]
\emkey{indentation-separator} ::= see text, \pagref{INDENTATION-SEPARATOR}
				and \pagref{INDENTATION-SEPARATOR2} \\[1ex]
\emkey{indentation-end} ::= see text, \pagref{INDENTATION-END}
				and \pagref{INDENTATION-END2}
\end{indpar}

\section{Low Level Data}

A low level \key{datum} in RECKON is either an atom, an object, or an arrow.

Expressions, blocks, and descriptions are higher level data layered
on top of these low level data.  An expression is either an atom or
a particular kind of object.  A block is a particular kind of object,
and a description is a particular kind of block.

An \key{atom} is a symbol or a number.

An object is just a place in memory, and is like a dot on a blank page.
It can be the source or target of arrows, and it is different from
every other object and from every atom.  But it is nothing more.

However, as a place in memory, an object has a identifier.  Objects are assigned
\skey{raw object identifier}s
of the form `\ttmnbkey{@}{in raw object identifier}$N$' where $N$
is a natural number (non-negative integer).
Raw object identifiers of this form are assigned only to objects
that must be named in an output stream (e.g., printed output).
The first object named in an output stream is assigned the identifier
\verb|@1|, the second object named in the output stream is assigned
the identifier \verb|@2|,
and so forth.  The same object may be assigned different identifiers
in different output streams.%
\footnote{A possible implementation is to give objects that
have been assigned identifiers
in an output stream a hidden system defined output
stream specific attribute (\pagref{ATTRIBUTE})
equal to the object's identifier integer.  Another implementation uses a
hash table per stream.}

There are two kinds of arrows: single and double.

A \key{single arrow} is an arrow from an object to either another object
or to an atom.  The arrow has a \key{label}, which is a sequence of zero or
more atoms.

A \key{double arrow} is a double headed arrow between two objects.
It has a separate label for each direction, with each label being a
sequence of zero or more atoms.  A double arrow is equivalent to a
\underline{related pair}
of single arrows going in opposite directions between the same two objects.
The difference between a double arrow and a pair of single arrows is that
it is possible to delete only one direction of a pair of single arrows, but 
when deleting a double arrow, both directions are deleted.

An \key{arrow label} is a sequence of zero or more atoms.
Two arrows leaving the same object may have the same label.  Thus
an object and an arrow label together name
a set of arrows sourced at the object.

\ikey{Arrow flags}{arrow flag} may be attached to arrow labels.
More precisely, a set of arrow flags is defined for each object
and each arrow label, and these flags apply to all arrows sourced at the
object that have the given label.
The standard flags are the \key{dot flag} (\ttmkey{.}{dot flag}),
and the \key{maybe flag} (\ttmkey{?}{maybe flag}).
Arrows with a dot flagged label are not to be output when their source
is output.
Targets of arrows with a maybe flagged label may be garbage collected
(made to disappear automatically, see \secref{GARBAGE-COLLECTION})
if they cannot be reached except by traversing arrows whose labels
have maybe flags.

We will give examples in the next section along with a basic way of
representing sets of objects in text.  In the rest of this document
arrows are called \skey{attribute}s,\label{ATTRIBUTE} arrow labels are called
\skey{attribute label}s, arrow flags are called \skey{attribute flag}s,
and arrow targets are called \skey{attribute value}s.
Also `\ikey{attribute L of object O}{attribute!of an object}\,'
denotes the set of all values (arrow targets) of attributes
of object O (arrows sourced at O) which have the attribute label
(arrow label) L.

A double arrow is called a \key{double attribute}.  When viewed from
an object at one end of the double arrow, the double arrow is an
attribute of that object, the label of the arrow directed away from that object
is the \mkey{attribute label}{of double attribute} of the double attribute,
and the label of the arrow directed toward the object is the
\mkey{reverse attribute label}{of double attribute} of the double attribute.


\subsection{Raw Representations}
\label{RAW-REPRESENTATIONS}

A set of objects can be written to a text file or read from a text file.
When this is done, a textual representation of the object set is used
in the file.  The simplest representation is the raw representation,
which we now describe.

The format of a \key{raw representation} is:

\begin{indpar}[0.5em]
\begin{tabular}{l}
\emkey{raw-representation}
\\\hspace*{0.5in}\begin{tabular}[t]{rl}
                 ::= & {\em empty} \\
		 $|$ & {\em raw-object-representation} \\
		     & \{ {\em indentation-separator}
		          {\em raw-object-representation} \}$^\star$
		 \end{tabular}
\end{tabular}

\begin{tabular}{l}
\emkey{raw-object-representation} ::=
\\\hspace*{0.5in}
    {\em object-header} {\em raw-single-attribute-value}\,$^\star$
    {\em raw-attribute-representations}
\end{tabular}

\begin{tabular}{l}
\emkey{object-header}
    \begin{tabular}[t]{@{}rl@{}}
    ::= & {\em object-identifier} \verb|=|
          \ttmindex{=}{in {\em object-header}} \\
    $|$ & {\em object-identifier} \verb|>|
          \ttmindex{>}{in {\em object-header}} \\
    $|$ & {\em object-identifier} \verb|>>|
          \ttmindex{>>}{in {\em object-header}} \\
    \end{tabular}
\end{tabular}

\begin{tabular}{l}
\emkey{object-identifier} ::=
	\ttmnbkey{@}{in {\em object-identifier}} {\em decimal-natural}
\end{tabular}

\begin{tabular}{l}
\emkey{decimal-natural} ::=
\\\hspace*{0.5in}
{\em number} lexeme (\pagref{NUMBER-LEXEME})
				 containing only digits and commas
\label{DECIMAL-NATURAL}
\end{tabular}%

\begin{tabular}{l}
\emkey{raw-attribute-representations}
\\\hspace*{0.5in}
	\begin{tabular}[t]{rl}
        ::= & {\em empty} \\
	$|$ & \underline{\LEFTBRACKET\BAR} \underline{\BAR\RIGHTBRACKET} \\
	$|$ & \underline{\LEFTBRACKET\BAR}
	      {\em raw-attribute-representation}
	      \{ \verb|;| {\em raw-attribute-representation} \}$^\star$
	      \underline{\BAR\RIGHTBRACKET} \\
	$|$ & \begin{tabular}[t]{@{}l@{}}
	      \underline{:\BAR}{\em -indentation-mark} \\
	      ~~~~{\em indentation-beginning}
	          {\em raw-attribute-representation} \\
	      ~~~~\{ {\em indentation-separator}
	         {\em raw-attribute-representation} \}$^\star$ \\
	      {\em indentation-end}
	      \end{tabular}
	\end{tabular}
\end{tabular}

\begin{tabular}{l}
\emkey{raw-attribute-representation}\label{RAW-ATTRIBUTE-REPRESENTATION}
    \begin{tabular}[t]{@{}rl@{}}
    ::= & {\em raw-single-attribute-representation} \\
    $|$ & {\em double-attribute-representation} \\
    $|$ & {\em empty}
    \end{tabular}
\end{tabular}

\begin{tabular}{l}
\emkey{raw-single-attribute-representation} ::=
\\\hspace*{0.5in}
	{\em attribute-label} {\em attribute-label-flags-option} \verb|=|
	{\em raw-single-attribute-value}
\end{tabular}%
\index{value!attribute}

\begin{tabular}{l}
\emkey{attribute-label} ::= {\em label}
\end{tabular}%
\index{label!attribute}

\begin{tabular}{l}
\emkey{label} ::= {\em atom}\,$^\star$
\end{tabular}%
\index{label}

\begin{tabular}{l}
\emkey{attribute-label-flags-option} ::=
    {\em empty} $|$ [ {\em symbol}\,$^\star$ ]
\end{tabular}%
\index{flags!attribute label}%
\index{attribute label!flags}

\begin{tabular}{l}
\emkey{raw-single-attribute-value} ::= {\em atom} $|$ {\em object-identifier}
\end{tabular}

\begin{tabular}{l}
\emkey{atom} ::= {\em non-special-symbol} $|$ {\em real-number}
\end{tabular}

\begin{tabular}{l}
{\em real-number} ::= see \pagref{NUMBER}
\end{tabular}

\begin{tabular}{l}
{\em symbol} ::= see \pagref{SYMBOL}
\end{tabular}

\begin{tabular}{l}
{\em non-special-symbol} ::= see \pagref{SPECIAL-SYMBOL}
\end{tabular}

\begin{tabular}{l}
\emkey{double-attribute-representation} ::=
\\\hspace*{0.5in}
	{\em attribute-label} {\em attribute-label-flags-option}
	\verb|=|
\\\hspace*{0.5in}
	{\em double-attribute-value} {\em reverse-attribute-label}
	{\em attribute-label-flags-option}
\end{tabular}

\begin{tabular}{l}
\emkey{double-attribute-value} ::= {\em object-identifier}
\end{tabular}

\begin{tabular}{l}
\emkey{reverse-attribute-label} ::= {\em label}
\end{tabular}

\end{indpar}

{\em Raw-object-representations} are lines in the file being read
(they are at the parser's top level)
and are separated by implicit {\em indentation-separators} placed
just before each non-indented line (see \pagref{TOP-LEVEL} for details).
Their syntax can
use either \verb/{|  |}/ brackets and \verb|;| separators, or
the \verb/:|/ indentation mark and {\em indentation-separators}.
To replace \verb/{|  |}/ and \verb|;| by indentation,
indent appropriately placing the \verb/{|/, \verb|;|, and \verb/|}/
brackets and separators at line ends, replace \verb/{|/ by \verb/:|/,
and delete the \verb|;|'s and \verb/|}/'s.
The \verb/:|/ can be glued to a previous mark, i.e.,
\verb/=  :|/ can be replaced by \verb/=:|/.  For example,

\begin{indpar}\begin{verbatim}
@1 = {| type = woman; name = Jill; husband = @2 wife |};
@2 = {| type = man; name = Jack |}
\end{verbatim}\end{indpar}

becomes

\begin{indpar}\begin{verbatim}
@1 =:|
    type = woman
    name = Jill
    husband = @2 wife
@2 =:|
    type = man
    name = Jack
\end{verbatim}\end{indpar}

These are {\em raw-representations} of an object pair that can
be represented pictorially as:

\begin{center}
\begin{picture}(3.0,1.5)
\put(0,0){\framebox(3.0,1.5){}}
\put(0.3,1.00){\makebox(0.8,0.3){\tt @1}}
\put(0.7,1.15){\oval(0.8,0.3)}
\put(0.5,1.00){\vector(0,-1){0.5}}
\put(0.45,0.75){\makebox(0,0)[r]{\tt type}}
\put(0.5,0.4){\makebox(0,0){\tt woman}}
\put(0.9,1.00){\vector(0,-1){0.7}}
\put(0.95,0.55){\makebox(0,0)[l]{\tt name}}
\put(0.9,0.2){\makebox(0,0){\tt Jill}}
\put(1.9,1.00){\makebox(0.8,0.3){\tt @2}}
\put(2.3,1.15){\oval(0.8,0.3)}
\put(2.1,1.00){\vector(0,-1){0.5}}
\put(2.05,0.75){\makebox(0,0)[r]{\tt type}}
\put(2.1,0.4){\makebox(0,0){\tt man}}
\put(2.5,1.00){\vector(0,-1){0.7}}
\put(2.55,0.55){\makebox(0,0)[l]{\tt name}}
\put(2.5,0.2){\makebox(0,0){\tt Jack}}
\put(1.1,1.17){\vector(1,0){0.8}}
\put(1.9,1.13){\vector(-1,0){0.8}}
\put(1.5,1.15){\oval(0.07,0.12)}
\put(1.5,1.30){\makebox(0,0){\tt husband}}
\put(1.5,1.00){\makebox(0,0){\tt wife}}
\end{picture}
\end{center}

There are two single attributes of object \verb|@1| (arrows sourced
at \verb|@1|),
one attribute labeled {\tt type} whose value (target) is the atom {\tt woman},
and one attribute labeled {\tt name} whose value is the atom {\tt Jill}.
There are two similar single attributes from object \verb|@2|.
There is a double attribute (double arrow)
between the two objects which has the
label {\tt husband} when going from \verb|@1| to \verb|@2|
and the label {\tt wife} when going in the reverse direction.

Note that in this syntax
only \emkey{non-special-symbols} may be used as {\em atoms}
that are parts of labels or attribute values.  A \key{special symbol}
is something like \verb|=| or \verb|+| that is given a special
interpretation during parsing.  In order to use a special symbol
as an atom in an attribute label or value,
it must be quoted; e.g., \verb|"="| must be used instead
of \verb|=| in a label.  This prevents the symbol from being confused with
the \verb|=| that follows the label.  In general, quoting a word or mark in an
attribute label or value never hurts,
as if the word or mark is not special, its quoted and unquoted
versions have the same meaning; e.g., \verb|"type"| and \verb|type|
denote the same symbol.  Consequently,
it is a good idea to quote any mark that is
used in a label, and also to quote words that are used
as operators, such as \verb|"if"|, \verb|"then"|, and \verb|"else"|.

A {\em raw-attribute-representation} is ignored if it is {\em empty},
which allows superfluous `\verb|;|'s in a list of
{\em raw-attribute-representations}.

Note lastly that the \verb/{| |}/ brackets, which are used in object
representation, are distinct from the \verb|{ }| brackets, which are
used to bracket executable code.

It is possible to place \skey{attribute flag}s on attribute labels
by putting flag characters in \verb|[ ]| brackets after a label.
The flag characters are those of one or more {\em symbols} enclosed
in the \verb|[ ]| brackets.  The parser does not try to give special
interpretation to these symbols, so they need not be quoted.
The following is the same as the above example except that flags
have been added to some of the attributes:

\begin{center}
\begin{tabular}[b]{@{}l@{}}
\verb/@1 =:|/\\
\verb|    type = woman|\\
\verb|    name[-] = Jill|\\
\verb|    husband[*] = @2 wife[*]|\\
\verb/@2 =:|/\\
\verb|    type = man|\\
\verb|    name[+] = Jack|\\
\end{tabular}
~~~~~~~~~
\begin{picture}(3.0,1.5)
\put(0,0){\framebox(3.0,1.5){}}
\put(0.3,1.00){\makebox(0.8,0.3){\tt @1}}
\put(0.7,1.15){\oval(0.8,0.3)}
\put(0.5,1.00){\vector(0,-1){0.5}}
\put(0.45,0.75){\makebox(0,0)[r]{\tt type}}
\put(0.5,0.4){\makebox(0,0){\tt woman}}
\put(0.9,1.00){\vector(0,-1){0.7}}
\put(0.95,0.55){\makebox(0,0)[l]{{\tt name}$^{\mbox{\tt -}}$}}
\put(0.9,0.2){\makebox(0,0){\tt Jill}}
\put(1.9,1.00){\makebox(0.8,0.3){\tt @2}}
\put(2.3,1.15){\oval(0.8,0.3)}
\put(2.1,1.00){\vector(0,-1){0.5}}
\put(2.05,0.75){\makebox(0,0)[r]{\tt type}}
\put(2.1,0.4){\makebox(0,0){\tt man}}
\put(2.5,1.00){\vector(0,-1){0.7}}
\put(2.55,0.55){\makebox(0,0)[l]{{\tt name}$^{\mbox{\tt +}}$}}
\put(2.5,0.2){\makebox(0,0){\tt Jack}}
\put(1.1,1.17){\vector(1,0){0.8}}
\put(1.9,1.13){\vector(-1,0){0.8}}
\put(1.5,1.15){\oval(0.07,0.12)}
\put(1.5,1.30){\makebox(0,0){{\tt husband}$^{\mbox{\tt *}}$}}
\put(1.5,1.00){\makebox(0,0){{\tt wife}$^{\mbox{\tt *}}$}}
\end{picture}
\end{center}

In the picture the attribute flags have been added as superscripts on the
attribute labels, and in the text the flags have been added as characters
in symbols inside \verb|[ ]| brackets that
follow attribute labels.

Several attributes of the same object (arrows sourced at the object)
may have the same attribute
label.  An example of this, in which object \verb|@1| has two
attributes labeled \verb|child|, is:

\begin{center}
\begin{tabular}{l@{\hspace*{1in}}l}
\begin{tabular}[b]{@{}l@{}}
\verb/@1 =:|/\\
\verb|    child = @2 parent|\\
\verb|    child = @3 parent|\\
\end{tabular}
&
\begin{picture}(3.0,1.5)
\put(0,0){\framebox(3.0,1.5){}}
\put(0.3,1.00){\makebox(2.4,0.3){\tt @1}}
\put(1.5,1.15){\oval(2.4,0.3)}
\put(0.65,1.00){\vector(0,-1){0.6}}
\put(0.60,0.80){\makebox(0,0)[r]{\tt child}}
\put(0.75,0.40){\vector(0,1){0.6}}
\put(0.80,0.55){\makebox(0,0)[l]{\tt parent}}
\put(2.25,1.00){\vector(0,-1){0.6}}
\put(2.20,0.80){\makebox(0,0)[r]{\tt child}}
\put(2.35,0.40){\vector(0,1){0.6}}
\put(2.40,0.55){\makebox(0,0)[l]{\tt parent}}
\put(0.3,0.10){\makebox(0.8,0.3){\tt @2}}
\put(0.7,0.25){\oval(0.8,0.3)}
\put(1.9,0.10){\makebox(0.8,0.3){\tt @3}}
\put(2.3,0.25){\oval(0.8,0.3)}
\end{picture}
\end{tabular}
\end{center}

We say that the value of the \verb|child| attribute of \verb|@1| is
the set to two elements, \verb|@2| and \verb|@3|.

The differences between \verb|=|, \verb|>|, and \verb|>>| in the
{\em object-header} relate
to what is done when an object or attribute label previously exists.
Note that with the indentation convention, these become differences
between \verb/=:|/, \verb/>:|/, and \verb/>>:|/.

\ttmnbkey{=}{in {\em object-header}}
(or \ttmnbkey{=:|}{in {\em object-header}})
indicates that the object being represented should not previously
exist, or if it does exist, must not have been defined by any previous
{\em raw-object-representation} (it may have been defined as the value of an
attribute).  Second, any attribute label represented in the object
representation, if it previously exists because it was part of a
{\em double-attribute-representation}, must be represented with exactly
the same flags as it already has.

At the other extreme,
\ttmnbkey{>>}{in {\em object-header}}
(or \ttmnbkey{>>:|}{in {\em object-header}})
adds to existing objects.
The object being represented can previously exist.  Any attribute
representation in the object representation creates a new attribute value.
Any flags on an attribute label are added to the flags of the label if
that label already exists.

\ttmnbkey{>}{in {\em object-header}}
(or \ttmnbkey{>:|}{in {\em object-header}})
is like \verb|>>| (or \verb|>>:|)
except that the object representation cannot
add new values to previously existing attributes of the object represented.
More precisely, the attribute label of any attribute representation in
the object representation must not have previously (before the object
representation is read) been an attribute label of the represented object.
Thus \verb|>:| is used to introduce new attributes to an existing object.
Note that reverse attribute labels are not attribute labels in the sense
of this paragraph.

Double attributes must have only one representation.  If they
are given two representations, one for each end of the attribute
(double headed arrow),
\underline{two} identical double attributes (two double headed arrows with the
same end points and labels) will be created.
Usually one end of a double attribute is
thought of as the primary end, and its object representation is used to
include the sole representation of the double attribute.

The {\em object-identifier} \ttnbkey{@0} is special; it always names
a particular object, the \ttnbdkey{GLOBAL} object,
whose its attributes are called \skey{global variables}.  One of the global
variables is named {\tt .GLOBAL} and has as its value the {\tt .GLOBAL}
object itself, a situation which can be achieved by the data representation:

\begin{indpar}\begin{verbatim}
@0>:|
    .GLOBAL = @0
\end{verbatim}\end{indpar}

Labels beginning with `\ttkey{.}' are reserved for use by
the RECKON system, and should not be defined by RECKON users.  {\tt .GLOBAL}
is an example of such a label.

The RECKON parser (\secref{PARSING})
parses\label{RAW-PARSING}
{\em raw-representations}.
Because special
symbols are avoided in attribute labels and values, the parser does
little with these.  However, the parser
does two things that affect attribute labels
and values.

The first is recognizing several lexeme {\em real-numbers}
(\secref{NUMBER-RECOGNITION}),
such as \verb|1.23e-2| and \verb|1 3/4|.  In all cases
a single numeric atom is stored inside the computer, and
details of its representation are lost.  Thus \verb|1.23e-2| and
\verb|0.0123| store the same number, and \verb|1 3/4| and \verb|7/4|
store the same number.

The second thing the parser does to attribute labels and values
is lexeme replacement (\secref{LEXEME-REPLACEMENT}).  Thus the
{\em raw-attribute-representation}
\begin{center}
\verb|Mary's power = people|
\end{center}
would standardly be turned into
\begin{center}
\verb|Mary 's power = person|
\end{center}
since possessives are standardly separated and
plural nouns are standardly replaced by singular nouns.
Of course you can prevent this parser action by using \verb|"| quotes.
Thus
\begin{center}
\verb|Mary's power = "people"|
\end{center}
is turned by the parse into
\begin{center}
\verb|Mary 's power = "people"|
\end{center}
That is, the unquoted lexemes may be replaced but not the quoted lexemes.

\subsection{Lists}

Objects are implemented so that attributes whose labels are small
strictly positive integers can be accessed with more efficiency
than other attributes.  If an object has attributes with consecutive
labels from \verb|1| to $N$, with no gaps,
then these values are said to form a \key{list} that is represented
by the object.  An example is

\begin{indpar}\begin{verbatim}
@93 =:|
    1 = this
    2 = is
    3 = a
    4 = sentence
    .terminator = "."
    .initiator = capital
\end{verbatim}\end{indpar}

which represents the list
\begin{indpar}
\verb|this is a sentence|
\end{indpar}

but also has some additional attributes, labeled \verb|.terminator|
and \verb|.initiator|.  An alternative {\em raw-object-representation}
to the one just given is:

\begin{indpar}\begin{verbatim}
@93 = this is a sentence:|
    .terminator = "."
    .initiator = capital
\end{verbatim}\end{indpar}

Any {\em raw-single-attribute-values} following the {\em object-header}
are assigned as values of the attributes labeled \verb|1|, \verb|2|,
\verb|3|, \ldots.  Additional attribute values can be given by
following these by either
\verb/{| |}/ bracketed and
\verb|;| separated {\em raw-attribute-representations}, or alternatively by
\verb/:|/ and then by indented
{\em raw-attribute-representations}.

\subsection{Cooked Representations}

As noted above (\pagref{RAW-PARSING}),
{\em raw-single-attribute-values} in a {\em raw-representation}
are mostly left alone by the RECKON parsers.  This is because the
use of special symbols are not allowed in these, aside from
{\em radix-indicators} and {\em exponent-indicators} which are
only recognized when adjacent to quoted string or number lexemes.

However, special symbols can be used in attribute value representations
to create attribute values that are complex objects produced by the
RECKON parsers in their full glory.  When this is done, the object
representation is said to be `\key{cooked}\,' instead of `\key{raw}'.

The syntax of {\em cooked-representations} is that of
{\em raw-representations} with `{\em raw-}' replaced by {\em cooked-}
and two syntax equations adjusted as follows:

\begin{indpar}

\emkey{cooked-object-representation} ::=
\\\hspace*{0.5in}
    {\em object-header} {\em expression-option}
    {\em cooked-attribute-representations}
\\[1ex]
\emkey{cooked-single-attribute-value} ::= {\em expression}
\\[1ex]
{\em expression} ::= see \secref{PARSING}

\end{indpar}

In the {\em cooked-object-representation} the list of {\em raw-single-attribute-values} that could follow the {\em object-header} has been replaced by
an {\em expression}, while a {\em cooked-single-attribute-value} can be
any {\em expression}

As a first example,

\begin{indpar}\begin{verbatim}
@93 = `This is a sentence.'
\end{verbatim}\end{indpar}

is the cooked representation of the object

\begin{center}
\begin{tabular}[b]{@{}l@{}}
\verb/@93 =:|/\\
\verb|    1 = this|\\
\verb|    2 = is|\\
\verb|    3 = a|\\
\verb|    4 = sentence|\\
\verb|    .terminator = "."|\\
\verb|    .initiator = capital|\\
\end{tabular}
~~~~~
\begin{picture}(4.1,1.5)
\put(0,0){\framebox(4.1,1.5){}}
\put(0.3,1.00){\makebox(3.4,0.3){\tt @93}}
\put(2.0,1.15){\oval(3.4,0.3)}
\put(1.00,1.00){\vector(0,-1){0.4}}
\put(0.95,0.85){\makebox(0,0)[r]{\tt .initiator}}
\put(1.00,0.50){\makebox(0,0)[c]{\tt capital}}
\put(1.50,1.00){\vector(0,-1){0.6}}
\put(1.45,0.85){\makebox(0,0)[r]{\tt 1}}
\put(1.50,0.30){\makebox(0,0)[c]{\tt this}}
\put(1.85,1.00){\vector(0,-1){0.6}}
\put(1.80,0.85){\makebox(0,0)[r]{\tt 2}}
\put(1.85,0.30){\makebox(0,0)[c]{\tt is}}
\put(2.10,1.00){\vector(0,-1){0.6}}
\put(2.05,0.85){\makebox(0,0)[r]{\tt 3}}
\put(2.10,0.30){\makebox(0,0)[c]{\tt a}}
\put(2.60,1.00){\vector(0,-1){0.6}}
\put(2.55,0.85){\makebox(0,0)[r]{\tt 4}}
\put(2.60,0.30){\makebox(0,0)[c]{\tt sentence}}
\put(3.00,1.00){\vector(0,-1){0.4}}
\put(3.00,0.50){\makebox(0,0)[c]{\tt "."}}
\put(3.05,0.85){\makebox(0,0)[l]{\tt .terminator}}
\end{picture}
\end{center}


The second example contains simple code:

\begin{indpar}\begin{verbatim}
@45 = { straight 3.2; left; straight (y + 9.4) }
\end{verbatim}\end{indpar}

is the cooked representation of the objects

\begin{center}
\begin{tabular}[b]{@{}l@{}}
\verb/@42 =:|/\\
\verb|    1 = straight|\\
\verb|    2 = 3.2|\\
\verb/@43 =:|/\\
\verb|    1 = "+"|\\
\verb|    2 = y|\\
\verb|    3 = 9.4|\\
\verb|    .initiator = "("|\\
\verb|    .terminator = ")"|\\
\verb/@44 =:|/\\
\verb|    1 = straight|\\
\verb|    2 = @43|\\
\verb/@45 =:|/\\
\verb|    1 = @42|\\
\verb|    2 = left|\\
\verb|    3 = @44|\\
\verb|    .initiator = "{"|\\
\verb|    .terminator = "}"|\\
\verb|    .separator = ";"|\\
\end{tabular}
~~~~~
\begin{picture}(4.1,3.7)
\put(0,0){\framebox(4.1,3.7){}}
\put(1.4,0.0){
\put(0.0,0.90){\makebox(2.0,0.3){\tt @43}}
\put(1.0,1.05){\oval(2.0,0.3)}
\put(0.40,0.90){\vector(0,-1){0.4}}
\put(0.35,0.75){\makebox(0,0)[r]{\tt .initiator}}
\put(0.40,0.40){\makebox(0,0)[c]{\tt "("}}
\put(0.70,0.90){\vector(0,-1){0.6}}
\put(0.65,0.75){\makebox(0,0)[r]{\tt 1}}
\put(0.70,0.20){\makebox(0,0)[c]{\tt "+"}}
\put(1.00,0.90){\vector(0,-1){0.6}}
\put(0.95,0.75){\makebox(0,0)[r]{\tt 2}}
\put(1.00,0.20){\makebox(0,0)[c]{\tt y}}
\put(1.30,0.90){\vector(0,-1){0.6}}
\put(1.25,0.75){\makebox(0,0)[r]{\tt 3}}
\put(1.30,0.20){\makebox(0,0)[c]{\tt 9.4}}
\put(1.60,0.90){\vector(0,-1){0.4}}
\put(1.60,0.40){\makebox(0,0)[c]{\tt ")"}}
\put(1.65,0.75){\makebox(0,0)[l]{\tt .terminator}}
}
\put(0.6,1.3){
\put(0.0,0.50){\makebox(1.2,0.3){\tt @42}}
\put(0.60,0.65){\oval(1.2,0.3)}
\put(0.30,0.50){\vector(0,-1){0.3}}
\put(0.25,0.35){\makebox(0,0)[r]{\tt 1}}
\put(0.30,0.10){\makebox(0,0)[c]{\tt straight}}
\put(0.90,0.50){\vector(0,-1){0.3}}
\put(0.85,0.35){\makebox(0,0)[r]{\tt 2}}
\put(0.90,0.10){\makebox(0,0)[c]{\tt 3.2}}
}
\put(2.2,1.3){
\put(0.0,0.50){\makebox(1.2,0.3){\tt @44}}
\put(0.60,0.65){\oval(1.2,0.3)}
\put(0.30,0.50){\vector(0,-1){0.3}}
\put(0.25,0.35){\makebox(0,0)[r]{\tt 1}}
\put(0.30,0.10){\makebox(0,0)[c]{\tt straight}}
\put(0.90,0.50){\vector(0,-1){0.6}}
\put(0.85,0.35){\makebox(0,0)[r]{\tt 2}}
}
\put(0.2,2.7){
\put(0.0,0.50){\makebox(3.2,0.3){\tt @45}}
\put(1.60,0.65){\oval(3.2,0.3)}
\put(0.80,0.50){\vector(0,-1){0.3}}
\put(0.75,0.35){\makebox(0,0)[r]{\tt .initiator}}
\put(0.80,0.10){\makebox(0,0)[c]{\tt "\LEFTBRACKET"}}
\put(1.30,0.50){\vector(0,-1){1.1}}
\put(1.25,0.35){\makebox(0,0)[r]{\tt 1}}
\put(1.70,0.50){\vector(0,-1){0.4}}
\put(1.65,0.30){\makebox(0,0)[r]{\tt 2}}
\put(1.70,0.00){\makebox(0,0)[c]{\tt left}}
\put(2.30,0.50){\vector(0,-1){1.1}}
\put(2.25,0.35){\makebox(0,0)[r]{\tt 3}}
\put(2.70,0.50){\vector(0,-1){0.8}}
\put(2.75,-0.15){\makebox(0,0)[l]{\tt .separator}}
\put(2.70,-0.40){\makebox(0,0)[c]{\tt ";"}}
\put(2.90,0.50){\vector(0,-1){0.3}}
\put(2.95,0.35){\makebox(0,0)[l]{\tt .terminator}}
\put(2.90,0.10){\makebox(0,0)[c]{\tt "\RIGHTBRACKET"}}
}
\end{picture}
\end{center}

Note that here the \verb|{ }| brackets surround code and not
{\em attribute-representations}.  They do \underline{not}
play the same role as \verb/{|  |}/ backets.

A third example uses multiple indented lines to represent code, so that

\begin{indpar}\begin{verbatim}
@138 = function (x,y):

          if (x > y):
              return y
          else:
              return x
\end{verbatim}\end{indpar}

is the cooked representation of the object in
Figure~\ref{EXAMPLE-CODE-OBJECT-REPRESENTATION}.
Note that here the \verb|:| indentation mark is used to introduce
code, and not {\em attribute-representations}, and does
\underline{not} play the same role as the \verb/:|/ indentation mark.


\begin{boxedfigure}

\begin{center}
\begin{tabular}[t]{@{}l@{}}
\verb/@130 =:|/\\
\verb|    1 = x|\\
\verb|    2 = y|\\
\verb|    .separator = ","|\\
\verb|    .initiator = "("|\\
\verb|    .terminator = ")"|\\
\verb/@131 =:|/\\
\verb|    1 = ">"|\\
\verb|    2 = x|\\
\verb|    3 = y|\\
\verb|    .initiator = "("|\\
\verb|    .terminator = ")"|\\
\verb/@132 =:|/\\
\verb|    1 = return|\\
\verb|    2 = y|\\
\verb|    .initiator = ":"|\\
\verb/@133 =:|/\\
\verb|    1 = if|\\
\verb|    2 = @131|\\
\verb|    3 = @132|\\
\verb/@134 =:|/\\
\verb|    1 = return|\\
\verb|    2 = x|\\
\verb|    .initiator = ":"|\\
\verb/@135 =:|/\\
\verb|    1 = else|\\
\verb|    2 = @134|\\
\verb/@136 =:|/\\
\verb|    1 = @133|\\
\verb|    2 = @135|\\
\verb|    .initiator = ":"|\\
\end{tabular}
~
\begin{tabular}[t]{@{}l@{}}
\verb/@137 =:|/\\
\verb|    1 = function|\\
\verb|    2 = @130|\\
\verb|    3 = @136|\\[2ex]
\begin{picture}(4.0,5.5)
\put(0,0){\framebox(4.0,5.5){}}
\put(0.6,0.0){
\put(0.0,0.50){\makebox(2.0,0.3){\tt @131}}
\put(1.0,0.65){\oval(2.0,0.3)}
\put(0.40,0.50){\vector(0,-1){0.25}}
\put(0.35,0.40){\makebox(0,0)[r]{\tt .initiator}}
\put(0.40,0.15){\makebox(0,0)[c]{\tt "("}}
\put(0.70,0.50){\vector(0,-1){0.25}}
\put(0.65,0.40){\makebox(0,0)[r]{\tt 1}}
\put(0.70,0.15){\makebox(0,0)[c]{\tt ">"}}
\put(1.00,0.50){\vector(0,-1){0.25}}
\put(0.95,0.40){\makebox(0,0)[r]{\tt 2}}
\put(1.00,0.15){\makebox(0,0)[c]{\tt x}}
\put(1.30,0.50){\vector(0,-1){0.25}}
\put(1.25,0.40){\makebox(0,0)[r]{\tt 3}}
\put(1.30,0.15){\makebox(0,0)[c]{\tt y}}
\put(1.60,0.50){\vector(0,-1){0.25}}
\put(1.65,0.40){\makebox(0,0)[l]{\tt .terminator}}
\put(1.60,0.15){\makebox(0,0)[c]{\tt ")"}}
}
\put(1.4,1.4){
\put(0.0,0.50){\makebox(1.3,0.3){\tt @132}}
\put(0.65,0.65){\oval(1.3,0.3)}
\put(0.20,0.50){\vector(0,-1){0.25}}
\put(0.15,0.40){\makebox(0,0)[r]{\tt .initiator}}
\put(0.20,0.15){\makebox(0,0)[c]{\tt ":"}}
\put(0.70,0.50){\vector(0,-1){0.25}}
\put(0.65,0.40){\makebox(0,0)[r]{\tt 1}}
\put(0.70,0.15){\makebox(0,0)[c]{\tt return}}
\put(1.10,0.50){\vector(0,-1){0.25}}
\put(1.05,0.40){\makebox(0,0)[r]{\tt 3}}
\put(1.10,0.15){\makebox(0,0)[c]{\tt y}}
}
\put(2.6,0.7){
\put(0.0,0.50){\makebox(1.3,0.3){\tt @134}}
\put(0.65,0.65){\oval(1.3,0.3)}
\put(0.20,0.50){\vector(0,-1){0.25}}
\put(0.15,0.40){\makebox(0,0)[r]{\tt .initiator}}
\put(0.20,0.15){\makebox(0,0)[c]{\tt ":"}}
\put(0.70,0.50){\vector(0,-1){0.25}}
\put(0.65,0.40){\makebox(0,0)[r]{\tt 1}}
\put(0.70,0.15){\makebox(0,0)[c]{\tt return}}
\put(1.10,0.50){\vector(0,-1){0.25}}
\put(1.05,0.40){\makebox(0,0)[r]{\tt 3}}
\put(1.10,0.15){\makebox(0,0)[c]{\tt x}}
}
\put(0.2,2.0){
\put(0.0,0.50){\makebox(1.2,0.3){\tt @133}}
\put(0.60,0.65){\oval(1.2,0.3)}
\put(0.30,0.50){\vector(0,-1){0.25}}
\put(0.25,0.40){\makebox(0,0)[r]{\tt 1}}
\put(0.30,0.15){\makebox(0,0)[c]{\tt if}}
\put(0.60,0.50){\line(0,-1){0.45}}
\put(0.50,0.05){\oval(0.2,0.2)[br]}
\put(0.50,-0.05){\line(-1,0){0.40}}
\put(0.10,-0.15){\oval(0.2,0.2)[tl]}
\put(0.00,-0.15){\line(0,-1){1.10}}
\put(0.10,-1.25){\oval(0.2,0.2)[bl]}
\put(0.10,-1.35){\vector(1,0){0.30}}
\put(0.55,0.40){\makebox(0,0)[r]{\tt 2}}
\put(0.90,0.50){\line(0,-1){0.35}}
\put(1.00,0.15){\oval(0.2,0.2)[bl]}
\put(1.00,0.05){\vector(1,0){0.2}}
\put(0.85,0.40){\makebox(0,0)[r]{\tt 3}}
}
\put(2.8,2.0){
\put(0.0,0.50){\makebox(0.8,0.3){\tt @135}}
\put(0.40,0.65){\oval(0.8,0.3)}
\put(0.20,0.50){\vector(0,-1){0.25}}
\put(0.15,0.40){\makebox(0,0)[r]{\tt 1}}
\put(0.20,0.15){\makebox(0,0)[c]{\tt else}}
\put(0.60,0.50){\vector(0,-1){1.0}}
\put(0.55,0.40){\makebox(0,0)[r]{\tt 2}}
}
\put(1.5,2.4){
\put(0.2,1.00){\makebox(1.3,0.3){\tt @136}}
\put(0.85,1.15){\oval(1.3,0.3)}
\put(0.40,1.00){\vector(0,-1){0.25}}
\put(0.35,0.90){\makebox(0,0)[r]{\tt .initiator}}
\put(0.40,0.65){\makebox(0,0)[c]{\tt ":"}}
\put(0.70,1.00){\line(0,-1){0.65}}
\put(0.60,0.35){\oval(0.2,0.2)[br]}
\put(0.60,0.25){\vector(-1,0){0.70}}
\put(0.65,0.90){\makebox(0,0)[r]{\tt 1}}
\put(1.00,1.00){\line(0,-1){0.65}}
\put(1.10,0.35){\oval(0.2,0.2)[bl]}
\put(1.10,0.25){\vector(1,0){0.20}}
\put(0.95,0.90){\makebox(0,0)[r]{\tt 2}}
}
\put(0.6,3.2){
\put(0.2,1.00){\makebox(1.3,0.3){\tt @130}}
\put(0.85,1.15){\oval(1.3,0.3)}
\put(0.40,1.00){\vector(0,-1){0.25}}
\put(0.35,0.90){\makebox(0,0)[r]{\tt .initiator}}
\put(0.40,0.65){\makebox(0,0)[c]{\tt "("}}
\put(0.70,1.00){\vector(0,-1){0.25}}
\put(0.65,0.90){\makebox(0,0)[r]{\tt 1}}
\put(0.70,0.65){\makebox(0,0)[c]{\tt x}}
\put(1.00,1.00){\vector(0,-1){0.25}}
\put(0.95,0.90){\makebox(0,0)[r]{\tt 2}}
\put(1.00,0.65){\makebox(0,0)[c]{\tt y}}
\put(1.30,1.00){\vector(0,-1){0.25}}
\put(1.35,0.90){\makebox(0,0)[l]{\tt .terminator}}
\put(1.30,0.65){\makebox(0,0)[c]{\tt ")"}}
\put(1.50,1.15){\vector(1,0){1.0}}
\put(1.55,1.20){\makebox(0,0)[l]{\tt .separator}}
\put(2.55,1.15){\makebox(0,0)[l]{\tt ","}}
}
\put(0.2,4.5){
\put(0.0,0.50){\makebox(3.6,0.30){\tt @137}}
\put(1.80,0.65){\oval(3.6,0.3)}
\put(0.30,0.50){\vector(0,-1){0.25}}
\put(0.25,0.40){\makebox(0,0)[r]{\tt 1}}
\put(0.30,0.15){\makebox(0,0)[c]{\tt function}}
\put(1.25,0.50){\vector(0,-1){0.5}}
\put(1.20,0.40){\makebox(0,0)[r]{\tt 2}}
\put(3.40,0.50){\line(0,-1){1.35}}
\put(3.30,-0.85){\oval(0.2,0.2)[br]}
\put(3.30,-0.95){\vector(-1,0){0.5}}
\put(3.35,0.40){\makebox(0,0)[r]{\tt 3}}
}
\end{picture}
\end{tabular}
\end{center}

\caption{Example Code Object Representation}
\label{EXAMPLE-CODE-OBJECT-REPRESENTATION}
\end{boxedfigure}

Cooked representations may replace raw object identifiers in the
description of other objects, as in

\begin{indpar}\begin{verbatim}
@291 =:|
      text = `This is a sentence.'
      outline = { straight 3.2, left, straight (y + 9.4) }
      min = function (x,y):

                if (x > y):
                    return y
                else:
                    return x
\end{verbatim}\end{indpar}

which is the cooked representation of the object

\begin{indpar}\begin{verbatim}
@291 =:|
    text = @93
    outline = @45
    min = @137
\end{verbatim}\end{indpar}

given the above examples.

One question left unanswered by the discussion so far is whether

\begin{indpar}\begin{verbatim}
@291 =:|
    text A = `This is a sentence.'
    text B = `This is a sentence.'
\end{verbatim}\end{indpar}

represents

\begin{indpar}\begin{verbatim}
@291 =:|
    text A = @93
    text B = @93
\end{verbatim}\end{indpar}

or instead

\begin{indpar}\begin{verbatim}
@291 =:|
    text A = @93
    text B = @999
\end{verbatim}\end{indpar}

where object \verb|@999| happens to have the same structure as
object \verb|@93|.  The default is to make both \verb|text A|
and \verb|text B| be the same object, \verb|@93|, and to make
that object `immutable', meaning that it cannot be changed.  The
rule is that unless otherwise indicated, only immutable objects
have the property that their cooked representations can replace
their raw object identifiers in the cooked representations of other
objects.

\section{Parsing}
\label{PARSING}

A program is written in a text file.  The file is read and
converted to a sequence of lexemes, where each lexeme is tagged
with its line number and the column number of its first character.
This sequence of lexemes is then converted to a datum called an
expression by a process called parsing.

\ikey{Parsing}{parsing} consists of the following steps which
are done in the given order:

\begin{indpar}[0.1in]
\begin{tabular}{@{}p{1.7in}@{\hspace*{0.3in}}p{4.3in}@{}}
    \begin{tabular}[t]{@{}l@{}}
    Explicit Subexpression\\
    Recognition (\secref{EXPLICIT-SUBEXPRESSION-RECOGNITION})
    \end{tabular}
    & Explicit brackets, indentation marks, and indentation
      are used to group lexemes into subexpressions.
\end{tabular} \\[2ex]
\begin{tabular}{@{}p{1.7in}@{\hspace*{0.3in}}p{4.3in}@{}}
    \begin{tabular}[t]{@{}l@{}}
    Lexeme Replacement\\
    (\secref{LEXEME-REPLACEMENT})
    \end{tabular}
    & Short sequences of lexemes are replaced by other lexemes.
\end{tabular} \\[2ex]
\begin{tabular}{@{}p{1.7in}@{\hspace*{0.3in}}p{4.3in}@{}}
    \begin{tabular}[t]{@{}l@{}}
    Radix Number\\
    Recognition (\secref{RADIX-NUMBER-RECOGNITION})
    \end{tabular}
    & A radix indicator (e.g., \verb|X#| or \verb|O#|)
      followed by a quoted string is recognized as
      a number with a special radix (e.g., hexadecimal, octal,
      as in \verb|X#"A5"| and \verb|O#"07700"|).
\end{tabular} \\[2ex]
\begin{tabular}{@{}p{1.7in}@{\hspace*{0.3in}}p{4.3in}@{}}
    \begin{tabular}[t]{@{}l@{}}
    Scientific Number\\
    Recognition (\secref{SCIENTIFIC-NUMBER-RECOGNITION})
    \end{tabular}
    & A number followed by an exponent (e.g., \verb|e-3| or \verb|E5|)
      is recognized as a scientific number (e.g., as in
      \verb|5.74e-3| and \verb|10E5|).
\end{tabular} \\[2ex]
\begin{tabular}{@{}p{1.7in}@{\hspace*{0.3in}}p{4.3in}@{}}
    \begin{tabular}[t]{@{}l@{}}
    Number Pair\\
    Recognition (\secref{NUMBER-PAIR-RECOGNITION})
    \end{tabular}
    & Consecutive numbers (e.g., \verb|42 3/4|) are recognized as
      parts of a single number.
\end{tabular} \\[2ex]
\begin{tabular}{@{}p{1.7in}@{\hspace*{0.3in}}p{4.3in}@{}}
    \begin{tabular}[t]{@{}l@{}}
    Number Unit\\
    Grouping (\secref{NUMBER-UNIT-GROUPING})
    \end{tabular}
    & Consecutive pairs each consisting of a number and a unit are
      recognized as part of the same number (e.g., \verb|4ft 5in|).
\end{tabular} \\[2ex]
\begin{tabular}{@{}p{1.7in}@{\hspace*{0.3in}}p{4.3in}@{}}
    \begin{tabular}[t]{@{}l@{}}
    Unit Multiplication\\
    Insertion (\secref{UNIT-MULTIPLICATION-INSERTION})
    \end{tabular}
    & A multiplication operator (\verb|*|)
    is inserted after prefix unit indicators
    and before postfix unit indicators: e.g., \verb|$4.95| and
    \verb|4ft| become \verb|$ * 4.95| and \verb|4 * ft|.
\end{tabular} \\[2ex]
\begin{tabular}{@{}p{1.7in}@{\hspace*{0.3in}}p{4.3in}@{}}
    \begin{tabular}[t]{@{}l@{}}
    Expression Parsing
    \end{tabular}
    & Expression parsing is done by a specialized parser, standardly
    either the operators parser or the text parser, that takes an
    expression consisting of a sequence of lexemes and explicit subexpressions
    and finds implicit subexpressions and other structure in it.
\end{tabular} \\[2ex]
\begin{tabular}{@{}p{1.7in}@{\hspace*{0.3in}}p{4.3in}@{}}
    \begin{tabular}[t]{@{}l@{}}
    Operator Parsing\\
    (\secref{OPERATOR-PARSER})
    \end{tabular}
    & Operator parsing is a particular brand of expression
      parsing that recognizes
      operators (e.g. \verb|+| and \verb|*|)
      and list separators (e.g., \verb|,| or \verb|;|,
      which are treated like operators), and produces algebraic expressions.
\end{tabular} \\[2ex]
\begin{tabular}{@{}p{1.7in}@{\hspace*{0.3in}}p{4.3in}@{}}
    \begin{tabular}[t]{@{}l@{}}
    Text Parsing\\
    (\secref{TEXT-PARSER})
    \end{tabular}
    & Text parsing is a particular brand of expression parsing that recognizes
      sentence terminators (e.g., \verb|.| and \verb|?|) and
      phrase separators (e.g., \verb|,| and \verb|;|) and produces
      expressions that represent sentences and paragraphs.
\end{tabular}
\end{indpar}

Expressions are parsed by either the operator parser or the text parser,
or by some user defined parser.  The following syntax categories are
defined for reference:

\begin{indpar}

\begin{tabular}{l}
\emkey{operator-expression} ::= an expression parsable by the operator parser
\label{OPERATOR-EXPRESSION}
\\[1ex]
\emkey{$O$-subexpression} ::= \begin{tabular}[t]{l}
	an {\em operator-expression} that has no operator \\
	outside brackets with the same or less precedence \\
	than operator or separator $O$
	\end{tabular}
\label{O-SUBEXPRESSION}
\\[6ex]
\emkey{text-expression} ::= an expression parsable by the text parser
\label{TEXT-EXPRESSION}
\end{tabular}

\end{indpar}

\subsection{The Parsing Definition Stack}
\label{PARSING-DEFINITION-STACK}

Parsing is controlled by parsing definitions, which
are placed in the \key{parsing definition stack}.
The following is a list
of the kinds of parsing definitions:%
\label{PARSING-DEFINITION-KINDS}

\begin{center}
\begin{tabular}{ll}
bracket & \secref{BRACKET-DEFINITION} \\
lexeme replacement & \secref{LEXEME-REPLACEMENT-DEFINITION} \\
radix indicator & \secref{RADIX-INDICATOR-DEFINITION} \\
unit specifier & \secref{UNIT-SPECIFIER-DEFINITION} \\
expression parser & \secref{EXPRESSION-PARSER-DEFINITION} \\
operator & \secref{OPERATOR-DEFINITION} \\
phrase separator & \secref{PHRASE-SEPARATOR-DEFINITION} \\
sentence terminator & \secref{SENTENCE-TERMINATOR-DEFINITION} \\
section initiator & \secref{SECTION-INITIATOR-DEFINITION}
\end{tabular}
\end{center}


At the top level, the file being parsed,
the parser reads and parses one line
at a time.  A \key{top level line} is a \underline{non-indented}
file line.  Indented file lines are treated as continuations of
the previous top level line.  Blank lines and comments are ignored.
(See \pagref{TOP-LEVEL} for a few extra details.)

A \key{parsing definition} can appear only as a top level line.
Once read and parsed, it is recognized as a parsing definition,
pushed into the parsing definition stack, and otherwise ignored.
Thereafter it can affect the parsing of subsequence top level lines.

Not all parsing definitions are effective at any given time.  The set
of parsing definitions that have effect is determined by parsing selectors.
A \key{parsing selector} is just a {\em name} (i.e., a sequence of
{\em symbols} and {\em number-lexemes} containing at least one {\em symbol},
see \pagref{NAME}). 
Parsing selectors are attached to parsing definitions,
and at any time during parsing there is a set of parsing selectors called
the `\key{current parsing selector set}' that determines which parsing
definitions are effective.  Specifically, a definition has effect
a member of the current parsing selector set is attached to the definition.
Such definitions are said to be `\key{current parsing definitions}'.%
\label{CURRENT-PARSING-DEFINITION}

For example, the
following two parsing definitions are standardly in the
parsing definition stack:

\begin{indpar}\begin{verbatim}
define operator "-" [operator] infix has precedence 10
define phrase separator "-" [text]
\end{verbatim}\end{indpar}

The \verb|[ ]| brackets in these definitions surround comma
separated lists of parsing selectors that are attached to the
definition.  Here there are two parsing selectors
named `\verb|operator|' and `\verb|text|'.
When the current parsing selector set contains `\verb|text|',
but \underline{not} `\verb|operator|', then the `{\tt define phrase separator}'
definition is effective, but not the `{\tt define operator}'
definition.  When the set does \underline{not}
contain `\verb|text|', but contains `\verb|operator|',
the `{\tt define operator}' definition is effective,
but not the `{\tt define phrase separator}' definition.

The \key{current parsing selector set} is defined as the topmost entry in
the \key{parsing selector set stack},\label{PARSING-SELECTOR-SET-STACK},
which contains parsing selector sets.  The members of the current
parsing selector set are called
\skey{current parsing selector}s.

If a subexpression begins and ends with matched explicit
brackets, a parsing selector
set determined by the bracket definition (\secref{BRACKET-DEFINITION})
is pushed into the parsing
selector set stack before parsing the subexpression.  At the end of
the subexpression parsing, this selector set is popped from the stack.
A similar thing happens for subexpressions that begin with an
indentation mark (\secref{INDENTATION-MARK-DEFINITION}).

A summary of the standard effect of brackets on the parsing selector
set is:

\begin{center}
\begin{tabular}{l@{~~~~~~}l@{~~~~~~}l}
With      &           			& Sets \\
Parsing   &				& Parsing \\
Selector  & Brackets  			& Selectors To \\[1ex]
-	  & \verb|(|\ldots\verb|)|	& [no change] \\
-	  & \verb|{|\ldots\verb|}|	& operator \\
-         & \verb|[|\ldots\verb|]|	& operator \\
-	  & \verb|`|\ldots\verb|'|	& text     \\
\end{tabular}\label{CONTEXT-SWITCHES}
\end{center}

Thus the \verb|{ }| brackets, whose definition is always current
(signified by `-' in the above table), pushes into the parsing
selector set stack the set whose only member is the `operator'
parsing selector.

A parsing definition contains \key{parsing selectors}
which are a \verb|[ ]| bracketed
list of the parsing selectors attached to the definition.
Some definitions, like bracket definitions, can
contain a \key{new parsing selectors},
which determine a parsing selector set to push into the
parsing selector set stack.  These have the syntax:

\begin{indpar}

\begin{tabular}{l}
\emkey{parsing-selectors} ::= {\em empty}
			     $|$ \verb|[| {\em parsing-selector-list} \verb|]|
\label{PARSING-SELECTORS}
\\[1ex]
\emkey{parsing-selector-list} ::= {\em empty}
    $|$ {\em parsing-selector} \{ \verb|,| {\em parsing-selector} \}$^\star$
\\[1ex]
\emkey{parsing-selector} ::= {\em name} ~~ [see \pagref{NAME}]
\end{tabular}

\begin{tabular}{l}
\emkey{new-parsing-selectors} \\
\hspace*{0.3in}\begin{tabular}[t]{rl}
    ::= & \verb|[| {\em parsing-selector-list} \verb|]| \\
    $|$ & \verb|[| {\em parsing-selector-op} {\em parsing-selector} \\
        & \hspace*{0.3in}
          \{ \verb|,| {\em parsing-selector-op} {\em parsing-selector}
	  \}$^\star$ \verb|]|
    \end{tabular}
\label{NEW-PARSING-SELECTORS}
\\[1ex]
\emkey{parsing-selector-op} ::= \verb|+| $|$ \verb|-| $|$ \verb|^|
\end{tabular}

\end{indpar}

If a parsing definition does not give \emkey{parsing selectors}
(i.e., the {\em parsing-selectors} are completely {\em empty}
in the above syntax, with no \verb|[ ]| brackets present), then
the definition is \underline{always} current.  Otherwise each
{\em parsing-selector} listed in the specification is attached to the
definition.

If a definition like a bracket definition gives \emkey{new parsing
selectors}, then this contains instructions how to make
a new parsing selector set.  There are two forms: one with
\emskey{parsing-selector-op}s and one without.  The form without
simply specifies the new parsing selector set literally, by listing
the {\em parsing selectors} in it.  The one with ops, specifies how
to make the new set from the existing current parsing selector set.
The \verb|+| op adds a selector if it was not previously present.
The \verb|-| op deletes a selector if it was previously present.
And the \verb|^| op flips a selector, adding it if it was not
previously present, and deleting it if it was previously present.

If a definition like a bracket definition does \underline{not}
give any {\em new-parsing-selectors}, then
the required new selector set is just a copy of the current selector set.

There is \underline{no} way to pop definitions off the parsing definition
stack.
However, you can place parsing definitions
in the stack
that suppress the effect of particular parsing definitions.
Thus if

\begin{indpar}\begin{verbatim}
define operator "-" [operator] infix has precedence 10
\end{verbatim}\end{indpar}

is in the stack, so that the operator expression parser will
recognize `\verb|-|' as an operator, then putting

\begin{indpar}\begin{verbatim}
undefine operator "-" [special operator]
\end{verbatim}\end{indpar}

further toward the top of the stack will cause the lexeme
`\verb|-|' to be not recognized as an operator whenever the
parsing selector set has both the `{\tt operator}' and the
`{\tt special operator}' selectors.

The operator expression parser introduces
\skey{implicit bracket}s.  These
can also be represented explicitly, though this is mostly done
for purposes of debugging.  The implicit brackets
introduced by operators are represented by \verb@(| |)@, and the
implicit brackets introduced by numbers are represented by \verb|(# #)|.

For example, the operator expression parser turns
\begin{center}
\verb|x + y - 5 * z|
\end{center}
into
\begin{center}
\verb@x + y - (| 5 * z |)@
\end{center}
Similarly the operator parser turns the number
\begin{center}
\verb|4ft 5 3/4 in|
\end{center}
first into
\begin{center}
\verb|(# 4 * ft + (# 5 + 3/4 #) * in #)|
\end{center}
and then finally into
\begin{center}
\verb@(# (| 4 * ft |) + (| (# 5 + 3/4 #) * in |) #)@
\end{center}

Implicit brackets are added to parsed expressions as \verb|.initiator|'s
and \verb|.terminator|'s.
The text expression parser works differently, and does not use
implicit brackets, but instead adds other kinds of \verb|.initiator|'s
and \verb|.terminator|'s to subexpressions.

Bracket, indentation mark, operator, phrase separator,
sentence terminator, and section
header definitions may specify reformatters
which reformat subexpressions after they have been normally parsed.
A \key{reformatter}\label{REFORMATTER} is a function that
is called with a parsed subexpression that is surrounded by brackets,
introduced by an indentation mark, has a lead operator, has a sentence
terminator, or has a section header.
The reformatter returns the reformatted subexpression.

Parsing definitions may also specify evaluators
that are functions attached to the parsed subexpressions which
are called later to evaluate the subexpressions.

\subsection{Brackets}
\label{BRACKETS}

Brackets surround an explicitly bracketed
subexpression and specify the parsing
selector set that determines how the subexpression is parsed.
The brackets that are recognized by the parser
are defined by \skey{bracket definition}s which specify

\begin{indpar}[1in]
Bracket Name and Parsing Selectors \\
Optional New Parsing Selectors \\
Optional Reformatter \\
Optional Evaluator
\end{indpar}

The syntax of bracket definitions is:

\begin{indpar}
\emkey{bracket-definition} \\
	\hspace*{0.5in}::= \ttkey{define bracket}
	    \begin{tabular}[t]{@{}l@{}}
	    {\em bracket-name} {\em parsing-selectors} \\
	    {}[ \verb|with parsing-selectors|
	        {\em new-parsing-selectors} ] \\
	    {}[ \verb|with reformatter|
	        {\em reformatter-name} ] \\
	    {}[ \verb|with evaluator| {\em evaluator-name} ] \\
	    \end{tabular}
\label{BRACKET-DEFINITION}
	    \\[1ex]
\emkey{bracket-name} ::=
	{\em opening-bracket-name}
	\verb|...|
	{\em closing-bracket-name}
\label{BRACKET-NAME}
	\\[1ex]
\emkey{opening-bracket-name} ::= {\em name} \\[1ex]
\emkey{closing-bracket-name} ::= {\em name} \\[1ex]
{\em name} ::= see \pagref{NAME} \\[1ex]
{\em parsing-selectors} ::= see \pagref{PARSING-SELECTORS}
	\\[1ex]
{\em new-parsing-selectors} ::= see \pagref{NEW-PARSING-SELECTORS}
	\\[1ex]
\emkey{reformatter-name} ::= {\em function-name }
	\\[1ex]
\emkey{evaluator-name} ::= {\em function-name }
	\\[1ex]
\emkey{function-name} ::= {\em name}
\end{indpar}


A {\em bracket-name}
has two subsequences of lexemes, an
\emkey{opening bracket name} and
a \key{closing bracket name}, separated by 
a `\verb/.../' lexeme.
By abuse of language, 
`\key{opening bracket}\,'
is used as a synonym for `{\em opening bracket name}'
and `\key{closing bracket}\,'
is used as a synonym for `{\em closing bracket name}'.

When a subexpression is surrounded by brackets, the brackets
are included in the subexpression.

The {\em parsing-selectors} in the {\em bracket-definition}
determine when the definition will be active (\pagref{PARSING-SELECTORS}).
The {\em new-parsing-selectors} specify how to compute a new parsing
selector set which is pushed into the parsing selector set stack by
the opening bracket and popped by the closing bracket
(\pagref{NEW-PARSING-SELECTORS}).

A {\em reformatter-name}
is the name of the function that is called with a parsed expression
as its single argument in order to reformat the expression
(\pagref{REFORMATTER}).  After a bracketed subexpression has been
scanned, the expression parser is called to parse the part of the expression
between brackets.  If this returns a list without \verb|.initiator|
or \verb|.terminator|, the opening and closing brackets are added as
\verb|.initiator| and \verb|.terminator| to this list.
Otherwise a new one-element list is created with the opening and
closing brackets as \verb|.initiator| and \verb|.terminator|
and the expression parser result as the single list element.
Then the bracket definition reformatter, if any, is
called to further reformat the resulting list.

If an {\em evaluator-name} is specified by the bracket definition,
it is attached as the \verb|.evaluator| attribute to each final
parsed bracketed subexpression.
The following are standard evaluators:

\begin{indpar}

\ttnbkey{-STANDARD-EVALUATOR-}.  Normal evaluator that calls functions
and executes operators.

\ttnbkey{-QUOTE-EVALUATOR-}.  Does not evaluate expressions, but just
returns the unevaluated expression as its value.  However, does search
for \verb|[ ]| bracketed subexpressions, evaluates them, and replaces
them by their values.  See \pagref{QUOTE-EVALUATOR}.

\end{indpar}

\subsection{Indentation Marks}
\label{INDENTATION-MARKS}

An \key{indentation mark}
introduces an indented subexpression (\pagref{INDENTED-SUBEXPRESSION}).
Indentation marks are
similar to opening brackets, except indentation marks
must appear at the end of a line, indentation is used
in place of a closing bracket, and indentation and line ends
are also used as separators to given an extra list layer
to the indented subexpression.

Indentation marks are defined by indentation mark definitions,
whose syntax is:

\begin{indpar}
\emkey{indentation-mark-definition} \\
	\hspace*{0.5in}::= {\tt define}~
	    \begin{tabular}[t]{@{}l@{}}
	    {\tt indentation mark}\ttindex{define indentation mark} \\
	    {\em indentation-mark-name} {\em parsing-selectors} \\
	    {}[ \verb|with parsing-selectors|
	        {\em new-parsing-selectors} ] \\
	    {}[ \verb|with reformatter|
	        {\em reformatter-name} ] \\
	    {}[ \verb|with evaluator| {\em evaluator-name} ] \\
	    \end{tabular}
\label{INDENTATION-MARK-DEFINITION}
	    \\[1ex]
\emkey{indentation-mark-name} ::=
	{\em mark-name} $|$ {\em gluing-indicator} {\em mark-name}
\label{INDENTATION-MARK-NAME}
	\\[1ex]
\emkey{mark-name} ::= {\em mark} $|$ {\em quoted-string}
	\\[1ex]
\emkey{gluing-indicator} ::= \verb|*|
	\\[1ex]
{\em parsing-selectors} ::= see \pagref{PARSING-SELECTORS}
	\\[1ex]
{\em new-parsing-selectors} ::= see \pagref{NEW-PARSING-SELECTORS}
	\\[1ex]
\emkey{reformatter-name} ::= {\em function-name }
	\\[1ex]
\emkey{evaluator-name} ::= {\em function-name }
	\\[1ex]
\emkey{function-name} ::= {\em name}
        \\[1ex]
{\em name} ::= see \pagref{NAME}
\end{indpar}

The name of an indentation mark is a restricted form of name
(\pagref{NAME}); it can only be a {\em mark} or a quoted {\em mark}.
The {\em gluing-indicator} \verb|*| specifies that the indentation
mark may be glued to the end of a previous {\em mark} in its line.
E.g., the two marks `\verb|= :|' may be replaced by `\verb|=:|'.
This joined {\em mark} must then be the last lexeme on its line.

\subsection{Explicit Subexpression Recognition}
\label{EXPLICIT-SUBEXPRESSION-RECOGNITION}

\ikey{Explicit subexpressions}{explicit subexpression}
are subexpressions surrounded by explicit brackets or subexpressions
introduced by indentation marks and delimited by
indentation.

\ikey{Explicit brackets}{explicit bracket}
are defined by bracket definitions in the
parsing definition stack, and are used to surround
\skey{explicitly bracketed subexpression}s.  An example bracket
definition is

\begin{indpar}\begin{tabular}{@{}l@{~}l}
\verb|define| & \verb|bracket "{" ... "}" [operator]| \\
              & \ldots
\end{tabular}\end{indpar}

This specifies that \verb|{| is an \key{opening bracket}
and \verb|}| is its corresponding \key{closing bracket}.  More details on
bracket definitions can be found in \secref{BRACKET-DEFINITION}.
The parser recognizes opening explicit brackets in
its input list of lexemes.  Once an opening bracket is recognized,
its corresponding closing bracket can be recognized, as long as it
is not inside another explicit subexpression.

\ikey{Indentation marks}{indentation mark}
are defined by indention mark
definitions in the parsing definition stack and are used to introduce
\skey{indented subexpression}s (\pagref{INDENTED-SUBEXPRESSION}).
An example indention mark definition is

\begin{indpar}\begin{verbatim}
define indentation mark * ":" [operator]
\end{verbatim}\end{indpar}

This specifies that a mark ending in \verb|:|
\underline{that is at the end of a line}
introduces an indented subexpression.  The following
example contains 3 indented subexpressions:

\begin{indpar}\begin{verbatim}
sum from X through Y <-- integer X, integer Y:
    `Sum of integers from X through Y.'
    if ( X > Y ):
        value = 0
    else:
        value = X + sum (X+1) through Y
\end{verbatim}\end{indpar}

Here the \verb|:| at the end of the first line introduces an
indented subexpression consisting of all following lines, and
the \verb|:|'s at the end of the `\verb|if|' and `\verb|else|'
lines each introduce one line indented subexpressions.

If expression parsing were \underline{not} done, the output of the
parser for the above example would be:

\begin{indpar}\begin{verbatim}
@1 = sum from X through Y "<--" integer X "," integer Y @2
@2 = @3 @4 @5 { .initiator = ":" }
@3 = Sum of integers from X through Y "."
         { .initiator = "`"; .terminator = "'" }
@4 = if @6 @7
@6 = X ">" Y { .initiator = "("; .terminator = ")" }
@7 = @8 { .initiator = ":" }
@8 = value "=" 0
@5 = else @9
@9 = @10 { .initiator = ":" }
@10 = value "=" X "+" sum @11 through Y
@11 = X "+" 1 { .initiator = "("; .terminator = ")" }
\end{verbatim}\end{indpar}

Note that expression parsing transforms these results
significantly.  Operators are recognized, and
\verb|@3| becomes:

\begin{indpar}\begin{verbatim}
@3 = sum of integers from X through Y
         { .initiator = capital; .terminator = "." }
\end{verbatim}\end{indpar}

in which the \verb|` '| brackets have disappeared completely,
\verb|"."| has been recognized as a \verb|.terminator|, and
capitalization has been encoded in as an \verb|.initiator|.

The \mkey{indentation}{of line} of a line is the
column number of the first non-white-space character in the line.

An \key{indented subexpression}\label{INDENTED-SUBEXPRESSION}
is introduced by an \key{indentation mark} that ends a line.  This mark must
be defined by an indention mark definition, as per the
example above.  If the mark is preceded in its definition by
\ttmkey{*}{in indention mark definition}, then it may be
\mkey{glued}{indentation mark}
to another mark immediately preceding it.  For example,
`\verb|= :|' may be written as `\verb|=:|'.

An indented subexpression is a list of non-blank lines.
The \mkey{indentation}{of indented subexpression}
of the subexpression is the indentation of the first non-blank line
after the indentation mark.
All lines in the subexpression list must begin with this indentation.
Any line that has greater indentation continues the line previous
to it.  The indented subexpression ends just before the next line
with less indentation.  Blank lines in an indented subexpression
are ignored.

In order to describe indented subexpressions in syntax equations,
the syntax categories \key{indentation-beginning}, \key{indentation-separator},
and \key{indentation-end} are used.
An {\em indentation-beginning}\label{INDENTATION-BEGINNING2}
occurs just after the {\em indentation-mark} that introduces the
indented subexpression, and just before the first line of the subexpression.
An {\em indentation-separator}\label{INDENTATION-SEPARATOR2}
occurs just before each line but the first in the indented subexpression.
An {\em indentation-end}\label{INDENTATION-END2}
occurs at the end of the indented subexpression,
in the same place a closing bracket would occur in a
bracketted subexpression.

The output of
the parser for an indented subexpression is a list whose elements
are the output of the parser for each non-blank line, and 
whose \verb|.initiator| is the indention mark that introduced
the subexpression.  This list does \underline{not} have a \verb|.separator|
or \verb|.terminator|. 

The \key{top level},\label{TOP-LEVEL}
the file containing the text being parsed,
is treated similarly
to an indented subexpression introduced by an implied indentation mark
before the
beginning of the file.  Each element of the top level is a
non-blank line indented
the same as the first non-blank
line of the file.  These elements are read and
processed sequentially.  It is an error for a file non-blank
line to have less
indentation that the first non-blank line of the file.

Consider the file:

\begin{indpar}\begin{verbatim}
@3 =:
    v =:
        w
        x y
    z =:
@4 = a b c
@5 =:
\end{verbatim}\end{indpar}

When the first element of this file is read using the
parser, it becomes the object \verb|@6| in:

\begin{indpar}\begin{verbatim}
@6 = "@" 3 "=" @7
@7 = @8 @9 { .initiator  = ":" }
@8 = v "=" @10
@10 = w @11 { .initiator = ":" }
@11 = x y
@9 = z "=" @12
@12 = { .initiator = ":" }
\end{verbatim}\end{indpar}

Note the list \verb|@12| introduced by line `\verb|z =:|' is
empty, because the next line is indented by less than
this line, and therefore the indented subexpression containing
this line ends right after the line.

The second element read from the above file is \verb|@13| in:

\begin{indpar}\begin{verbatim}
@13 = "@" 4 "=" a b c
\end{verbatim}\end{indpar}

and the third and last element is \verb|@14| in:

\begin{indpar}\begin{verbatim}
@14 = "@" 5 "=" @15
@15 = { .initiator = ":" }
\end{verbatim}\end{indpar}

Here \verb|@15| is the empty list because the file ends
after the line `\verb|@5 =:|' that introduces it.

It is a general rule\label{INDENTATION-EQUIVALENCE-RULE}
of RECKON that lists with \verb|{ }| brackets
and `\verb|;|' separator are semantically equivalent to indented
subexpressions introduced by `\verb|:|'.  Thus

\begin{indpar}\begin{verbatim}
@3 =:
    v =:
        w
        x y
    z =:
@4 = a b c
@5 =:
\end{verbatim}\end{indpar}

and

\begin{indpar}\begin{verbatim}
@3 = {
    v = {
        w;
        x y };
    z = {} }
@4 = a b c
@5 = {}
\end{verbatim}\end{indpar}

are semantically equivalent files.  But they do \underline{not}
parse the same.  Also, the lines of the top level may optionally
be ended by `\verb|;|', as in

\begin{indpar}\begin{verbatim}
@3 = {
    v = {
        w;
        x y };
    z = {} };
@4 = a b c;
@5 = {};
\end{verbatim}\end{indpar}

without semantic effect, as long as indentation subexpressions
are not used outside explicit brackets.

\subsubsection{Explicit Subexpression Recognition Algorithm}
\label{EXPLICIT-SUBEXPRESSION-RECOGNITION-ALGORITHM}

The \ikey{explicit subexpression recognition algorithm}{explicit subexpression
recognition!algorithm} is the
parsing subalgorithm that recognizes explicitly bracketed
and indented subexpressions.  Here we describe this algorithm, which
runs on the output of the lexeme replacement algorithm.

The algorithm maintains a
stack of subexpression records, called the \key{subexpression stack}.
A \key{subexpression record} contains a pointer to a bracket definition
or an indentation mark definition,
an indentation (column number), a subexpression list, and a line list.
Any of these components may be missing.

Initially the subexpression stack contains a single subexpression record with
no definition pointer, indentation equal to 1, subexpression list equal
to the lines read so far at top level, and line list that is either missing
or contains what has been
read so far from the current line.
The stack cannot become empty;
the bottommost indentation record on the stack is always the same.

The record at the top of the indentation stack is called the
`\key{current subexpression record}'.  If it has an indentation, bracket
definition, indentation mark definition, subexpression list, etc., these
are called `current', as in `current indentation',
`current bracket definition', or `current subexpression list'.
The components of the definition are
also called current, as in `current closing bracket'.

The explicit subexpression recognition algorithm is
applied to the lexeme sequence immediately after lexical replacement.
At any point during algorithm execution the sequence of remaining input lexemes
are referred to as the current input, and the first of these is
referred to as the current input lexeme.  This lexeme
may be the first or last in its file line, and if first, will
have some indentation with respect to the beginning of its file line.

The explicit subexpression algorithm executes a loop each of whose
iterations execute the following steps in order.

\begin{indpar}

{\bf Indentation Error.}\index{Indentation Error}
\begin{indpar}
If
\begin{list}{}
	     {\setlength{\itemsep}{0ex}%
	      \setlength{\topsep}{0ex}%
	      \setlength{\parsep}{0ex}%
	      \setlength{\leftmargin}{0.5in}%
	      \setlength{\rightmargin}{0.5in}}%
\item[(1)] the current input lexeme is the first lexeme on its line,
\item[(2)] there is a current indentation, and
\item[(3)] the indentation of this lexeme in its line
is 1 less than or 1 greater
than the current indentation,
\end{list}
then a parsing error is announced.
This ensures that when indentation is
used to insert implicit lexemes, important indentation
differences must be by at least
2 columns, and cannot be by just 1 column.
\end{indpar}

{\bf Indentation Mark Ungluing.}%
\index{Indentation Mark Ungluing}
\begin{indpar}
If
\begin{list}{}
	     {\setlength{\itemsep}{0ex}%
	      \setlength{\topsep}{0ex}%
	      \setlength{\parsep}{0ex}%
	      \setlength{\leftmargin}{0.5in}%
	      \setlength{\rightmargin}{0.5in}}%
\item[(1)] the current input lexeme is the last lexeme on its line,
\item[(2)] this lexeme is a mark, and
\item[(3)] there is a current indentation mark definition in the
parsing definition stack which defines a gluing mark that is
at the end of the current input lexeme, but not the whole lexeme,
\end{list}
then the current input lexeme is split in two and replaced by two lexemes.
The second of these is the gluing indentation mark, and the first
is what precedes it in the original lexeme.  The first of these two
lexemes becomes the current input lexeme, and the second (the
indentation mark) becomes the
next lexeme in the current input.
\end{indpar}

{\bf Indented Line Termination.}\index{Indented Line Termination}
\begin{indpar}
If
\begin{list}{}
	     {\setlength{\itemsep}{0ex}%
	      \setlength{\topsep}{0ex}%
	      \setlength{\parsep}{0ex}%
	      \setlength{\leftmargin}{0.5in}%
	      \setlength{\rightmargin}{0.5in}}%
\item[(1)] the current input lexeme is the first lexeme on its line,
\item[(2)] there is a current indentation,
\item[(3)] the indentation of the current input lexeme is less than or equal
to the current indentation, and
\item[(4)] there is a current line list,
\end{list}
then the current line list is terminated and the resulting list
is added to the current subexpression list.  The current line list
is then set to missing.
\end{indpar}

{\bf Indented Subexpression Termination.}%
\index{Indented Subexpression Termination}
\begin{indpar}
If
\begin{list}{}
	     {\setlength{\itemsep}{0ex}%
	      \setlength{\topsep}{0ex}%
	      \setlength{\parsep}{0ex}%
	      \setlength{\leftmargin}{0.5in}%
	      \setlength{\rightmargin}{0.5in}}%
\item[(1)] the current input lexeme is the first lexeme on its line,
\item[(2)] there is a current indentation, and
\item[(3)] the indentation of the current input lexeme is less than
to the current indentation,
\end{list}
then the current subexpression record is popped from the subexpression
stack and its subexpression list is added as a single element to the
new current line list.  The current parsing selector set is popped
from its stack.  Then this loop iteration is terminated, without
consuming the current input lexeme.
\end{indpar}

{\bf Bracketed Subexpression Termination.}%
\index{Bracketed Subexpression Termination}
\begin{indpar}
If
\begin{list}{}
	     {\setlength{\itemsep}{0ex}%
	      \setlength{\topsep}{0ex}%
	      \setlength{\parsep}{0ex}%
	      \setlength{\leftmargin}{0.5in}%
	      \setlength{\rightmargin}{0.5in}}%
\item[(1)] there is a current bracket definition, and
\item[(2)] the closing bracket in that definition matches a sequence
of lexemes at the beginning of the current input,
\end{list}
then the current subexpression record is popped from the subexpression
stack and its subexpression list is added as a single element to the
new current line list.
The current parsing selector set is popped
from its stack.
The closing bracket is removed from the beginning of the current input and
discarded.
Then this loop iteration is terminated.
\end{indpar}

{\bf Indentation Initiation.}%
\index{Indentation Initiation}
\begin{indpar}
If
\begin{list}{}
	     {\setlength{\itemsep}{0ex}%
	      \setlength{\topsep}{0ex}%
	      \setlength{\parsep}{0ex}%
	      \setlength{\leftmargin}{0.5in}%
	      \setlength{\rightmargin}{0.5in}}%
\item[(1)] the current input lexeme is the first lexeme on its line,
\item[(2)] there is a current indentation mark definition, and
\item[(3)] there is \underline{no} current indentation (meaning this is
the first lexeme encountered after indentation mark),
\end{list}
then the current indentation is set to the indentation of the lexeme.
\end{indpar}

{\bf Indented Line Initiation.}%
\index{Indented Line Initiation}
\begin{indpar}
If
\begin{list}{}
	     {\setlength{\itemsep}{0ex}%
	      \setlength{\topsep}{0ex}%
	      \setlength{\parsep}{0ex}%
	      \setlength{\leftmargin}{0.5in}%
	      \setlength{\rightmargin}{0.5in}}%
\item[(1)] the current input lexeme is the first lexeme on its line,
\item[(2)] there is a current indentation,
\item[(3)] the indentation of the current input lexeme equals
the current indentation, and
\item[(4)] there is no current line list,
\end{list}
then an empty current line list is created.
\end{indpar}

{\bf Indented Subexpression Initiation.}%
\index{Indented Subexpression Initiation}
\begin{indpar}
If
\begin{list}{}
	     {\setlength{\itemsep}{0ex}%
	      \setlength{\topsep}{0ex}%
	      \setlength{\parsep}{0ex}%
	      \setlength{\leftmargin}{0.5in}%
	      \setlength{\rightmargin}{0.5in}}%
\item[(1)] the current input lexeme is the last lexeme on its line, and
\item[(2)] there is a current indentation mark definition in the
parsing definition stack which defines a mark that matches the
current input lexeme,
\end{list}
then a new subexpression record is pushed into the subexpression stack.
The new record has the current indentation mark definition as its
definition, an empty subexpression list with the indentation mark as
its {\tt .initiator}, missing indentation, and missing line list.
A new parsing selector set computed using the current
parsing selector set and the indentation mark definition
{\em new-parsing-selectors}, and the new set is pushed into the
parsing selector set stack.
The indentation mark is removed from the current input and
discarded.
Then this loop iteration is terminated.
\end{indpar}

{\bf Bracketed Subexpression Initiation.}%
\index{Bracketed Subexpression Initiation}
\begin{indpar}
If
\begin{list}{}
	     {\setlength{\itemsep}{0ex}%
	      \setlength{\topsep}{0ex}%
	      \setlength{\parsep}{0ex}%
	      \setlength{\leftmargin}{0.5in}%
	      \setlength{\rightmargin}{0.5in}}%
\item[(1)] there is a current bracket definition in the
parsing definition stack which defines an opening bracket that matches an
initial sequence in the current input,
\end{list}
then a new subexpression record is pushed into the subexpression stack.
The new record has the current bracket definition as its
definition, an empty subexpression list with bracket definition's
opening and closing brackets as its {\tt .initiator} and {\tt .terminator},
respectively, missing indentation, and missing line list.
A new parsing selector set computed using the current
parsing selector set and the bracket definition
{\em new-parsing-selectors}, and the new set is pushed into the
parsing selector set stack.
The opening bracket is removed from the current input and
discarded.
Then this loop iteration is terminated.
\end{indpar}

{\bf Lexeme Consumption.}%
\index{Lexeme Consumption}
\begin{indpar}
The current input lexeme is removed from the current input and
pushed to the end of the current line list, if that exists, or to the
current subexpression list, otherwise.
\end{indpar}


\end{indpar}

\subsection{Lexeme Replacement}
\label{LEXEME-REPLACEMENT}

The \key{lexeme replacement}
process replaces a string of one or more lexemes by a string of zero or
more lexemes.  Lexeme replacement is done on sequences of lexemes
in each subexpression produced
by the explicit subexpression recognition algorithm
(\secref{EXPLICIT-SUBEXPRESSION-RECOGNITION-ALGORITHM}).
These subexpressions are lists that may contain elements that are
subexpressions, and not lexemes, and lexeme replacement cannot cross over
the boundary created by such subexpression elements.
The lists do \underline{not} include brackets or
indentation marks, which
have become \verb|.initiator|'s and \verb|.terminators| of the subexpression
lists.  However, if a subexpression is just a single lexeme by itself,
that subexpression is treated as a list of one lexeme.

Note that lexeme replacement is done after explicit subexpression recognition,
and cannot affect backets or indentation marks.

Lexeme replacement may be done by either a dictionary or a function.
Replacement is controlled by \skey{lexeme replacement definition}s
in the parsing definition stack (\secref{PARSING-DEFINITION-STACK}).

There are two kinds of lexeme replacement definitions:
dictionary and function.  These have the syntax:

\begin{indpar}
\emkey{lexeme-replacement-definition}\,
		     \begin{tabular}[t]{rl}
                     ::= & {\em lexeme-dictionary-definition} \\
		     $|$ & {\em lexeme-function-definition}
		     \end{tabular}
\label{LEXEME-REPLACEMENT-DEFINITION}%
		     \\[1ex]
\emikey{lexeme-dictionary-definition}
       {lexeme-dictionary-@{\em lexeme-dictionary-}!definition@{\em definition}}
           \\
	\hspace*{0.5in}::= \begin{tabular}[t]{@{}l@{}l@{}}
	                   \verb|define | & \verb|lexeme dictionary|
                                            {\em dictionary-name}
					    {\em parsing-selectors} \\
				& {\em lexeme-dictionary-entries}
		     \end{tabular} \\[1ex]
\emkey{dictionary-name} ::= {\em name}
	\\[1ex]
{\em name} ::= see \pagref{NAME}
	\\[1ex]
{\em parsing-selectors} ::= see \pagref{PARSING-SELECTORS}
	\\[1ex]
\emkey{lexeme-dictionary-entries}
                    ::= \underline{\LEFTBRACKET}
		        {\em lexeme-dictionary-entry-list}
			\underline{\RIGHTBRACKET}
		    \\[1ex]
\emkey{lexeme-dictionary-entry-list} \\
		     \hspace*{0.5in}\begin{tabular}[t]{@{}rl@{}}
                     ::= & {\em lexeme-dictionary-entry} \\
		     $|$ & {\em lexeme-dictionary-entry-list} \verb|;|
		           {\em lexeme-dictionary-entry}
		     \end{tabular} \\[1ex]
\emkey{lexeme-dictionary-entry} \\
    \hspace*{0.5in}::=
	{\em replaced-lexemes} \verb|==>| {\em replacing-lexemes}
	\\[1ex]
\emkey{replaced-lexemes} ::= {\em name}
	\\[1ex]
\emkey{replacing-lexemes} ::= {\em empty} $|$ {\em name }
	\\[1ex]
\emkey{lexeme-function-definition} \\
	\hspace*{0.5in}::= \verb|define lexeme function|
				{\em function-name}
				{\em parsing-selectors} \\[1ex]
\emkey{function-name} ::= {\em name}
\label{FUNCTION-NAME}
\end{indpar}

A \emkey{lexeme-dictionary-entry} gives a sequence of lexemes
that is to be replaced
and a sequence of lexemes that replace it.  For example, the entry

\begin{center}
\verb|people ==> person|
\end{center}

causes the word `\verb|people|' to be replaced by the word `\verb|person|'.

A \key{lexeme function} is a function that is called with a list of
lexemes as its single argument and which returns either
`\verb|false|' if the lexeme at the beginning of the list is not to be
replaced, or returns a pair consisting of first a list of replacing
lexemes and second the in input list with the replaced lexemes removed
from its beginning.
For example, given the lexeme function definition

\begin{indpar}
\begin{verbatim}
define lexeme function replace people [operator]
\end{verbatim}
\end{indpar}

and the function definition

\begin{indpar}
\begin{verbatim}
replace people X <-- list ( X ):
    if first X == `people':
        value = ( `person', rest X )
    else:
        value = false
\end{verbatim}
\end{indpar}

then

\begin{center}
\verb|replace people `people with hats'| $\Longrightarrow$
\verb|(`person',`with hats')|

\verb|replace people `fee fie foe fum'| $\Longrightarrow$ \verb|false|
\end{center}


Lexeme replacement is \underline{not} recursive: the replacement lexemes are
not themselves subject to replacement.

A quoted string in a {\em replaced-lexemes} or {\em replacing-lexemes}
sequence of lexemes denotes the lexeme made by removing its outer quotes.
Thus \verb|","| denotes the separator
\verb|,| and \verb|"\",\""| denotes the quoted string \verb|","|.

If several different lexeme replacement definitions could be used to
replace lexemes at the beginning of a lexeme sequence, the topmost
definition in the parsing definition stack
(\secref{PARSING-DEFINITION-STACK}) is used.

The following lexeme dictionaries and functions are
defined in the initial parsing definition stack.
Their definitions are ordered in the
stack so the first given below is at the top of the stack and is the
first that replaces lexemes.

\begin{list}{}{}

\item
\verb|define lexeme dictionary English lexeme dictionary [operator list]|\\[1ex]
This dictionary translates common English irregular plurals,
to their singular form, and decomposes
irregular possessives to their singular decomposed form.
This dictionary also protects irregular singular forms that might be
mistaken for regular plural forms (e.g., `\verb|news|').
Some example translations are:

\begin{center}
\begin{tabular}{l}
\verb|people| $\longrightarrow$ \verb|[person]| \\
\verb|women| $\longrightarrow$ \verb|[woman]| \\
\verb|geese| $\longrightarrow$ \verb|[goose]| \\
\verb|fungi| $\longrightarrow$ \verb|[fungus]| \\
\verb|news| $\longrightarrow$ \verb|[news]| \\
\end{tabular}
\end{center}

\item
\verb|define lexeme function English lexeme function [operator list]|\\[1ex]
This function translates common English standard plurals
to their singular form, and decomposes
standard possessives to their singular decomposed form.
Some example translations are:

\begin{center}
\begin{tabular}{l}
\verb|boys| $\longrightarrow$ \verb|[boy]| \\
\verb|boy's| $\longrightarrow$ \verb|[boy 's]| \\
\verb|boxes| $\longrightarrow$ \verb|[box]| \\
\end{tabular}
\end{center}

\end{list}

Because RECKON, outside the context of quotes,
insists on mapping different forms of a word to a single
word, some subtleties of language are lost.  For example, `\verb|people|'
can be a singular word referring to a group of people, but RECKON will
standardly confuse it with `\verb|person|'.

\subsection{Number Recognition}
\label{NUMBER-RECOGNITION}

Number lexemes are decimal numbers with an optional decimal point
or slash
and optional commas every 3 digits.  \ikey{Numbers}{number} are sequences of
lexemes that are identified during \key{lexical number parsing},
which is applied to the output of the indentation lexeme insertion algorithm. 
When a number contains more than one lexeme, it is surrounded by
the implicit \verb|(# #)| brackets.

The following are the top level syntax equations for numbers.

\begin{indpar}
\emkey{number} ::= {\em real-number} $|$ {\em number-unit-group} \\[1ex]
\emkey{real-number} ::= {\em decimal-number} $|$ {\em radix-number}
				           $|$ {\em scientific-number}
				           $|$ {\em number-pair}
\end{indpar}%
\label{REAL-NUMBER}\label{NUMBER}

Note that numbers are all unsigned.  Signs are all considered to
be arithmetic operators (except for exponent signs in
{\em scientific-numbers}).

\subsubsection{Decimal Numbers}
\label{DECIMAL-NUMBERS}

\ikey{Decimal numbers}{decimal number} are just number lexemes, which
are sequences of digits with optional commas and
an optional decimal point or slash.

\begin{indpar}
\emkey{decimal-number} \begin{tabular}[t]{rl}
                              ::= & {\em decimal-integer} \\
		              $|$ & {\em decimal-integer}\verb|.|%
		                    {\em decimal-fraction} \\
		              $|$ & \verb|.|{\em decimal-fraction} \\
		              $|$ & {\em decimal-numerator}\verb|/|%
		                    {\em decimal-denominator} \\
		              \end{tabular} \\[1ex]
\emkey{decimal-integer} ::= {\em decimal-natural}
\label{DECIMAL-INTEGER}
\\[1ex]
\emkey{decimal-fraction} ::= {\em decimal-natural}
\label{DECIMAL-FRACTION}
\\[1ex]
\emkey{decimal-numerator} ::= {\em decimal-natural}
\label{DECIMAL-NUMERATOR}
\\[1ex]
\emkey{decimal-denominator} ::= {\em decimal-natural}
\label{DECIMAL-DENOMINATOR}
\\[1ex]
\emkey{decimal-natural} ::= {\em decimal-digits}
		     $|$ {\em decimal-natural} \verb|,| {\em decimal-digits}
		     \\[1ex]
\emkey{decimal-digits} ::= {\em digit} {\em digit}\,$^\star$
\end{indpar}

Decimal Number Examples:

\begin{indpar}[0.1in]
\tt
\begin{tabular}{l@{~~~~~}l@{~~~~~}l@{~~~~~}l@{~~~~~}l}
123	& 1,234		& 12,345	& 1,234,567 \\
123.0	& .123		& 0.0		& 1,234.987654	& 1,234.987,654 \\
1/2	& 134/874	& 1,345/3	& 1234/987654   & 1,234/987,645
\end{tabular}
\end{indpar}

In a number lexeme, and therefore in a {\em decimal-number},
a decimal point must be followed by
a digit, commas must be surrounded by digits, and slashes must be surrounded
by digits.

Some number lexemes are \skey{illegal decimal number}s, meaning
that they are number lexemes that cannot be converted to numbers.
A number lexeme with more than one decimal point, more than one
slash, or both a decimal point and a slash is illegal.
Commas are optional, but if present in a {\em decimal-fraction} or
{\em decimal-denominator}, they must also be used in any
{\em decimal-integer} or {\em decimal-numerator} that is part of the
same number lexeme.
In addition, commas if present must be located every 3 digits from the right
end of a {\em decimal-integer}, {\em decimal-denominator}, or
{\em decimal-numerator}, or from the left end of a {\em decimal-fraction}.
Lastly, a {\em decimal-denominator} may not be zero.
Failure to follow the rules of this paragraph will result in an
error when the lexeme is converted to a number,
but is \underline{not} an error of lexeme formation, and
is \underline{not} a parsing error.

The following are examples of illegal decimal numbers:

\begin{indpar}[0.1in]
\tt
\begin{tabular}{l@{~~~~~}l@{~~~~~}l@{~~~~~}l@{~~~~~}l}
1.2.3	& 1.86,54	& 1,234567.892	& 12345.678,92	& 1.234567,892 \\
3/4/5   & 3/0.5         & 1.45/3        & 1000/3,000    & 5/0
\end{tabular}
\end{indpar}

\subsubsection{Radix Number Recognition}
\label{RADIX-NUMBER-RECOGNITION}

\ikey{Radix-numbers}{radix-number} permit binary, octal, or hexadecimal
radi\-ces to the used instead of decimal.  In fact, other number representation
schemes are permitted.

\begin{indpar}
\emkey{radix-number} \\
	\hspace*{0.5in}::= {\em radix-indicator}
		        \verb|"| {\em radix-number-mark}
		        {\em radix-number-mark}\,$^\star$ \verb|"|
		        \\[1ex]
\emkey{radix-indicator} ::= {\em symbol} {\em symbol}\,$^\star$ \\[1ex]
\emkey{radix-number-mark} ::= {\em character-representative}
~~~~~ [See Figure \figref{CHARACTER-REPRESENTATIVES}]
\end{indpar}

A {\em radix-number} is thus a {\em radix-indicator} followed by
any quoted string.  Some examples of legal {\em radix-numbers}
using standard {\em radix-indicators} are:

\begin{indpar}[0.1in]
\tt
\begin{tabular}{l@{~~~~~}l@{~~~~~}l@{~~~~~}l}
B\#"10110100"	& O\#"7534201" & D\#"9758"	& X\#"E8A932B" \\
B\#"01101"	& O\#".7753"   & D\#"97.58"	& X\#".fe8a932b" \\
B\#"0,1101"	& O\#"2,3456"  & D\#".123,5"	& X\#"E8A,932B.7CCD,83" \\
\end{tabular}
\end{indpar}

The following {\em radix-indicators} are standard.

\begin{center}
\begin{tabular}{l@{~~~~~}l@{~~~~~}l@{~~~~~}l}
Radix	& Radix		 & Allowed Number	& Allowed Digits \\
Name	& Indicators     & Marks (Digits)	& Between Commas \\[1ex]
binary	& \tt b\#~~~B\#	 & \tt 0 1		& 3 or 4 \\
octal	& \tt o\#~~~O\#	 & \tt 0 1 2 3 4 5 6 7	& 3 \\
decimal	& \tt d\#~~~D\#	 & \tt 0 1 2 3 4 5 6 7 8 9
						& 3 \\
hexadecimal
	& \tt x\#~~~X\#	 & \tt 0 1 2 3 4 5 6 7 8 9
						& 4 \\
	&		 & \tt a b c d e f A B C D E F
\end{tabular}
\end{center}

Standard {\em radix-indicators} permit a single decimal point, which must
be followed by a digit, or alternatively, as single slash, which must
be surrounded by digits.
Standard {\em radix-indicator}
rules for comma location are the same as for {\em decimal-numbers}
(\secref{DECIMAL-NUMBERS}), except the number of digits between commas may
be 3 or 4, depending on the {\em radix-indicator}.  You cannot mix two
different inter-comma distances, i.e.~both 3 and 4,
in the same {\em radix-number}.

{\em Radix-numbers} may be unconvertible to numbers.  Such are
called \skey{illegal radix number}s.  The following are some examples
using standard {\em radix-indicators}:

\begin{indpar}[0.1in]
\tt
\begin{tabular}{l@{~~~~~}l@{~~~~~}l@{~~~~~}l}
B\#"5,7b63"	& O\#"2/3.456"	& D\#"-0.1"	& X\#".E8A932B.7CCD"
\end{tabular}
\end{indpar}

When a {\em radix-number} is encountered during number parsing,
it is surrounded by \verb|(# #)| implicit brackets.  Thus if
\verb|B#"10011"| is input to number parsing,
\verb|(# B # "10011" #)| will be output.

Radix numbers are recognized after indentation lexemes have been
inserted.

{\em Radix-indicators} are defined by \skey{radix indicator definition}s:

\begin{indpar}
\ikey{radix-indicator-definition}{radix-indicator!definition} \\
	\hspace*{0.5in}::= \begin{tabular}[t]{@{}l@{}l@{}}
	                   \verb|define | & \verb|radix indicator|
                                            {\em radix-indicator}
					    {\em parsing-selectors} \\
	    			& \verb|with conversion function|
				    {\em function-name} \\
		     \end{tabular}
\label{RADIX-INDICATOR-DEFINITION}
		     \\[1ex]
\emkey{radix-indicator} ::= {\em name}
	\\[1ex]
{\em parsing-selectors} ::= see \pagref{PARSING-SELECTORS}
	\\[1ex]
{\em function-name} ::= {\em name}
	\\[1ex]
{\em name} ::= see \pagref{NAME}
\end{indpar}

Given such a definition, the defined {\em radix-indicator}
will be recognized as such whenever it is followed by a quoted
string in the input.

The conversion function is passed the quoted string from a
{\em radix-number} as its only argument, and must return
either a number if conversion is successful, or an error message
otherwise.


\subsubsection{Scientific Number Recognition}
\label{SCIENTIFIC-NUMBER-RECOGNITION}

A {\em scientific-number} is a {\em decimal-number} or a {\em radix-number}
followed by an exponent.

\begin{indpar}
\emkey{scientific-number} \begin{tabular}[t]{rl}
                        ::= & {\em decimal-number} {\em exponent} \\
			$|$ & {\em radix-number} {\em exponent}
		        \end{tabular} \\[1ex]
\emkey{exponent} ::= {\em exponent-indicator}
		   {\em exponent-sign-and-digits} \\[1ex]
\emkey{exponent-indicator} ::= \verb|e| $|$ \verb|E| \\[1ex]
\emkey{exponent-sign-and-digits} ::= {\em decimal-digits}
			    $|$ {\em sign} {\em decimal-digits}
\end{indpar}

The following are examples of legal {\em scientific-numbers} using
standard radix indicators:

\begin{indpar}[0.1in]
\tt
\begin{tabular}{l@{~~~~~}l@{~~~~~}l@{~~~~~}l@{~~~~~}l}
123e0		& 123e+2	& 123e-321	& 1,234e9 \\
123E0		& 123E+2	& 123E-321	& 0.123,456e-3	\\
.123e0	& .123e+2
				& 0.123,456e-3 & 1,234.567890e6 \\
X\#"a9"e0	& B\#"1011"e-3	& O\#"0.7753"e-5
					    & X\#"0.FE8A,932B,E"e+5 \\
\end{tabular}
\end{indpar}

Note that exponents cannot contain commas.

The digits in an exponent are always decimal, even when the number has
a radix indicator such as {\tt B\#} or {\tt X\#} that indicates a different
radix.  However, the interpretation of the exponent depends upon the
radix indicator.  Standard radix indicators interpret the exponent as
multiplication by their radix to the exponent power.  Thus
{\tt B\#"1101"e-2} and {\tt B\#"11.01"} are both equal to {\tt 3.25}.

When a {\em scientific-number} is encountered during number parsing,
it is surrounded by \verb|(# #)| implicit brackets.  Thus if
\verb|B\#"1101"e-2| is input to number parsing,
\begin{center}
\verb|(# (# B # "10011" #) e - 2 #)|
\end{center}
will be output.

An \key{illegal scientific number} is a {\em scientific number}
that cannot be converted to a number.  These include
{\em scientific numbers} whose number lexemes are illegal,
and {\em scientific numbers} with no or standard radix indicators
whose number lexemes contain a slash (\verb|/|).
The following are some examples of illegal scientific numbers:

\begin{indpar}[0.1in]
\tt
\begin{tabular}{l@{~~~~~}l@{~~~~~}l@{~~~~~}l@{~~~~~}l}
1,23e6	& 3/4e2	& B\#"5,7b63"e32  & O\#"2/3"e-2	& X\#".E.7"e-4
\end{tabular}
\end{indpar}

Scientific numbers are recognized after radix numbers have been
recognized.

\subsubsection{Number Pair Recognition}
\label{NUMBER-PAIR-RECOGNITION}

A \key{number pair} is a pair of {\em decimal-numbers}, the first
of which is in integer and the second of which is a fraction
containing a slash.

\begin{indpar}
\emkey{number-pair} ::= {\em decimal-integer}
		   {\em decimal-numerator}\verb|/|{\em decimal-denominator}
		   \\[1ex]
{\em decimal-integer} ::= see \pagref{DECIMAL-INTEGER} \\[1ex]
{\em decimal-numerator} ::= see \pagref{DECIMAL-NUMERATOR} \\[1ex]
{\em decimal-denominator} ::= see \pagref{DECIMAL-DENOMINATOR}
\end{indpar}

Some examples of number pairs are:

\begin{indpar}[0.1in]
\tt
\begin{tabular}{l@{~~~~~~~~~~}l@{~~~~~~~~~~}l@{~~~~~~~~~~}l}
1 1/2	& 55 3/4	& 174 15/16  & 1,234,567 2,875/3,408
\end{tabular}
\end{indpar}

When a {\em number-pair} is encountered during number parsing,
it is surrounded by \verb|(# #)| implicit brackets and a \verb|+| is
inserted between its two parts.  Thus if
\verb|41 3/4| is input to number parsing,
\verb|(# 41 + 3/4 #)|
will be output.

A number pair is illegal if either of its two parts is illegal.

Number pairs are recognized after scientific numbers have been
recognized.

\subsubsection{Number Unit Grouping}
\label{NUMBER-UNIT-GROUPING}

A {\em number-unit-group} is a sequence of one or more {\em number-unit-pairs}
each of which consists of two lexemes: a {\em real-number}
and a {\em unit-specifier}.
The syntax equations are:

\begin{indpar}
\emkey{number-unit-group} ::= {\em number-unit-pair}
			    {\em number-unit-pair}\,$^\star$ \\[1ex]
\emkey{number-unit-pair} \begin{tabular}[t]{rl}
                     ::= & {\em prefix-unit-specifier} {\em real-number} \\
                     $|$ & {\em real-number} {\em postfix-unit-specifier} \\
		     \end{tabular} \\[1ex]
\emkey{prefix-unit-specifier} ::= {\em name} \\[1ex]
\emkey{postfix-unit-specifier} ::= {\em name} \\[1ex]
\emkey{unit-specifier} ::= {\em prefix-unit-specifier} $|$
                         {\em postfix-unit-specifier} \\[1ex]
{\em name} ::= see \pagref{NAME}
\end{indpar}

In order to be recognized as a {\em unit-specifier} a {\em symbol} sequence
must be defined as a {\em unit-specifier-name} by the following:

\begin{indpar}
\emkey{unit-specifier-definition} \\
	\hspace*{0.5in}::= \verb|define unit specifier|
	    \begin{tabular}[t]{l}
	    {\em unit-specifier-fixity} \\
	    {\em unit-specifier} {\em parsing-selectors}
	    \end{tabular}
\label{UNIT-SPECIFIER-DEFINITION}
	    \\[1ex]
\emkey{unit-specifier-fixity} ::= \ttkey{prefix} $|$ \ttkey{postfix}
	\\[1ex]
{\em parsing-selectors} ::= see \pagref{PARSING-SELECTORS}
\end{indpar}

The \key{number unit grouping} phase of
parsing recognizes {\em number-unit-groups} containing more than
one {\em number-unit-pair}, places
\verb|(# #)| implied brackets around them,
and places implied `\verb|+|' operators
between their {\em number-unit-pairs}.

For example, if `\verb|hr|' and `\verb|min|'
are {\em postfix-unit-specifiers},
`\verb|7 hr 30 min|' is a {\em number-unit-group} containing
2 {\em number-unit-pairs} that number unit grouping transforms into
\begin{center}
\verb/(# 7 hr + 30 min #)/
\end{center}
As another example,
if `\verb|ft|' and `\verb|in|' are {\em postfix-unit-specifiers},
`\verb|12ft 11 3/4in|' becomes
\begin{center}
\verb|(# 12 ft + (# 11 + 3/4 #) in #)|
\end{center}

Number unit groups are recognized after number pairs have been
recognized.

\subsubsection{Unit Multiplication Insertion}
\label{UNIT-MULTIPLICATION-INSERTION}

The \key{unit multiplication insertion} phase of
parsing inserts a multiplication operator lexeme, `\verb|*|',
before a {\em postfix-unit-specifier}, and
after a {\em prefix-unit-specifier}, unless the point at which the
`\verb|*|' is to be inserted is already occupied by a
`\verb|*|' or `\verb|/|' lexeme.  This is done after number unit
grouping (\secref{NUMBER-UNIT-GROUPING}).

For example, if `\verb|sec|', `\verb|ft|', and `\verb|lb|'
are {\em postfix-unit-specifiers},
then
\begin{indpar}\begin{verbatim}
some function ( 3 ft 2 1/4 in / sec,
                9 ft ^ 2 lb / sec,
                $3.50 )
\end{verbatim}\end{indpar}
becomes
\begin{indpar}\begin{verbatim}
some function ( (# 3 * ft + (# 2 + 1/4 #) * in #) / sec,
                9 * ft ^ 2 * lb / sec,
                $ * 3.50 )
\end{verbatim}\end{indpar}

Unit multiplication insertion is done after number unit groups have been
recognized.

\subsection{Expression Parsers}
\label{EXPRESSION-PARSERS}

An \key{expression parser} is a function which when called with
a subexpression returns the subpexpression reformatted according to the
operators, sentence terminators, or similar things it finds in the
original subexpression.  The expression parser is called after
explicit subexpression recognition, lexeme replacement, and number
recognition have all been done, so the input subexpression is a sequence
of lexemes, explicit subexpressions, and implicit number subexpressions.
Note that number recognition is done regardless of the expression parser
used, e.g., even inside \verb|` '| quotes.

Expression parsers are defined by
\skey{expression parser definition}s\label{EXPRESSION-PARSER-DEFINITION}.
The topmost current expression parser definition
(\pagref{CURRENT-PARSING-DEFINITION})
in the parsing stack names the parser used to parse expressions.

Expression parser definitions have the syntax:

\begin{indpar}
\emkey{expression-parser-definition} ::=\\
\hspace*{0.5in}\verb|define expression parser| {\em parser-name}
				               {\em parsing-selectors} \\[1ex]
\emkey{parser-name} ::= {\em name} \\[1ex]
{\em name} ::= see \pagref{NAME} \\[1ex]
{\em parsing-selectors} ::= see \pagref{PARSING-SELECTORS}
\end{indpar}

There are two standard \ikey{expression parsers}{parser!standard expression},
the \key{operator parser} and the \key{text parser}, that have the
definitions:

\begin{indpar}\begin{verbatim}
define expression parser -OPERATOR-PARSER- [operator]
define expression parser -TEXT-PARSER- [text]
\end{verbatim}\end{indpar}

The `operator' parser has a definition selected by the `operator'
parsing selector, and recognizes any
operators whose definitions are current
(list separators are treated as operators),
whereas the `text' parser has a definition selected
by the `text' selector, and recognizes phrase separators, sentence
terminators, and section initiators whose definitions are current.
The 'operator' parser does \underline{not} recognize
any phrase separators, sentence terminators, or section initiators,
and the `text'
parser does \underline{not} recognize any operator
definitions.


\subsection{The Operator Parser}
\label{OPERATOR-PARSER}

The \key{operator parser} is an expression parser that uses
operators to restructure expressions.  Operators
are defined by operator definitions that can be added to the
parsing definition stack.  List separators, such as `\verb|,|', are treated
as operators, and have operator definitions.

\subsubsection{Operator Definitions}
\label{OPERATOR-DEFINITION}

An \key{operator definition} specifies for each operator the following:

\begin{indpar}[1in]
Name and Selectors \\
Precedence \\
Operator Flags \\
Reformatter \\
Evaluator
\end{indpar}

The syntax of operator definitions is:

\begin{indpar}
\emkey{operator-definition} \\
	\hspace*{0.5in}::= \ttkey{define operator}
	    \begin{tabular}[t]{@{}l@{}}
	    {\em operator-name} {\em parsing-selectors} \\
	    {\em operator-flag}\,$^\star$ \\
	    {}[ \verb|with precedence| {\em precedence} ] \\
	    {}[ \verb|with reformatter| {\em reformatter-name} ] \\
	    \end{tabular}
	    \\[1ex]
\emkey{operator-name} \begin{tabular}[t]{rl}
		    ::= & {\em simple-operator-name} \\
		    $|$ & \verb|bracket| {\em bracket-name} \\
		    $|$ & \verb|indentation mark| {\em indentation-mark-name}
		    \end{tabular}
		    \\[1ex]
{\em simple-operator-name} ::= {\em name}  [see \pagref{NAME}] \\[1ex]
{\em bracket-name} ::= see \pagref{BRACKET-NAME} \\[1ex]
{\em indentatio-mark-name} ::= see \pagref{INDENTATION-MARK-NAME} \\[1ex]
\emkey{operator-flag} ::= \ttmkey{prefix}{operator flag}
                    $|$ \ttmkey{infix}{operator flag}
                    $|$ \ttmkey{postfix}{operator flag}
                    $|$ \ttmkey{nofix}{operator flag}
                    $|$ \ttmkey{afix}{operator flag}
	\\[1ex]
\emkey{precedence} ::= {\em sign-option} {\em decimal-integer}
	\\[1ex]
\emkey{sign-option} ::= {\em empty} $|$ \verb|+| $|$ \verb|-|
	\\[1ex]
\emkey{reformatter-name} ::= {\em function-name }
	\\[1ex]
\emkey{function-name} ::= {\em name}
	\\[1ex]
{\em name} ::= see \pagref{NAME}
\end{indpar}

A {\em simple-operator-name} is matched to lexemes in a subexpression
in order to identify occurences of the operator.
The other forms of {\em operator-name} permit explicit subexpressions
with particular kinds of brackets to be parsed as if they were operators.
Thus in `\verb|x[5]=0|' the explicit subexpression
`\verb|[5]|' can be a postfix operator.  A subexpression
bracketed by `\verb|{ }|' is used as an afix (see below) to the
\verb|<--| operator (as is a subexpression introduced by the `\verb|:|'
indentation mark).

By abuse of language, the term `\key{operator}' is often used
as a synonym for `{\em operator-name}'.

Operators can have \skey{operator flag}s that
affect parsing of subexpressions of the operator.  The possible
flags are `{\tt infix}', `{\tt prefix}', `{\tt postfix}',
`{\tt nofix}', and `{\tt afix}'.  By default an operator is `{\tt nofix}'.

An \ttkey{infix} operator must be between two non-empty operands,
while a \ttkey{prefix} operator must precede a non-empty operand,
and a \ttkey{postfix} operator must follow a non-empty operand.

A \ttkey{nofix} operator is like an infix operator but may have
empty operands.  It may appear at the beginning or ending of
an expression, or two nofix operators may be consecutive.

An \ttkey{afix} operator is like a nofix operator but must follow
another non-afix operator in the expression that has the same
precedence.  Explicit subexpressions bracketed by `\verb|{ }|'
are standard afix operators with the same precedence
as the \verb|<--| operator, so that an expression such as:
\begin{center}
\verb|sum from X through Y <-- integer X, integer Y { ... }|
\end{center}
parse as
\begin{center}
\verb|(sum from X through Y) <-- (integer X, integer Y) { ... }|
\end{center}
and \underline{not} as
\begin{center}
\verb|(sum from X through Y) <-- (integer X, integer Y { ... })|
\end{center}

Inside a subexpression (with brackets removed),
an operator that can be prefix if it begins the subexpression,
or follows another operator that is not postfix.
An operator can be postfix if it ends the
subexpression or precedes another operator that is not prefix.  
An operator can be infix if it does not begin or end the subexpression,
follow an operator that is prefix,
or precede an operator that is postfix.

A\label{FIXITY-RULES}
nofix operator cannot be infix, prefix, postfix or afix.
An afix operator cannot be infix, prefix, postfix or nofix.
A postfix operator cannot be infix.
Thus an operator may be only nofix, only afix, only infix,
only prefix, only postfix, prefix and postfix, or prefix and infix.
An operator that can be prefix
and either postfix or infix is taken to be prefix if and only if it begins
a subexpression or follows an operator previously
determined in a left-to-right scan to be prefix, infix, nofix, or afix.

The {\em precedence} of an operator is an integer.  Precedence is used to
determine which operators are inside and outside implicit brackets.
Operators with higher precedence are placed inside the 
implicit brackets that surround operands of operators of lower precedence.

The precedence
in an operator definition applies only to the operator when it is used
as an infix, nofix, or afix operator; prefix and postfix operators are always
treated as having precedence higher than any infix, nofix, or afix operator.
If several prefix and postfix operators apply to a single operand,
the postfix operators are all inside the implicit brackets surrounding
the prefix operator operands (i.e., the postfix operators are
`executed first').  Thus `\verb|-x[1]|' is equivalent to `\verb|-(x[1])|'
(where `\verb|[1]|' is treated as a postfix operator).

The {\em reformatter-name} in an {\em operator-definition} names a
function that is called after all other parsing has been done to
reformat a subexpression whose first operator is the defined operator.
For example, given the expression `\verb|-x+6*y|', the subexpression
`\verb|6*y|' is extracted, and as its first operator is `\verb|*|',
the reformatter for that operator is called and yeilds `\verb|* 6 y|'.
Similarly the subexpression `\verb|-x|' is extracted but the reformatter
for `\verb|-|' does not change it.
Then the reformatter for `\verb|+|' is called
with `\verb|(-x)+(* 6 y)|', since `\verb|+|' is the first operator in
this subexpression \underline{after} subexpressions have been handled.
This reformatter returns `\verb|+ (-x) (* 6 y)|'.  Here we have
use parentheses \verb|( )| to indicate implicit parentheses.


\subsubsection{Standard Operators}
\label{STANDARD-OPERATORS}

The following are the standard operators

\begin{center}

\begin{tabular}{rll@{\hspace*{2em}}l@{\hspace*{2em}}l}

precedence & rerformatter	& type	& operator	& meaning 
\\[2ex]
-1000	& \ttkey{separator}	& \tt nofix	& \ttkey{;}	& separator \\
+0000	& \ttkey{define}	& \tt nofix	& \ttnbkey{<--}	& define \\
	&			& \tt afix	& \ttkey{\LEFTBRACKET{}
							 ... \RIGHTBRACKET}
								& block \\
+1000	& \ttkey{assign}	& \tt infix	& \ttnbkey{=}	& assignment \\
     	&               	&          	& \ttnbkey{+=}	& increment \\
     	&               	&          	& \ttnbkey{-=}	& decrement \\
     	&               	&          	& \ttnbkey{*=}	& multiply by \\
     	&               	&          	& \ttnbkey{/=}	& divide by \\
+2000	& \ttkey{separator}	&		& \ttkey{,}	& separator \\
+3000	& \ttkey{logical}	& \tt nofix	& \ttkey{AND}	& logical and \\
	&			&		& \ttkey{OR}	& logical or \\
	&			&		& \ttkey{NOT}  & logical not \\
	&			&		& \ttkey{BUT}  & logical filler
								 \\
+4000 	& \ttkey{compare}	& \tt infix	& \ttnbkey{==}	& equal \\
	&			&		& \ttnbkey{/=}  & not equal \\
	&			&		& \ttnbkey{!=}	& ditto \\
	&		      	&		& \ttnbkey{<}	& less than \\
	&			&		& \ttnbkey{<=}	& less than or
								  equal \\
	&			&		& \ttnbkey{=<}	& ditto \\
	&		      	&		& \ttnbkey{>}	& greater than
									\\
	&			&		& \ttnbkey{>=}	& greater than
								  or equal \\
	&			&		& \ttnbkey{=>}	& ditto \\
+5000	& \ttkey{sum}		& \tt infix	&  \ttnbkey{+}	& addition \\
	&			&		& \ttnbkey{-}	& subtraction \\
+5100	& \ttkey{product}	& \tt infix	&  \ttnbkey{*}
							    & multiplication \\
	&			&		& \ttnbkey{/}	& division \\
none	& none			& \tt prefix	&  \ttnbkey{-}	& minus \\
	& 			& \tt prefix	&  \ttnbkey{+}	& plus \\
	& 			& \tt prefix	&  \ttnbkey{@}	& object name \\
none	& \ttkey{subscript}	& \tt postfix	&  \ttnbkey{[...]}
								& subscript \\
\end{tabular}

\end{center}


Below be describe the effects of standard operator reformatters.
We use notation such as

\hspace*{2em}\begin{tabular}{lcl}
\verb|x = y = z + w| & $\Longrightarrow$ & \verb|= x ( = y (+ x w))| \\
\verb|x AND AND y| & $\Longrightarrow$ & error
\end{tabular}

Here $\Longrightarrow$ means `is reformatted as'.  Furthermore, the
parentheses introduced by the rewrite are \underline{implied},
which means that the lists they bracket have \underline{no}
\verb|.initiator| or \verb|.terminator|, and the parentheses are
merely written here to indicate sublists in the expression structure.

Reformatters can detect parsing errors, such the missing operand
in `\verb|x AND AND y|'.

Sometimes \ikey{temporaries}{temporary}\label{TEMPORARY}
are introduced by reformatting.  The syntax involving temporaries is:

\begin{indpar}
\emkey{temporary-definition} ::= {\em temporary} {\em subexpression} \\[1ex]
\emkey{temporary} ::= \verb|$| {\em decimal-natural} \\[1ex]
{\em decimal-natural} ::= see \pagref{DECIMAL-NATURAL}
\end{indpar}

During reformatting, a subexpression may be replaced by
a {\em temporary-definition} containing the subexpression.  This
assigns the {\em temporary} to the value of the subexpression.
Then the {\em temporary} can be used later in the reformatted
expression to refer to this value.  An example is

\begin{center}
\verb|x == y + 3 == z| ~~~ $\Longrightarrow$ ~~~
\verb|AND (== x ($ 563 (+ y 3))) (== ($ 563) z)|
\end{center}

Here the temporary has been used to avoid computing \verb|y + 3|
more than once.

The {\em decimal-naturals} in {\em temporaries} are assigned so no
two {\em temporary-definitions} ever have the same {\em temporary}.

With these things in mind, the reformatters are:

\begin{indpar}[1em]

\newcommand{\OP}[1]{\ttmkey{#1}{reformatting}}
\newcommand{\NBOP}[1]{\ttmnbkey{#1}{reformatting}}

\bigskip

\ttmkey{separator}{reformatter} \hfill \OP{;} ~~~ \OP{,}

\begin{indpar}[0.5em]
Here `\verb|;|' or `\verb|,|' is the \key{separator}.  These have different
precendences, and so cannot appear together in the same expression.

A list of all between-separator subexpressions is made, with empty
between-separator subexpressions being represented by empty lists.
There will be at least two subexpressions: one following
the last separator and one preceding the first separator.
The list of subexpressions is given a
\ttmkey{.separator}{produced by parsing}
attribute with value of the separator (\verb|";"| or \verb|","|),
and is returned as the result of the reformatting.

The standard bracket reformatters will merge the returned list with
their brackets.  Thus given `\verb|(x,y)|', the `\verb|separator|'
reformatter will return
\begin{indpar}\begin{verbatim}
@1 = x y {| .separator = "," |}
\end{verbatim}\end{indpar}
so the input to the \verb|( )| reformatter will be
\begin{indpar}\begin{verbatim}
@2 = @1 {| .initiator = "("; .terminator = ")" |}
@1 = x y {| .separator = "," |}
\end{verbatim}\end{indpar}
and this reformatter will merge the two lists into one,
returning
\begin{indpar}\begin{verbatim}
@3 = x y :|
    .initiator = "("
    .terminator = ")"
    .separator = ","
\end{verbatim}\end{indpar}

\end{indpar}

\bigskip

\ttmkey{define}{reformatter} \hfill \NBOP{<--} ~~~
	\NBOP{\LEFTBRACKET \RIGHTBRACKET} ~~~ \OP{:}

\begin{indpar}[0.5em]

There will be a \verb|<--| operator (the other operators are afix),
and it is a parsing error
detected by the reformatter if there is more than one.
The one \verb|<--| operator is moved to the front of the expression:

\hspace*{2em}\begin{tabular}{lcl}
\verb|x <-- y { z }| & $\Longrightarrow$ & \verb|<-- x y { z }| \\
\verb|x <-- { z }| & $\Longrightarrow$ & \verb|<-- x { z }| \\
\verb|x <--| & $\Longrightarrow$ & \verb|<-- x|
\end{tabular}

Indented subexpressions introduced by the \verb|:| indentation
mark are parsed like final \verb|{ }|
bracketted subexpressions.  Because they are afix operators with the
same precedence as \verb|<--|,
`\verb|x <-- y { z }|' does \underline{not}
end up as `\verb|<-- x ( y { z } )|', and we get results like:

\hspace*{2em}\begin{tabular}{lcl}

\verb|x <-- u v w { z }| & $\Longrightarrow$ & \verb|<-- x ( u v w ) { z }|
\\[1ex]
\begin{tabular}{@{}l@{}}
\verb|x <-- u v w:| \\
\verb|    z|
\end{tabular}
& $\Longrightarrow$ &
\begin{tabular}{@{}l@{}}
\verb|<-- x ( u v w ):| \\
\verb|    z|
\end{tabular}

\end{tabular}


\end{indpar}

\bigskip


\ttmkey{assign}{reformatter} \hfill \NBOP{=} ~~~ \NBOP{+=} ~~~ \NBOP{-=}
				           ~~~ \NBOP{*=} ~~~ \NBOP{/=}

\begin{indpar}[0.5em]
If there is only one operator, it is simply moved to the front.  If there
are several, they are rewritten as one operator subexpressions so the
rightmost executes first.

\hspace*{2em}\begin{tabular}{lcl}
\verb|y = z| & $\Longrightarrow$ & \verb|= y z| \\
\verb|x = y = z| & $\Longrightarrow$ & \verb|= x (= y z)| \\
\verb|x += y *= z| & $\Longrightarrow$ & \verb|+= x (*= y z)|
\end{tabular}
\end{indpar}

\bigskip

\ttmkey{logical}{reformatter} \hfill \NBOP{AND} ~~~ \NBOP{OR} ~~~ \NBOP{NOT}
							      ~~~ \NBOP{BUT}

\begin{indpar}[0.5em]
If there is only one operator and it is at the beginning of the expression,
then the expression is not changed.  It is a reformatter detected parsing
error if this operator is \verb|BUT|, or if the operator is \verb|NOT|
and there are zero or more than one operand.

Otherwise if the expression has only \verb|AND| or only \verb|OR| operators
the expression is rewritten with the operator at the beginning.  It is
a reformatter detected error if there are missing operands, either beteen
operators, before the first operator, or after the last operator.  Thus:

\hspace*{2em}\begin{tabular}{lcl}
\verb|x AND y| & $\Longrightarrow$ & \verb|AND x y| \\
\verb|x AND y AND z| & $\Longrightarrow$ & \verb|AND x y z| \\
\verb|x OR y| & $\Longrightarrow$ & \verb|OR x y| \\
\verb|x OR y OR z| & $\Longrightarrow$ & \verb|OR x y z| \\
\verb|AND y AND z| & $\Longrightarrow$ & error \\
\verb|x AND AND z| & $\Longrightarrow$ & error \\
\verb|x AND y AND| & $\Longrightarrow$ & error \\
\end{tabular}

Otherwise the expression must have the operator sequence `\ttnbkey{BUT NOT}'
and one of the forms:

\hspace*{2em}\begin{tabular}{l}
$e_1$ \verb|BUT NOT| $e_3$ \\
$e_1$ \ldots{} \verb|BUT NOT| $e_3$ \verb|OR| $e_4$ \verb|OR| \ldots{} \\
$e_1$ \verb|AND| $e_2$ \verb|AND| \ldots{} \verb|BUT NOT| $e_3$ \\
$e_1$ \verb|AND| $e_2$ \verb|AND| \ldots{} \verb|BUT NOT|
$e_3$ \verb|OR| $e_4$ \verb|OR| \ldots{} \\
\end{tabular}

There can be \verb|AND|'s before the \verb|BUT NOT| and \verb|OR|'s after
the \verb|BUT NOT|,
but there must be at least one operand before the \verb|BUT NOT|
and at least one after.  These expressions are rewritten using prefix
\verb|AND| and \verb|NOT| operators:

\hspace*{2em}\begin{tabular}{lcl}
\verb|x BUT NOT v| & $\Longrightarrow$ & \verb|AND x (NOT v)| \\
\verb|x AND y BUT NOT v| & $\Longrightarrow$ & \verb|AND x y (NOT v)| \\
\verb|x BUT NOT v OR w| & $\Longrightarrow$ & \verb|AND x (NOT v) (NOT w)| \\
\verb|x AND y BUT NOT v OR w|
    & $\Longrightarrow$ & \verb|AND x y (NOT v) (NOT w)| \\
\end{tabular}

All other forms of expression are reformatter detected parsing errors.

Note that {\tt NOT} is not a classical prefix operator, which would have
higher priority than \verb|=| or \verb|<|.  Also note that {\tt AND}
and {\tt OR} may not be used in the same logical expression without using
explicit brackets, unless there is a {\tt BUT NOT}.  Thus:

\hspace*{2em}\begin{tabular}{lcl}
\verb|x AND y OR z| & $\Longrightarrow$ & error \\
\verb|x AND NOT y| & $\Longrightarrow$ & error \\
\verb|x AND NOT v OR w| & $\Longrightarrow$ & error \\
\verb|NOT x < y| & $\Longrightarrow$ & \verb|NOT (x < y )| \\
\end{tabular}
\end{indpar}

\bigskip

\ttmkey{compare}{reformatter} \hfill
	\NBOP{=} ~~~ \NBOP{<} ~~~ \NBOP{>} ~~~
	\NBOP{/=} ~~~ \NBOP{!=} ~~~
	\NBOP{=>} ~~~ \NBOP{>=} ~~~
	\NBOP{=<} ~~~ \NBOP{<=}

\begin{indpar}[0.5em]
The expression is rewritten using a multi-argument {\tt AND}
function and two-argument compare functions.  Temporaries
(\pagref{TEMPORARY})
are used to name intermediate expression values to
avoid recomputing arguments.

\hspace*{2em}\begin{tabular}{lcl}
\verb|x < y < z| & $\Longrightarrow$ &
    \verb|AND (< x ($ 56 y)) (< ($ 56) z))| \\[1ex]
\verb|w == x != y <= z| & $\Longrightarrow$
             & \begin{tabular}[t]{@{}l@{~}l@{}}
	       \verb|AND| & \verb|(== w ($ 57 x))| \\
			  & \verb|(!= ($ 57) ($ 58 y))| \\
			  & \verb|(<= ($ 58) z)| \\
	       \end{tabular}
\end{tabular}

Note that sequences of comparison operators are treated as they are
in mathematics and not as they are in classical programming languages.
E.g., \verb|x<y<z| means \verb|x<y AND y<z| and \underline{not}
\verb|(x<y)<z|.
\end{indpar}

\bigskip

\ttmkey{sum}{reformatter} \hfill \NBOP{+} ~~~ \NBOP{-}

\begin{indpar}[0.5em]
The results are rewritten using the multi-argument summation function \verb|+|
and the unary negation function \verb|-|.

\hspace*{2em}\begin{tabular}{lcl}
\verb|x - y + z - w| & $\Longrightarrow$ & \verb|+ x (- y) z (- w)|
\end{tabular}
\end{indpar}

\bigskip

\ttmkey{product}{reformatter} \hfill \NBOP{*} ~~~ \NBOP{/}

\begin{indpar}[0.5em]
The different kinds of multiplication operators, \verb|*| and \verb|/|,
cannot be mixed in the same expression.  There may not be more than one
\verb|/| operator in the expression.  The results are rewritten using
the multi-argument multiplication function \verb|*| or the binary
division function \verb|/|.  E.g.:

\hspace*{2em}\begin{tabular}{lcl}
\verb|x * y * z| & $\Longrightarrow$ & \verb|* x y z| \\
\verb|x / y| & $\Longrightarrow$ & \verb|/ x y| \\
\verb|x / y / z| & $\Longrightarrow$ & error \\
\verb|x * y / z| & $\Longrightarrow$ & error \\
\end{tabular}

\end{indpar}

\bigskip

\ttmkey{subscript}{reformatter} \hfill \NBOP{[~...~]}

\begin{indpar}[0.5em]
The expression is rewritten using the binary subscript function:

\hspace*{2em}\begin{tabular}{lcl}
\verb|x[y]| & $\Longrightarrow$ & \verb|subscript x y| \\
\end{tabular}

\end{indpar}


\end{indpar}


\subsubsection{The Operator Parser Algorithm}
\label{OPERATOR-PARSER-ALGORITHM}


The operator parser uses an input list which it initializes to the parser's
list input argument.  Lexemes and subexpressions are removed from this
as they are recognized by the parsing algorithm.

and an output list which is initially
empty.  The parser executes a parsing loop that removes lexemes
from the beginning of the input list and adds {\em expression-items}
to the end of the output list.  When the parser terminates, the output
list becomes the returned parsed expression.

The operator parser has a helper function that is called with
a single optional argument called the \key{terminating precedence}.
The helper function parses an initial segment of the input list,
discards this segment from the input list, and returns the parsed
result of this segment as the helper function value.
The initial segment is terminated the end of the input list,
or by an operator whose precedence
is equal to or less than the terminating precedence argument.

The operator helper function has an output list which it initializes
to be empty and into which it copies lexemes and subexpressions.
Some of these may be operators.
Operators in the output list are identified when they are moved from beginning
of the input list to the end of the output list.
The first such operator in the output list is called the \key{lead operator},
and its definition is called the \key{lead operator definition}.
This definition provides things like reformatters and evaluators when
the output list is viewed as an expression.

The helper function uses an operation called \key{reformatting the
output list}.  This consists of calling the reformatter of the lead
operator definition, and replacing the output list with the returned
value.  If there is no lead operator, nothing is done.

The helper function also
uses a suboperation known as \key{compacting the output list}.
If the list contains zero or just one element, nothing is done.  Otherwise
the list is replaced by a one element list whose only element is
the previous output list.

In reading the following algorithm, it may be helpful to recall that an
operator can have only one fixity, prefix, postfix, infix, nofix, or afix,
except for the case of a prefix operator, which can also be either infix
or postfix (but not both) (see \pagref{FIXITY-RULES}).

After initializing its the output list to empty,
the helper function executes a \key{parsing loop} that repeats the following:

\begin{enumerate}

\item The beginning of the input list is inspected to see if it
begins with an current operator.  Afix operators are ignored.
If more than one current operator qualifies, the operator whose definition
is nearest the top of the parsing definition stack is selected.
If the input list is empty, it does not begin with an operator.

\item If the input list does not begin with a current operator,
and the list is not empty, the lexeme or subexpression at the
beginning of the input list is moved to the end of the output list, and
the parsing loop iterates.

\item If the input list is not empty, it begins with an operator.
The \mkey{operator fixity}{in parsing loop}
and \mkey{operator precedence}{in parsing loop} are determined as follows:

\begin{enumerate}

\item If the output list is empty, and the operator can be prefix
or nofix, the operator fixity is prefix if the operator can be prefix,
or nofix otherwise (the operator cannot be both prefix and nofix).

\item If the output list is empty
and the operator cannot be prefix or nofix, then an error operand
is inserted into the output list, a parsing error is announced, and
the operator fixity is determined by the following.

\item If the output list is non-empty
and the operator cannot be nofix, infix, or postfix,
then an error nofix operator is inserted at the \underline{beginning}
of the \underline{input list}, a parsing error is announced, and
the parsing loop is iterated (so the error nofix operator will become
the current operator).

\item If the output list is non-empty and the operator can be postfix,
infix, or nofix, the operator fixity is postfix if the operator can
be postfix, infix if the operator can be infix, or nofix if the operator
can be nofix (the operator cannot be more than one of these fixities).

\item The operator precedence is set to the precedence
in the operator definition if the operator fixity
is infix or nofix,
and is otherwise the error precedence if the operator is an error
nofix operator, the prefix precedence if the operator fixity is
prefix, or the postfix precedence if the operator fixity is
postfix.

\end{enumerate}

\item If the input list is empty, or if
a terminating precedence argument was given, the operator fixity is
not prefix, and the operator precedence
is equal to or less than the terminating precedence argument,
the parsing loop and helper function terminate.
Nothing is removed from the input list.  The output list is reformatted
and returned as the value of the helper function.

\item If the output list is non-empty, it
is reformatted and compacted (becoming the
first operand of the current operator that is infix or nofix).
Note that because of what happens below, the output list cannot
consist of one element that is an operator.

\item The operator is removed from the input list and copied
to the output list.  The operator will be the first
operator in the output list, and therefore
becomes the lead operator of the output list.

\item
If the operator fixity is prefix, infix, or nofix, then
a \key{parsing subloop} that repeats the following is executed:

\begin{enumerate}

\item The parsing helper is called with
the operator precedence as its terminating precedence argument.

\item If the returned parsed expression is the empty list, and
the operator fixity is prefix or infix, the returned parsed expression is
replaced by an error operand, and a parsing error is announced.

\item If the returned parsed expression contains more than
one element, it is converted to a one element
list whose only element is the returned parsed expression list.
Then the returned parsed expression
is added by concatenation to the end of the output list.

\item If the operator fixity is prefix, or if
the input list now begins with a current operator that cannot be
infix, nofix, or afix, or that has a precedence below the
operator precedence,
the parsing subloop terminates and the parsing loop iterates.

\item The input list must now begin with an infix, nofix, or
afix current operator whose precedence equals the operator precedence.
That operator is moved from the input list to the output list,
and the parsing subloop iterates.

\end{enumerate}

\end{enumerate}

\subsection{Text Parsing}
\label{TEXT-PARSING}

OBSOLETE - revise

\ikey{Text parsing}{text parsing} is performed by the \ttkey{-TEXT-PARSER-},
which is the parser for subexpressions of the
\verb|`|...\verb|'|, etc. matchfix operators.
The \verb/|/ format separator and sentence and paragraph ends are
recognized by text processing, while
operators, qualifiers, qualifier shortcuts, and
the \verb|::?|, \verb|<:>|, \verb|::>|, \verb|@@|, and
\verb|??| marks are \underline{not} recognized.

Text parsing is normally done in the context of a pair of matched
{\em quotes}, and in this context {\em white-space} pre-lexemes
become lexemes.  Note that {\em white-space} lexemes all consist
of zero or more {\em vertical space} characters followed by zero or
more {\em single-space} characters (reference: TBD: make white space
lexemes sometimes?).
There are three kinds of {\em white-space} lexemes
used by text parsing:

\begin{list}{}{}

\item[{\bf Spacer Lexemes}.]
A \key{spacer} lexeme is a {\em white-space} lexeme containing
only single spaces.  Spacers are used in text parsing if they follow
a \verb\|\ format separator on a line.

\item[{\bf Line Separator Lexemes}.]
A \key{line separator} lexeme is a {\em white-space}
lexeme that contains a single {\em line-feed} character and no other
{\em vertical-space} characters.  Such lexemes separate
non-blank lines, and are used by text parsing to end lines containing
a \verb\|\ format separator.

\item[{\bf Blank Line Lexemes}.]
A \key{blank line} lexeme is a {\em white-space}
lexeme that contains either two or more {\em line-feed} characters or contains
a {\em vertical-space} character that is not a {\em line-feed} character.
Such lexemes
represent blank lines between non-blank lines, and are used by text parsing
both to end lines containing a \verb\|\ format separator and
to separate paragraphs.

\end{list}

\subsubsection{Section, Paragraph, and Sentence Parsing}
\label{SECTION-PARAGRAPH-AND-SENTENCE-PARSING}

If the text being parsed does not contain any format separators,
the text is parsed into phrases, sentences, and paragraphs.

First the text is divided by blank line lexemes into paragraphs.
The sequence of paragraphs comprises a section.

Then in each paragraph, sentence terminators are located.
White-space lexemes in the paragraph are deleted after sentence terminators
are located.
Each sequence
of lexemes or subexpressions ending in a sentence terminator
is made into a sentence, and any
non-empty sequence
of lexemes or subexpressions following the last sentence terminator
is made into a phrase.
The paragraph is then a sequence of zero or more sentences 
possibly followed by a phrase.  However, a paragraph cannot be empty.

The syntax of the result is:

\begin{indpar}
\emkey{section} ::= \verb|[-SECTION-| {\em paragraph} {\em paragraph}\,$^\star$
                  \verb|]| \\[1ex]
\emkey{paragraph}
	\begin{tabular}[t]{rl}
	::= &  \verb|[-PARAGRAPH-| {\em sentence} {\em sentence}\,$^\star$
	       \verb|]| \\
	$|$ &  \verb|[-PARAGRAPH-| {\em sentence}\,$^\star$ {\em phrase}
	       \verb|]|
	\end{tabular} \\[1ex]
\emkey{sentence} ::= \verb|[-SENTENCE-| {\em sentence-non-terminator}\,$^\star$
                                    {\em sentence-terminator}
                  \verb|]| \\[1ex]
\emkey{phrase}
	\begin{tabular}[t]{rl}
	::= &  \verb|[| \begin{tabular}[t]{@{}l@{}}
			{\em sentence-non-terminator}
			{\em sentence-non-terminator} \\
		        {\em sentence-non-terminator}\,$^\star$ \verb|]|
			\end{tabular} \\
	$|$ &  {\em sentence-non-terminator}
	\end{tabular} \\[1ex]
\emkey{sentence-terminator} ::= \verb|.| $|$
                              \verb|?| $|$
                              \verb|!| \\[1ex]
\emkey{sentence-non-terminator} ::= {\em symbol} $|$
                                  {\em subexpression}
\end{indpar}

Note that a {\em phrase} with more than one {\em sentence-non-terminator}
is a list, but a {\em phrase} with just one {\em sentence-non-terminator}
is not a list, but just the single {\em sentence-non-terminator} by itself.

There are several rules that modify the description just given:

{\bf Sentence Terminator Rule.}\index{Sentence Terminator Rule}
A \key{sentence-terminator} is any lexeme that is syntactically
a sentence terminator, that is not preceded by a {\em white-space}
lexeme, and that is followed by a {\em white-space} lexeme, a
{\em closing-mark} lexeme, or the
end of the lexeme sequence.  All other lexemes and all subexpressions are
\skey{sentence-non-terminator}s.

{\bf Initial Capitalization Rule.}\index{Initial Capitalization Rule}
A {\em word} consisting of an initial capital letter followed
by zero or more lower case letters is converted
to an all lower case word if it begins a sentence.
A {\em word} consisting of an initial
\verb|^|\index{^@{\tt \Circumflex}} followed by an upper
case letter followed by zero or more lower case letters has the
initial \verb|^| removed.

{\bf Text Simplification Rule.}\index{Text Simplification Rule}
If the {\tt -TEXT-PARSER-} is to return a {\em section} with just
one {\em paragraph} and that {\em paragraph} contains nothing but
just one {\em sentence} or {\em phrase},
then just the {\em sentence} or {\em phrase} is returned.
Otherwise, if a {\em section} with just one {\em paragraph} is
to be returned, just the {\em paragraph} is returned.


Some examples follow:

\begin{center}
\begin{tabular}{lcl}

\verb|`the wife of Bob'|
& parses as &
\verb|[-PHRASE- the wife of Bob]|
\\[2ex]
\verb|`She hit the ball.'|
& parses as &
\verb|[-SENTENCE- she hit the ball .]|
\\[2ex]
\begin{tabular}{@{}l@{}}
\verb|`^Bill swung.| \\
\verb|  But he missed!'|
\end{tabular}
& parses as &
\begin{tabular}{@{}l@{}}
\verb|[-PARAGRAPH- [-SENTENCE- Bill swung .]| \\
\verb|             [-SENTENCE- but he missed !]]|
\end{tabular}
\\[5ex]
\begin{tabular}{@{}l@{}}
\verb|`^I liked| \\
\verb|  the party.| \\
\verb|| \\
\verb|  Later, we caught| \\
\verb|  the bus.'|
\end{tabular}
& parses as &
\begin{tabular}{@{}l@{}}
\verb|[-SECTION-| \\
\verb|   [-PARAGRAPH-| \\
\verb|      [-SENTENCE- I liked the party .]]| \\
\verb|   [-PARAGRAPH-| \\
\verb|      [-SENTENCE- later , we caught the| \\
\verb|                  bus .]]]| \\
\end{tabular}

\end{tabular}
\end{center}

Note that capitalized words like proper names and `\verb|I|' need to be
prefixed by `\verb|^|' if they begin a sentence or phrase.


\subsubsection{Text with Format Separators}
\label{TEXT-WITH-FORMAT-SEPARATORS}

TBD

\subsection{The Parsing Algorithm}
\label{THE-PARSING-ALGORITHM}
Parsing is done by a recursive descent left-to-right algorithm.
A parser is called to parse each subexpression.  This parser is
given the following explicit arguments:

\begin{center}
\begin{tabular}{l}
a list of lexemes to parse \\
an optional (closing) bracket definition \\
an optional (terminating) operator precedence \\
\end{tabular}
\end{center}

The bracket definition, if given, specifies a closing bracket
which must appear in the list of lexemes.  When the parser
finds this bracket outside other brackets, the parser terminates
the parse.

The operator precedence, if given, specifies that infix or
nofix operators of this and lower precedence will terminate the parsing if
they are encountered in the list of lexemes.

In addition the parser is given the following implicit
arguments:

\begin{center}
\begin{tabular}{l}
the parsing definition stack \\
the parsing selector set stack
\end{tabular}
\end{center}

The parser returns

\begin{center}
\begin{tabular}{l}
the parsed expression \\
the unparsed final segment of the input lexeme list
\end{tabular}
\end{center}

When parsing is terminated by finding a closing bracket matching
the closing bracket definition argument, then the part of the
input lexeme list after this closing bracket is returned as the
unparsed final segment of the input lexeme list.  When parsing is
terminated by finding a terminating operator of precedence equal to or lower
than an operator precedence argument, the part of the input
lexeme list beginning with this terminating operator is returned as the
unparsed final segment of the input lexeme list.  Otherwise the
returned unparsed final segment of the input lexeme list is empty.

There are two standard kinds of parser: the operator parser
and the text parser.  These use somewhat different algorithms.

\subsubsection{The Text Parser}
\label{TEXT-PARSER}

The text parser divides the input into paragraphs that are separated by
blank lines.

Paragraphs are classified as tabular or free-form according
to whether their first line is a tabular format line.
A \key{tabular format line} contains optional whitespace characters,
followed by a `\ttmnbkey{+}{in tabular format line}', followed
by any number of `{\tt +}' or
`\ttmnbkey{-}{in tabular format line}' characters,
followed by a `{\tt +}' that ends the line, except that superfluous
whitespace characters are allowed after the `line ending' {\tt+}.
An example of a tabular paragraph is:


\begin{indpar}\begin{verbatim}
+------------------------+--------+------+
 ice melt                 40 lbs    $4.50
 2x4's, 8ft               10       $27.70
 16d nails                 2 lbs     3.21
\end{verbatim}\end{indpar}


A paragraph that is not tabular is \ikey{free-form}{paragraph}.
Each free-form paragraph is scanned for explicitly bracketed subexpressions,
phrase separators, and sentence terminators.  The paragraph is divided into
sentences using sentence terminators outside brackets, and each sentence
is given \verb|<* *>| implicit brackets.
Each sentence is then divided into
phrases if it has any phrase separators, and 



\section{Expression Evaluation}
\label{EXPRESSION-EVALUATION}

An expression is evaluated by first searching for an expression definition
that matches the expression.  Expression definitions have patterns that
are matched to the expression.  An expression definition may have
guards, which are expressions that must evaluate to true in order for
the expression definition match to succeed, and an expression definition
may have constaint equations, which match subexpressions to patterns or
to each other.
An expression definition may have an expression block that executes
in order to produce a value list for the expression if the definition
matches.  If a matching
expression definition has no expression block, the expression
evaluates to `\ttkey{true}'.  If no expression definition matches an
expression, the expression evaluates to `\ttkey{false}'.

Expression definitions are searched for in a context, which is a list
of expression definitions and pointers to other contexts.
Each point in the program has a lexical context, which is used by default
for expression evaluation. 
By default expressions are evaulated in the
lexical context of the place in the program code where the expression
appears.  In addition, there may be other
contexts in which expressions may be evaluated that effectively implement
either data bases or alternative programming languages.

When an expression definition is found whose pattern matches an expression,
a set of constraints are established that must be statisfied to
complete the match.  There are five kinds of constraints: syntax
equations, pattern equations, default equations, alternative
equations, and guards.
Syntax equations equate expressions that involve syntax variables,
which are names beginning with a \verb|$| followed by a capital letter.
Pattern equations are like syntax equations but
involve a pattern which can represent one of many possible syntax
expressions.  Default equations assign values to syntax variables that are
discarded when a pattern is unfolded to become the syntax expression
it will actually represent.  Alternative equations specify alternatives
for simple atomic clauses that may be in a pattern.
Guards are just expressions that must evaluate to
\verb|true| in order for the match to succeed.

The syntax equations are solved during the matching process,
to produce values for the syntax variables.  Patterns are unfolded during
the matching process to become the syntax expressions they represent.
Guards are evaluated, and in some cases the value of a syntax variable
value is evaluated.
If the syntax equations or pattern equations are inconsistent and
cannot be solved, or if a guard or syntax variable value that must be
evaluated cannot be evaluated, or if a guard evaluates to \verb|false|,
the match fails.  Evaluation of the guards or syntax variable values
may result in additional matches which generate more
constraints involving more syntax variables.

The matching process must consider all possible choices of which definitions
to match to an expression being evaluated.  If all choices fail, the
expression evaluates to \verb|false|.  If only one choice succeeds, that
choice is used to evaluate the expression.  If several choices succeed,
the situation becomes ambiguous, and the evaluation proceeds according
to the matching mode, as is described below
(\secref{MATCHING-ALGORITHM}).

A syntax variable name beginning with
\ttmnbkey{\$}{in syntax variable name} denotes an unevaluated
expression.  The same name without the \verb|$| denotes the value
of this unevaluated expression when it is evaluated
in the context in which the unevaluated expression appears.
This last value is called the `\key{evaluation}' of the unevaluated
expression.  Thus, for example, \verb|$X| denotes an unevaluated
expression and \verb|X| denotes the evaluation of that expression.

As an example, given the syntax equation
\begin{center}
\verb|foo(2+2) :=: foo($X)|
\end{center}
(where \verb|:=:| means `is syntactically equal to'), we get
the syntax equation
\begin{center}
\verb|2+2 :=: $X|
\end{center}
that defines \verb|$X|.  If there is then a guard `\verb|number(X)|',
the expression \verb|$X|, namely `\verb|2+2|',
will be evaluated in its context, the context in which `\verb|foo(2+2)|'
appeared, to produce the value \verb|4|, which will become the value of
\verb|X|, so the guard will become `\verb|number(4)|'.

An expression cannot be evaluated if it contains any undefined syntax
variables.  For example, if we began with the syntax equation
\begin{center}
\verb|foo(2+$Y) :=: foo($X)|
\end{center}
and guard `\verb|number(X)|', \verb|$X| would be `\verb|2+$Y|' which
could not be evaluated.  If at some later time in the matching process
the syntax equation
\begin{center}
\verb|$Y :=: 7|
\end{center}
is generated, then the value of \verb|$X| becomes `\verb|2+7|'
which can now be evaluated to produce the value \verb|9| for \verb|X|
and allow the guard to become `\verb|number(9)|'.

In the above \verb|$X| is an `unevaluated syntax variable' and
\verb|X| is its `associated' `evaluated syntax variable'.  It is
possible to use \verb|X| in a definition where \verb|$X| is actually
meant, but if that is done once, then it must be done for every occurance
of \verb|$X| in the definition, and the only computation that may be
performed on the (unevaluated) value of \verb|$X| is to evaluate it to
produce a value for \verb|X|.

Except for choices of which definitions to match to which expressions,
the entire matching process is monotonic.  This means the order in which
syntax equations are solved, patterns are unfolded, guards are evaluated,
and unevaluated syntax variable values are evaluated does not matter.

In order to make the matching process monotonic, pattern unfolding must
be monotonic.  This means that if undefined syntax variables in a pattern
equation whose pattern has been unfolded are given arbirary values later,
the pattern unfolding must still be valid and unambiguous.

Similarly guard evaluations must not have side effects.  In other
words, evaluating a guard cannot affect any future valuations.
Side effects can only occur during block execution, so any blocks
executed during the guard evaluation process must not have side effects.

Lastly, required evaluations of unevaluated syntax variable values
must be monotonic.  For example, given the syntax variable \verb|$X|,
if the value of \verb|X| is required, the evaluation of the value of
\verb|$X| must be monotonic.
In order to ensure this, an unevaluated expression is not evaluated until
all syntax variables it contains have been given values, so that
the expression to be evaluated does not contain any undefined syntax
variables.  Furthermore, evaluation of such an expression may not have
side effects.  Again this last means that any blocks executed during
the evaluation of the expression must not have side effects.
If an evaluation is needed, but the expression to be evaluated contains
a syntax variable that never becomes defined,
then the matching process fails for the expression definition, just as it
would if a guard evaluated to false.

\subsection{Expression Definitions}
\label{EXPRESSION-DEFINITION}

\ikey{Expression definitions}{expression definition} have the syntax:

\begin{indpar}
\emkey{expression-definition} ::=
	{\em pattern} \verb|<--| {\em constraint-list-option} {\em block-option}
	\\[1ex]
{\em pattern} ::= \verb|<--|{\em -subexpression}
	~~~ [see {\em O-subexpression}, \pagref{O-SUBEXPRESSION}] \\[1ex]
{\em pattern} ::= {\em pattern-object}
	~~~ [see \pagref{PATTERN-OBJECT}] \\[1ex]
\emkey{constraint-list-option} ::= {\em empty} $|$ {\em constraint-list} \\[1ex]
\emkey{constraint-list}
    ::= {\em constraint} \{ \verb|,| {\em constraint} \}$^\star$ \\[1ex]
\emkey{constraint} ::= \verb|,|{\em -subexpression}
	~~~ [see {\em O-subexpression}, \pagref{O-SUBEXPRESSION}] \\[1ex]
\emkey{constraint} ::= {\em syntax-equation}
		       \begin{tabular}[t]{@{}l@{}}
		       $|$ {\em pattern-equation} $|$ {\em default-equation} \\
		       $|$ {\em alternative-equation} $|$ {\em guard}
		       \end{tabular} \\[1ex]
\emkey{syntax-equation} ::= {\em syntax-expression}
		{\tt :=:} {\em syntax-expression}
	        ~~~ [see \pagref{SYNTAX-EQUATIONS}]
	 	\\[1ex]
\emkey{pattern-equation} ::= {\em syntax-expression}
		{\tt :=\TILDE} {\em constraint-pattern}
	        ~~~ [see \pagref{PATTERN-EQUATIONS}]
		\\[1ex]
{\em constraint-pattern} ::= {\em pattern-object}
	~~~ [see \pagref{PATTERN-OBJECT}] \\[1ex]
\emkey{default-equation} ::= {\em syntax-variable}
		{\tt :=?} {\em syntax-expression}
	        ~~~ [see \pagref{DEFAULT-EQUATIONS}]
		\\[1ex]
\emkey{alternative-equation} ::= \\
\hspace*{3em}{\em syntax-variable}
		{\tt :=:} {\em alternative}
		          \verb/|/ {\em alternative}
			  \{ \verb/|/ {\em alternative} \}$^\star$
	                  ~~~ [see \pagref{ALTERNATIVE-EQUATIONS}]
		\\[1ex]
\emkey{alternative} ::= {\em atom} {\em atom}$^\star$
		\\[1ex]
\emkey{guard} ::= \verb|,|{\em -subexpression}
	~~~ [see {\em O-subexpression}, \pagref{O-SUBEXPRESSION}] \\[1ex]
\emkey{block-option} ::= {\em empty} $|$ \verb|{ }| $|$ {\em block} \\[1ex]
\emkey{block} ::= \verb|{| {\em statement}
                           \{ \verb|;| {\em statement} \}$^\star$ \verb|}|
	    \\[1ex]
{\em statement} ::= see \pagref{STATEMENT}
\end{indpar}

The \mkey{pattern}{in expression definition} of an expression definition
is the subexpression before the \verb|<--|.  If the expression definition
with pattern $p$ is being matched to the expression $e$,
the pattern equation $p$ {\tt :=\TILDE} $e$ is asserted, the
constraint syntax and pattern equations in the definition
are asserted, and the definition guards are required to evaluate
to \verb|true|.  Default equations are asserted as necessary.

Just before an expression definition is matched to an expression, the
definition is copied, and the act of copying 
creates a new set of variables that are distinct from any
previous variables.  Thus if \verb|$X| appears in a definition, each
use of the definition will involve a \underline{different}
variable named \verb|$X|.

\subsection{Syntax Equations}
\label{SYNTAX-EQUATIONS}

Although pattern equations are asserted before syntax equations are asserted,
a knowledge of syntax equations is required to understand pattern
equations.

A \key{syntax equation} asserts syntactic identity between two
\skey{syntax expression}s.  A syntax expression is a syntax variable,
an atom, or an object whose attribute values are syntax expressions.
The syntax of a syntax equation is:

\begin{indpar}
\emkey{syntax-equation} ::= {\em syntax-expression} \ttnbkey{:=:}
			    {\em syntax-expression}
			    \\[1ex]
\emkey{syntax-expression} ::= {\em syntax-variable}
			   $|$ {\em atom} $|$ {\em object}
			   \\[1ex]
\emkey{syntax-variable}\label{SYNTAX-VARIABLE}
			\begin{tabular}[t]{rl}
			::= & {\tt \$} {\em capitalized-word } \\
			$|$ & {\tt \$} {\tt (} {\em capitalized-word }
			      {\em name-component}\,$^\star$ {\tt )} \\
			$|$ & {\em place-holding-syntax-variable}
			    ~~~ [see \secref{PLACE-HOLDING-SYNTAX-VARIABLES}] \\
			$|$ & {\em evaluated-syntax-variable}
			    ~~~ [see \secref{EVALUATED-SYNTAX-VARIABLES}] \\
			\end{tabular} \\[1ex]
{\em name-component} ::= see \pagref{NAME-COMPONENT}
\end{indpar}

Syntax equations can be consistent or inconsistent according to the:

\begin{indpar}
\begin{list}{}{}
\item[\ikey{Consistency Rule}{consistency rule}:]
A syntax equation is \key{consistent} if it
\begin{enumerate}
\item asserts identity between a syntax variable and a syntax expression, or
\item asserts identity between two identical atoms, or
\item asserts identity between two objects each of which has the same
attribute labels as the other, and all the attributes in both objects
have exactly one value.
\end{enumerate}
However, this rule is applied after applying the Parentheses
and Atom Rules below.

Syntax equations that are not consistent are \key{inconsistent}.
\end{list}
\end{indpar}

The following rules amend the above process of consistency checking:

\begin{indpar}
\begin{list}{}{}
\item[\ikey{Parentheses Rule}{parentheses rule}:]\label{PARENTHESES-RULE}
An object whose {\tt .initiator} is {\tt "("} and whose
{\tt .terminator} is {\tt ")"} is treated as if it had no
{\tt .initiator} or {\tt .terminator} attributes.
Also, a syntax variable name in \verb|( )| parentheses is treated
as if there were no parentheses.

\item[\ikey{Atom Rule}{atom rule}:]\label{ATOM-RULE}
In a syntax equation asserting the identity of an atom and an object,
the atom is treated as if it were an object that has
no attributes except one list element equal to the atom.
\end{list}
\end{indpar}

Thus the following identities are consistent:

\begin{center}
\begin{tabular}{r@{\tt ~:=:~}l}
\verb/5 + 6/ & \verb/( 5 + 6 )/ \\
\verb/5/ & \verb/( 5 )/ \\
\verb/($X)/ & \verb/{ 5 + 6 }/ \\
\end{tabular}
\end{center}

From a consistent syntax equation asserting the syntax identity
of two objects new equations may be deduced for every attribute
label shared by the two objects.
Given such an attribute label, the values
of the attribute for the two objects are asserted to be syntactically
identical.  This is called \key{propagation}
of the syntax equation, and the rule that permits it is called
the \ikey{Propagation Rule}{propagation rule}\label{PROPAGATION-RULE}.
For example, from

\begin{center}
\verb/sort ($X) {| foo = 5 |} :=: sort ( 5 + 6 ) {| foo = 10 |}/
\end{center}

we can deduce by propagation that

\begin{center}
\begin{tabular}{r@{\tt ~:=:~}l}
\verb/sort/ & \verb/sort/ \\
\verb/($X)/ & \verb/( 5 + 6 )/ \\
\verb/5/ & \verb/10/
\end{tabular}
\end{center}

The deduced equations need not be consistent in order to be deduced.
In this case the first two equations are consistent and the third is not.

In addition to the Propagation Rule, we apply the following, where
$v$ is a variable and $e_1$ and $e_2$ are subexpressions of the original
syntax equations:

\begin{indpar}
\begin{list}{}{}
\item [\ikey{Restricted Symmetry Rule}{restricted symmetry rule}:]%
\label{RESTRICTED-SYMMETRY-RULE}
From $e_1$ {\tt :=:} $v$ we deduce $v$ {\tt :=:} $e_1$.

\item [\ikey{Restricted Transitivity Rule}{restricted transitivity rule}:]%
\label{RESTRICTED-TRANSITIVITY-RULE}
From $v$ {\tt :=:} $e_1$ and $v$ {\tt :=:} $e_2$
we deduce $e_1$ {\tt :=:} $e_2$.
\end{list}
\end{indpar}

We have now given all the deduction rules used to solve syntax equations.
Note that these rules do \underline{not} create new syntax expressions:
all the syntax expressions in any deduced equation were subexpressions
in previous equations.  Because of this,
an algorithm that keeps making deductions until
no new deductions can be made will stop fairly quickly.

Note, however, that two different subexpressions
are not necessarily \verb|:=:| even if they are syntactically the same.
For example, given the original syntax equation:

\begin{center}
\verb/sort ($X, $Y) :=: sort ( 5, 5 )/
\end{center}

we derive by propagation that

\begin{center}
\begin{tabular}{r@{\tt ~:=:~}l}
\verb/sort/ & \verb/sort/ \\
\verb/,/ & \verb/,/ \\
\verb/$X/ & \verb/5/$^1$ \\
\verb/$Y/ & \verb/5/$^2$ \\
\end{tabular}
\end{center}

where we have put superscripts $^1$ and $^2$ on the two \verb|5|'s to
indicate that they are different subexpressions of the original
syntax equation expressions.  But
but we are \underline{not} permitted to apply transitivity
to deduce \verb|$X := $Y|,
because the two \verb|5|'s are not the \underline{same} subexpression of
the original syntax equation expressions.

However, we do make \verb|:=:| different subexpressions
that are variables with the same name.

\begin{quote}

As a technical matter we note that if we did use unrestricted rules
of symmetry, and transitivity, we would not get any essentially new results.
Specifically, the set of variables $v$ for which there is an equation of the
form $v$ {\tt :=:} $e$ where $e$ is not a variable would not expand.  Here
we assume that the original equations and all equations deduced from
these by Propagation, Restricted Symmetry, and Restricted Transitivity are
consistent.

Proof Sketch: Let $S$ be the original set of syntax equations.  Let $S'$ be
$S$ plus the equations deducible from equations in $S$ by using Propagation,
Restricted Symmetry, and Restricted Transitivity.

Let $S''$ be the set of equations $e_1$ {\tt :=:} $e_n$
such that there exists a sequence of expressions $e_2$, $e_3$,
\ldots, $e_{n-1}$ that are \underline{not} variables such that for $i<n$,
either $e_i$ {\tt :=:} $e_{i+1}$
or $e_{i+1}$ {\tt :=:} $e_i$ is in $S'$.  $n=2$ is allowed.

Let $S'''$ be $S$ plus
the equations deducible from $S$ by Propagation, Symmetry,
and Transitivity, without any restriction.

Then $S\subseteq S'\subseteq S''\subseteq S'''$.

If we can prove that
$S''=S'''$, the result will follow, since for a given $v$ an equation
of the form $v$ {\tt :=:} $e$ with $e$ a non-variable can exist in $S''$ only
if an equation of this form exists in $S'$.

So we need to prove $S'''\subseteq S''$.  We do this by mathematical
induction on the size of the deduction of an equation in $S'''$.
This amounts to applying the general rules, Symmetry, Transitivity,
and Propagation to equations in $S''$ and showing that the resulting
consequent must be an equation in $S''$, under the assumption that the
equations in $S'$ are consistent.

\end{quote}

\subsection{Patterns}
\label{PATTERNS}
\label{PATTERN-EQUATIONS}

A \emkey{pattern} is an object that represents one of
a set of syntax expressions.  Patterns are used in
{\em pattern-equations}, which identify a {\em syntax-expression} with
a {\em pattern}.  The syntax of a pattern equations and patterns is:

\begin{indpar}
\emkey{pattern-equation} ::= {\em syntax-expression} \ttnbkey{:=\TILDE}
			    {\em pattern}
			    \\[1ex]
\emkey{pattern} ::= {\em pattern-object}
\\[3ex]
\emkey{pattern-object} ::=
    \begin{tabular}[t]{l}
    {\em pattern-term-option}
        \{ {\em pattern-separator} {\em pattern-term} \}$^\star$ \\
    {\em pattern-attribute-representations}
    \end{tabular}
\label{PATTERN-OBJECT}
    \\[1ex]
\emkey{pattern-term-option} ::= {\em empty} $|$ {\em pattern-term} \\[1ex]
\emkey{pattern-separator} ::= \ttmkey{.}{pattern separator} \\[1ex]
\emkey{pattern-term} ::= {\em pattern-clause} {\em pattern-qualifier-option}
	\\[1ex]
\emkey{pattern-clause} ::= {\em pattern-factor} {\em pattern-factor}\,$^\star$
	\\[1ex]
\emkey{pattern-factor} ::= {\em pattern-object} $|$ {\em atom}
		       $|$ {\em syntax-variable} \\[1ex]
\emkey{pattern-qualifier-option} ::=
	{\em empty} $|$ {\em pattern qualifier} \\[1ex]
\emkey{pattern-qualifier} ::=
		           \ttmkey{?}{pattern qualifier}
		       $|$ \ttmkey{??}{pattern qualifier}
		       $|$ \ttmkey{...}{pattern qualifier}
		       $|$ \ttmkey{...?}{pattern qualifier}
	\\[1ex]
\emkey{pattern-attribute-representations}
\\\hspace*{0.5in}
	\begin{tabular}[t]{rl}
        ::= & {\em empty} \\
	$|$ & \underline{\LEFTBRACKET\BAR} \underline{\BAR\RIGHTBRACKET} \\
	$|$ & \underline{\LEFTBRACKET\BAR}
	      \begin{tabular}[t]{@{}l@{}}
	      {\em pattern-attribute-representation} \\
	      \{ \verb|;|
	              {\em pattern-attribute-representation} \}$^\star$
	      \underline{\BAR\RIGHTBRACKET} \\
	      \end{tabular}
	\end{tabular}
\\[1ex]
\emkey{pattern-attribute-representation} ::=
\\\hspace*{0.5in}
    {\em required-attribute-representation}
    $|$ {\em optional-attribute-representation}
\\[1ex]
\emkey{required-pattern-attribute-representation} ::=
\\\hspace*{0.5in}
	{\em attribute-label} {\em attribute-label-flags-option} \verb|=|
	      {\em pattern}
\\[1ex]
\emkey{optional-pattern-attribute-representation} ::=
\\\hspace*{0.5in}
	{\em attribute-label} {\em attribute-label-flags-option} \verb|=?|
	      {\em pattern}
\end{indpar}

A pattern represents one of many possible syntax expressions.  The
syntax expression it represents is made by concatenating the
{\em pattern-clauses} in different ways.  For example,

\begin{center}
\verb/replace ($X) . in ($Y) . by ($Z)/
\end{center}

represents one of the two syntax expressions:

\begin{center}
\verb/replace ($X) in ($Y) by ($Z)/ \\
or \\
\verb/replace ($X) by ($Z) in ($Y)/ 
\end{center}

The rules for pattern representation are:

\begin{enumerate}
\item The represented {\em syntax-expression} is a sequence of
{\em pattern-clauses} from the {\em pattern} taken in any order,
\underline{except}, if the first {\em pattern-clause} in the
{\em pattern} is not preceded by {\em pattern-separator} `\verb|.|',
it must be first in the {\em syntax-expression}.

\item A {\em pattern-clause} not followed by a {\em pattern-qualifier}
(\verb|?|, \verb|??|, \verb|...|, or \verb|...?|)
in the {\em pattern} must appear exactly
once in the represented {\em syntax-expression}.

\item A {\em pattern-clause} followed by `\verb|?|'
in the {\em pattern} is an \key{optional pattern clause}
and must appear exactly once or not at all
in the represented {\em syntax-expression}.
See \secref{DEFAULT-EQUATIONS} for examples.

\item\label{OPTIONAL-TRUTH-VALUE-CLAUSE-RULE}
A {\em pattern-clause} followed by `\verb|??|'
in the {\em pattern} is an \key{optional truth-value pattern clause}.
Like an optional pattern clause this must appear exactly once or not at all
in the represented {\em syntax-expression}.
In addition, the {\em pattern-clause} must end with a {\em syntax-variable},
and this may be omitted in the represented {\em syntax-expression}.
See \secref{OPTIONAL-TRUTH-VALUE-PATTERN-CLAUSES} for examples.

\item A {\em pattern-clause} followed by `\verb|...|'
in the {\em pattern} is a \key{repeated pattern clause}
and must appear one or more times
in the represented {\em syntax-expression}.
See \secref{REPEATED-PATTERN-CLAUSES} for examples.

\item A {\em pattern-clause} followed by `\verb|...?|'
in the {\em pattern} is an \key{optional repeated pattern clause}
and must appear one or more times or not at all
in the represented {\em syntax-expression}.
See \secref{REPEATED-PATTERN-CLAUSES} for examples.

\item A {\em syntax-variable} in a {\em pattern}
that appears in an {\em alternative-equation}
is called an \key{alternative-syntax-variable} and must be replaced
(along with any parentheses surrounding it)
in the represented {\em syntax-ex\-pres\-sion}
by one of the {\em alternatives} from the {\em alternative-equation}.
See \secref{ALTERNATIVE-EQUATIONS} for examples.

\item A {\em required-pattern-attribute-representation}
that has an `\verb|=|' sign
must appear exactly once in the represented {\em syntax-expression}.

\item An {\em optional-pattern-attribute-representation}
that has an `\verb|=?|' sign
and must appear exactly once or not at all
in the represented {\em syntax-expression}.

\end{enumerate}

Patterns appear in pattern equations, which are just
like syntax equations except their right sides are patterns and not
a syntax expressions.  If the syntax expression on the left side of
a pattern equation is an object, then the pattern on the right side
can be \key{unfolded} to match the syntax expression.  Unfolding
means removing the
\skey{pattern separator}s, `\verb|.|',
and \skey{pattern qualifier}s,
`\verb|?|', `\verb|??|', `\verb|...|', and `\verb|...?|',
arranging the pattern clauses in the correct order,
and removing {\em optional-attribute-representations}.
For example, given the pattern equation:

\begin{center}
\begin{tabular}{r@{\tt ~:=\TILDE~}l}
\verb/replace {b} by {5 + c} in (exp 1)/
	& \verb/replace ($X) . in ($Y) . by ($Z)/ \\
\end{tabular}
\end{center}

The pattern may be unfolded so the equation becomes:

\begin{center}
\begin{tabular}{r@{\tt ~:=\TILDE~}l}
\verb/replace {b} by {5 + c} in (exp 1)/
	& \verb/replace ($X) by ($Z) in ($Y)/ \\
\end{tabular}
\end{center}

The \key{Propagation Rule} (\pagref{PROPAGATION-RULE})
may be applied to a pattern
equation whose right side pattern has been unfolded.  Thus in the
example just given one may may deduce:

\begin{center}
\begin{tabular}{r@{\tt ~:=\TILDE~}l}
\verb/{b}/ & \verb/($X)/ \\
\verb/{5 + c}/ & \verb/($Z)/ \\
\verb/(exp 1)/ & \verb/($Y)/ \\
\end{tabular}
\end{center}

Note that this results in pattern equations and \underline{not}
syntax equations.

A pattern that contains pattern separators or qualifiers
(`\verb|.|', `\verb|?|', `\verb|??|', `\verb|...|', or `\verb|...?|')
\underline{outside} subexpressions and {\em attribute-representations},
or that contains {\em optional-attribute-representations}
(with `\verb|=?|' sign),
is said to be `\key{folded}'.  Other patterns are said to be
\key{unfolded}.  Subexpressions of a pattern are also patterns.

A pattern that is unfolded and all of whose subexpressions
and attribute representation patterns are
unfolded, that is, a pattern that contains no pattern qualifiers or
optional attribute representations,
even in subexpressions or attribute representations,
is said to be \key{completely unfolded}.
Such patterns are \key{promoted} to be syntax expressions, and
any pattern equations containing them are promoted to be
syntax equations.  Thus in the above example the last four
pattern equations can be promoted and become the following
four syntax equations:

\begin{center}
\begin{tabular}{r@{\tt ~:=:~}l}
\verb/replace {b} by {5 + c} in (exp 1)/
	& \verb/replace ($X) by ($Z) in ($Y)/ \\
\verb/{b}/ & \verb/($X)/ \\
\verb/{5 + c}/ & \verb/($Z)/ \\
\verb/(exp 1)/ & \verb/($Y)/ \\
\end{tabular}
\end{center}

The Restricted Symmetry Rule (\pagref{RESTRICTED-SYMMETRY-RULE})
and Restricted Transitivity Rule (\pagref{RESTRICTED-TRANSITIVITY-RULE})
cannot be applied to pattern equations, which are inherently asymmetric.
However the following can be applied, where $v$ is a syntax variable, $e$
a syntax expression, and $p$ a pattern:

\begin{indpar}
\begin{list}{}{}
\item [\ikey{Pattern Transitivity Rule}{pattern transitivity rule}:]%
\label{PATTERN-TRANSITIVITY-RULE}
From $v$ {\tt :=:} $e$ and $v$ {\tt :=\TILDE} $p$
we deduce $e$ {\tt :=\TILDE} $p$.
\end{list}
\end{indpar}

The Parentheses Rule (\pagref{PARENTHESES-RULE})
and Atom Rule (\pagref{ATOM-RULE}) do apply to pattern equations.
For example, a pattern that is an atom may be treated as if it were
a list whose only element is that atom, and a syntax variable in
\verb|( )| parentheses is treated as a syntax variable.

Finally, we need to state the following more carefully:

\begin{indpar}
\begin{list}{}{}
\item [\ikey{Pattern Unfolding Rule}{pattern unfolding rule}:]%
\label{PATTERN-UNFOLDING-RULE}
If a pattern equation asserts the identity of a syntax expression that
is an object with a pattern, and if the pattern can be unfolded unambiguously
so that the result would be consistent were the pattern equation
instead a syntax equation between
objects, then the pattern is unfolded.  Otherwise nothing is done.

When a pattern is unfolded, \underline{all instances} of the pattern
are unfolded, and this affects all equations containing the pattern.
\end{list}
\end{indpar}

The last sentence of the Pattern Unfolding Rule needs explanation.
Suppose we start with the pattern equation:

\begin{center}
\begin{tabular}{r@{\tt ~:=\TILDE~}l}
\verb/replace {b} [by {5 + c} in (exp 1)]/
	& \verb/replace ($X) [. in ($Y) . by ($Z)]/ \\
\end{tabular}
\end{center}

which is similar to our previous equation except the clauses are
now in a subexpression.  At the top level there is only one clause,
so the pattern is already unfolded, and by the Propagation Rule
we get

\begin{center}
\begin{tabular}{r@{\tt ~:=\TILDE~}l}
\verb/replace/ & \verb/replace/ \\
\verb/{b}/ & \verb/($X)/ \\
\verb/[by {5 + c} in (exp 1)]/ & \verb/[. in ($Y) . by ($Z)]/ \\
\end{tabular}
\end{center}

Now we have a total of 4 equations.
The pattern in the last of these equations can be unfolded and
when this is done, \underline{all} the equations containing the pattern are
affected, and we have the 4 equations

\begin{center}
\begin{tabular}{r@{\tt ~:=\TILDE~}l}
\verb/replace {b} [by {5 + c} in (exp 1)]/
	& \verb/replace ($X) [by ($Z) in ($Y)]/ \\
\verb/replace/ & \verb/replace/ \\
\verb/{b}/ & \verb/($X)/ \\
\verb/[by {5 + c} in (exp 1)]/ & \verb/[by ($Z) in ($Y)]/ \\
\end{tabular}
\end{center}

In otherwords, because the pattern in the equation

\begin{center}
\begin{tabular}{r@{\tt ~:=\TILDE~}l}
\verb/[by {5 + c} in (exp 1)]/ & \verb/[. in ($Y) . by ($Z)]/ \\
\end{tabular}
\end{center}

was a subexpression of the pattern in the equation

\begin{center}
\begin{tabular}{r@{\tt ~:=\TILDE~}l}
\verb/replace {b} [by {5 + c} in (exp 1)]/
	& \verb/replace ($X) [. in ($Y) . by ($Z)]/ \\
\end{tabular}
\end{center}

then what appears to be two copies of the same pattern is in fact
only one copy, and unfolding either of these unfolds the other in
exactly the same way.

This is another aspect of the remark near the end of
Section~\secref{SYNTAX-EQUATIONS} that deduction does not create
new syntax expressions: it merely creates new equations between
existing syntax expressions.  This means the deduction process must
quickly terminate, since the supply of syntax expressions is limited to
those in the the initial equations.  Similarly new patterns are not
created by deduction, only new equations involving existing patterns.
And when a pattern unfolds, the folded pattern is replaced by the
unfolded pattern in all equations involving the pattern.

If after doing all possible deductions on a set of equations
all patterns are unfolded,
then all pattern equations will have been promoted to syntax equations.
If on the other hand, some patterns remain folded, then the pattern
equations involving them are said to be
`\mkey{unsolvable}{pattern equations}'.

A pattern equation between a syntax expression that is not a syntax
variable and a folded pattern is said to be
`\mkey{inconsistent}{pattern equation}' if there is \underline{no}
way to unfold the pattern so that the equation can be viewed as a
consistent syntax equation.  Clearly if a pattern equation is inconsistent
then the pattern equation will be unsolvable, or the pattern equation
will become inconsistent when some other equation causes the pattern
to be unfolded and the pattern equation to be promoted so it becomes
an inconsistent syntax equation.

However, if there is more than one way to unfold a pattern in a pattern
equation so that the equation can be viewed as a consistent syntax equation,
then the equation is said to be `\mkey{ambiguous}{pattern equation}'.
An ambiguous equation cannot be used to unfold a pattern, and may become
unsolvable, but, it is possible that another non-ambiguous pattern equation
may exist or be deduced which will allow the pattern to be unfolded, in
which case at the end of all deductions there may be no unfolded patterns
left and no unsolvable pattern equations.  In this case the
ambiguous pattern equation will have been promoted to be a syntax equation,
which may or may not be consistent.

\subsubsection{Default Equations}
\label{DEFAULT-EQUATIONS}

When a pattern is unfolded, syntax variables in optional pattern clauses
not included in the unfolded pattern are given default values
provided by default equations.  Default equations have the
syntax:

\begin{indpar}
\emkey{default-equation} ::= {\em syntax-variable} \ttnbkey{:=?}
			     {\em default-value}
\\[1ex]
\emkey{default-value} ::= {\em syntax-expression}
\end{indpar}

For example, given the equations:

\begin{center}
\begin{tabular}{rcl}
\verb/sort x/ & \tt :=\TILDE & \verb/sort ($X) . in direction ($Y) ?/ \\
\verb/$Y/ & \tt :=? & \verb|ascending|
\end{tabular}
\end{center}

the pattern in the first equation will be unfolded to give the equation:

\begin{center}
\begin{tabular}{rcl}
\verb/sort x/ & \tt :=\TILDE & \verb/sort ($X)/ \\
\end{tabular}
\end{center}

and because the variable \verb|$Y| was dropped during the unfolding,
the default equation that defines it will promoted to become the syntax
equation:

\begin{center}
\begin{tabular}{rcl}
\verb/$Y/ & \tt :=: & \verb|ascending|
\end{tabular}
\end{center}

thereby establishing a value for \verb|$Y|.  Default equations that
are not promoted to become syntax equations by this mechanism are
ignored.  This mechanism does \underline{not} apply to repeated pattern
clauses or optional repeated pattern clauses.

\subsubsection{Alternative Equations}
\label{ALTERNATIVE-EQUATIONS}

An {\em alternative-equation} specifies that a syntax variable must take
one of several alternative values.

\begin{indpar}
\emkey{alternative-equation} ::= \\
\hspace*{3em}{\em syntax-variable}
		{\tt :=:} {\em alternative}
		          \verb/|/ {\em alternative}
			  \{ \verb/|/ {\em alternative} \}$^\star$
		\\[1ex]
\emkey{alternative} ::= {\em atom} {\em atom}$^\star$
\end{indpar}

For example,
\begin{center}
\verb/DIRECTION :=: ascending | descending/
\end{center}

Note that the {\em alternatives} are simple {\em atom} sequences,
and cannot include subexpressions or {\em syntax-variables}.

The {\em syntax-variable} in an alternative equation is called an
\key{alternative-syntax-variable}.  When such a variable appears
in a pattern it must be replaced by one of the {\em alternatives}
from the {\em alternative-equation} when the pattern is unfolded.
Any parentheses surrounding the variable in the pattern are removed.
The replacing {\em alternative} is integrated into the unfolded
pattern as if it had appeared in the pattern instead of the
{\em alternative-syntax-variable} and any parentheses surrounding it.

For example, given the above {\em alternative-equation} and the
{\em pattern-equation}
\begin{center}
\verb/sort ascending (3,2,7,8) :=~ sort DIRECTION (X)/
\end{center}
the pattern in thus equation can be unfolded to make the {\em syntax-equation}
\begin{center}
\verb/sort ascending (3,2,7,8) :=: sort ascending (X)/
\end{center}

However, given instead the pattern equation
\begin{center}
\verb/sort (SORT DIRECTION) (3,2,7,8) :=~ sort DIRECTION (X)/
\end{center}
the pattern in thus equation \underline{cannot} be unfolded because
there is ambiguity about which {\em alternative}
should replace \verb|DIRECTION|.

Whenever a pattern containing a {\em alternative-syntax-variable}
is unfolded, a particular {\em alternative} replaces the
variable in the pattern, and the syntax equation
\begin{center}
{\em alternative-syntax-variable} {\tt :=:} {\em alternative}
\end{center}
is asserted.  In this equation the unevaluated form of the
{\em alternative-syntax-variable} is used.  Thus in the above
example where the pattern was unfoled, the equation
\begin{center}
\verb/$DIRECTION :=: ascending/
\end{center}
is asserted.



\subsubsection{Optional Truth-Value Pattern Clauses}
\label{OPTIONAL-TRUTH-VALUE-PATTERN-CLAUSES}

An \key{optional truth-value pattern clause}%
\index{truth-value pattern clause}%
\index{pattern clause!optional truth value}
(with `{\tt ??}' {\em clause-qualifier}\,)
must end with a syntax variable $v$,
and this variable is treated specially in the following ways.
First, the guard:
\begin{center}
truth value ($v$)
\end{center}
is asserted.  Second, if the clause is omitted from the unfolded pattern,
the syntax equation
\begin{center}
$v$ {\tt :=:} {\tt false}
\end{center}
is asserted.  Third, the clause without its ending syntax variable
may appear in the unfolded pattern,
according to Rule \itemref{OPTIONAL-TRUTH-VALUE-CLAUSE-RULE},
in which case the syntax equation
\begin{center}
$v$ {\tt :=:} {\tt true}
\end{center}
is asserted.

Here $v$ is usually an evaluated syntax variable
(\pagref{EVALUATED-SYNTAX-VARIABLES}), but it may be
an unevaluated syntax variable.

For example, the pattern equation

\begin{center}
\begin{tabular}{rcl}
\verb/sort x/ & \tt :=\TILDE & \verb/sort ($X) . assending ASCENDING ??/ \\
\end{tabular}
\end{center}

produces the guard and syntax equation:

\begin{center}
\verb/truth value (ASCENDING)/ \\
\begin{tabular}{rcl}
\verb/ASCENDING/ & \tt :=: & \verb/false/ \\
\end{tabular}
\end{center}

and the pattern equation

\begin{center}
\begin{tabular}{rcl}
\verb/sort x ascending/ & \tt :=\TILDE &
	\verb/sort ($X) . assending ASCENDING ??/ \\
\end{tabular}
\end{center}

produces the guard and syntax equation:

\begin{center}
\verb/truth value (ASCENDING)/ \\
\begin{tabular}{rcl}
\verb/ASCENDING/ & \tt :=: & \verb/true/ \\
\end{tabular}
\end{center}



\subsubsection{Repeated Pattern Clauses}
\label{REPEATED-PATTERN-CLAUSES}

When a pattern is unfolded, a syntax variable in a
repeated or optional repeated pattern clause is replaced
in the unfolded pattern by new variables that represent elements of a list,
and a new syntax equation setting the original variable to this list
is created.  For example, when the pattern in the equation

\begin{center}
\begin{tabular}{rcl}
\verb/increment x by 5 by 10/ & \tt :=\TILDE
			      & \verb/increment ($X) . by ($Y) ...?/ \\
\end{tabular}
\end{center}

is unfolded, the following equations result:

\begin{center}
\begin{tabular}{rcl}
\verb/increment x by 5 by 10/ & \tt :=\TILDE
			      & \verb/increment ($X) by ($Y$1) by ($Y$2)/ \\
\verb/$Y/ & \tt :=: & \verb|($Y$1, $Y$2)|
\end{tabular}
\end{center}

Note that here `\verb|$Y$1|' and `\verb|$Y$2$|' are each a single syntax
variable name, each with two \verb|$|'s in it.  Users of RECKON should
not use \verb|$| two or more times in
a syntax variable name in order to avoid conflicting
with this usage.

With an optional repeated pattern clause it is also possible for the
resulting list to be empty.  Thus

\begin{center}
\begin{tabular}{rcl}
\verb/increment x/ & \tt :=\TILDE
			      & \verb/increment ($X) . by ($Y) ...?/ \\
\end{tabular}
\end{center}

yields

\begin{center}
\begin{tabular}{rcl}
\verb/increment x/ & \tt :=\TILDE
			      & \verb/increment ($X)/ \\
\verb/$Y/ & \tt :=: & \verb|()|
\end{tabular}
\end{center}

\subsubsection{Place Holding Syntax Variables}
\label{PLACE-HOLDING-SYNTAX-VARIABLES}

A `\verb|$|' by itself can be used as a syntax variable called
a \key{place holding syntax variable} that has the special
property that each of its original equation occurances
is treated as if it were a \underline{different} variable.  The syntax is:

\begin{indpar}
\emkey{place-holding-syntax-variable} ::= \ttnbkey{\$}
\end{indpar}

More specifically, whenever \verb|$| appears in an original
equation, it is replaced by a unique new syntax variable name. 
For example, the pattern equation:

\begin{center}
\begin{tabular}{r@{\tt ~:=:~}l}
\verb/replace {b} by {5 + c} in (exp 1)/
	& \verb/replace ($X) . by $ . in $/ \\
\end{tabular}
\end{center}

is treated as if it were

\begin{center}
\begin{tabular}{r@{\tt ~:=:~}l}
\verb/replace {b} by {5 + c} in (exp 1)/
	& \verb/replace ($X) . by ($1$) . in ($2$)/ \\
\end{tabular}
\end{center}

where `\verb|$1$|' and `\verb|$2$|' are unique new
syntax variable names created by the RECKON system.




\subsubsection{Evaluated Syntax Variables}
\label{EVALUATED-SYNTAX-VARIABLES}

Syntax variables whose names begin with \verb|$|
take values that are syntax expressions
which are \underline{not} evaluated.  Such syntax variables are called
\key{unevaluated syntax variables}.  With every unevaluated syntax
variable there can be associated an \key{evaluated syntax variable}
whose name is made by omitting the \verb|$| from the beginning of the
unevaluated syntax variable name.  Thus \verb|X| is associated with
\verb|$X|.  The syntax is:

\begin{indpar}
\emkey{unevaluated-syntax-variable}
			\begin{tabular}[t]{rl}
			::= & {\tt \$} {\em capitalized-word } \\
			$|$ & {\tt \$} {\tt (} {\em capitalized-word }
			      {\em name-component}\,$^\star$ {\tt )} \\
			\end{tabular}
\\[1ex]
\emkey{evaluated-syntax-variable} 
			::= {\em capitalized-word }
			{\em name-component}\,$^\star$
\\[1ex]
{\em name-component} ::= {\em non-special-symbol} $|$ {\em decimal-natural}
			 ~~~ [as per \pagref{NAME-COMPONENT}]
\end{indpar}

Informally, an evaluated syntax variable is assigned the value obtained by
evaluating its associated unevaluated syntax variable's value.  In order
for this to happen, the unevaluated syntax variable must be evaluatable.
This means that its value, a syntax expression, must not contain any
unevaluatable syntax variables.

More formally:

\begin{indpar}
\begin{list}{}{}
\item [\ikey{Evaluatable Definition}{evaluatable definition}:]%
\label{EVALUATABLE-DEFINITION}
A syntax variable $v$ is evaluatable if a syntax equation $v$ {\tt :=:} $e$
has been deduced and every syntax variable in $e$ is evaluatable.
In this case $e$ is called the \key{unevaluated value} of $v$, and
the \key{complete unevaluated value} of $v$ is $e$ with all the
syntax variables it contains replaced by their complete unevaluated values.
\item [\ikey{Evaluation Rule}{evaluation rule}:]%
\label{EVALUATION-RULE}
If an evaluated syntax variable $v$ appears in a syntax equation and
its associated unevaluated syntax variable {\tt \$}$v$ is evaluatable,
then the syntax equation $v$ {\tt :=:} $E$ is deduced, where $E$
is the value obtained by evaluating the unevaluated value of
{\tt \$}$v$ in the context
in which the unevaluated value of {\tt \$}$v$ appears.
It is an error if this evaluation has side effects (\pagref{SIDE-EFFECTS}).
\end{list}
\end{indpar}

For example, given the code

\begin{indpar}\begin{verbatim}
sum ($X) and ($Y) <-- number(X), number(Y) { value = X + Y }
. . . . .
z = sum (1+1) and (5+5)
\end{verbatim}\end{indpar}

the call to `\verb|sum|' in the last line is matched with the definition
of `\verb|sum|' in the first line giving rise to a number of deduced
equations, among which are:

\begin{center}
\begin{tabular}{rcl}
\verb/sum (1+1) and (5+5)/ & \tt :=\TILDE
			      & \verb/sum ($X) and ($Y)/ \\
\verb/$X/ & \tt :=: & \verb/(1+1)/ \\
\verb/$Y/ & \tt :=:\TILDE & \verb/(5+5)/ \\
\verb/X/ & \tt :=: & \verb/2/ \\
\verb/Y/ & \tt :=:\TILDE & \verb/10/ \\
\end{tabular}
\end{center}

The last two equations are required to deduce the value of the evaluated
variables \verb|X| and \verb|Y| that are needed for the guards
\verb|number(X)| and \verb|number(Y)| and the block code statement
`\verb|value = X + Y|\,'.  These last two equations are obtained by
the Evaluation Rule.  For example, to obtain the value \verb|2| for the
evaluated variable \verb|X|, the value `\verb|(1+1)|' of the a associated
unevaluated variable \verb|$X| is evaluated.  `\verb|(1+1)|' is
evaluatable because it contains no syntax variables and for this reason is
also its own `complete unevaluated value'.

Semantically, evaluated syntax variables are not permitted in patterns.
However, syntactically they can be placed in patterns according to the
following:

\begin{indpar}
\begin{list}{}{}
\item [\ikey{Evaluated Variable Pattern Rule}%
{evaluated variable pattern rule}:]%
\label{EVALUATED-VARIABLE-PROMOTION-RULE}
If an evaluated syntax variable $v$ appears in a pattern, it is 
replaced in the pattern by its associated unevaluated variable
\verb|$|$v$, and in addition
any occurances of \verb|$|$v$ in the containing expression definition
are treated as errors (i.e., $v$ and not \verb|$|$v$ must be used
throughout the expression definition).
\end{list}
\end{indpar}

For example, the definition

\begin{indpar}\begin{verbatim}
for every counter:
    on increment THIS . by Y ? <-- counter (THIS), number(Y),
                                   Y :=? 1:
        next count = count + Y
\end{verbatim}\end{indpar}

is treated as if it were

\begin{indpar}\begin{verbatim}
for every counter:
    on increment $THIS . by $Y ? <-- counter (THIS), number(Y),
                                     Y :=? 1:
        next count = count + Y
\end{verbatim}\end{indpar}

while the definition

\begin{indpar}\begin{verbatim}
for every counter:
    on increment THIS . by Y ? <-- counter (THIS), number(Y),
                                   $Y :=? 1:
        next count = count + Y
\end{verbatim}\end{indpar}

would be in error because \verb|Y| is used in the pattern but
\verb|$Y| is used in the default equation.

\subsection{The Matching Algorithm}
\label{MATCHING-ALGORITHM}

The \key{evaluation algorithm} inputs an expression to be evaluated
and a context.  The context (\secref{CONTEXTS}) provides a list of expression
definitions that may match the expression.

An expression to be evaluated may contain syntax variables that are assigned
values during matching.  The result of matching is both a list of values for
the expression and an assignment of values for these variables.

More than one definition may match an expression.
More than one definition may match a guard,
and different guard definitions may lead to different
values of variables in the original expression being evaluated.
So expression matching is a search process to find a choice
of expression definitions that
leads to success, and more than one choice may succeed.

Note that evaluations of guards and evaluations
used to find values of evaluated syntax variables are required to have
no side effects, so the order of these evaluations does not matter.
Given the choices of which definitions are matched to which expressions,
the outcome of the matching process is uniquely determined, and does not
depend on the order of syntax equation deductions, guard evaluations, etc.,
or on the order in which the choices are tried.

Matching may be done in any of the following \skey{matching mode}s:

\begin{list}{}{}

\item[\ttkey{first-value}]~\\
The first definitions tried that lead to successful matches are the only ones
used.  Definitions are tried in the order they are given in the contexts
used in evaluation.

\item[\ttkey{all-values}]~\\
All possible choices are tried and the
successful results are collected in a set of results.  Each result
in this set consists of a value list for the expression being evaluated
and values for each syntax variable in that expression.

\item[\ttkey{consistent-values}]~\\
All possible choices are tried and the
successful results are collected in a set of results.  Then these results
are tested to see if they are pairwise equal.
All the value lists of the expression
being evaluated must be equal, and all the values of each syntax variable
contained in the expression must be equal.  If all expression value lists or
values of a syntax variable are equal, one of these expression value lists
is returned as the value list of the expression, and one syntax variable value
is returned as the value of the syntax variable.
If some of the expression value lists or syntax variable values are unequal, an
error value giving the context of the evaluation and the unequal value lists
or values is returned as the value of the expression or syntax variable.

\end{list}

If the expression match search process yields no matches at all,
the expression is given the value `\verb|false|', and variables in the
expression are not given any values.

\subsection{Contexts}
\label{CONTEXTS}

An expression is evaluated in a context.  The context is searched
for an expression definition whose pattern matches the expression being
evaluated, and that definition is then used to evaluate the expression.

A \key{context} is either a list or a set of expression definitions and
other contexts.  Context elements that are expression definitions are
matched to the expression being evaluated.  Context elements that are
themselves contexts are searched recursively.

\ikey{Context lists}{list!context} are searched in order if the
matching mode is {\tt first-value}, and are searched exhaustively
otherwise.
\ikey{Context sets}{set!context} are always searched exhaustively.

An expression definition is an object (\secref{OBJECTS})
that consists of a pattern, an optional list of constraints,
an optional block, and an optional context.  An
{\em expression-definition} (\pagref{EXPRESSION-DEFINITION})
computes an expression definition that has no context.
A context can be added to the expression definition later by executing:

\begin{indpar}
\verb|set| {\em expression-definition} \verb|context| {\em context}
\end{indpar}

Once a context has been added to an expression definition, the context
cannot be changed.

A new expression definition can be made from an old one by
the expression:

\begin{indpar}
	\verb|an| \ttkey{expression-definition}
	      {\em expression-definition}
	      {\em context}
\end{indpar}

The new expression definition has a different context, given by
the second argument, than the first argument does.  The special
value \ttmnbkey{UNDEFINED}{argument of!an expression-definition@{\tt an
expression-definition}} can be given as the {\em context} argument
to create a new expression definition whose pattern, constraints, and block
are the same as those of {\em expression-definition} argument
but whose context part is missing and can be set later.

There are two kinds of contexts: \mkey{immutable}{context} and
\mkey{mutable}{context}.
An immutable context cannot be modified.  A mutable context can have
its list (or set) modified.
Each kind can be either a set or a list.

A context can be created by:

\begin{indpar}
\verb|a| \ttkey{context}
    \begin{tabular}[t]{@{}l@{}}
    \verb|(| {\em context-element} \{ \verb|,| {\em context-element} \}
	\verb|)| \\
    \ttmkey{is list}{of context!of {\tt context}} {\em list} \\
    \ttmkey{is mutable}{of context!of {\tt context}}
           {\em mutable} \\
    \ttmkey{with contexts missing}{of context!of {\tt context}}
           {\em contexts-missing}
    \end{tabular}
\end{indpar}

in which each {\em context-element} is either an expression definition or
a context, and {\em list}, {\em mutable}, and {\em contexts-missing}
are either `{\tt false}' (the default) or `{\tt true}'.
If {\em contexts-missing} is {\tt false} (the default), any expression
definition {\em context-elements} that do not have their
contexts set will have them set equal to the context being created.

Thus given expression definitions that do not have their contexts set,
the default is to create an immutable context set whose expression definitions
have the new context and therefore can reference each other.  Blocks
containing {\em expression-definitions} perform exactly this kind of
context creation.

The {\em context-item} list of a context object is a list object
(\pagref{LIST}) which can be extracted from the context object by

\begin{indpar}
\verb|the| \ttmkey{list}{of context} \verb|of| {\em context}
\end{indpar}

This list object is a list or set according to whether or not the
context is a list or set, and the list object is immutable or mutable
according to whether or not the context object is immutable or mutable.
If mutable, altering the list object will alter its containing context
object, and this is in fact the only way to mutate a mutable context.

\section{Blocks}
\label{BLOCKS}

A block is a set of variables, values for some of the variables, and
code for computing these values.

\subsection{Block Syntax}
\label{BLOCK-SYNTAX}

The code of a block has the following syntax:

\begin{indpar}
\emkey{block} ::= \verb|{| {\em group}
                         \{ {\em sequence-break} {\em group} \}$^\star$
			 \verb|}| \\[1ex]
\emkey{sequence-break} ::= \ttnbkey{---}\verb|-|$^\star$
	(1 word consisting of 3 or more \verb|-|'s) \\[1ex]
\emkey{group} ::= {\em declaration-group} $|$ {\em statement-group}
			 \\[1ex]
\emkey{declaration-group}\label{DECLARATION-GROUP} ::= {\em declaration}
    \{ \verb|;| {\em declaration} \}$^\star$ \\[1ex]
\emkey{statement-group} ::= {\em statement}
	\{ \verb|;| {\em statement} \}$^\star$ \\[1ex]
\emkey{declaration}
    \begin{tabular}[t]{rl}
    ::= & {\em expression-definition} \\
    $|$ & {\em method-definition} \\
    $|$ & {\em empty} \\
    \end{tabular} \\[1ex]
\emkey{expression-definition} ::= {\em EXPRESSION-DEFINITION} 
				(see \pagref{EXPRESSION-DEFINITION}) \\[1ex]
\emkey{method-definition} ::= \ttkey{on} {\em EXPRESSION-DEFINITION} \\[1ex]
\emkey{statement} ::= {\em qualified-statement} $|$ {\em empty}
\label{STATEMENT}\\[1ex]
\emkey{qualified-statement}
    \begin{tabular}[t]{rl}
    ::= & {\em assignment-statement} \\
    $|$ & {\em unguarded-subblock} \\
    $|$ & {\em guarded-statement} \\
    $|$ & {\em statement-qualifier} {\em qualified-statement}
    \end{tabular} \\[1ex]
\emkey{statement-qualifier} ::= \ttkey{first}
			  $|$ \ttkey{always}
			  $|$ \ttkey{default}
			  \\[1ex]
\emkey{assignment-statement}
	\begin{tabular}[t]{rl}
	::= & {\em variable-assignment-statement} \\
	$|$ & {\em pattern-assignment-statement}
	\end{tabular} \\[1ex]
\emkey{variable-assignment-statement} ::=
	{\em output-variable} \ttkey{=} {\em right-side} \\[1ex]
\emkey{right-side} \
    \begin{tabular}[t]{rl}
    ::= & {\em right-side-expression} \\
    $|$ & {\em right-side-expression} \ttnbkey{=>} {\em output-variable}
		\{ \verb|,| {\em output-variable} \}$^\star$
    \end{tabular} \\[1ex]
\emkey{right-side-expression} ::= {\em EXPRESSION} \\[1ex]
\emkey{output-variable} ::= {\em variable-name} $|$ {\em next-variable} \\[1ex]
\emkey{input-variable} ::= {\em variable-name} $|$ {\em next-variable} \\[1ex]
\emkey{next-variable} ::= \ttkey{next} \verb|(| {\em variable-name} \verb|)|
		\\[1ex]
\emkey{variable-name} ::= {\em word} \\[1ex]
\emkey{pattern-assignment-statement} ::=
	{\em assignment-pattern} \verb|~=~|\index{~=~@{\tt \Tilde=\Tilde}}
	{\em right-side} \\[1ex]
\emkey{assignment-pattern} ::= {\em EXPRESSION} \\[1ex]
\emkey{unguarded-subblock} ::= \verb|{| {\em statement-group} \verb|}| \\[1ex]
\emkey{guarded-statement} ::=
      {\em if-statement} $|$ {\em when-statement} \\[1ex]
\emkey{if-statement} ::=
      \begin{tabular}[t]{l}
      \ttkey{if} {\em guard} {\em guarded-subblock} \\
      {\em else-if-continuation}\,$^\star$ \\
      {\em else-continuation-option}
      \end{tabular} \\[1ex]
\emkey{else-if-continuation} ::=
      \verb|;| \ttkey{else if} {\em guard} {\em guarded-subblock} \\[1ex]
\emkey{else-continuation-option} ::= {\em empty} $|$
      \verb|;| \ttkey{else} {\em guard} {\em guarded-subblock} \\[1ex]
\emkey{when-statement} ::=
      \ttkey{when} {\em guard} {\em guarded-subblock} \\[1ex]
\emkey{guard} ::= {\em right-side} \\[1ex]
\emkey{guarded-subblock} ::= \verb|{| {\em statement-group} \verb|}|
\end{indpar}

A block is parsed when the statement that contains it (typically
an {\em EXPRESSION-DEFINI\-TION}, \pagref{EXPRESSION-DEFINITION})
is parsed.

[TBD: How is parsing controlled; old statement:
Because the \ttmkey{;}{statement separator} operator used
as a statement separator in a {\em block} is by default
{\tt definitional} (??), in addition to {\em statements}
a {\em block}
can contain definitions that control parsing but do not become part of the
parsed block.  Such definitions are omitted from the above syntax.]

When the pattern and guard parts of an expression definition are parsed,
they are parsed together to create an expression graph, and
implicit conversion (??) of variable names
is used to produce variables for that graph.
Any {\em block} part of the expression
definition is parsed separately to produce a separate expression graph that
has no expression graph variables (it does have variables in
a different sense: see \secref{BLOCK-VARIABLE-NAMES}).
Implicit conversion is not used for any part of {\em block} parsing,
except for {\em assignment-patterns}, {\em expression-definitions},
and {\em method-definitions}, each of which becomes a separate
expression graph with its own separate expression graph variables
[TBD: how is this represented and done?].

\subsection{Block Variable Names}
\label{BLOCK-VARIABLE-NAMES}

After parsing, the {\em variable-names} in the code of
a block are identified.  Each
{\em variable-name} is a subexpression consisting of a single
{\em word}, but not all such subexpressions are {\em variable-names}.
Some {\em variable-names} may be \mkey{inherited}{variable-name}
from a statement containing the block.
Some are {\em output-variables} in {\em assignment-statements}
or {\em guards}.
Some are expression graph variables of {\em assignment-patterns}.
All the {\em variable-names}
in the block are inherited or can be identified by looking at the left
sides of {\em assignment-statements} or at the {\em output-variables}
following \verb|=>| in {\em assignment-statements} or {\em guards}.

When identifying {\em variable-names} in a {\em block}, {\em statements} in a
{\em subblock} of the {\em block} are treated as if they
were in the {\em block} proper.  Thus variables named in the
{\em subblock} are variables named in the {\em block}.\footnote{
RECKON does not have the notion of name space nesting, because the
{\tt \CurlyBra\CurlyKet} brackets that would
indicate nesting can be implied by the {\tt :} construction.}

If a {\em block} is part of an {\em EXPRESSION-DEFINITION}
(\pagref{EXPRESSION-DEFINITION}), the names of expression graph variables of
the {\em pattern} and {\em guard-list} expression tree
become {\em variable-names} inherited by the {\em block}.
Thus in

\begin{indpar}[1in]
\verb|sum from X through Y <-- integer X, integer Y| {\em block}
\end{indpar}

the variable names \verb|X| and \verb|Y| are inherited by the {\em block}.

An {\em assignment-pattern} is parsed to an expression graph with its
own expression graph variables.  These variables are called
\skey{pattern variable}s, and their names become
{\em variable-names} of the {\em block} containing the
{\em assignment-pattern}.  Thus in the statement

\begin{indpar}[1in]
\verb|X + Y ~=~ `5 + ( 7 * y )'|
\end{indpar}

the variable names \verb|X| and \verb|Y| are pattern variable names
that are {\em variable-names} of the {\em block} containing this
{\em pattern-assignment-statement}.

The variable named before the \verb|=| in a {\em variable-assignment-statement}
is an {\em output-variable}.
Variables named after \verb|=>| following an expression in
a {\em right-side} are also {\em output-variables}.  In the statements

\begin{indpar}[1in]\begin{verbatim}
when sort x to y => y:
    z = first 
\end{verbatim}\end{indpar}

\verb|y| and \verb|z| are {\em output-variables}.

From the point of view of block evaluation there is no distinction between
variable names beginning with \verb|#| and other variable names.  The
only distinction occurs in {\em EXPRESSION-DEFINITION} {\em patterns},
where the values obtained by call unification for input variables
whose names do not begin with \verb|#| are replaced by their evaluations
(??).

TBD: Arrays and array element names.

\subsection{Block Evaluation}
\label{BLOCK-EVALUATION}

\ikey{Blocks}{block!evaluation}
are divided into \ikey{groups}{group!evaluation} by \skey{sequence-break}s.
The {\em groups} are evaluated in order: each group being completely
evaluated before the next group is evaluated.  However,
evaluation within a \mkey{statement-group}{evaluation}
is driven by availability of variable values,
and not by the order of the {\em statements} in the group.

Each variable in a block can be assigned at most one value: it is
an error if the variable is assigned a value more than once during
a block evaluation, even if all the values assigned are the same.

The \skey{input-variable}s of a {\em right-side-expression} are all
variables in the expression that are not {\em output-variables} or
{\em pattern-variables} of
the {\em assignment-statement} or {\em guard} containing the expression.
Each {\em right-side-expression} in a {\em statement-group}
is evaluated only when all its input variables have values.
When the {\em right-side-expression} of an {\em assignment-statement}
is evaluated, the variables named on the left side of the statement and any
{\em output-variables} named after a \verb|=>| in the {\em right-side}
are given values.
When the {\em right-side-expression} of a {\em guard} is evaluated, any
{\em output-variables} named after a \verb|=>| in the {\em guard}
are given values.

None of the statements in an {\em if-statement}
{\em guarded-block} are
evaluated until the block's {\em guard} has been evaluated to true.
If the guard evaluates to false, no statement in the
{\em guarded-block} is ever evaluated.  An {\em else-if-continuation}
{\em guard} is not evaluated until all {\em guards}
in any preceding {\em if-statement}
or {\em else-if-continuations} in the same {\em guard-statement}
have been evaluated to false.  The {\em guarded-block} of an
{\em else-continuation} is evaluated if and only if
all {\em guards} in any preceding {\em if-statement}
or {\em else-if-continuation} in the same {\em guard-statement}
have been evaluated to false.

An example application of these rules is:

\begin{indpar}\begin{verbatim}
{
  z = y1
  z = y2
  if X > 5:
    y1 = 9
  else:
    y2 = 10
}
\end{verbatim}\end{indpar}

where \verb|X| is an inherited variable name.  If \verb|X > 5| is true,
the variable \verb|y1| is given the value \verb|9| and then
\verb|z| is given this value, while the variable \verb|y2|
is never given a value.  If \verb|X > 5| is false,
the variable \verb|y2|
is given the value \verb|10| and then \verb|z| is given this
value, while the variable \verb|y1| is never given a value.

A {\em when-statement} is just like an {\em if-statement} that has
no {\em else-if-continuation} or {\em else-continu\-a\-tion}.
[TBD: what about making a variable true if it has ANY value, for the
purposes of a {\em when-statement}?]

A {\em statement-group} terminates when all the
{\em right-side-expressions} in it have either been evaluated or
cannot be evaluated because of lack of an input variable value or
because of {\em guards}.
Once a {\em statement-group}
terminates, no part of the group can be evaluated, even if another group
later in the block defines that part's input variables.

However, group evaluation is additionally modified by {\em statement-qualifiers}
(\secref{DEFAULT-STATEMENTS}, \secref{ITERATION}).

The \ikey{declarations}{declaration!evaluation} of a
\mkey{declaration-group}{evaluation} are evaluated in order.  Evaluation of a
{\em declaration} just adds its definition to the current context.
The {\em declaration-group} terminates when its last {\em declaration}
has evaluated.  There are no {\em guards} or block variables in a declaration
group (the variables of a definition are not variables of the block).

\ikey{Empty-statements}{empty-statement!evaluation} and
\ikey{empty-declarations}{empty-declaration!evaluation} do nothing
when they evaluate.

The {\em groups} of a {\em block} are evaluated in order.  No part of
a {\em group}
can evaluate until all previous {\em groups} of the block have completely
finished evaluating.  Once a {\em group} starts to evaluate, no part of
a previous {\em group} can evaluate.

A {\em block} terminates when its last group terminates.

When a block terminates, the \mkey{value}{of block} of the block is the
value of its {\tt value} variable\index{value variable@{\tt value} variable},
if any.  Thus the block

\begin{center}
\verb|{ value = X + Y }|
\end{center}

which inherits the variables \verb|X| and \verb|Y| will return
the sum of its inherited variables as the value of the block.

If a block finishes without producing a value for a variable named
{\tt value}, the value of the block is \ttmkey{true}{block value}.

Block evaluation is additionally modified by {\em statement-qualifiers}
and {\em next-variables}
(\secref{DEFAULT-STATEMENTS} and \secref{ITERATION}).

\subsection{Default Statements}
\label{DEFAULT-STATEMENTS}

The \ttkey{default} {\em statement-qualifier} modifies group execution.
A statement qualified by {\tt default}
is called a \key{default statement}.  Default statements in a {\em group}
are initially inactive, meaning that they are treated as if they do not exist,

After the {\em group} without its default statements finishes executing,
any default statement in the {\em group} that has
\underline{no} output or pattern variable with a value
is made active.  All default statements that can be made active in this
way are made active at the same time.  Then the {\em group}, which now
consists of all non-default statements and all active default statements,
continues executing, until no more non-default or active default statement
can be executed.

Since all default statements that become active in a group become active
at the same time, it is possible for an error to occur if two such
statements assign values the same variable.

An example application of these rules is:

\begin{indpar}\begin{verbatim}
{
  if X > 5:
    value = `true'
  default value = `false'
}
\end{verbatim}\end{indpar}

where \verb|X| is an inherited variable name.  If \verb|X > 5| is true,
the value of the block is `{\tt true}' and the {\tt default}
{\em assignment-statement} remains inactive, but if \verb|X > 5| is false,
the {\tt default} {\em assignment-statement} becomes active and
the value of the block is `{\tt false}'.

\subsection{Iteration}
\label{ITERATION}

A block can \key{iterate}, meaning that it generates another block
that is the next block in a sequence of blocks.  A block
iterates if it does \underline{not} produce a value of a {\tt value}
variable and if it does produce a value for a {\em next-variable}.
The sequence of blocks are called the
\skey{iteration}s of the sequence.  Evaluation of a block can always
be thought of as producing a sequence of iterations, though this
sequence might include only one block which does not iterate.

A {\em next-variable} is named by a {\em variable-name} that is the
operand of a \ttkey{next} unary operator.  A {\em next-variable}
is effectively a new variable with a name derived from the
{\em variable-name}.  We will used the notation \verb|next(|$V$\verb|)|
to denote the {\em next-variable} made from the variable name $V$.
The value of \verb|next(|$V$\verb|)| at the end of execution of the
current block iteration becomes the value of $V$ at the beginning
of execution of the next block iteration.  In order for there to be
a next iteration, the current iteration must compute the value of
some {\em next-variable}, and the current iteration must not compute
the value of the {\tt value} variable.

{\em Next-variables} can be both output and input variables.
When used as input variables they are just like other input variable.
The {\tt next} operator can be applied to an expression that does not
consist solely of a {\em variable-name}.  When this is done, it is
as if the {\tt next} operator had instead been applied to every
{\em variable-name} in the expression.  Thus `\verb|next(x+y)|' is
the equivalent of `\verb|next(x) + next(y)|'.

If a default statement outputs a {\em next-variable}, the statement
cannot become active unless some other {\em next-variable} has already
been given a value.  Thus the decision to iterate cannot be made inside
a default statement.

A statement of the form

\begin{center}
\verb|default| \verb|next(|$V$\verb|)| = $V$
\end{center}

is implied in the last group of a block
for every inherited {\em variable-name} $V$ provided
no other default statement in the last group of the block
outputs \verb|next(|$V$\verb|)|.
Thus inherited variables are normally propagated unchanged from
one iteration to the next.

If a {\em next-variable} is given the value of
the expression `\ttkey{UNDEFINED}',\label{UNDEFINED}
the variable will become undefined
at the beginning of the next iteration.  Thus the statement

\begin{center}
\verb|default| \verb|next(|$V$\verb|) = UNDEFINED|
\end{center}

for an inherited {\em variable-name} $V$ will keep the inherited
variable from being propagated from one iteration to the next.
The expression `{\tt UNDEFINED}' cannot be used to set a
non-{\em next-variable}.

A \ttkey{first} qualified {\em statement} is only visible in the
first iteration of a block sequence.

An \ttkey{always} qualified {\em statement} is equivalent to the {\em statement}
qualified by {\tt first} plus additional {\em statements} of the form

\begin{center}
\verb|default| \verb|next(|$V$\verb|) = |$V$
\end{center}

for every {\em variable-name} $V$ that can be assigned by the
{\tt always} qualified {\em statement}.  Thus the
{\tt always} qualified {\em statement} will assign values on the first
iteration, and these values will then be propagated to subsequent iterations.


\section{Objects}
\label{OBJECTS}

An object is a typed block that can be used as a value.
A typed block, or object, has a type and inherits code from its type.

An \key{object} can be created by an {\em OBJECT} expression:


\begin{indpar}
\emkey{OBJECT} ::= \{ \ttkey{a} $|$ \ttkey{an} \} {\em type-name}
		      {\em block-option} \\[1ex]
\emkey{type-name} ::= {\em word}
\end{indpar}

The code in the {\em block} becomes a permanent part of the object.
The variable values defined by this code become \skey{component}s of the object.
These components can be retrieved by expressions of the form:

\begin{center}
\ttmkey{the}{the of@{\tt the} \ldots {\tt of}}
{\em variable-name}
\ttmkey{of}{the of@{\tt the} \ldots {\tt of}}
{\em object}
\end{center}

Objects are updated by adding code to them either permanently or temporarily.
Whenever code is added to an object, the code executes as much as it
can to define variable values that are then components of the object.
When the code can execute no further (\secref{BLOCK-EVALUATION},
\secref{DEFAULT-STATEMENTS}, \secref{ITERATION}), any
variables that do not have values become undefined components.  If some of
undefined components are given values later, any code that is a permanent
part of the object may restart and produce additional variable values that
define additional components.

Recall that the concept of being a variable of a block
of code is defined syntactically and independently of which variable values
the block actually computes (\secref{BLOCK-VARIABLE-NAMES}).
The components of an object are more precisely the syntax variables
of the code added permanently to the object, whether or not these
variables have values defined by code added permanently or temporarily
to the object.  Variables of code added temporarily that are not
syntactically variables of code added permanently are
\underline{not} components of the object,
and are not visible outside the temporarily added code.

TBD: need a way to declare an object component without otherwise referencing
it in permanent code.

The permanent code of an object all belongs to the same group.  Blocks
of permanent code cannot have {\em sequence-breaks}, and therefore
have only one {\em group}.  Code that is added temporarily
to an object can have several groups, and the permanent code of the
object behaves as
if it were a separate group executed after the temporary code is executed.

A statement of the form:

\begin{indpar}
\ttkey{for every} {\em type-name} {\em block} 
\end{indpar}

adds the code in its block permanently to every object of the given type,
including both existing objects and objects that are
created in the future.  The code in the block is associated with the
type and is said to be `\skey{inherit}{ed}' by every object of that type.

A statement of the form:

\begin{indpar}
\ttkey{update} {\em OBJECT} {\em block} 
\end{indpar}\label{UPDATE}

where {\em OBJECT} evaluates to an object adds the code in the
{\em block} temporarily to the object.  The code is added and all
code in the object executes until it can do nothing more.  Then
the temporary code is removed from the object.

When code is added to an object and executes, the statement qualifier
{\tt default} acts when execution stops to enable execution of {\tt default}
statements, as per \secref{DEFAULT-STATEMENTS}.  Similarly
the {\tt next} operator can be used to create iterations of the
object.  Each iteration replaces the previous iteration of the object
wherever the object is referenced.  Thus if two variables equal
the object, and one is used to cause the object to iterate, both variable
values will become the new iterated object.

A statement of the form

\begin{center}
\verb|default| \verb|next(|$C$\verb|) = |$C$
\end{center}

is implied in the permanent code
for every component name $C$ of an object, provided
no other default statement in the permanent code
outputs \verb|next(|$C$\verb|)|.
Thus components are normally propagated unchanged from
one object iteration to the next.  A statement of the form

\begin{center}
\verb|default| \verb|next(|$C$\verb|) = UNDEFINED|
\end{center}

can be used to override this behavior to
make $C$ have no value at the beginning of the next object
iteration.

When an iteration of an object is created by temporary code, the
sequence of actions is:

\begin{center}
\begin{tabular}{lp{5.5in}}
(1) & Add the temporary code to the object. \\
(2) & Execute all object code until it terminates. \\
(3) & If any {\tt next} component values were defined by the
      execution in step (2), create
      the next iteration of the object, giving this
      iteration only the permanent code of the object. \\
(4) & In the next iteration of the object execute all
      code until it terminates.
\end{tabular}
\end{center}

Code can be temporarily added to an object by invoking methods.
A \key{method} is defined by a \key{method definition}
that is an expression definition which is part of the code of an object.
The method is callable from code inside or outside the object code block.
The syntax for a method definition is:

\begin{center}
\ttkey{on} {\em expression-definition}
\end{center}

When the method definition is called, the method code block
is added temporarily to the code that contained
the method definition.  The object whose code this is
may be referred to within its
code by the name \ttkey{SELF}, which may or may not also be an argument
of the method definition.  If it is an argument, the method definition
has an implicit guard that requires the {\tt SELF} argument value to be
equal to the object whose code contains the method definition.

If there is no {\tt SELF} argument, a new object
is created when the method is called, and the permanent code plus
method code is executed for that object.  The permanent code must
contain the method definition in this case.  Such a method is
called a {\tt constructor}, and the object created is said to be
constructed by the method execution.  Constructor executions usually return
the object they construct, but this is not required by the language.
Constructors usually
have patterns that begin with `\{ \verb|a| $|$ \verb|an| \} {\em type-name}',
where {\em type-name} names the type of object they construct, but
this is not required by the language either.

TBD: protection; protection zones.


\section{Side Effects}
\label{SIDE-EFFECTS}

A \key{side effect} is an action that changes memory, inputs information from
the outside world, or outputs information to the outside world.
When an expression is evaluated, it may or may not have side effects.

The order in which side effects are executed is determined by
{\em sequence-breaks} that divide a {\em block} into {\em groups}
further (\secref{BLOCK-EVALUATION}).  A programmer typically writes code
so there is at most one side effect per {\em group}, in order to
ensure side effects execute in the desired order.

TBD: could this last rule be enforced.

The \key{side effect mode} controls the execution of side effects.
It has three settings: {\tt execute}, {\tt delay}, and {\tt error}.
In \ttkey{execute mode} a side effect simply executes.  In
\ttkey{error mode} an attempt to execute a side effect raises an error,
and the side effect is not executed.

In \ttkey{delay mode} input and memory change side effects execute,
but put operations on an {\tt undo} list that can undo their effects,
while output side effects do not execute, but are instead put on a
{\tt todo} list.

There are two lists maintained that permit side effects to be delayed
or undone.  The \ttmkey{todo}{list} list is a list of delayed output
actions that have been delayed.  The \ttmkey{undo}{list} list is
a list of input and memory change actions that can be undone.
The position of these lists can be recorded and an undo
operation can be performed that backs up to previously recorded positions
by deleting actions form the end of the {\tt todo} list and undoing
actions on the end of the {\tt undo} list.

To control the side effect mode there is a \key{side effect mode stack}.
This contains items each of which contains a side effect mode and
positions in the {\tt todo} and {\tt undo} stacks.  The side effect mode
of the top item on the side effect mode stack is the effective side
effect mode for current execution.
Whenever an item is pushed to the side effect mode stack, the current
positions of the {\tt todo} and {\tt undo} lists are recorded in the
item.

The following statements operate on the side effect mode stack:

\begin{list}{}{}
\item[\ttkey{begin executing side effects}]~~~Push a new item with side effect
execute mode onto the side effect mode stack.  Before the push the
stack must be empty or the top item in the stack must have execute or
error mode.

\item[\ttkey{end executing side effects}]~~~Pop the top item from
the side effect mode stack.  This top item must have
execute mode.

\item[\ttkey{begin forbidding side effects}]~~~Push a new item with side effect
error mode onto the side effect mode stack.  Before the push the
stack must be empty or the top item in the stack must have execute or
error mode.

\item[\ttkey{end forbidding side effects}]~~~Pop the top item from the
side effect mode stack.  This top item must have
error mode.

\item[\ttkey{delay side effects}]~~~Push a new item with side effect
delay mode onto the side effect mode stack.

\item[\ttkey{commit side effects}]~~~Pop the top item from the
side effect mode stack.  This top item must have
delay mode.  It the resulting stack has a new top item that is not
delay mode, discard the contents of the {\tt undo} stack, and execute
and then discard the contents of the {\tt todo} stack.

\item[\ttkey{abort side effects}]~~~Pop the item from the
the side effect mode stack.  This top item must have
delay mode.  Consider the {\tt todo} and {\tt undo} list positions
of the new item at the top of the stack, or take these positions to be
the beginning of the lists if the stack has become empty.  Remove
elements from ends of the lists until these considered positions become
the current list positions.  When removing an element from the end of the
{\tt undo} list, perform the undo action specified by the element.

\end{list}

\section{Debugging}

Design:

Debugging is based on the notion that almost all
RECKON programs will run quickly.
Input checkpointing is used to record all inputs to a computation
so the computation can be deterministically rerun.  Detailed
traces can be generated which explain for each value how it was generated.
Values have a sequence number that identifies the point in the execution
where they were generated.  It is therefore possible to ask for a detailed
accounting of how any value was generated, provided the run is short enough
to be repeated once or a few times so the computer can turn the history
tracing on appropriately.

\section{Design Notes}

These are some detailed design rules to be incorporated in the language
definition later.

\begin{list}{}{}

\item
{\bf Blank Algebraic Operators}.
The blank, or missing operator, denotes \verb|*| when it precedes a word,
as in \verb|5x| being equivalent to \verb|5*x|.  When it is between a
preceding integer and a following ratio, it adds the ratio to the integer,
as in \verb|41 1/3|.

\end{list}

\section{To Do}

Describe the quote evaluator.\label{QUOTE-EVALUATOR}

Describe the phrase separator definition.\label{PHRASE-SEPARATOR-DEFINITION}

Describe the sentence terminator definition.
\label{SENTENCE-TERMINATOR-DEFINITION}

Describe the section initiator definition.
\label{SECTION-INITIATOR-DEFINITION}

Why doesn't `\verb|define qualifier xxx|' mean define expressions equal
to `\verb|qualifier xxx|'.

\verb|missing(#X)| is true if \verb|#X| is a null node.
\verb|integer(#X)| is true if \verb|#X| is an integer.

Qualifier shortcuts should be conditioned on the first words of
the expression being qualified.  E.g., if these words are
`\verb|define operator|' the shortcut `\verb|left => |{\tt with
associativity [left]}' would be defined.

Expressions to be evaluated can have sets of possible values.

Imaginary Units\label{IMAGINARY-UNITS}

Visible Side Effects\label{VISIBLE-SIDE-EFFECTS}

List Objects\label{LIST}

Qualifier Definition\label{QUALIFIER-DEFINITION}

Qualifier Shortcut Definition\label{QUALIFIER-SHORTCUT-DEFINITION}

Automatic Optional Marks\label{AUTOMATIC-OPTIONAL-MARKS}

Describe Garbage Collection\label{GARBAGE-COLLECTION}

Manual Deletion\label{MANUAL-DELETION}, the stub is marked deleted,
and gc's make pointers to the stub either NULL or point them at
a standard deleted object so the deleted stub can be collected.

\bibliographystyle{plain}
\bibliography{reckon}

\printindex

\end{document}

