%  RECKON (Personal Reckoning Langauge)
%
% File:         reckon.tex
% Author:       Bob Walton (walton@deas.harvard.edu)
% Date:		See \date below.

% Possible alternative names:
%
%	RECKON	Personal Reckoning Language
%	CASTLE  Calculation and Simulation Total Language Environment
%	MFL	Multi-Facetted Language
%	ROPE	Really Omni Programming Environment
%	RIPE	Robert's Information Processing Environment
%	AGILE	Another Goofy Information Language and Environment
%	OMNI	Omni-Programming Language
%	OPL	Omni-Programming Language
%	OPE	Omni-Programming Environment
%	APE	A Programming Environment
%	RUG	Really Useful Gadget
%	RUCL	Really Useful Computer Language
  
\documentclass[12pt]{article}

\usepackage[T1]{fontenc}
\usepackage{times}
\usepackage{makeidx}
\usepackage{pictex}

\makeindex

\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}
\raggedbottom

\setlength{\unitlength}{1in}

\pagestyle{headings}
\setlength{\parindent}{0.0in}
\setlength{\parskip}{1ex}

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}
\newcommand{\subsubsubsection}[1]{\paragraph[#1]{#1.}}
\newcommand{\subsubsubsubsection}[1]{\subparagraph[#1]{#1.}}

% Begin \tableofcontents surgery.

\newcount\AtCatcode
\AtCatcode=\catcode`@
\catcode `@=11	% @ is now a letter

\renewcommand{\contentsname}{}
\renewcommand\l@section{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\l@table{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\tableofcontents{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{0.8in}%
	      \setlength{\rightmargin}{0.8in}}%
    \item\@starttoc{toc}%
    \end{list}}
\renewcommand\listoftables{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}%
	      }%
    \item\@starttoc{lot}%
    \end{list}}

\catcode `@=\AtCatcode	% @ is now restored

% End \tableofcontents surgery.

\newcommand{\CN}[2]%	Change Notice.
    {\hspace*{0in}\marginpar{\sloppy \raggedright \it \footnotesize
     $^{\mbox{#1}}$#2}}
    % Change notice.

\newcommand{\TT}[1]{{\tt \bfseries #1}}

\newcommand{\key}[1]{{\bf \em #1}\index{#1}}
\newcommand{\lkey}[2]{{\bf \em #1 #2}\index{#1!#2}}
\newcommand{\mkey}[2]{{\bf \em #1}\index{#1!#2}}
\newcommand{\skey}[2]{{\bf \em #1#2}\index{#1}}
\newcommand{\slkey}[3]{{\bf \em #1 #2#3}\index{#1!#2}}
\newcommand{\ikey}[2]{{\bf \em #1}\index{#2}}
\newcommand{\ttkey}[1]{\TT{#1}\index{#1@{\tt #1}}}
\newcommand{\ttlkey}[2]{\TT{#1 #2}\index{#1@{\tt #1}!#2@{\tt #2}}}
\newcommand{\ttnbkey}[1]{{\tt #1}\index{#1@{\tt #1}}}
\newcommand{\ttmnbkey}[2]{{\tt #1}\index{#1@{\tt #1}!#2}}
\newcommand{\ttmkey}[2]{\TT{#1}\index{#1@{\tt #1}!#2}}
\newcommand{\ttdkey}[1]{\TT{.#1}\index{#1@{\tt .#1}}}
\newcommand{\ttdmkey}[2]{\TT{.#1}\index{#1@{\tt .#1!#2}}}
\newcommand{\ttnbdkey}[1]{\TT{.#1}\index{#1@{\tt .#1}}}
\newcommand{\tttkey}[1]{\TT{<#1>}\index{#1@{\tt <#1>}}}
\newcommand{\tttmkey}[2]{\TT{<#1>}\index{#1@{\tt <#1>}!#2}}
\newcommand{\tttbkey}[1]{{\TT {<#1|}\ldots\TT{|#1>}}%
    \index{#1@\TT{<#1|}\ldots\TT{|#1>}}}
\newcommand{\tttbmkey}[2]{{\TT{<#1|}\ldots\TT{|#1>}}%
    \index{#1@\TT{<#1|}\ldots\TT{|#1>}!#2}}
\newcommand{\ttindex}[1]{\index{#1@{\tt #1}}}
\newcommand{\ttmindex}[2]{\index{#1@{\tt #1}!#2}}
\newcommand{\emkey}[1]{{\bf \em #1}\index{#1@{\em #1}}}
\newcommand{\emlkey}[2]{{\bf \em #1#2}\index{#1@{\em #1}!#2@{\em #2}}}
\newcommand{\emskey}[2]{{\bf \em #1#2}\index{#1@{\em #1}}}
\newcommand{\emikey}[2]{{\bf \em #1}\index{#2}}
\newcommand{\emindex}[1]{\index{#1@{\em #1}}}

\newcommand{\opt}{$^!$}

\newcommand{\itemref}[1]{\ref{#1}$\,^{p\,\pageref{#1}}$}
\newcommand{\secref}[1]{\ref{#1}$\,^{p\,\pageref{#1}}$}
\newcommand{\stepref}[1]{\ref{#1}\,$^{p\,\pageref{#1}}$}
\newcommand{\appref}[1]{\ref{#1}$\,^{p\,\pageref{#1}}$}
\newcommand{\figref}[1]{\ref{#1}$\,^{p\,\pageref{#1}}$}
\newcommand{\pagref}[1]{p\pageref{#1}}
\newcommand{\pagnote}[1]{$\,^{p\,\pageref{#1}}$}

\newcommand{\EOL}{\penalty \exhyphenpenalty}

\newcommand{\STAR}{{\Large $^\star$}}
\newcommand{\PLUS}[1][]{{$^{+#1}$}}
\newcommand{\QMARK}{{$^{\,\mbox{\footnotesize ?}}$}}
\newcommand{\OPEN}{{$\{$}}
\newcommand{\CLOSE}{{$\}$}}

\newlength{\figurewidth}
\setlength{\figurewidth}{\textwidth}
\addtolength{\figurewidth}{-0.40in}

\newsavebox{\figurebox}

\newenvironment{boxedfigure}[1][!btp]%
	{\begin{figure*}[#1]
	 \begin{lrbox}{\figurebox}
	 \begin{minipage}{\figurewidth}

	 \vspace*{1ex}}%
	{
	 \vspace*{1ex}

	 \end{minipage}
	 \end{lrbox}
	 \begin{center}
	 \fbox{\hspace*{0.1in}\usebox{\figurebox}\hspace*{0.1in}}
	 \end{center}
	 \end{figure*}}

\newenvironment{indpar}[1][0.3in]%
	{\begin{list}{}%
		     {\setlength{\itemsep}{0in}%
		      \setlength{\topsep}{0in}%
		      \setlength{\parsep}{1ex}%
		      \setlength{\labelwidth}{#1}%
		      \setlength{\leftmargin}{#1}%
		      \addtolength{\leftmargin}{\labelsep}}%
	 \item}%
	{\end{list}}

\newenvironment{labpar}[2][0.3in]%
	{\begin{list}{}%
		     {\setlength{\itemsep}{0in}%
		      \setlength{\topsep}{0in}%
		      \setlength{\parsep}{1ex}%
		      \setlength{\labelwidth}{#1}%
		      \setlength{\leftmargin}{#1}%
		      \addtolength{\leftmargin}{\labelsep}}%
	 \item[#2]}%
	{\end{list}}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{lemma}[theorem]{Lemma}

\begin{document}
        
\title{Personal Reckoning Language\\[2ex]
       RECKON\\[2ex]
       (Draft 1b)}

\author{Robert L. Walton\thanks{Copyright 2008 Robert L. Walton.
Permission to copy this document verbatim is granted by the author
to the public.  This document was partly inspired
by teaching courses at Suffolk University, and by the work of Thomas
Cheatham and Stuart Shieber.}}

\date{May 25, 2014}

\maketitle

\newpage
\begin{center}
\large \bf Table of Contents
\end{center}

\bigskip

\tableofcontents 

\newpage

\section{Introduction}

This document describes the programming language RECKON.  RECKON,
for what its worth, stands for `Personal Reckoning Language',
which hints at its purpose.

RECKON is designed for naive programmers: that is, for people who may never
be able to program computers well.  It is a fairly simple language with
powerful data types that make it easier to write small programs
that do a variety of tasks a person might want to do.  Generally
the tasks fall into the categories of calculating things (taxes,
probabilities, statistics) or simulating things
(computer games, construction designs, mathematics demonstrations).
Included are:

\begin{center}
\begin{tabular}{l}
Calculations that might be done with a spreadsheet. \\
Drawing pictures. \\
Simulating popular board games and creating new ones. \\
Creating simple computer games, including dialog games. \\
Computing and analyzing documents. \\
Doing elementary algebra and calculus problems. \\
Doing matrix calculations. \\ 
Calculating basic probabilities and statistics. \\
Simulating two and three dimensional objects. \\
Simulating simple electrical, mechanical, chemical, and biological systems.\\
Solving problems in elementary logic. \\
\end{tabular}
\end{center}

There are many computer languages that have some powerful data type that adapts
them for a specific kind of computation.  RECKON tries to combine these.
Some previous computer languages that have influenced RECKON, and
the data types they particularly support, are:

\begin{center}
\begin{tabular}{l@{\hspace{0.5in}}l}
Various Spreadsheets		& Spreadsheets \\
Various Data Base Languages	& Data Bases \\
Various Script Languages	& Documents \\
MATLAB				& Matrices \\
Mathematica			& Mathematical Formulae \\
TCL				& Character Strings and Lists \\
Lisp				& Words and Phrases \\
PROLOG				& Logical Expressions \\
\end{tabular}
\end{center}

RECKON is \underline{not} designed to be a computer-efficient language.
It is designed to be person-efficient, and to do small calculations
rapidly enough with inexpensive modern computers.

\section{Remarks}

RECKON was created as an answer to the question: what programming language
should you teach beginning programming students most of whom do not have
the talent or will not develop the inclination
to become serious programmers?  The initial answer, that it does
not matter provided you implement some powerful types of data in the
language you choose, has a flaw.  The flaw is that without the right powerful
data types, the language will be useless to the students after the course
is over.  So what is needed is a programming language that will be useful
to students after a first course in programming, and the essence of
such a language is the integration within it of many powerful and useful
data types.

The basic principles of the RECKON design were developed
by the author while teaching the intended customers of
RECKON.\footnote{Specifically, while teaching CS121 at Suffolk University
using the C programming language.}
The language should have as few parts as possible, to cut down
on the amount of detail that must be remembered to use the language, but
conversely, there is no limit to the conceptual complexity of any well-used
part.\footnote{There was no problem teaching recursion, but it was better
not to teach many different looping constructs.}
The language should have powerful data types, well integrated into
the syntax of the language.  As much as possible, statement executions
in the language should have visible effect.

The current version of RECKON is not stable, because it has not been
implemented, and because, unlike most programming languages, RECKON
has lots of subtle important interactions between its various features.  The
hope is that after implementation and experimentation a stable sensible
version of RECKON, integrating all its data types, can be achieved.

\section{Overview}

RECKON has two major kinds of data: expressions and blocks.  Numbers are
the simplest expressions.  More complex expressions are math
expressions or document expressions.  A block is a set of variables
and pieces of code.  Each variable can have a value, which is an expression.
Each block has a unique indentifier, which by itself can be used as
an expression that names the block.
The code contains expressions that can be evaluated under appropriate
circumstances to produce values for variables.

In RECKON a `description' is a block that has an associated `type'.  For
example, there may be a description `george' with type `person'.  All
descriptions of the same type have the same code,
and many of the same variables,
but typically have different variable values.

You can use RECKON as a calculator by typing into it expressions to
be evaluated, assignments of values to variables, and definitions
of functions, predicates, and blocks.  Some examples involving numbers are:

\begin{indpar}\begin{verbatim}
> 9
9
> 9 + 8
17
> x = 9
9
> y = 9 + 8
17
> x + y
26
> f(b,c,x) = b*x + c
function(b,c,x) evaluates to (b*x + c)
> f(10,x,y)
179
\end{verbatim}\end{indpar}

Here the `\TT{>~}' at the beginning of some lines is the RECKON \key{prompt}
that tells you its OK to input an expression to be evaluated.
Except for this prompt, lines beginning with `\TT{> }' are input lines to
a RECKON interpreter, and other lines are output lines.

At somewhat the opposite extreme from numbers are words, phrases, sentences,
and paragraphs.  You can calculate with these `\skey{document expression}s\,'.%
\footnote{If we followed LISP, \TT{``[g]''} would evaluate to \TT{`[g]'}
and \TT{``[[g]]''} would evaluate to \TT{`hello'}, but we do the
reverse of this, so in RECKON \TT{``[g]''} evaluates to \TT{`hello'}
and \TT{``[[g]]''} evaluates to \TT{`[g]'}.}

\begin{indpar}
\verb|> g = `hello'| \\
\verb|`|hello\verb|'| \\
\verb|> `[g] there'| \\
\verb|`|hello there\verb|'| \\
\verb|> z = `I thought he said `[g]'.'| \\
\verb|`|I thought he said `hello'.\verb|'| \\
\verb/> notice = `This document is meant to be read./ \\
\verb/+           Reading this document is good, but.../ \\
\verb/+           / \\
\verb/+           [z].'/ \\
This document is meant to be read.  Reading this document is good, but\ldots
\\[2ex]
I thought he said `hello'. \\
\verb|> `When you add [x] and [y] you get [x+y].'| \\
\verb|`|When you add 9 and 17 you get 26.\verb|'| \\
\verb|> `This is a paragraph.| \\
\verb|> | \\
\verb|> And a second paragraph.| \\
\verb|> With two sentences.'| \\
This is a paragraph. \\[2ex]
And a second paragraph. With two sentences.
\end{indpar}

Modern math computes with expressions, and not just numbers.
You can compute with \skey{math expression}s in RECKON.

\begin{indpar}
\verb/> f = {< 10x^2 - 3.67x - 0.04 >}/ \\
\verb/{</ $10x^2-3.67x-0.04$ \verb/>}/ \\
\verb/> h = (- 0.96 + 0.67x) in x/ \\
\verb/{</ $-0.96+0.67x$ \verb/>}/ \\
\verb/> (f + h) in x/ \\
\verb/{</ $10x^2-3x-1$ \verb/>}/ \\
\verb/> solve (f + h = 0) for x/ \\
\verb/{</ $x = (-0.2, 0.5)$ \verb/>}/ \\
\verb/> (f + h) at (x = (3, 4, 5))/ \\
\verb/(78.95, 145.28, 231.61)/ \\
\verb/> g = {< integral (x ^ 2 dx) >}/ \\
\verb/{</ $\int x^2 dx$ \verb/>}/ \\
\verb/> simplify g/ \\
\verb/{</ $\frac{1}{3} x^3$ \verb/>}/ \\
\verb/> v = g from (x = 1) to (x = 5)/ \\
\verb:41 1/3: \\
\verb/> out = `The value of {[g] from (x = 1) to (x = 5)} is [v].'/ \\
\verb/`/The value of $\int_{x = 1}^{x = 5} x^2 dx$ is $41\frac{1}{3}$.\verb/'/
\end{indpar}

Matrices are another kind of data that you can compute
with:

\begin{indpar}
\verb/> V = [| 1  2  3 |]/ \\
\verb/[| 1 1 1 |]/ \\
\verb/> M = [| 0  1  1/ \\
\verb/>       -1  1  0/ \\
\verb/>        1  0  -1 |]/ \\
\verb/[| 0  1  1/ \\
\verb/  -1  1  0/ \\
\verb/   1  0  -1 |]/ \\
\verb/> V**T/ \\
\verb/[| 1/ \\
\verb/   2/ \\
\verb/   3 |]/ \\
\verb/> M*V**T/ \\
\verb/[| 5/ \\
\verb/   1/ \\
\verb/  -2 |]/
\end{indpar}

Another kind of datum you can compute with in RECKON is
the block.  A \key{block} contains a set of variables, each of which
can have a value which is an expression.  A block can also
have code, which contains expressions that are evaluated under appropriate
circumstances to produce values for the block's variables.

In RECKON a \key{description}
is a block that has an associated \key{type}.  For
example, there may be a description named `Jack' with type `person'.
All descriptions
of the same type have the same code, and many of the same variables,
but typically have different variable values.  For example:

\begin{indpar}
\verb|> a person:| \\
\verb|+     name = `Jack'| \\
\verb|+     weight = 123 lb| \\
\verb|+     height = 5 ft 9 in| \\
\verb|+     age = 23 yr 2 mo| \\
\begin{tabular}{|r|l|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf type} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000000 & person & Jack & \tt 123 lb & \tt 5 ft 9 in & \tt 23 yr 2 mo \\
\hline
\end{tabular} \\[0.5ex]
\verb|> a person:| \\
\verb|+     name = `Jill'| \\
\verb|+     weight = 110 lb| \\
\verb|+     height = 5 ft 7 in| \\
\verb|+     age = 21 yr 8 mo| \\
\begin{tabular}{|r|l|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf type} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000001 & person & Jill & \tt 110 lb & \tt 5 ft 7 in & \tt 21 yr 8 mo \\
\hline
\end{tabular} \\[0.5ex]
\verb|> all persons| \\
\begin{tabular}{|r|l|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf type} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000000 & person & Jack & \tt 123 lb & \tt 5 ft 9 in & \tt 23 yr 2 mo \\
\tt @1000001 & person & Jill & \tt 110 lb & \tt 5 ft 7 in & \tt 21 yr 8 mo \\
\hline
\end{tabular} \\[0.5ex]
\verb|> the person Jack| \\
\begin{tabular}{|r|l|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf type} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000000 & person & Jack & \tt 123 lb & \tt 5 ft 9 in & \tt 23 yr 2 mo \\
\hline
\end{tabular} \\[0.5ex]
\verb|> the person named Jack's height| \\
\verb|5 ft 9 in| \\
\verb|> the weight of the person named Jack| \\
\verb|123 lb| \\
\verb|> @1000001| \\
\begin{tabular}{|r|l|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf type} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000001 & person & Jill & \tt 110 lb & \tt 5 ft 7 in & \tt 21 yr 8 mo \\
\hline
\end{tabular} \\[0.5ex]
\verb|> the weight of @1000001| \\
\verb|110 lb|
\end{indpar}

It is possible to add code to a type such as `\TT{person}'.  This has
the affect of adding the code to all blocks that are descriptions of that type.
For example:

\begin{indpar}
\verb|> for every person:| \\
\verb|+     body mass index = 703.06958 * weight in lbs| \\
\verb|+                     / (height in inches)^2| \\
\verb|> all persons| \\
\begin{tabular}{@{}|r|l|l|r|r|r|r|@{}}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf type} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} &
\multicolumn{1}{|c|}{\bf \shortstack{body mass\\index}} \\
\hline
\tt @1000000 & person & Jack
	     & \tt 123 lb & \tt 5 ft 9 in & \tt 23 yr 2 mo & \tt 18.1637 \\
\tt @1000001 & person & Jill
	     & \tt 110 lb & \tt 5 ft 7 in & \tt 21 yr 8 mo & \tt 17.2282 \\
\hline
\end{tabular}
\end{indpar}

One can use definitions to define expressions that compute values:

\begin{indpar}
\verb|> sum from X through Y <-- integer X, integer Y:| \\
\verb|+     `Sum of integers from X through Y.'| \\
\verb|+     if ( X > Y ):| \\
\verb|+         value = 0| \\
\verb|+     else:| \\
\verb|+         value = X + sum (X+1) through Y| \\
\verb|> sum from 5 through 10| \\
\verb|45| \\
\verb|> all (sums from X through Y)| \\
\begin{tabular}{|r|r|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf parent} &
\multicolumn{1}{|c}{\bf X} &
\multicolumn{1}{|c}{\bf Y} &
\multicolumn{1}{|c|}{\bf value} \\
\hline
\tt @1000002 & \tt @1		& \tt 5	& \tt	10	& \tt 45 \\
\tt @1000003 & \tt @1000002	& \tt 6	& \tt	10	& \tt 40 \\
\tt @1000004 & \tt @1000003	& \tt 7	& \tt	10	& \tt 34 \\
\tt @1000005 & \tt @1000004	& \tt 8	& \tt	10	& \tt 27 \\
\tt @1000006 & \tt @1000005	& \tt 9	& \tt	10	& \tt 19 \\
\tt @1000007 & \tt @1000006	& \tt 10	& \tt	10	& \tt 10 \\
\tt @1000008 & \tt @1000007	& \tt 11	& \tt	10	& \tt 0 \\
\hline
\end{tabular} \\[0.5ex]
\verb|> sum from 1 through 2| \\
\verb|3| \\
\verb|> all (sums from X through Y)| \\
\begin{tabular}{|r|r|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf parent} &
\multicolumn{1}{|c}{\bf X} &
\multicolumn{1}{|c}{\bf Y} &
\multicolumn{1}{|c|}{\bf value} \\
\hline
\tt @1000002 & \tt @1		& \tt 5		& \tt	10	& \tt 45 \\
\tt @1000003 & \tt @1000002	& \tt 6		& \tt	10	& \tt 40 \\
\tt @1000004 & \tt @1000003	& \tt 7		& \tt	10	& \tt 34 \\
\tt @1000005 & \tt @1000004	& \tt 8		& \tt	10	& \tt 27 \\
\tt @1000006 & \tt @1000005	& \tt 9		& \tt	10	& \tt 19 \\
\tt @1000007 & \tt @1000006	& \tt 10	& \tt	10	& \tt 10 \\
\tt @1000008 & \tt @1000007	& \tt 11	& \tt	10	& \tt 0 \\
\tt @1000009 & \tt @1		& \tt 1		& \tt	2	& \tt 3 \\
\tt @1000010 & \tt @1000009	& \tt 2		& \tt	2	& \tt 2 \\
\tt @1000011 & \tt @1000010	& \tt 3		& \tt	2	& \tt 0 \\
\hline
\end{tabular}
\end{indpar}

Executions can be examined in detail, because
when an expression is computed, the block that computes it is remembered
for some time.  However, as memory is finite, eventually these
computations are forgotten as they can always be regenerated if
needed.

The sum above was computed by recursion: to compute the sum of 5 through 10
one adds 5 to the sum of 6 through 10.  One can also compute sums by
iteration.

\begin{indpar}
\verb|> sum from X through Y <-- integer X, integer Y:| \\
\verb|+     `Sum of integers from X through Y.'| \\
\verb|+     first sum = 0| \\
\verb|+     if ( X <= Y ):| \\
\verb|+         next sum = sum + X| \\
\verb|+         next X = X + 1| \\
\verb|+     else:| \\
\verb|+         value = sum| \\
\verb|> sum from 5 through 10| \\
\verb|45| \\
\verb|> all (sums from X through Y)| \\
\begin{tabular}{|r|r|r|r|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf previous} &
\multicolumn{1}{|c}{\bf next} &
\multicolumn{1}{|c}{\bf X} &
\multicolumn{1}{|c}{\bf Y} &
\multicolumn{1}{|c}{\bf sum} &
\multicolumn{1}{|c|}{\bf value} \\
\hline
\tt @1000012 &              & \tt @1000013
	     & \tt 5	& \tt 10   & \tt 0	& \\
\tt @1000013 & \tt @1000012 & \tt @1000014
	     & \tt 6	& \tt 10   & \tt 5	& \\
\tt @1000014 & \tt @1000013 & \tt @1000015
	     & \tt 7	& \tt 10   & \tt 11	& \\
\tt @1000015 & \tt @1000014 & \tt @1000016
	     & \tt 8	& \tt 10   & \tt 18	& \\
\tt @1000016 & \tt @1000015 & \tt @1000017
	     & \tt 9	& \tt 10   & \tt 26	& \\
\tt @1000017 & \tt @1000016 & \tt @1000018
	     & \tt 10	& \tt 10   & \tt 35	& \\
\tt @1000018 & \tt @1000017 &
	     & \tt 11	& \tt 10   & \tt 45	& \tt 45 \\
\hline
\end{tabular}
\end{indpar}

One can also iterate over data.

\begin{indpar}
\verb|> average weight of X <-- list X of persons:| \\
\verb|+     first count = 0| \\
\verb|+     first sum = 0| \\
\verb|+     if X = ():| \\
\verb|+         if count = 0:| \\
\verb|+             value = error `Cannot average 0 things.'| \\
\verb|+         else:| \\
\verb|+             value = sum / count| \\
\verb|+     else:| \\
\verb|+         next count = count + 1| \\
\verb|+         next sum = sum + the weight of (first X)| \\
\verb|+         next X = rest X| \\
\verb|> average weight of (all persons)| \\
\verb|116.5 lbs| \\
\verb|> z = 10 + average weight of (all persons named Bill)| \\
\verb|error `Cannot average 0 things.'| \\
\verb|      occurred during: average weight of| \\
\verb|                      (all persons named Bill)| \\
\verb|      occurred during: 10 + ditto| \\
\verb|      occurred during: z = ditto|
\end{indpar}

In case you wonder how some of the above works, here are some hints.

RECKON tends to ignore word endings: thus `\TT{person}' and
`\TT{persons}' are to RECKON the same word.
RECKON can even be told that `\TT{person}'
and `\TT{people}' are the same word.
On the other hand, `\TT{Jack's}' is treated an abbreviation
of two separate words `\TT{Jack}' and `\TT{'s}', where `\TT{'s}' is
a separate word by itself.

Expressions are just strings of words and subexpressions.  Subexpressions
must be parenthesized unless they consist of a single word, or unless
they are delimited by operators.

Lists of values can be stored in \skey{list}s, which are computed by comma
separated lists in parentheses.  Thus

\begin{indpar}
\verb|> (the person named Jill, the person named Jack)| \\
\begin{tabular}{|r|l|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf type} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000001 & person & Jill & \tt 110 lb & \tt 5 ft 7 in & \tt 21 yr 8 mo \\
\tt @1000000 & person & Jack & \tt 123 lb & \tt 5 ft 9 in & \tt 23 yr 2 mo \\
\hline
\end{tabular} \\[0.5ex]
\verb|> (the person named Jack, the person named Jill)| \\
\begin{tabular}{|r|l|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf type} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000000 & person & Jack & \tt 123 lb & \tt 5 ft 9 in & \tt 23 yr 2 mo \\
\tt @1000001 & person & Jill & \tt 110 lb & \tt 5 ft 7 in & \tt 21 yr 8 mo \\
\hline
\end{tabular} \\[0.5ex]
\verb|> raw (all persons)| \\
\verb|(the person named Jack, the person named Jill)| \\
\verb|> really raw (all persons)| \\
\verb|(@1000000, @1000001)|
\end{indpar}

The `\TT{raw}' form of a value represents the value
as you could input it in a way that reveals its internal structure.  Thus
`\TT{raw(all~persons)}' denotes the list of all persons, and it is the list
structure that is revealed, not the structure of the elements of the list.

`\TT{the person named Jack}' is a printed representation of the
internal name of a description.  Such printed representations are chosen
automatically from the set of all possible representations, which
in this case include `\TT{the person weighing 123 lbs}' and
`\TT{the person named Jack weighing 123 lbs}'.

The `\TT{really raw}' form of a value identifies descriptions by their IDs.

A single non-list value is equivalent to a list with one element.
Lists cannot have other lists as elements; instead attempts to
compute such lists are \key{flattened}:

\begin{indpar}
\verb|> x = (1,(2,3),4)| \\
\verb|(1,2,3,4)| \\
\verb|> first x| \\
\verb|1| \\
\verb|> rest x| \\
\verb|(2,3,4)| \\
\verb|> rest (rest x)| \\
\verb|(3,4)| \\
\verb|> rest (rest (rest x))| \\
\verb|4| \\
\verb|> rest 4| \\
\verb|()|
\end{indpar}

For this reason RECKON lists are sometimes called `\skey{flat list}s'.

RECKON has different kinds of quotes or brackets.  The brackets
\verb|{|\ldots\verb|}| and \verb|`|\ldots\verb|'|
turn
evaluation off, while \verb|[|\ldots\verb|]| turns evaluation on.
The brackets \verb|`|\ldots\verb|'| turn
recognition of operators (e.g., \verb|+| and \verb|=|) off, and turn
recognition of phrase separators (e.g., `\verb|,|' and `\verb|;|') and
sentence terminators (e.g., `\verb|.|' and `\verb|?|') on, while
\verb|[|\ldots\verb|]| and \verb|{|\ldots\verb|}|
turn recognition of operators on, and turn recognition of phrase
separators and sentence terminators off.

RECKON can store information as expressions.  For example:

\begin{indpar}
\verb|> (a person named `Jack') is husband of| \\
\verb|>     (a person named `Jill') <--| \\
\verb|>     Y is wife of X <-- X is husband of Y|
\end{indpar}

Here `\verb|<--|' means `is asserted' or `is asserted if'.
All the assertions that have been made can be queried:

\begin{indpar}
\verb|> (a person named `Jill') is wife of| \\
\verb|> (a person named `Jack') ?| \\
\verb|true| \\
\verb|> (a person named `Jack') is wife of| \\
\verb|> (a person named `Jill') ?| \\
\verb|false| \\
\verb|> (a person named X) is wife of| \\
\verb|> (a person named `Jack') ?| \\
\verb|X = `|Jill\verb|'| \\
\verb|> X is wife of (a person named `Jack') ?| \\
\verb|X = (a person named `Jill')| \\
\verb|> @1000001 is wife of (a person named `Jack') ?| \\
\verb|true| \\
\verb|> @1000001 = (a person named `Jill') ?| \\
\verb|true| \\
\verb|> @1000001 = (a person named `Jack') ?| \\
\verb|false|
\end{indpar}

RECKON supports pictorial data
that are expressions displayed as pictures:

\begin{indpar}
\verb/> x = {<circle 0.4>}/ \\[1ex]
\begin{picture}(0.4,0.4)
\put(0.2,0.2){\circle{0.4}}
\end{picture} \\
\verb/> y = {<rectangle (0.4,0.2)>}/ \\[1ex]
\begin{picture}(0.4,0.2)
\put(0,0){\framebox(0.4,0.2){}}
\end{picture} \\
\verb/> z = {<(circle 0.4) labeled `Jack'>}/ \\[1ex]
\begin{picture}(0.4,0.4)
\put(0.2,0.2){\circle{0.4}}
\put(0.0,0.0){\makebox(0.4,0.4){Jack}}
\end{picture} \\
\verb/> {<([x] right of [y]) above [z]>}/ \\[1ex]
\begin{picture}(0.8,0.8)
\put(0.6,0.6){\circle{0.4}}
\put(0.0,0.5){\framebox(0.4,0.2){}}
\put(0.4,0.2){\circle{0.4}}
\put(0.2,0.0){\makebox(0.4,0.4){Jack}}
\end{picture} \\
\verb/> {<row([x],[y],[z])>}/ \\[1ex]
\begin{picture}(1.4,0.4)
\put(0.2,0.2){\circle{0.4}}
\put(0.4,0.1){\framebox(0.4,0.2){}}
\put(1.0,0.2){\circle{0.4}}
\put(0.8,0.0){\makebox(0.4,0.4){Jack}}
\end{picture} \\
\verb/> p = {<column (row([x],[y],[z]), row([z],[y],[x]))>}/ \\[1ex]
\begin{picture}(1.4,0.8)
\put(0.2,0.6){\circle{0.4}}
\put(0.4,0.5){\framebox(0.4,0.2){}}
\put(1.0,0.6){\circle{0.4}}
\put(0.8,0.4){\makebox(0.4,0.4){Jack}}
\put(1.0,0.2){\circle{0.4}}
\put(0.4,0.1){\framebox(0.4,0.2){}}
\put(0.2,0.2){\circle{0.4}}
\put(0.0,0.0){\makebox(0.4,0.4){Jack}}
\end{picture} \\
\verb/> raw x/ \\
\verb/{<circle 0.4>}/ \\
\verb/> raw p/ \\
\verb/{<column (row (circle 0.4,/ \\
\verb/               rectangle (0.4,0.2),/ \\
\verb/               (circle 0.4) labeled `Jack'),/ \\
\verb/          row ((circle 0.4) labeled `Jack',/ \\
\verb/               rectangle (0.4,0.2),/ \\
\verb/               circle 0.4))>}/
\end{indpar}

You can also change how an expression is displayed.

\begin{indpar}
\newlength{\ovalraise}
\setlength{\ovalraise}{-0.1in}
\addtolength{\ovalraise}{0.8ex}
\verb/> display ( P ) <-- person ( P ) has name ( X ):/ \\
\verb/>     value = {<oval (0.4,0.2) labeled [X]>}/ \\
\verb/> (a person named `Jack')/ \\
\begin{picture}(0.4,0.2)
\put(0.2,0.1){\oval(0.4,0.2)}
\put(0.0,0.0){\makebox(0.4,0.2){Jack}}
\end{picture} \\
\verb/> `[a person named `Jill'] is wife of/ \\
\verb/   [a person named `Jack']'/ \\
\verb/`/
\raisebox{\ovalraise}{\begin{picture}(0.4,0.2)
\put(0.2,0.1){\oval(0.4,0.2)}
\put(0.0,0.0){\makebox(0.4,0.2){Jill}}
\end{picture}}
{is the wife of}
\raisebox{\ovalraise}{\begin{picture}(0.4,0.2)
\put(0.2,0.1){\oval(0.4,0.2)}
\put(0.0,0.0){\makebox(0.4,0.2){Jack}}
\end{picture}}
\verb/'/
\end{indpar}

Displays can be used to make demonstrations:

\begin{indpar}
\verb|> for every demo:| \\
\verb|>     on a demo with angle X:| \\
\verb|+         angle = X| \\
\verb|> x = a demo with angle 30 degrees| \\
\begin{tabular}{|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf type} &
\multicolumn{1}{|c|}{\bf angle} \\
\hline
\tt @1000043 & demo & 30 degrees \\
\hline
\end{tabular} \\[0.5ex]
\verb|> for every demo:| \\
\verb|+     on update THIS to X:|\\
\verb|+         next angle = X| \\
\verb|+     on increment THIS by X:| \\
\verb|+         next angle = angle + X| \\
\verb|> update x to 40 degrees| \\
\begin{tabular}{|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf type} &
\multicolumn{1}{|c|}{\bf angle} \\
\hline
\tt @1000044 & demo & 40 degrees \\
\hline
\end{tabular} \\[0.5ex]
\verb|> increment x by 5 degrees| \\
\begin{tabular}{|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf type} &
\multicolumn{1}{|c|}{\bf angle} \\
\hline
\tt @1000045 & demo & 45 degrees \\
\hline
\end{tabular} \\[0.5ex]
\verb/> display ( D ) <-- demo ( D ) with angle ( X ):/ \\
\verb/+     c = {<circle 1.0 dotted center (0.0,0.0)>}/ \\
\verb/+     x axis = {<arrow from (-0.75,0.0) to (0.75,0.0)>}/ \\
\verb/+     y axis = {<arrow from (0.0,-0.75) to (0.0,0.75)>}/ \\
\verb/+     line = {<line from (0.0,0.0)/ \\
\verb/+                   to [(0.5*cos X, 0.5*sin X)]>}/ \\
\verb/+     arc = {<arc arrow from (0.7,0.0)/ \\
\verb/+                       to [(0.3*cos X, 0.3*sin X)]>}/ \\
\verb/+     theta = {<Greek th>}/ \\
\verb/+     value = {<label (/ \\
\verb/+                `Depiction of Angle [theta]=[X]',/ \\
\verb/+                overlap (/ \\
\verb/+                  [c],/ \\
\verb/+                  [x axis] labeled `X Axis',/ \\
\verb/+                  [y axis] labeled `Y Axis',/ \\
\verb/+                  [line],/ \\
\verb/+                  [arc] labeled `[theta]' ) ) >}/ \\
\verb/> show x/ \\
See `Depiction of Angle $\theta=45^\circ$' \\
\verb|> increment x by -15 degrees| \\
See `Depiction of Angle $\theta=30^\circ$'
\end{indpar} 

\begin{center}
\newcommand{\anglestuff}{
    \put(1.0,0.95){\qbezier[40](0.5,0.0)(0.46,0.46)(0.0,0.5)}
    \put(1.0,0.95){\qbezier[40](0.0,0.5)(-0.46,0.46)(-0.5,0.0)}
    \put(1.0,0.95){\qbezier[40](-0.5,0.0)(-0.46,-0.46)(0.0,-0.5)}
    \put(1.0,0.95){\qbezier[40](0.0,-0.5)(0.46,-0.46)(0.5,0.0)}
    \put(1.0,0.2){\vector(0,1){1.5}}
    \put(0.0,1.7){\makebox(2.0,0.2){Y Axis}}
    \put(0.25,0.95){\vector(1,0){1.5}}
    \put(1.80,0.85){\makebox(0.7,0.2)[l]{X Axis}}
}
\begin{picture}(5.5,1.9)
\put(0,0){
    \anglestuff
    \put(1.0,0.95){\qbezier[1000](0,0)(0.1767765,0.1767765)(0.353553,0.353553)}
    \put(1.0,0.95){
	\qbezier[250](0.3,0.0)(0.3,0.124264)(0.212132,0.212132)
	\put(0.212132,0.212132){\vector(-1,1){0.00}}
	\put(0.31,0.1){$\theta$}}
    \put(0.0,0.0){\makebox(2.0,0.2){Depiction of Angle $\theta=45^\circ$}}
}
\put(3.0,0){
    \anglestuff
    \put(1.0,0.95){\qbezier[1000](0,0)(0.2165065,0.125)(0.433013,0.25)}
    \put(1.0,0.95){
	\qbezier[250](0.3,0.0)(0.32,0.0745584)(0.2598078,0.15)
	\put(0.2598078,0.15){\vector(-1,1){0.00}}
	\put(0.33,0.05){$\theta$}}
    \put(0.0,0.0){\makebox(2.0,0.2){Depiction of Angle $\theta=30^\circ$}}
}
\end{picture}

\end{center}

In this example we first define a `constructor'
of the form `\TT{a demo with angle X}' to make new \TT{demo} descriptions,
and then we define two `methods', namely `\TT{update THIS to X}' and
`\TT{in\-cre\-ment THIS by X}', to change a \TT{demo} description.  Changing
a \TT{demo} description is like iterating a loop to make a new description.

Next we define how to display a \TT{demo} description.  Then we use the
`\TT{show x}' command
to cause the \TT{demo} description value of \TT{x}
to be displayed in a separate window.
Every time this \TT{demo} description
changes, the window is updated, and every time the description
is to be printed,
`See `Depiction of Angle $\theta=\ldots^\circ$'\,'
is printed instead, where `Depiction \ldots' is the \TT{label} part of
the display.


TBD: example of a simple game.

The rest of this document is a reference manual for RECKON.

\begin{boxedfigure}

\begin{verbatim}
for every board:
    on a board of dimension S:
        `Make a board of size SxS.'
        size = S
        `Allowed vessels have lengths 2 (destroyer),
         3 (cruiser), 5 (battleship).  vessels(L) is
         number of length L.'
        array vessels of size 5
              with initial element 0
        `maximum vessels(L) is maximum number of vessels of
         length L.'
        array maximum vessels of size 5
              with initial element 0
        maximum vessels(2) = 5
        maximum vessels(3) = 2
        maximum vessels(5) = 1
        `state(I,J) is `none', `miss', or `hit' iff shell
         has not struck square (I,J), struck square (I,J)
         but that square had no ship, or struck square (
         ,J) and hit a ship at that square.'
        array hit of size (S,S) with initial element `none'
        `vessel(I,J) is the vessel at (I,J)'
        array vessel of size (S,S)
              with initial element `none'
\end{verbatim}

\caption{Code for the Battleship Game, Part I}
\label{CODE-FOR-BATTLESHIP-1}
\end{boxedfigure}


\begin{boxedfigure}

\begin{verbatim}
direction vector of D:
    `given a direction N, NE, E, SE, S, SW, W, NW,
     return a vector with unit components in the
     given direction.'
    if D == `N':
        value = (1,0)
    else if D == `NE':
        value = (1,1)
    else if D == `E':
        value = (1,0)
    else if D == `SE':
        value = (1,-1)
    else if D == `S':
        value = (0,-1)
    else if D == `SW':
        value = (-1,-1)
    else if D == `W':
        value = (-1,0)
    else if D == `NW':
        value = (-1,1)
\end{verbatim}

\caption{Code for the Battleship Game, Part II}
\label{CODE-FOR-BATTLESHIP-2}
\end{boxedfigure}

\begin{boxedfigure}

\begin{verbatim}
for every vessel:
    on a vessel of length L with direction D from (I,J) on B:
        `make a vessel of length L positioned in direction D
         from origin (I,J) on boards B; directions are N,
         NE, E, SE, S, SW, W, NW'
        length = L
        direction = D
        origin = (I,J)
        vector = direction vector of D
        destination = L * vector + origin
        board = B
        conflict =:
            first p = origin
            first k = 0
            next k = k + 1
            next p = p + vector
            TBD
        if L < 2 or L > 5:
            value = error `bad length [L]'
        else if maximum vessels(L) of B >= vessels(L) of B:
            value = error `two many vessels of length [L]
                           on board [B]'
        else:
            vessels(L) of B += 1
\end{verbatim}

\caption{Code for the Battleship Game, Part III}
\label{CODE-FOR-BATTLESHIP-3}
\end{boxedfigure}

\newpage

\section{Lexemes}

Input text is a sequence of characters.  This is scanned from
left to right and top to bottom to produce a sequence of lexemes,
which include words, marks, separators, numerics, and quoted strings.

For example, the input
\begin{center}
\verb|x = 7ft 1 3/4in;|
\end{center}
contains in order the following lexemes:
\begin{center}
\begin{tabular}{ll}
\tt x	& word \\
\tt =	& mark \\
\tt 7	& numeric \\
\tt ft	& word \\
\tt 1	& numeric \\
\tt 3/4	& numeric \\
\tt in	& word \\
\tt ;	& separator \\
\end{tabular}
\end{center}

\ikey{Lexemes}{lexeme} are defined more specifically as follows:

\begin{indpar}
\emkey{lexeme}
	::= {\em word}
	$|$ {\em numeric}
	$|$ {\em mark}
	$|$ {\em separator}
	$|$ {\em quoted-string}
	$|$ {\em comment}
\label{SYMBOL-LEXEME}
\\[2ex]
\emkey{word} :::= {\em word-character} {\em word-character}\,$^\star$
\label{WORD}
\\[1ex]
\emkey{numeric} :::=
        {\em numeric-character} {\em numeric-character}\,$^\star$
\label{NUMERIC}
\\[1ex]
\emkey{mark} :::= {\em mark-character} {\em mark-character}\,$^\star$
\\[1ex]
\emkey{separator}
	:::= {\em separator-character} except \TT{|} $|$ \TT{|}\PLUS{}
\label{SEPARATOR}
\\[1ex]
\emkey{quoted-string} :::=
    \TT{"} {\em character-representative}\,$^\star$ \TT{"}
\label{QUOTED-STRING}
\\[1ex]
\emkey{comment} :::=
    \TT{//} {\em comment-character}\,$^\star$ \TT{"}
\label{COMMENT}
\\[2ex]
\emkey{word-character} \begin{tabular}[t]{rl}
                     :::= & {\em letter} \\
		     $|$ & \TT{'} followed by a letter \\
		     \end{tabular}
		     \\[1ex]
\emkey{letter} :::= {\em lower-case-letter} $|$ {\em upper-case-letter} \\[1ex]
\emkey{lower-case-letter} :::=  \TT{a}%
			    $|$\TT{b}%
			    $|$\TT{c}%
			    $|$\TT{d}%
			    $|$\TT{e}%
			    $|$\TT{f}%
			    $|$\TT{g}%
			    $|$\TT{h}%
			    $|$\TT{i}%
			    $|$\TT{j}%
			    $|$\TT{k}%
			    $|$\TT{l}%
			    $|$\TT{m}%
			    $|$\TT{n}%
			    $|$\TT{o}%
			    $|$\TT{p}%
			    $|$\TT{q}%
			    $|$\TT{r}%
			    $|$\TT{s}%
			    $|$\TT{t}%
			    $|$\TT{u}%
			    $|$\TT{v}%
			    $|$\TT{w}%
			    $|$\TT{x}%
			    $|$\TT{y}%
			    $|$\TT{z}
			    \\[1ex]
\emkey{upper-case-letter} :::=  \TT{A}%
			    $|$\TT{B}%
			    $|$\TT{C}%
			    $|$\TT{D}%
			    $|$\TT{E}%
			    $|$\TT{F}%
			    $|$\TT{G}%
			    $|$\TT{H}%
			    $|$\TT{I}%
			    $|$\TT{J}%
			    $|$\TT{K}%
			    $|$\TT{L}%
			    $|$\TT{M}%
			    $|$\TT{N}%
			    $|$\TT{O}%
			    $|$\TT{P}%
			    $|$\TT{Q}%
			    $|$\TT{R}%
			    $|$\TT{S}%
			    $|$\TT{T}%
			    $|$\TT{U}%
			    $|$\TT{V}%
			    $|$\TT{W}%
			    $|$\TT{X}%
			    $|$\TT{Y}%
			    $|$\TT{Z}
			    \\[1ex]
\emkey{numeric-character} \begin{tabular}[t]{rl}
		:::= &   {\em digit} \\
		$|$ & \TT{.} followed by by a {\em digit } \\
		$|$ & \TT{'} followed by by a {\em digit } \\
		$|$ & \TT{,} surrounded by {\em digits} \\
		$|$ & \TT{/} surrounded by {\em digits} \\
		$|$ & \TT{:} surrounded by {\em digits} \\
		    \end{tabular}\\[1ex]
\emkey{digit} :::=  \TT{0}%
		$|$\TT{1}%
		$|$\TT{2}%
		$|$\TT{3}%
		$|$\TT{4}%
		$|$\TT{5}%
		$|$\TT{6}%
		$|$\TT{7}%
		$|$\TT{8}%
		$|$\TT{9} \\[1ex]
\emkey{mark-character} \begin{tabular}[t]{rl}
		     :::= &      \TT{+}%
		             $|$\TT{-}%
		             $|$\TT{*}%
		             $|$\TT{/}%
		             $|$\TT{\textbackslash}%
		             $|$\TT{\~{ }}%
		             $|$\TT{@}%
		             $|$\TT{\#}%
		             $|$\TT{\$}%
		             $|$\TT{\%}%
		             $|$\TT{\^{ }}%
		             $|$\TT{\&}%
		             $|$\TT{=}%
		             $|$\TT{<}%
		             $|$\TT{>}%
		             $|$\TT{\_}%
		             $|$\TT{!}%
		             $|$\TT{?} \\
		     $|$ & \TT{.} not followed by a {\em digit} \\
		     $|$ & \TT{/} not surrounded by {\em digits} \\
		     $|$ & \TT{:} not surrounded by {\em digits} \\
			\end{tabular}\\[1ex]
\emkey{separator-character} \begin{tabular}[t]{rl}
		:::= &   \TT{(}
	       	    $|$ \TT{)}
	       	    $|$ \TT{[}
	       	    $|$ \TT{]}
	       	    $|$ \TT{\{}
	       	    $|$ \TT{\}}
	       	    $|$ \TT{;}
	       	    $|$ \TT{|}
	       	    $|$ \TT{`} \\
		$|$ & \TT{,} not surrounded by {\em digits} \\
		$|$ & \TT{'} not followed by a letter or digit \\
		    \end{tabular}\\[1ex]
\emkey{character-representative} \begin{tabular}[t]{rl}
		    :::= & {\em graphic-character} other than \TT{"} \\
		    $|$ & {\em single-space-character} \\
		    $|$ & {\em special-character-representative}
		    \end{tabular}\\[1ex]
\emlkey{special}{-character-representative}
    :::= see Figure~\figref{SPECIAL-CHARACTER-REPRESENTATIVES} \\
\emkey{comment-character}
    :::= {\em graphic-character} $|$ {\em horizontal-space-character}
\end{indpar}

\begin{boxedfigure}[!t]

\begin{center}
\begin{tabular}{lp{2in}}
\tttkey{NUL} & nul \\
\tttkey{SOH} & start of heading \\
\tttkey{STX} & start of text \\
\tttkey{ETX} & end of text \\
\tttkey{EOT} & end of transmission \\
\tttkey{ENQ} & enquiry \\
\tttkey{ACK} & acknowledge \\
\tttkey{BEL} & bell \\
\tttkey{BS}  & backspace \\
\tttkey{HT}  & horizontal tab \\
\tttkey{LF}  & line feed \\
\tttkey{VT}  & vertical tab \\
\tttkey{FF}  & form feed \\
\tttkey{CR}  & carriage ret \\
\tttkey{SO}  & shift out \\
\tttkey{SI}  & shift in \\
\tttkey{DLE} & data link escape
\\[1ex]
\tttkey{NL}  & new line (equals \TT{<LF>}) \\
\end{tabular}
\begin{tabular}{lp{2in}}
\tttkey{DC1} & device control 1 \\
\tttkey{DC2} & device control 2 \\
\tttkey{DC3} & device control 3 \\
\tttkey{DC4} & device control 4 \\
\tttkey{NAK} & negative ack. \\
\tttkey{SYN} & synchronous idle \\
\tttkey{ETB} & end of transmission block \\
\tttkey{CAN} & cancel \\
\tttkey{EM}  & end of medium \\
\tttkey{SUB} & substitute \\
\tttkey{ESC} & escape \\
\tttkey{FS}  & file separator \\
\tttkey{GS}  & group separator \\
\tttkey{RS}  & record separator \\
\tttkey{US}  & unit separator \\
\tttkey{SP}  & single space \\
\tttkey{DEL} & delete
\\[1ex]
\tttkey{Q}  & double quote (\TT{"}) \\
\end{tabular}
\end{center}

\caption{Special Character Representatives}
\label{SPECIAL-CHARACTER-REPRESENTATIVES}
\end{boxedfigure}

A \key{word} is a sequence of letters that may include
a \TT{'} if it is followed by a letter.  A \key{mark} is a
sequence of mark characters (e.g., \TT{+} and \TT{-}).
A \key{separator} is a single separator character or
a sequence of one or more \TT{|}'s.
A \key{numeric} is a sequence of digits,
decimal points followed by a digit,
\TT{'} followed by a digit,
commas both preceded and followed by digits,
slashes both preceded and followed by digits,
and colons both preceded and followed by digits.
A \key{quoted-string} is
a sequence of \skey{character representative}s surrounded by
the double quote character (\ttkey{"}), where \skey{graphic character}s
other than \TT{"}
are their own representatives (\TT{A}, \TT{B}, \TT{0}, \TT{1},
etc.) but other characters are represented by character sequences
that begin with \TT{<} and end with \TT{>}; e.g., \TT{<LF>} represents
a line feed character and \TT{<Q>} represents \TT{"}.
A \key{comment} is a pair of \TT{/}'s followed by a sequence
of {\em graphic-} and {\em white-space-characters}.

Outside {\em quoted-strings} and {\em comments},
a \ttkey{'} is a {\em word-character} if it is followed by a letter,
a {\em numeric-character} if it is followed by a digit,
and a {\em separator-character} otherwise.
Similarly a \TT{.} is a {\em numeric-character} (decimal point) if it
is followed by a digit, and a {\em mark-character} otherwise;
a \ttkey{,} is a {\em numeric-character} if surrounded by digits, and
a {\em separator-character} otherwise;
a \ttkey{/} is a {\em numeric-character} if surrounded by digits, and
a {\em mark-character} otherwise;
and a \ttkey{:} is a {\em numeric-character} if surrounded by digits, and
a {\em mark-character} otherwise.

Lexemes may be separated by \key{white-space}, which
is a sequence of white-space characters (single space, horizontal tab, form
feed, etc.), but is not itself a lexeme.

\begin{indpar}
\emkey{white-space} :::= {\em white-space-character}
                         {\em white-space-character}\,$^\star$ \\[1ex]
\emkey{white-space-character}
    \begin{tabular}[t]{rl}
    :::= & {\em horizontal-space-character} \\
    $|$ & {\em vertical-space-character}
    \end{tabular}
    \\[1ex]
\emkey{horizontal-space-character} :::=
    \key{space} $|$ \key{horizontal-tab} \\[1ex]
\emkey{vertical-space-character} :::=
    \key{line-feed} $|$ \key{vertical-tab} $|$ \key{form-feed}
\end{indpar}

The symbol `\ttmkey{:::=}{in syntax equation}' is used in syntax equations
that define lexemes or parts of lexemes and whose syntactic elements are
character sequences that must \underline{not} be separated by {\em white-space}.
The symbol `\ttmkey{::=}{in syntax equation}'
is used in syntax equations that define sequences of lexemes that may
and sometimes must be separated by {\em white-space}.
{\em Comments} are treated as lexemes, but are discarded before the
lexeme stream is transmitted to the parser.

Non-{\em white-space} control characters are ignored, as if they
did not exist, except that a warning message may be issued.  However
no warning is issued for \emskey{carriage-return}s that are next to
a {\em vertical-space-character}.

The tabs used by the {\em horizontal-tab} character are set every
8 columns.

Every {\em vertical-space-character} causes the current position to
return to the beginning of a new line.
{\em Horizontal-space-characters} before a {\em vertical-space-character}
are ignored, as if they did not exist.
Warning messages are issued for {\em form-feeds} and {\em vertical-tabs}
that occur when the column position is not at the beginning of a line.

{\em Numerics} represent \key{numbers}\label{NUMBER} which are stored
as strings of binary
digits.  Several {\em numerics} may represent the same number.  For example,
\TT{007} and \TT{7} both represent the same number,
and \TT{15/2}, \TT{7.5}, and \TT{7.50} all represent the same number.

{\em Words}, {\em marks}, {\em separators}, and {\em quoted-strings}
represent \skey{symbol}s\label{SYMBOL} which are stored as character strings.
The character strings represented by
{\em words}, {\em marks}, and {\em separators}
are exactly the character strings of these lexemes.

The character string represented by a {\em quoted-string} with no
{\em special-character-representatives}
is just the {\em quoted-string} lexeme in its entirety,
including its surrounding quotes (\TT{"}).
{\em Special-charac\-ter-representatives} inside the \TT{"}'s of a
quoted string may be used to represent various characters: for
example, the {\em quoted-string} \TT{"<Q>Help!<Q>"} represents the
9-character symbol \TT{""Help!""}.

Symbols and numbers are referred to as \skey{atom}s.\label{ATOM}

Symbols that begin and end with \TT{"}'s are called \key{quoted symbols}.
In many contexts, such symbols are \skey{dequote}d\label{DEQUOTE}
by having their
beginning and ending \TT{"}'s removed.  Dequoting a symbol that does
not begin with \TT{"} or does not end with \TT{"} does nothing to the
symbol.  Dequoting a number atom does nothing to the atom.

In other contexts symbols
are \skey{quote protect}{ed} by converting them to {\em quoted-string}
lexemes if and only if they are not the character strings of a
{\em word} lexeme.  Quote protecting a number atom does nothing to
the atom.

Also symbols can be \ikey{quoted}{quote!a symbol} by adding a \TT{"}
character to each end.

Input to the parser is a string of atoms that have not been dequoted,
while output from the parser is dequoted.
Thus \TT{+} and \TT{"+"} are not the same when input, but when
output they are the same.
For instance, given \TT{x + y} as input the parser will recognize
\TT{+} as an operator and output \TT{+ x y},
but given \TT{x "+" y} as input the parser will output \TT{x + y}.

Lexemes are contained in lines.  Line beginnings
are translated into a special lexeme which is
input to the parser.  Lines can also be organized into indented subparagraphs
whose beginnings and endings are translated into special sequences of
lexemes that are input to the parser.

A non-blank line beginning translates into the lexeme `\ttkey{<*>}', unless
the line is the first non-blank line of an indented
subparagraph (see below).

A non-blank line can be \mkey{continued}{line} by a following sequence of
\emkey{continuation-lines}.  These must be non-blank and
have an indentation greater than that of the \emkey{continuted-line}.
However their indentations may differ, as long
as each is indented more than that of the initial {\em continued-line}.
A {\em continuation-line} may contain just a {\em comment}.
Thus

\begin{indpar}\begin{verbatim}
This is a line
     which is continued
       // A comment.
   and continued.
\end{verbatim}\end{indpar}

translates to the lexeme squence

\begin{indpar}\begin{verbatim}
<*> This is a line which is continued and continued .
\end{verbatim}\end{indpar}

All that has been done here is to omit the \TT{<*>} line beginning
lexemes of the continuation lines.

A \key{subparagraph}, also known as a \key{subblock},
is introduced by a `\ttmkey{:}{introducing subparagraph}'
at the end of a line.  This translates to the lexeme sequence
`\ttkey{\{:}' and also specifies that the next non-blank
line is not a continuation of any previous line.  If the
indentation of this next non-blank line is larger than the
indentation of the line ending with `\TT{:}', this
indentation becomes the indentation of the
subparagraph, and all the lines of the subparagraph.  When a
line with smaller indentation is encountered, it is interpreted
as the first line beyond the end of the subparagraph, and
the lexeme squence `\ttkey{:\}}' is inserted just after
the last lexeme in the last subparagraph line (or
just after \TT{\{:} if the subparagraph is empty).

Each subparagraph line but the first begins with a `\TT{<*>}'
lexeme.  This `\TT{<*>}' lexeme is suppressed for the first
line, so it serves as a line separator within
the subparagraph `\TT{\{:\ldots:\}}'.


Thus

\begin{indpar}\begin{verbatim}
This is a line:
     And a subparagraph
         line.
     And another.
And more.
\end{verbatim}\end{indpar}

translates to the lexeme sequence

\begin{indpar}\begin{verbatim}
<*> This is a line {:
        And a subparagraph line.
    <*> And another. :}
<*> And more.
\end{verbatim}\end{indpar}

If the next non-blank line after a line ending in `\TT{:}' does
not have a greater indent than the line ending in `\TT{:}', the
subparagraph is empty, and all that happens is that the line
ending `\TT{:}' is replaced by `\TT{\{:~:\}}'.

`\TT{:\}}' sequences are added at the end of a file to
match any unmatched `\TT{\{:}' sequences from subparagraphs
that extend to the end of file.

A line ending `\TT{:}' is a character and not a lexeme; if it
is at the end of a {\em mark}, it is removed from the {\em mark}.
Thus

\begin{indpar}\begin{verbatim}
x =:
     y = 5
     z = 10
\end{verbatim}\end{indpar}

translates to the lexeme sequence

\begin{indpar}\begin{verbatim}
<*> x = {: <*> y = 5 <*> z = 10 :}
\end{verbatim}\end{indpar}

Blank lines are ignored unless they appear just before a non-continuation
line outside any subparagraph,
in which case they are translated into the `\ttkey{<\#>}' lexeme if
the line they appear before is not indented, and into the
`\ttkey{<\#\#>}' lexeme if the line they appear before is indented.
Note that a blank line before another blank line is ignored.  Thus

\begin{indpar}\begin{verbatim}
This is a line
     which is continued.

And more.

   And yet more.
\end{verbatim}\end{indpar}

translates to the lexeme squence

\begin{indpar}\begin{verbatim}
<*> This is a line which is continued .
<#> <*> And more .
<##> <*> And yet more .
\end{verbatim}\end{indpar}


A single \TT{<\#>} or \TT{<\#\#>} lexeme is also placed at the beginning of
a file that begins with a non-blank line, as if a blank line 
had been inserted at the beginning of the file.


\section{Names}

A \key{name} is a sequence of atoms represented by a sequence
of {\em atom-names}:

\begin{indpar}
\emkey{name} := {\em atom-name}\PLUS{}
\label{NAME}
\\[1ex]
\emkey{atom-name}
    \begin{tabular}[t]{rl}
    ::= & {\em word} \\
    $|$ & {\em quoted-string} \\
    $|$ & {\em fractional-number}\pagnote{FRACTIONAL-NUMBERS} \\
    $|$ & {\em scientific-number}\pagnote{SCIENTIFIC-NUMBERS} \\
    $|$ & {\em date}\pagnote{DATES} \\
    $|$ & {\em time}\pagnote{TIMES} \\
    $|$ & {\em concatenated-quoted-string}%
          \pagnote{CONCATENATED-QUOTED-STRINGS} \\
    $|$ & {\em radix-number}\pagnote{RADIX-NUMBERS} \\
    \end{tabular}
\label{ATOM-NAME}
\end{indpar}

Generally {\em names} consist of {\em words}, {\em numerics}, and
{\em quoted-strings}, but \underline{not} {\em marks} or {\em separators}.
An atom that is a {\em mark} or {\em separator} can be represented in
a {\em name} by a {\em quoted-string}.  However there are three {\em marks}
that can appear in particular locations within {\em names}:
\TT{+}, \TT{-}, and \TT{\#}.

The parser inputs a {\em name} that is a string of lexemes
and outputs a {\em name} that is the sequence of those atoms whose
{\em atom-names} appear in the input.  The output is \underline{not}
dequoted (see \pagref{DEQUOTE}), but is often
dequoted before it is used.

An \emkey{atom-name} represents a single atom.  {\em Words} and
{\em quoted-strings}, if they are single-lexeme {\em atom-names},
represent symbols as described on \pagref{SYMBOL}.
{\em Numerics}, if they are single-lexeme {\em atom-names}
consisting of just decimal digits with an optional decimal point, or
alternatively if they have an optional fraction indicator \TT{/},
represent a numbers, as described on \pagref{NUMBER}.
Other {\em atom-names} are more complex; some examples are
`\TT{12:45:13}' which represents the {\em time}\pagnote{TIMES}
$60*(60*12+45)+13$ seconds,
`\TT{03/14/27}' which represents the {\em date}\pagnote{DATES}
March 14, 2027, expressed as seconds relative to
noon GMT on January 1, 4713 BC,
and `\TT{1.3e5}', which represents the
{\em scientific-number}\pagnote{SCIENTIFIC-NUMBERS}
$1.3*10^{5}$.

Names are used to name both variables and constants.  Thus \TT{123}
generally names an integer constant, but can also be the label of
an element in a vector, \TT{"123"} generally names a symbol constant, \TT{X}
generally names a variable, and \TT{"X"} generally names a symbol constant.
In many contexts, names are dequoted, in which
case \TT{X} and \TT{"X"} represent the same name.

After the representation of a name is converted into a sequence
of atoms, this sequence may be further parsed into an expression.
Such names are called `compound names'.  For example, the name
`\TT{george's weight}' is parsed to make the expression
`\TT{george 's weight}' where \TT{'s} has become an operator
(like the `\TT{.}' operator in C, C++, or other programming languages).
See \itemref{COMPOUND-NAMES} for details.

If a syntactic unit {\em X-name} is used, the syntactic equation
`{\em X-name} ::= {\em name}' is implied.

Multi-lexeme {\em atom-names}, and the more complex single-lexeme
{\em atom-names}, are described in the following sections.

\subsection{Fractional Numbers}
\label{FRACTIONAL-NUMBERS}

A \key{fractional number} is a {\em numeric} with contains only digits
and a single \TT{/}, optionally preceeded by a {\em sign} and an
{\em integer-numeric}:

\begin{indpar}
\emkey{fractional-number} ::=
    {\em sign}\QMARK{} {\em integral-numeric}\QMARK{} {\em fractional-numeric}
\\[1ex]
\emkey{sign} ::= \TT{+} $|$ \TT{-}
\\[1ex]
\emkey{integral-numeric} :::= {\em digit}\PLUS{}
	$|$ {\em digit}\QMARK{} {\em digit}\QMARK{} {\em digit}
	    \{ \TT{,} {\em digit} {\em digit} {\em digit} \}\PLUS{}
\\[1ex]
\emkey{fractional-numeric} :::= {\em digit}\PLUS{} \TT{/} {\em digit}\PLUS{}
\end{indpar}

Some examples are: \TT{1/3},~~~\TT{+~48/97},~~~\TT{42~3/8},~~~\TT{-10~6/10}.

Internally a fraction is stored as an IEEE double precision floating
point number.  If an internally stored number can print as a fraction
with a small denominator more accurately than it can be printed with
some given number of decimal places, it may in some contexts be
printed as a fraction.  Thus in these contexts a number input as
\TT{1/3} will print as \TT{1/3} and not as \TT{0.333333}.

The fraction \TT{0/0} denotes the IEEE \key{NaN} value, which
stands of `Not a Number'.  The fraction \TT{$N$/0} for $N>0$
denotes \TT{+inf}, or plus infinity, while \TT{-~$N$/0} denotes
\TT{-inf}, or minus infinity.

\subsection{Scientific Numbers}
\label{SCIENTIFIC-NUMBERS}

A \key{scientific number} is a {\em numeric} which contains only
digits plus an optional decimal point and optional commas,
with an optional preceeding sign and an optional trailing exponent:

\begin{indpar}
\emkey{scientific-number} ::= {\em sign}\QMARK{} {\em scientific-numeric}
			     {\em exponent}\QMARK{} \\[1ex]
\emkey{sign} ::= \TT{+} $|$ \TT{-} \\[1ex]
\emkey{scientific-numeric} :::= {\em integral-numeric}
       {\em fractional-part}\QMARK{} \\[1ex]
\emkey{integral-numeric} :::= {\em digit}\PLUS{}
	$|$ {\em digit}\QMARK{} {\em digit}\QMARK{} {\em digit}
	    \{ \TT{,} {\em digit} {\em digit} {\em digit} \}\PLUS{} \\[1ex]
\emkey{fractional-part} :::= \TT{.} {\em digit}\PLUS{}
	$|$ \TT{.} \{ {\em digit} {\em digit} {\em digit} \TT{,} \}\PLUS{}
	    {\em digit} {\em digit}\QMARK{} {\em digit}\QMARK{} \\[1ex]
\emkey{exponent} ::= {\em exponent-indicator} {\em sign}\QMARK{}
                     {\em integral-numeric} \\[1ex] 
\emkey{exponent-indicator} ::= \TT{e} $|$ \TT{E}
\end{indpar}

{\em Commas} must be every three {\em digits} from the end of
a {\em integral-numeric} or the beginning of a {\em fractional-part}.
If the {\em scientific-numeric} contains a decimal point, it must
be preceeded by a digit (write \TT{0.5} and not \TT{.5}).
An {\em exponent} shifts the decimal point (including the implied
decimal point at the end of the {\em scientific-numeric} that has
no decimal point); a positive exponent shifts right and a negative
exponent shifts left.

\subsection{Dates}
\label{DATES}

A \key{date} is an {\em atom-name} that names an integer atom
which gives the \key{Julian Day Number} of the day times
the number of seconds in one day ($60*60*24=86,400$).
The Julian Day Number system assigns day \TT{0} to the day starting
at noon GMT on January 1, 4713 BC, in the Gregorian Calendar extended
backwards, and counts days forward and backward
from this day.\footnote{Julian Day Numbers are used for dates in astronomy.}
Note that in this system days start at noon, and not at midnight.

A variety of different date formats may be used:

\begin{indpar}
\emkey{date} \begin{tabular}[t]{rl}
	     ::= & {\em weekday}\QMARK{} {\em date-numeric} {\em era}\QMARK{} \\
	     $|$ & {\em weekday}\QMARK{} {\em month-name} {\em day}
	           {\em year-name} {\em era}\QMARK{} \\
	     $|$ & {\em weekday}\QMARK{} {\em day} {\em month-name}
	           {\em year-name} {\em era}\QMARK{} \\
	     $|$ & {\em month-name} {\em year-name}
	           {\em era}\QMARK{} \\
	     $|$ & {\em short-year-name}
	     \end{tabular}
\label{DATE}
\\[1ex]
\emkey{date-numeric} :::= {\em month}\TT{/}{\em day}\TT{/}{\em year}
\\[1ex]
\emkey{month} :::=  {\em digit}\PLUS{}
\\[1ex]
\emkey{day} :::=  {\em digit}\PLUS{}
\\[1ex]
\emkey{year} :::= {\em digit}\PLUS{}
\\[1ex]
\emkey{month-name}
    \begin{tabular}[t]{rl}
    ::= & \TT{jan} $|$ \TT{Jan} $|$ \TT{January} \\
    $|$ & \TT{feb} $|$ \TT{Feb} $|$ \TT{February} \\
    $|$ & \TT{mar} $|$ \TT{Mar} $|$ \TT{March} \\
    $|$ & \TT{apr} $|$ \TT{Apr} $|$ \TT{April} \\
    $|$ & \TT{may} $|$ \TT{May} $|$ \TT{May} \\
    $|$ & \TT{jun} $|$ \TT{Jun} $|$ \TT{June} \\
    $|$ & \TT{jul} $|$ \TT{Jul} $|$ \TT{July} \\
    $|$ & \TT{aug} $|$ \TT{Aug} $|$ \TT{August} \\
    $|$ & \TT{sep} $|$ \TT{Sep} $|$ \TT{September} \\
    $|$ & \TT{oct} $|$ \TT{Oct} $|$ \TT{October} \\
    $|$ & \TT{nov} $|$ \TT{Nov} $|$ \TT{November} \\
    $|$ & \TT{dec} $|$ \TT{Dec} $|$ \TT{December} \\
    \end{tabular}
\\[1ex]
\emkey{year-name} ::=  {\em year} $|$ {\em short-year-name}
\\[1ex]
\emkey{short-year-name} ::=  \TT{'} {\em digit}\PLUS{}
\\[1ex]
\emkey{weekday}
    \begin{tabular}[t]{rl}
    ::= & \TT{Mon} $|$ \TT{Monday} \\
    $|$ & \TT{Tue} $|$ \TT{Tues} $|$ \TT{Tuesday} \\
    $|$ & \TT{Wed} $|$ \TT{Wednesday} \\
    $|$ & \TT{Thu} $|$ \TT{Thur} $|$ \TT{Thursday} \\
    $|$ & \TT{Fri} $|$ \TT{Friday} \\
    $|$ & \TT{Sat} $|$ \TT{Satday} \\
    $|$ & \TT{Sun} $|$ \TT{Sunday} \\
    \end{tabular}
\\[1ex]
\emkey{era} ::=  \TT{AD} $|$ \TT{BC} $|$ \TT{ADG} $|$ \TT{ADJ}
                         $|$ \TT{BCG} $|$ \TT{BCJ}
\end{indpar}

{\em Weekdays} are superfluous; if they are input and are wrong,
a warning message is issued.

The default {\em era} is \TT{AD}.
A `\TT{G}' at the end of an {\em era} indicates the date is in the
Gregorian Calendar, and a `\TT{J}' indicates the date is in the Julian
Calendar.  If neither is given, the date is Gregorian if it is on
or after 15 October 1582, and Julian otherwise.  Years always begin
at the midnight just before January 1.
There is no year \TT{0}; \TT{1AD} is immediately preceeded
by \TT{1BC}.

A date consisting of just a {\em year-name} refers to January 1 of that
year; e.g., \TT{'05} and \TT{01/01/2005} are the same date.
A date consisting of just a {\em month-name} and a {\em year-name}
refers to the first day of the month; e.g., \TT{May '05} and
\TT{05/01/2005} are the same date.

If no {\em era} is given and the {\em year} is \TT{999} or less,
the {\em year} is taken to denote the year nearest the current
year which ends in the same digits as given in {\em year}.
Thus in 2014 \TT{97} denotes 1997 and \TT{114} denotes 2114.

A warning message is issued if {\em month} is out of the range
\TT{1..12}, but the date is still computed letting \TT{0} denote
December of the previous year, \TT{13} denote January of the
next year, etc.  A warning message is issued if {\em day} is
\TT{0} or too large for the given month and year, but again
the date is still computed with \TT{0} denoting the last day of
the previous month, etc.

\subsection{Times}
\label{TIMES}

A \key{time} is a {\em numeric} containing digits, possibly a decimal
point, and one or two colons, optionally followed by a meridiem indication
and/or a time zone, and optionally followed by or surrounded by a date.

\begin{indpar}
\emkey{time} \begin{tabular}[t]{rl}
    ::= & {\em time-interval} \\
    $|$ & {\em time-of-day} {\em date}\QMARK{} \\
    $|$ & {\em weekday}\QMARK{} {\em month-name} {\em day}
          {\em time-of-day} {\em year-name} {\em era}\QMARK{} \\
    $|$ & {\em weekday}\QMARK{} {\em day} {\em month-name}
          {\em time-of-day} {\em year-name} {\em era}\QMARK{} \\
    \end{tabular}
\\[1ex]
\emkey{time-of-day}
    ::= {\em time-numeric} {\em meridiem}\QMARK{} {\em time-zone}\QMARK{}
\\[1ex]
\emkey{time-numeric} :::= {\em hour} \TT{:} {\em minute}
                          \{ \TT{:} {\em seconds} \}\QMARK{}
\\[1ex]
\emkey{hour} :::= {\em digit}\QMARK{} {\em digit}
\\[1ex]
\emkey{minute} :::= {\em digit} {\em digit}
\\[1ex]
\emkey{seconds} :::=
	{\em digit} {\em digit} {\em fractional-part}\QMARK{}
\\[1ex]
\emkey{meridiem} ::= \TT{am} $|$ \TT{AM} $|$ \TT{pm} $|$ \TT{PM}
                 $|$ \TT{noon} $|$ \TT{midnight}
\\[1ex]
\emkey{time-zone}
    \begin{tabular}[t]{rl}
    :::= & \TT{GMT} $|$ \TT{UTC} $|$
           \TT{UTC} {\em sign} {\em digit}\QMARK{} {\em digit}
	   \{ \TT{:} {\em digit} {\em digit} \}\QMARK{} \\
    $|$ & \TT{WET} $|$ \TT{CET} $|$ \TT{EET} \\
    $|$ & \TT{WAT} $|$ \TT{BT} $|$ \TT{CCT} \\
    $|$ & \TT{IDLE} $|$ \TT{IDLW} \\
    $|$ & \TT{JST} $|$ \TT{JDT} \\
    $|$ & \TT{GST} $|$ \TT{GDT} \\
    $|$ & \TT{NZST} $|$ \TT{NZDT} \\
    $|$ & \TT{AT} \\
    $|$ & \TT{AST} $|$ \TT{ADT} \\
    $|$ & \TT{EST} $|$ \TT{EDT} \\
    $|$ & \TT{CST} $|$ \TT{CDT} \\
    $|$ & \TT{MST} $|$ \TT{MDT} \\
    $|$ & \TT{PST} $|$ \TT{PDT} \\
    $|$ & \TT{YST} $|$ \TT{YDT} \\
    $|$ & \TT{AHST} $|$ \TT{AHDT} \\
    $|$ & \TT{HST} $|$ \TT{HDT} \\
    $|$ & \TT{CAT} \\
    $|$ & \TT{NT} \\
    \end{tabular}
\end{indpar}

A {\em time-numeric} represents the number
$60*(60*hour+minute)+seconds$.  A {\em minutes} or
{\em seconds} value equal or greater than $60$ causes a warning
message to be issued.

A {\em meridiem} limits the {\em time-numeric}
to be equal to or greater than \TT{0:00} and strictly less than
\TT{13:00}; else a warning message is issued.  A \TT{noon}
or \TT{midnight} {\em meridiem} limits the {\em time-numeric}
to be equal to \TT{12:00}; else a warning message is issued.
The absence of a {\em meridiem} limits the {\em time-numeric}
to be equal to or less than {\TT 24:00}.

If \TT{am} or \TT{AM} is given, $12$ hours is subtracted from
{\em time-numeric} values equal to or greater than \TT{12:00}.
If \TT{pm} or \TT{PM} is given, $12$ hours is added to
{\em time-numeric} values that are strictly less than \TT{12:00}.
The time \TT{12:00 midnight} is interpreted as \TT{24:00}.

A {\em time-zone} such as \TT{UTC-05:00} refers to Greenwich Mean Time
(\TT{UTC}, Temps Universel Coordonn\'e in French)
minus 5 hours (\TT{-05:00}) and is the same as
Eastern Standard Time, or \TT{EST}.   When localities that use \TT{EST}
go in Daylight Savings Time, they convert to Eastern Daylight Time, or
\TT{EDT}, which is that same as \TT{UTC-04:00}.

As another example, \TT{NZST}, New Zealand Standard Time, is the same
as \TT{UTC+12:00}.

If a {\em time-zone} is given, the difference between the {\em time-zone}
time and GMT is subtracted from the {\em time-numeric}.
Thus for \TT{UTC-5:00} 5 hours is added to the {\em time-numeric},
and for \TT{UTC+12:00} 12 hours is subtracted from the {\em time-numeric}.
It is possible to get negative numbers, which indicate a time in the previous
GMT day.

\subsection{Concatenated Quoted Strings}
\label{CONCATENATED-QUOTED-STRINGS}

A \key{concatenated quoted string} is a seqence of {\em quoted-strings}
separated by \TT{\#} marks that denotes a single symbol
made by concatenating the separate dequoted {\em quoted-string}
symbols and quoting the result.

\begin{indpar}
\emkey{concatenated-quoted-string} ::=
    {\em quoted-string} \{ \TT{\#} {\em quoted-string} \}\STAR{}
\end{indpar}

\subsection{Radix Numbers}
\label{RADIX-NUMBERS}

\section{Low Level Data}

A low level \key{datum} in RECKON is either an atom, an object, or an arrow.

Expressions, blocks, and descriptions are higher level data layered
on top of these low level data.  An expression is either an atom or
a particular kind of object.  A block is a particular kind of object,
and a description is a particular kind of block.

An \key{atom} is a symbol or a number.

An object is just a place in memory, and is like a dot on a blank page.
It can be the source or target of arrows, and it is different from
every other object and from every atom.  But it is nothing more.

However, as a place in memory, an object has a identifier.  Objects are assigned
\skey{raw object identifier}s
of the form `\ttmkey{@}{in raw object identifier}$N$' where $N$
is a natural number (non-negative integer).
Raw object identifiers of this form are assigned only to objects
that must be named in an output stream (e.g., printed output).
The first object named in an output stream is assigned the identifier
\TT{@1}, the second object named in the output stream is assigned
the identifier \TT{@2},
and so forth.  The same object may be assigned different identifiers
in different output streams.%
\footnote{A possible implementation is to give objects that
have been assigned identifiers
in an output stream a hidden system defined output
stream specific attribute (\pagref{ATTRIBUTE})
equal to the object's identifier integer.  Another implementation uses a
hash table per stream.}

There are two kinds of arrows: single and double.

A \key{single arrow} is an arrow from an object to either another object
or to an atom.  The arrow has a \key{label}, which is a sequence of zero or
more atoms.

A \key{double arrow} is a double headed arrow between two objects.
It has a separate label for each direction, with each label being a
sequence of zero or more atoms.  A double arrow is equivalent to a
\underline{related pair}
of single arrows going in opposite directions between the same two objects.
The difference between a double arrow and a pair of single arrows is that
it is possible to delete only one direction of a pair of single arrows, but 
when deleting a double arrow, both directions are deleted.

An \key{arrow label} is a sequence of zero or more atoms.
Two arrows leaving the same object may have the same label.  Thus
an object and an arrow label together name
a set of arrows sourced at the object.

\ikey{Arrow flags}{arrow flag} may be attached to arrow labels.
More precisely, a set of arrow flags is defined for each object
and each arrow label, and these flags apply to all arrows sourced at the
object that have the given label.
The standard flags are the \key{dot flag} (\ttmkey{.}{dot flag}),
and the \key{maybe flag} (\ttmkey{?}{maybe flag}).
Arrows with a dot flagged label are not to be output when their source
is output.
Targets of arrows with a maybe flagged label may be garbage collected
(made to disappear automatically, see \secref{GARBAGE-COLLECTION})
if they cannot be reached except by traversing arrows whose labels
have maybe flags.

We will give examples in the next section along with a basic way of
representing sets of objects in text.  In the rest of this document
arrows are called \skey{attribute}s,\label{ATTRIBUTE} arrow labels are called
\skey{attribute label}s, arrow flags are called \skey{attribute flag}s,
and arrow targets are called \skey{attribute value}s.
Also `\ikey{attribute L of object O}{attribute!of an object}\,'
denotes the set of all values (arrow targets) of attributes
of object O (arrows sourced at O) which have the attribute label
(arrow label) L.

A double arrow is called a \key{double attribute}.  When viewed from
an object at one end of the double arrow, the double arrow is an
attribute of that object, the label of the arrow directed away from that object
is the \mkey{attribute label}{of double attribute} of the double attribute,
and the label of the arrow directed toward the object is the
\mkey{reverse attribute label}{of double attribute} of the double attribute.


\subsection{Raw Object Representations}
\label{RAW-OBJECT-REPRESENTATIONS}

A set of objects can be written to a text file or read from a text file.
When this is done, a textual representation of the object set is used
in the file.  The simplest representation of an object
is the \key{raw object representation}, which we now describe.

A raw object representation is a special case of an {\em object-representation}.
This special case makes minimal use of the parser and is used when
data is written to a file without any attempt to format the data.

The syntax of an {\em object-representation} is:

\begin{indpar}[0.5em]
\begin{tabular}{l}
\emkey{object-representation}
\\\hspace*{0.5in}
	\begin{tabular}[t]{rl}
        ::= \TT{<*>} & {\em object-identifier}
	               {\em object-assignment-operator}
		       {\em object-list}\QMARK{} \\
	             & {\em attribute-representation-subparagraph}\QMARK{} \\
        \end{tabular}
\end{tabular}

\begin{tabular}{l}
\emkey{object-identifier} ::=
	\ttmkey{@}{in {\em object-identifier}}
	{\em natural-number-name} \\
\end{tabular}

\begin{tabular}{l}
\emkey{natural-number-name} ::= {\em atom-name}\pagnote{ATOM-NAME}
    representing a single non-negative integer atom
\end{tabular}

\begin{tabular}{l}
\emkey{object-assignment-operator} ::= ~~~
	\ttmkey{=}{object assignment operator} $|$
	\ttmkey{=>}{object assignment operator} $|$
	\ttmkey{=>{}>}{object assignment operator}
\end{tabular}

\begin{tabular}{l}
\emkey{object-list}
    \begin{tabular}[t]{rl}
    ::= & {\em object-element}\STAR{} \\
    $|$ & {\em bracketed-list} (not used in raw representation)
    \end{tabular}
\end{tabular}

\begin{tabular}{l}
\emkey{object-element}
    ::= {\em object-identifier} $|$ {\em atom-name}
\end{tabular}

\begin{tabular}{l}
\emlkey{attribute-representation}{-subparagraph}
    ::= \TT{\{:} {\em attribute-representation}\STAR{} \TT{:\}}
\end{tabular}

\begin{tabular}{l}
\emkey{attribute-representation}\label{ATTRIBUTE-REPRESENTATION}
    \begin{tabular}[t]{rl}
    ::= & {\em single-attribute-representation} \\
    $|$ & {\em double-attribute-representation} \\
    \end{tabular}
\end{tabular}

\begin{tabular}{l}
\emlkey{single-attribute-}{representation}%
\label{SINGLE-ATTRIBUTE-REPRESENTATION}
::=
\\\hspace*{0.5in}
	\TT{<*>}
	{\em single-attribute-label} {\em attribute-label-flags}\QMARK{}
	\begin{tabular}[t]{@{}l@{}}
	{\em attribute-assignment-operator} \\
	{\em single-attribute-value}
	\end{tabular}
\end{tabular}

\begin{tabular}{l}
\emkey{single-attribute-label}\label{SINGLE-ATTRIBUTE-LABEL}
    ::= {\em name}\pagnote{NAME}
\end{tabular}

\begin{tabular}{l}
\emkey{attribute-label-flags} ::=
    \TT{[} {\em flag-lexeme}\STAR{} \TT{]}
\end{tabular}%
\index{flags!attribute label}%
\index{attribute label!flags}

\begin{tabular}{l}
\emkey{flag-lexeme}
    ::= {\em word} $|$ {\em mark} $|$ {\em quoted-string}
\end{tabular}

\begin{tabular}{l}
\emkey{attribute-assignment-operator}
    \begin{tabular}[t]{rll}
    ::= & \TT{=} \\
    $|$ & \TT{=>}    & (not used in raw representation) \\
    $|$ & \TT{=>{}>} & (not used in raw representation) \\
    \end{tabular}
\end{tabular}

\begin{tabular}{l}
\emkey{single-attribute-value}\label{SINGLE-ATTRIBUTE-VALUE}
    \begin{tabular}[t]{rl}
    ::= & {\em object-element} \\
    $|$ & {\em bracketed-list} (not used in raw representation)
    \end{tabular}
\end{tabular}

\begin{tabular}{l}
\emlkey{double-attribute}{-representation}%
\label{DOUBLE-ATTRIBUTE-REPRESENTATION}
    ::=
\\\hspace*{0.5in}
	\TT{<*>} {\em double-attribute-label}
	         {\em attribute-label-flags}\QMARK{}
\\\hspace*{1.0in}
	\begin{tabular}[t]{@{}l@{}}
	\TT{=} {\em double-attribute-value} \\
	\TT{=} {\em reverse-attribute-label}
	       {\em attribute-label-flags}\QMARK{}
	\end{tabular}
\end{tabular}

\begin{tabular}{l}
\emkey{double-attribute-label} ::= {\em name}\pagnote{NAME}
\end{tabular}

\begin{tabular}{l}
\emkey{double-attribute-value} ::= {\em object-identifier}
\end{tabular}

\begin{tabular}{l}
\emkey{reverse-attribute-label} ::= {\em name}
\end{tabular}

\end{indpar}

Raw object representations do not make any use of some of the syntax
elements mentioned above; specifically, {\em bracketed-lists} are
not used (as {\em object-lists} or {\em single-attribute-values}),
and \TT{=>} and \TT{=>{}>} are not used as {\em attribute-assignment-operators}.

{\em Object-representations} are lines beginning with \TT{@}.
For example,

\begin{indpar}\begin{verbatim}
@1 =:
    type = woman
    name = Jill
    husband = @2 = wife
@2 =:
    type = man
    name = Jack
\end{verbatim}\end{indpar}

These are {\em object-representations} of an object pair that can
be represented pictorially as:

\begin{center}
\begin{picture}(3.0,1.5)
\put(0,0){\framebox(3.0,1.5){}}
\put(0.3,1.00){\makebox(0.8,0.3){\tt @1}}
\put(0.7,1.15){\oval(0.8,0.3)}
\put(0.5,1.00){\vector(0,-1){0.5}}
\put(0.45,0.75){\makebox(0,0)[r]{\tt type}}
\put(0.5,0.4){\makebox(0,0){\tt woman}}
\put(0.9,1.00){\vector(0,-1){0.7}}
\put(0.95,0.55){\makebox(0,0)[l]{\tt name}}
\put(0.9,0.2){\makebox(0,0){\tt Jill}}
\put(1.9,1.00){\makebox(0.8,0.3){\tt @2}}
\put(2.3,1.15){\oval(0.8,0.3)}
\put(2.1,1.00){\vector(0,-1){0.5}}
\put(2.05,0.75){\makebox(0,0)[r]{\tt type}}
\put(2.1,0.4){\makebox(0,0){\tt man}}
\put(2.5,1.00){\vector(0,-1){0.7}}
\put(2.55,0.55){\makebox(0,0)[l]{\tt name}}
\put(2.5,0.2){\makebox(0,0){\tt Jack}}
\put(1.1,1.17){\vector(1,0){0.8}}
\put(1.9,1.13){\vector(-1,0){0.8}}
\put(1.5,1.15){\oval(0.07,0.12)}
\put(1.5,1.30){\makebox(0,0){\tt husband}}
\put(1.5,1.00){\makebox(0,0){\tt wife}}
\end{picture}
\end{center}

There are two single attributes of object \TT{@1} (arrows sourced
at \TT{@1}),
one attribute labeled \TT{type} whose value (target) is the atom \TT{woman},
and one attribute labeled \TT{name} whose value is the atom \TT{Jill}.
There are two similar single attributes from object \TT{@2}.
There is a double attribute (double arrow)
between the two objects which has the
label \TT{husband} when going from \TT{@1} to \TT{@2}
and the label \TT{wife} when going in the reverse direction.

It is possible to place \skey{attribute flag}s on attribute labels
by putting flag characters in {\em flag-lexemes} inside
\TT{[ ]} brackets after a label.
It may be necessary to use a
{\em quoted-string} {\em flag-lexeme} in order to include
separator characters or digits as flag characters.
The following is the same as the above example except that flags
have been added to some of the attributes:

\begin{center}
\begin{tabular}[b]{@{}l@{}}
\verb/@1 =:/\\
\verb|    type = woman|\\
\verb|    name[-] = Jill|\\
\verb|    husband[*] = @2 wife[*]|\\
\verb/@2 =:/\\
\verb|    type = man|\\
\verb|    name[+] = Jack|\\
\end{tabular}
~~~~~~~~~
\begin{picture}(3.2,1.5)
\put(0,0){\framebox(3.2,1.5){}}
\put(0.3,1.00){\makebox(0.8,0.3){\tt @1}}
\put(0.7,1.15){\oval(0.8,0.3)}
\put(0.5,1.00){\vector(0,-1){0.5}}
\put(0.45,0.75){\makebox(0,0)[r]{\tt type}}
\put(0.5,0.4){\makebox(0,0){\tt woman}}
\put(0.9,1.00){\vector(0,-1){0.7}}
\put(0.95,0.55){\makebox(0,0)[l]{{\tt name}$^{\mbox{\tt -}}$}}
\put(0.9,0.2){\makebox(0,0){\tt Jill}}
\put(1.9,1.00){\makebox(0.8,0.3){\tt @2}}
\put(2.3,1.15){\oval(0.8,0.3)}
\put(2.1,1.00){\vector(0,-1){0.5}}
\put(2.05,0.75){\makebox(0,0)[r]{\tt type}}
\put(2.1,0.4){\makebox(0,0){\tt man}}
\put(2.5,1.00){\vector(0,-1){0.7}}
\put(2.55,0.55){\makebox(0,0)[l]{{\tt name}$^{\mbox{\tt +}}$}}
\put(2.5,0.2){\makebox(0,0){\tt Jack}}
\put(1.1,1.17){\vector(1,0){0.8}}
\put(1.9,1.13){\vector(-1,0){0.8}}
\put(1.5,1.15){\oval(0.07,0.12)}
\put(1.5,1.30){\makebox(0,0){{\tt husband}$^{\mbox{\tt *}}$}}
\put(1.5,1.00){\makebox(0,0){{\tt wife}$^{\mbox{\tt *}}$}}
\end{picture}
\end{center}

In the picture the attribute flags have been added as superscripts on the
attribute labels, and in the text the flags have been added
inside \TT{[ ]} brackets that follow attribute labels.

Several attributes of the same object (arrows sourced at the object)
may have the same attribute
label.  An example of this, in which object \TT{@1} has two
attributes labeled \TT{child}, is:

\begin{center}
\begin{tabular}{l@{\hspace*{0.5in}}l}
\begin{tabular}{@{}l@{}}
\\[-20ex]
\verb/@1 =:/\\
\verb|    child = @2 = parent|\\
\verb|    child = @3 = parent|\\
\end{tabular}
&
\begin{picture}(3.1,1.5)
\put(0,0){\framebox(3.1,1.5){}}
\put(0.3,1.00){\makebox(2.4,0.3){\tt @1}}
\put(1.5,1.15){\oval(2.4,0.3)}
\put(0.65,1.00){\vector(0,-1){0.6}}
\put(0.60,0.80){\makebox(0,0)[r]{\tt child}}
\put(0.75,0.40){\vector(0,1){0.6}}
\put(0.80,0.55){\makebox(0,0)[l]{\tt parent}}
\put(2.25,1.00){\vector(0,-1){0.6}}
\put(2.20,0.80){\makebox(0,0)[r]{\tt child}}
\put(2.35,0.40){\vector(0,1){0.6}}
\put(2.40,0.55){\makebox(0,0)[l]{\tt parent}}
\put(0.3,0.10){\makebox(0.8,0.3){\tt @2}}
\put(0.7,0.25){\oval(0.8,0.3)}
\put(1.9,0.10){\makebox(0.8,0.3){\tt @3}}
\put(2.3,0.25){\oval(0.8,0.3)}
\end{picture}
\end{tabular}
\end{center}

We say that the value of the \TT{child} attribute of \TT{@1} is
the set to two elements, \TT{@2} and \TT{@3}.

The differences between \TT{=}, \TT{=>}, and \TT{=>{}>} in a
{\em object-representation} relate
to what is done when an object or attribute label previously exists.

\ttmkey{=}{in {\em object-representation}}
indicates that the object being represented should not previously
exist, or if it does exist, must not have been defined by any previous
{\em object-representation} (it may have been defined as the value of an
attribute).  Second, any attribute label represented in the
{\em object-representation}, if it previously exists because it was part of a
{\em double-attribute-representation}, must be represented with exactly
the same flags as it already has.

At the other extreme,
\ttmkey{=>{}>}{in {\em object-representation}}
adds to existing objects.
The object being represented can previously exist.  Any attribute
representation in the {\em object-representation} creates a new attribute value
to be added to the set of values of the given attribute label (which
is created if it did not previously exist).
Any flags on an attribute label are added to the flags of the label if
that label already exists.

\ttmkey{=>}{in {\em object-representation}}
is like \TT{=>{}>}
except that the {\em object-representation} cannot
add new values to previously existing attributes of the object being
represented.
More precisely, the {\em attribute-label} of any
{\em attribute-representation}
in the {\em object-representation} must not have previously (before the
{\em object-representa\-tion} is read)
been an {\em attribute-label} of the represented object.
Thus \TT{=>} is used to introduce new attributes to an existing object.

However, if \TT{=>} is used to add a double attribute to
object $O1$ whose value is object $O2$, then while
the {\em double-attribute-label}
of the added attribute must \underline{not} have previously existed for $O1$,
the {\em reverse-attribute-label} \underline{may} have previously existed
for $O2$.

Double attributes must have only one representation.  If they
are given two representations, one for each end of the attribute
(double headed arrow),
\underline{two} identical double attributes (two double headed arrows with the
same end points and labels) will be created.
Usually one end of a double attribute is
thought of as the primary end, and its object representation is used to
include the sole representation of the double attribute.

The {\em object-identifier} \ttkey{@0} is special; it always names
a particular object, the \ttnbdkey{GLOBAL} object,
whose attributes are called \skey{global variables}.  One of the global
variables is named \TT{.GLOBAL} and has as its value the \TT{.GLOBAL}
object itself, a situation which can be achieved by the
{\em object-representation}:

\begin{indpar}\begin{verbatim}
@0=>:
    .GLOBAL = @0
\end{verbatim}\end{indpar}

Labels beginning with `\ttkey{.}' are reserved for use by
the RECKON system, and should not be defined by RECKON users.  \TT{.GLOBAL}
is an example of such a label.

The RECKON parser (\secref{PARSING}) parses {\em object-representations}.
However, within {\em object-representa\-tions} (lines beginning with \TT{@})
the parser does not recognize operators or compound names
outside bracketed lists, and as
raw representations have no bracketed lists, the parser does not recognize
operators or compound names in raw {\em object-representations}.%
\label{RAW-PARSING}
The parser does, however,
recognize and process {\em atom-names}.
In doing this for an {\em object-list}, the lexemes in the list are scanned
left to right and the longest sequence of lexemes that comprises an
{\em atom-name} or {\em object-identifier}
is accepted as the representative of an atom or object identifier at
each stage of the scan.
Thus the {\em object-list}
\begin{center}
\tt 5 e + 2 e 3 4 "e" 3 @ 7 e 5
\end{center}
translates as (see \secref{SCIENTIFIC-NUMBER-RECOGNITION}):
\begin{center}
\tt
\begin{tabular}{r@{~~$\Longrightarrow$~~}rl}
5 e + 2 & \rm number & 500 \\
e	& \rm symbol & e \\
3	& \rm number & 3 \\
4	& \rm number & 4 \\
"e"	& \rm symbol & e \\
3	& \rm number & 3 \\
@ 7	& \rm object identifier & @ 7 \\
e	& \rm symbol & e \\
5	& \rm number & 5 \\
\end{tabular}
\end{center}

the {\em object-list}

\begin{center}
"5" 5 "6" \# "7" \# "8" "\#" "9"
\end{center}
translates as (see \secref{RADIX-NUMBER-RECOGNITION}):
\begin{center}
\tt
\begin{tabular}{r@{~~$\Longrightarrow$~~}rl}

"5"			& \rm symbol & 5 \\
5			& \rm number & 5 \\
"6" \# "7" \# "8"	& \rm symbol & 678 \\
"\#"			& \rm symbol & \# \\
"9"			& \rm symbol & 9 \\
\end{tabular}
\end{center}

and the {\em object-list}

\begin{center}
b \# "1010" b \# "10" \# "1" e 1 b "\#" "1010"
\end{center}
translates as (see \secref{CONCATENATED-QUOTED-STRINGS}):
\begin{center}
\tt
\begin{tabular}{r@{~~$\Longrightarrow$~~}rll}
b \# "1010"		& \rm number & 10 \\
b \# "10" \# "1" e 1	& \rm number & 10
			& \rm (same as {\tt b \# "101" e 1}) \\
b			& \rm symbol & b \\		
"\#"			& \rm symbol & \# \\		
"1010"			& \rm symbol & 1010 \\		
\end{tabular}
\end{center}


\subsection{Lists}

Objects are implemented so that attributes whose labels are small
strictly positive integers can be accessed with more efficiency
than other attributes.  If an object has attributes with consecutive
labels from \TT{1} to $N$, with no gaps,
then these values are said to form a \key{list} that is represented
by the object.  An example is

\begin{indpar}\begin{verbatim}
@93 =:
    1 = this
    2 = is
    3 = a
    4 = sentence
    .type = s
    .initiator = "`"
    .terminator = "'"
    capitalize = true
    end mark = "."
\end{verbatim}\end{indpar}

which represents the list
\begin{indpar}
\verb|this is a sentence|
\end{indpar}

but also has some additional attributes, labeled \TT{.type},
\TT{.initiator}, \TT{.terminator}
\TT{capitalize}, and \TT{end mark}.
An alternative raw {\em object-representation}
to the one just given is:

\begin{indpar}\begin{verbatim}
@93 = this is a sentence:
    .type = s
    .initiator = "`"
    .terminator = "'"
    capitalize = true
    end mark = "."
\end{verbatim}\end{indpar}

The {\em atom-names} and {\em object-identifiers} in an {\em object-list}
within an {\em object-representation} name atoms or object identifiers that
are assigned as values of the attributes labeled \TT{1}, \TT{2},
\TT{3}, \ldots.  Additional attribute values can be given by
following the {\em object-list} by a line ending `\TT{:}' that begins an
{\em attribute-representation-subparagraph}, which in this case
gives values to the \TT{.type}, \TT{.initiator}, \TT{.terminator},
\TT{capitalize}, and \TT{end mark} attributes.

\subsection{Cooked Representations}

If an {\em object-representation} contains a bracketed list, operators
are recognized by the parser within this list, and the representaton
is said to be `\key{cooked}' instead of raw.  Also if
the \TT{=>} and \TT{=>{}>} {\em data-assignment-operators}
are used in place of the \TT{=} within any {\em attribute-representation}
in the {\em object-representation}, that representation is
said to be `cooked'.

The syntax of {\em object-representations} is augmented by adding
the following definition of {\em bracketed-list}:

\begin{indpar}[0.5in]

\begin{tabular}{l}
\emkey{bracketed-list}\label{BRACKETED-LIST}
    \begin{tabular}[t]{rl}
    ::= & \TT{(} {\em prefix-0-list} \TT{)} \\
    $|$ & \TT{[} {\em prefix-0-list} \TT{]} \\
    $|$ & \TT{`} {\em prefix-0-list} \TT{'} \\
    $|$ & \TT{\{} {\em m-type} {\em prefix-0-list} {\em m-type} \TT{\}} \\
    $|$ & \TT{\{|} {\em prefix-0-list} \TT{|\}} \\
    $|$ & \TT{\{<} {\em prefix-0-list} \TT{>\}} \\
    $|$ & \TT{\{(} {\em prefix-0-list} \TT{)\}} \\
    $|$ & \TT{\{[} {\em prefix-0-list} \TT{]\}} \\
    $|$ & \TT{\{`} {\em prefix-0-list} \TT{'\}} \\
    $|$ & \TT{\{\{} {\em prefix-0-list} \TT{\}\}} \\
    $|$ & \TT{\{} {\em w-type} {\em attributes}\QMARK{}
          \TT{|} {\em prefix-0-list}
          \TT{|\}} \\
    $|$ & \TT{\{|} {\em prefix-0-list}
          \TT{|} {\em w-type} {\em attributes}\QMARK{} \TT{\}} \\
    $|$ & \TT{\{} {\em w-type} {\em attributes}\QMARK{}
          \TT{| } {\em prefix-0-list}
          \TT{|} {\em w-type} {\em attributes}\QMARK{} \TT{\}} \\
    \end{tabular}
\end{tabular}

\begin{tabular}{l}
\emkey{m-type} ::= {\em mark} other than \TT{<} or \TT{>}
\end{tabular}

\begin{tabular}{l}
\emkey{w-type} ::= {\em name}\pagnote{NAME}
\end{tabular}

\begin{tabular}{l}
\emkey{type} ::= {\em m-type} $|$ {\em w-type}
\end{tabular}

\begin{tabular}{l}
\emkey{list-opening}
    \begin{tabular}[t]{rl}
    ::= & \TT{(} $|$ \TT{[} $|$ \TT{`} $|$ \TT{\{|} $|$
          \TT{\{<} $|$ \TT{\{(} $|$ \TT{\{[} $|$ \TT{\{`} $|$ \TT{\{\{} \\
    $|$ & \TT{\{} {\em m-type} \\
    $|$ & \TT{\{} {\em w-type} {\em attributes}\QMARK{} \TT{|} \\
    \end{tabular}
\end{tabular}

\begin{tabular}{l}
\emkey{list-closing}
    \begin{tabular}[t]{rl}
    ::= & \TT{)} $|$ \TT{]} $|$ \TT{'} $|$ \TT{|\}} $|$
          \TT{>\}} $|$ \TT{)\}} $|$ \TT{]\}} $|$ \TT{'\}} $|$ \TT{\}\}} \\
    $|$ & {\em m-type} \TT{\}} \\
    $|$ & \TT{|} {\em w-type} {\em attributes}\QMARK{} \TT{\}} \\
    \end{tabular}
\end{tabular}

\begin{tabular}{l}
\emkey{prefix-n-list}
    ::= \{ {\em prefix-n} {\em prefix-n+1-list} \}\STAR{}
    $|$ {\em list-element}\STAR{} \\
\end{tabular}

\begin{tabular}{l}
\emkey{prefix-n} ::= {\em prefix} \\
\end{tabular}

\begin{tabular}{l}
\emkey{prefix}\label{PREFIX}
    ::= \TT{\{} {\em m-type} \TT{\}}
    $|$ \TT{\{} {\em w-type} {\em attributes}\QMARK{} \TT{\}}
\\[1ex]
\end{tabular}

\begin{center}
All {\em prefix-n}'s in a {\em prefix-n-list} have the same type.
\end{center}

\begin{tabular}{l}
\emkey{list-element} ::= {\em single-attribute-value}%
                         \pagnote{SINGLE-ATTRIBUTE-VALUE}
\end{tabular}

\begin{tabular}{l}
\emkey{attributes}
    \begin{tabular}[t]{rl}
    ::= & \TT{:} {\em attribute} \{ \TT{,} {\em attribute} \}\STAR{} \\
    $|$ & \TT{\{:} \{ \TT{<*>} {\em attribute} \}\STAR{} \TT{:\}} \\
    \end{tabular}
\end{tabular}

\begin{tabular}{l}
\emkey{attribute}
    \begin{tabular}[t]{rl}
    ::= & {\em raw-attribute-representation} \\
    $|$ & {\em single-attribute-label}\pagnote{SINGLE-ATTRIBUTE-LABEL} \\
    $|$ & \TT{no} {\em single-attribute-label} \\
    \end{tabular}
\end{tabular}

\begin{tabular}{l}
\emkey{raw-attribute-representation} \\
\hspace*{0.3in}
    \begin{tabular}[t]{rl}
    ::= & {\em single-attribute-representation}%
          \pagnote{SINGLE-ATTRIBUTE-REPRESENTATION}
	  with \TT{=} {\em attribute-assignment-operator} \\
    $|$ & {\em double-attribute-representation}%
          \pagnote{DOUBLE-ATTRIBUTE-REPRESENTATION}
    \end{tabular}
\end{tabular}

\end{indpar}

{\em Prefixes}, {\em types}, and {\em attributes} are explained
below.  First we give some examples involving just parsed untyped
{\em bracketed-lists} without {\em attributes}.  In some of these
the fact is used that
`\TT{\{!~!\}}' brackets translate to a list of \TT{.type} \TT{"!"}.

In the cooked {\em object-representation}
the list of {\em atom-values} can be followed by a single
{\em bracketed-list}.  A simple first example is:

As a first example,

\begin{indpar}\begin{verbatim}
@93 = `This is a sentence.'
\end{verbatim}\end{indpar}

which is the cooked representation of the object

\begin{center}
\begin{tabular}[b]{@{}l@{}}
\verb/@93 =:/\\
\verb|    1 = this|\\
\verb|    2 = is|\\
\verb|    3 = a|\\
\verb|    4 = sentence|\\
\verb|    .type = s|\\
\verb|    .initiator = "`"|\\
\verb|    .terminator = "'"|\\
\verb|    capitalize = true|\\
\verb|    end mark = "."|\\
\end{tabular}
~~~~~
\begin{picture}(5.6,2.0)
\put(0,0){\framebox(5.6,2.0){}}
\put(0.2,1.50){\makebox(4.8,0.3){\tt @93}}
\put(2.6,1.65){\oval(4.8,0.3)}
\put(0.60,1.50){\vector(0,-1){0.4}}
\put(0.55,1.35){\makebox(0,0)[r]{\tt 1}}
\put(0.60,1.00){\makebox(0,0)[c]{\tt this}}
\put(0.95,1.50){\vector(0,-1){0.4}}
\put(0.90,1.35){\makebox(0,0)[r]{\tt 2}}
\put(0.95,1.00){\makebox(0,0)[c]{\tt is}}
\put(1.20,1.50){\vector(0,-1){0.4}}
\put(1.15,1.35){\makebox(0,0)[r]{\tt 3}}
\put(1.20,1.00){\makebox(0,0)[c]{\tt a}}
\put(1.70,1.50){\vector(0,-1){0.4}}
\put(1.65,1.35){\makebox(0,0)[r]{\tt 4}}
\put(1.70,1.00){\makebox(0,0)[c]{\tt sentence}}
\put(2.30,1.50){\vector(0,-1){0.6}}
\put(2.25,1.35){\makebox(0,0)[r]{\tt .type}}
\put(2.30,0.80){\makebox(0,0)[c]{\tt s}}
\put(2.60,1.50){\vector(0,-1){1.2}}
\put(2.55,0.55){\makebox(0,0)[r]{\tt .initiator}}
\put(2.60,0.20){\makebox(0,0)[c]{\tt "`"}}
\put(3.00,1.50){\vector(0,-1){1.2}}
\put(3.05,0.55){\makebox(0,0)[l]{\tt .terminator}}
\put(3.00,0.20){\makebox(0,0)[c]{\tt "'"}}
\put(4.15,1.50){\vector(0,-1){0.4}}
\put(4.10,1.35){\makebox(0,0)[r]{\tt capitalize}}
\put(4.15,1.00){\makebox(0,0)[c]{\tt true}}
\put(4.60,1.50){\vector(0,-1){0.6}}
\put(4.65,1.35){\makebox(0,0)[l]{\tt end mark}}
\put(4.60,0.80){\makebox(0,0)[c]{\tt "."}}
\end{picture}
\end{center}


The second example contains simple code:

\begin{indpar}\begin{verbatim}
@45 = {! straight 3.2; left; straight (y + 9.4) !}
\end{verbatim}\end{indpar}

which is the cooked representation of the objects

\begin{center}
\begin{tabular}[b]{@{}l@{}}
\verb/@42 =:/\\
\verb|    1 = straight|\\
\verb|    2 = 3.2|\\
\verb/@43 =:/\\
\verb|    1 = "+"|\\
\verb|    2 = y|\\
\verb|    3 = 9.4|\\
\verb|    .initiator = "("|\\
\verb|    .terminator = ")"|\\
\verb/@44 =:/\\
\verb|    1 = straight|\\
\verb|    2 = @43|\\
\verb/@45 =:/\\
\verb|    1 = @42|\\
\verb|    2 = left|\\
\verb|    3 = @44|\\
\verb|    .type = "!"|\\
\verb|    .separator = ";"|\\
\end{tabular}
~~~~~
\begin{picture}(4.4,3.7)
\put(0,0){\framebox(4.4,3.7){}}
\put(1.5,0.0){
\put(0.0,0.90){\makebox(2.0,0.3){\tt @43}}
\put(1.0,1.05){\oval(2.0,0.3)}
\put(0.40,0.90){\vector(0,-1){0.4}}
\put(0.35,0.75){\makebox(0,0)[r]{\tt .initiator}}
\put(0.40,0.40){\makebox(0,0)[c]{\tt "("}}
\put(0.70,0.90){\vector(0,-1){0.6}}
\put(0.65,0.75){\makebox(0,0)[r]{\tt 1}}
\put(0.70,0.20){\makebox(0,0)[c]{\tt "+"}}
\put(1.00,0.90){\vector(0,-1){0.6}}
\put(0.95,0.75){\makebox(0,0)[r]{\tt 2}}
\put(1.00,0.20){\makebox(0,0)[c]{\tt y}}
\put(1.30,0.90){\vector(0,-1){0.6}}
\put(1.25,0.75){\makebox(0,0)[r]{\tt 3}}
\put(1.30,0.20){\makebox(0,0)[c]{\tt 9.4}}
\put(1.60,0.90){\vector(0,-1){0.4}}
\put(1.60,0.40){\makebox(0,0)[c]{\tt ")"}}
\put(1.65,0.75){\makebox(0,0)[l]{\tt .terminator}}
}
\put(0.7,1.3){
\put(0.0,0.50){\makebox(1.2,0.3){\tt @42}}
\put(0.60,0.65){\oval(1.2,0.3)}
\put(0.30,0.50){\vector(0,-1){0.3}}
\put(0.25,0.35){\makebox(0,0)[r]{\tt 1}}
\put(0.30,0.10){\makebox(0,0)[c]{\tt straight}}
\put(0.90,0.50){\vector(0,-1){0.3}}
\put(0.85,0.35){\makebox(0,0)[r]{\tt 2}}
\put(0.90,0.10){\makebox(0,0)[c]{\tt 3.2}}
}
\put(2.3,1.3){
\put(0.0,0.50){\makebox(1.2,0.3){\tt @44}}
\put(0.60,0.65){\oval(1.2,0.3)}
\put(0.30,0.50){\vector(0,-1){0.3}}
\put(0.25,0.35){\makebox(0,0)[r]{\tt 1}}
\put(0.30,0.10){\makebox(0,0)[c]{\tt straight}}
\put(0.90,0.50){\vector(0,-1){0.6}}
\put(0.85,0.35){\makebox(0,0)[r]{\tt 2}}
}
\put(0.3,2.7){
\put(0.0,0.50){\makebox(3.2,0.3){\tt @45}}
\put(1.60,0.65){\oval(3.2,0.3)}
\put(0.80,0.50){\vector(0,-1){0.3}}
\put(0.75,0.35){\makebox(0,0)[r]{\tt .type}}
\put(0.80,0.10){\makebox(0,0)[c]{\TT{"!"}}}
\put(1.30,0.50){\vector(0,-1){1.1}}
\put(1.25,0.35){\makebox(0,0)[r]{\tt 1}}
\put(1.70,0.50){\vector(0,-1){0.4}}
\put(1.65,0.30){\makebox(0,0)[r]{\tt 2}}
\put(1.70,0.00){\makebox(0,0)[c]{\tt left}}
\put(2.30,0.50){\vector(0,-1){1.1}}
\put(2.25,0.35){\makebox(0,0)[r]{\tt 3}}
\put(2.70,0.50){\vector(0,-1){0.8}}
\put(2.75,-0.15){\makebox(0,0)[l]{\tt .separator}}
\put(2.70,-0.40){\makebox(0,0)[c]{\tt ";"}}
}
\end{picture}
\end{center}

A third example uses multiple indented lines to represent code, so that

\begin{indpar}\begin{verbatim}
@138 = {! function (x,y):

            if (x > y):
                return y
            else:
                return x
       !}
\end{verbatim}\end{indpar}

is the cooked representation of the object in
Figures~\ref{EXAMPLE-CODE-OBJECT-REPRESENTATION-1}
and~\ref{EXAMPLE-CODE-OBJECT-REPRESENTATION-2}.
Note that here the \TT{:} indentation mark is used to introduce
subparagraphs within the code,
and not {\em attribute-representations}.


\begin{boxedfigure}
\small

\begin{center}
\begin{tabular}[t]{@{}l@{}}
\verb/@130 =:/\\
\verb|    1 = x|\\
\verb|    2 = y|\\
\verb|    .separator = ","|\\
\verb|    .initiator = "("|\\
\verb|    .terminator = ")"|\\
\verb/@131 =:/\\
\verb|    1 = ">"|\\
\verb|    2 = x|\\
\verb|    3 = y|\\
\verb|    .initiator = "("|\\
\verb|    .terminator = ")"|\\
\verb/@132 =:/\\
\verb|    1 = return|\\
\verb|    2 = y|\\
\verb|    .type = ":"|\\
\verb/@133 =:/\\
\verb|    1 = if|\\
\verb|    2 = @131|\\
\verb|    3 = @132|\\
\verb/@134 =:/\\
\verb|    1 = return|\\
\verb|    2 = x|\\
\verb|    .type = ":"|\\
\verb/@135 =:/\\
\verb|    1 = else|\\
\verb|    2 = @134|\\
\verb/@136 =:/\\
\verb|    1 = @133|\\
\verb|    2 = @135|\\
\verb|    .type = ":"|\\
\verb|    .separator = "<*>"|\\
\verb/@137 =:/\\
\verb|    1 = function|\\
\verb|    2 = @130|\\
\verb|    3 = @136|\\
\verb|    .type = "!"|\\
\end{tabular}
\end{center}
\vspace*{-3ex}
\caption{Example Code Object Representation I}
\label{EXAMPLE-CODE-OBJECT-REPRESENTATION-1}
\end{boxedfigure}

\begin{boxedfigure}

\begin{center}
\begin{picture}(4.0,5.5)
\put(0.6,0.0){
\put(0.0,0.50){\makebox(2.0,0.3){\tt @131}}
\put(1.0,0.65){\oval(2.0,0.3)}
\put(0.25,0.50){\vector(0,-1){0.25}}
\put(0.20,0.40){\makebox(0,0)[r]{\tt .initiator}}
\put(0.25,0.15){\makebox(0,0)[c]{\tt "("}}
\put(0.70,0.50){\vector(0,-1){0.25}}
\put(0.65,0.40){\makebox(0,0)[r]{\tt 1}}
\put(0.70,0.15){\makebox(0,0)[c]{\tt ">"}}
\put(1.00,0.50){\vector(0,-1){0.25}}
\put(0.95,0.40){\makebox(0,0)[r]{\tt 2}}
\put(1.00,0.15){\makebox(0,0)[c]{\tt x}}
\put(1.30,0.50){\vector(0,-1){0.25}}
\put(1.25,0.40){\makebox(0,0)[r]{\tt 3}}
\put(1.30,0.15){\makebox(0,0)[c]{\tt y}}
\put(1.75,0.50){\vector(0,-1){0.25}}
\put(1.80,0.40){\makebox(0,0)[l]{\tt .terminator}}
\put(1.75,0.15){\makebox(0,0)[c]{\tt ")"}}
}
\put(1.4,1.4){
\put(0.0,0.50){\makebox(1.3,0.3){\tt @132}}
\put(0.65,0.65){\oval(1.3,0.3)}
\put(0.20,0.50){\vector(0,-1){0.25}}
\put(0.15,0.40){\makebox(0,0)[r]{\tt .type}}
\put(0.20,0.15){\makebox(0,0)[c]{\tt ":"}}
\put(0.70,0.50){\vector(0,-1){0.25}}
\put(0.65,0.40){\makebox(0,0)[r]{\tt 1}}
\put(0.70,0.15){\makebox(0,0)[c]{\tt return}}
\put(1.15,0.50){\vector(0,-1){0.25}}
\put(1.10,0.40){\makebox(0,0)[r]{\tt 3}}
\put(1.15,0.15){\makebox(0,0)[c]{\tt y}}
}
\put(2.9,0.7){
\put(0.0,0.50){\makebox(1.3,0.3){\tt @134}}
\put(0.65,0.65){\oval(1.3,0.3)}
\put(0.20,0.50){\vector(0,-1){0.25}}
\put(0.15,0.40){\makebox(0,0)[r]{\tt .type}}
\put(0.20,0.15){\makebox(0,0)[c]{\tt ":"}}
\put(0.70,0.50){\vector(0,-1){0.25}}
\put(0.65,0.40){\makebox(0,0)[r]{\tt 1}}
\put(0.70,0.15){\makebox(0,0)[c]{\tt return}}
\put(1.15,0.50){\vector(0,-1){0.25}}
\put(1.10,0.40){\makebox(0,0)[r]{\tt 3}}
\put(1.15,0.15){\makebox(0,0)[c]{\tt x}}
}
\put(0.2,2.0){
\put(0.0,0.50){\makebox(1.2,0.3){\tt @133}}
\put(0.60,0.65){\oval(1.2,0.3)}
\put(0.30,0.50){\vector(0,-1){0.25}}
\put(0.25,0.40){\makebox(0,0)[r]{\tt 1}}
\put(0.30,0.15){\makebox(0,0)[c]{\tt if}}
\put(0.60,0.50){\line(0,-1){0.45}}
\put(0.50,0.05){\oval(0.2,0.2)[br]}
\put(0.50,-0.05){\line(-1,0){0.40}}
\put(0.10,-0.15){\oval(0.2,0.2)[tl]}
\put(0.00,-0.15){\line(0,-1){1.10}}
\put(0.10,-1.25){\oval(0.2,0.2)[bl]}
\put(0.10,-1.35){\vector(1,0){0.30}}
\put(0.55,0.40){\makebox(0,0)[r]{\tt 2}}
\put(0.90,0.50){\line(0,-1){0.35}}
\put(1.00,0.15){\oval(0.2,0.2)[bl]}
\put(1.00,0.05){\vector(1,0){0.2}}
\put(0.85,0.40){\makebox(0,0)[r]{\tt 3}}
}
\put(2.9,2.0){
\put(0.0,0.50){\makebox(0.8,0.3){\tt @135}}
\put(0.40,0.65){\oval(0.8,0.3)}
\put(0.20,0.50){\vector(0,-1){0.25}}
\put(0.15,0.40){\makebox(0,0)[r]{\tt 1}}
\put(0.20,0.15){\makebox(0,0)[c]{\tt else}}
\put(0.60,0.50){\vector(0,-1){1.0}}
\put(0.55,0.40){\makebox(0,0)[r]{\tt 2}}
}
\put(1.5,2.4){
\put(0.05,1.00){\makebox(1.8,0.3){\tt @136}}
\put(0.95,1.15){\oval(1.8,0.3)}
\put(0.40,1.00){\vector(0,-1){0.25}}
\put(0.35,0.90){\makebox(0,0)[r]{\tt .type}}
\put(0.40,0.65){\makebox(0,0)[c]{\tt ":"}}
\put(0.70,1.00){\line(0,-1){0.65}}
\put(0.60,0.35){\oval(0.2,0.2)[br]}
\put(0.60,0.25){\vector(-1,0){0.70}}
\put(0.65,0.90){\makebox(0,0)[r]{\tt 1}}
\put(1.10,1.00){\line(0,-1){0.65}}
\put(1.20,0.35){\oval(0.2,0.2)[bl]}
\put(1.20,0.25){\vector(1,0){0.20}}
\put(1.05,0.90){\makebox(0,0)[r]{\tt 2}}
\put(1.50,1.00){\vector(0,-1){0.25}}
\put(1.55,0.90){\makebox(0,0)[l]{\tt .separator}}
\put(1.50,0.65){\makebox(0,0)[c]{\tt "<*>"}}
}
\put(0.6,3.2){
\put(0.2,1.00){\makebox(1.3,0.3){\tt @130}}
\put(0.85,1.15){\oval(1.3,0.3)}
\put(0.40,1.00){\vector(0,-1){0.25}}
\put(0.35,0.90){\makebox(0,0)[r]{\tt .initiator}}
\put(0.40,0.65){\makebox(0,0)[c]{\tt "("}}
\put(0.70,1.00){\vector(0,-1){0.25}}
\put(0.65,0.90){\makebox(0,0)[r]{\tt 1}}
\put(0.70,0.65){\makebox(0,0)[c]{\tt x}}
\put(1.00,1.00){\vector(0,-1){0.25}}
\put(0.95,0.90){\makebox(0,0)[r]{\tt 2}}
\put(1.00,0.65){\makebox(0,0)[c]{\tt y}}
\put(1.30,1.00){\vector(0,-1){0.25}}
\put(1.35,0.90){\makebox(0,0)[l]{\tt .terminator}}
\put(1.30,0.65){\makebox(0,0)[c]{\tt ")"}}
\put(1.50,1.15){\vector(1,0){1.0}}
\put(1.55,1.25){\makebox(0,0)[l]{\tt .separator}}
\put(2.55,1.15){\makebox(0,0)[l]{\tt ","}}
}
\put(0.0,4.5){
\put(0.1,0.50){\makebox(4.0,0.30){\tt @137}}
\put(1.90,0.65){\oval(4.0,0.3)}
\put(0.20,0.50){\vector(0,-1){0.25}}
\put(0.15,0.40){\makebox(0,0)[r]{\tt .type}}
\put(0.20,0.15){\makebox(0,0)[c]{\tt "!"}}
\put(0.90,0.50){\vector(0,-1){0.25}}
\put(0.85,0.40){\makebox(0,0)[r]{\tt 1}}
\put(0.90,0.15){\makebox(0,0)[c]{\tt function}}
\put(1.45,0.50){\vector(0,-1){0.5}}
\put(1.40,0.40){\makebox(0,0)[r]{\tt 2}}
\put(3.60,0.50){\line(0,-1){1.35}}
\put(3.50,-0.85){\oval(0.2,0.2)[br]}
\put(3.50,-0.95){\vector(-1,0){0.15}}
\put(3.55,0.40){\makebox(0,0)[r]{\tt 3}}
}
\end{picture}
\end{center}

\caption{Example Code Object Representation II}
\label{EXAMPLE-CODE-OBJECT-REPRESENTATION-2}
\end{boxedfigure}

\newpage

Cooked representations may replace raw object identifiers in the
description of other objects, as in

\begin{indpar}\begin{verbatim}
@291 =:
      text = `This is a sentence.'
      outline = {! straight 3.2, left, straight (y + 9.4) !}
      min = {! function (x,y):

                  if (x > y):
                      return y
                  else:
                      return x
	    !}
\end{verbatim}\end{indpar}

which is the cooked representation of the object

\begin{indpar}\begin{verbatim}
@291 =:
    text = @93
    outline = @45
    min = @137
\end{verbatim}\end{indpar}

given the above examples.

One question left unanswered by the discussion so far is whether

\begin{indpar}\begin{verbatim}
@291 =:
    text A = `This is a sentence.'
    text B = `This is a sentence.'
\end{verbatim}\end{indpar}

represents

\begin{indpar}\begin{verbatim}
@291 =:
    text A = @93
    text B = @93
\end{verbatim}\end{indpar}

or instead

\begin{indpar}\begin{verbatim}
@291 =:
    text A = @93
    text B = @999
\end{verbatim}\end{indpar}

where object \TT{@999} happens to have the same structure as
object \TT{@93}.  The default is to make both \TT{text A}
and \TT{text B} be the same object, \TT{@93}, and to make
that object `immutable', meaning that it cannot be changed.  The
rule is that unless otherwise indicated, only immutable objects
have the property that their cooked representations can replace
their raw object identifiers in the cooked representations of other
objects.

We now elaborate on the syntax and internal representation
of {\em bracketed-lists}.

A {\em list-closing} must match the {\em list-opening} of the last unclosed
list.  The closing `\TT{)}' matches only `\TT{(}', the closing
`\TT{]}' matches only `\TT{[}', and the
closing `\TT{'}' matches only `\TT{`}'.

Any `\TT{\}}' must match a corresponding `\TT{\{}', and in addition,
the lexemes before the `\TT{\}}' must match, though not
exactly, the lexemes after the `\TT{\{}'.  Specifically, any
`\TT{\}}' must be proceeded by a
`\TT{|}', `\TT{>}', `\TT{)}', `\TT{]}', `\TT{'}', `\TT{\}}',
`{\em m-type}', or `\TT{|} {\em w-type} {\em attributes}\QMARK{}' phrase,
and the corresponding `\TT{\{}' must be followed respectively
by a
`\TT{|}', `\TT{<}', `\TT{(}', `\TT{[}', `\TT{`}', `\TT{\{}',
`{\em m-type}', or `{\em w-type} {\em attributes}\QMARK{} \TT{|}' phrase,
and if either list opening or list closing has a {\em type}, both must
have the same {\em type}.
As special cases,
`\TT{\{} {\em w-type} {\em attributes}\QMARK{} \TT{|}' can be matched by
`\TT{|\}}' and `\TT{\{|}' can match
`\TT{|} {\em w-type} {\em attributes}\QMARK{} \TT{\}}'.

A `\TT{\}}' can also end a {\em prefix}, which is a separate case.

A `\TT{\{}' that does not begin a {\em list-opening} or {\em prefix} is
in error, as is a `\TT{\}}' that does not end a {\em list-opening} or
{\em prefix}.

A {\em list-closing} is recognized even if it fails to match the
last unclosed {\em list-opening}, but in this case the {\em list-closing}
is treated as an error, and is either ignored if it does not
match any unclosed {\em list-opening}, or generates missing
{\em list-closings} if the {\em list-closing} matches some non-last unclosed
{\em list-opening}.

\ikey{Untyped bracketed lists}{untyped bracketed list}
are given an \ttdmkey{initiator}{of bracketed list}
equal to their {\em list-opening} and a
\ttdmkey{terminator}{of bracketed list} equal to their {\em list-closing}.
This includes lists with \TT{.initiators} `\TT{(}', `\TT{[}', `\TT{`}',
`\TT{\{<}', `\TT{\{(}', `\TT{\{[}', `\TT{\{`}', `\TT{\{\{}',
and \TT{.terminators} `\TT{)}', `\TT{]}', `\TT{'}',
`\TT{>\}}', `\TT{)\}}', `\TT{]\}}', `\TT{'\}}', `\TT{\}\}}',
but \underline{not} `\TT{\{|\ldots|\}}' lists which are a special case.

\ikey{Typed bracketed lists}{typed bracketed list} are given a
\ttdmkey{type}{of list} attribute equal to their {\em m-type} or
{\em w-type}.  An exception is that a list with {\em w-type} \TT{""}
(the empty {\em quoted-string}) is not given any \TT{.type} attribute
at all.

The elements of the
list become the attributes labeled \TT{1}, \TT{2}, \TT{3}, \ldots.

`\TT{\{|\ldots|\}}' lists are given no special attributes.
Note that `\TT{\{||\}}' denotes the empty list with no attributes
at all, and is equivalent to `\TT{\{""||\}}' (the list with {\em w-type}
\TT{""}).

{\em Attributes} in a {\em w-typed} bracketed list can be the same as
raw {\em attribute-representations}, or they can be just a label with
no flags or value.  In the latter case, if
the {\em attribute-label} does not begin with the word `\TT{no}',
the value `\TT{true}' is implied, and if the label does begin with
`\TT{no}', the `\TT{no}' is removed from the beginning of the label
and the value `\TT{false}' is implied.
If no value is given, it is an error if the label is just
`{\tt no}' by itself.

Some examples are as follows.  First:
\begin{center}
\tt \{| a b c |\}
\end{center}
is equivalent to, among other things, any of the following:
\begin{center}
\begin{tabular}{l}
\tt \{""| a b c |\} \\
\tt \{"":~1 = a, 2 = b, 3 = c ||\} \\
\tt \{"":~3 = c, 1 = a, 2 = b ||\} \\
\tt \{""| a b | "":~3 = c \} \\
\tt \{"":~3 = c | a | "":~2 = b \}
\end{tabular}
\end{center}

Second:

\begin{center}
\tt \{my type:~format, no capitalize, tweak = 5\}
\end{center}
is equivalent to
\begin{center}
\tt
\begin{tabular}{@{}l@{}}
\{my type:~format = true, capitalize = false, \\
~~~~~~~~~~~~~~~~~~~~~~~~~tweak = 5\} \\
\end{tabular}
\end{center}

{\em Prefixes} are an unusual kind of separator
that must appear at the beginning of the list as well as between
elements of the list, and their appearance at the beginning of the list
announces their use as a separator for the list and also establishes their
precedence relative to other {\em prefix} separators.
More explicitly, the type of the first {\em prefix-n} in a {\em prefix-n-list}
specifies that all {\em prefixes} of that type shall be {\em prefix-n}'s,
and {\em prefixes} of other types shall not be {\em prefix-n}'s.

Algorithmically, during a left to right scan of a {\em prefix-0-list},
there is a stack of `\key{open list prefix types}'.  Initially we are
at the beginning of a sublist which is the entire {\em prefix-0-list}.
Then:
\begin{enumerate}

\item
When a {\em prefix} of a type that is not in the stack appears at the
beginning of a sublist, its type is pushed into the stack, and a sublist
of that type beginning just after the {\em prefix} is begun.

\item
When a {\em prefix} of a type that is in the stack appears, it pops the
stack until the type is the top of the stack.  Sublists of popped types
are terminated.  The sublist of the type now at the top of the stack
is terminated.  A new sublist of that type beginning just after the
{\em prefix} is begun.

\item
When a {\em prefix} of a type that is not in the stack appears inside
(not at the beginning of) a sublist, it is announced as an error and
ignored.

\item
Each sublist is associated with a {\em prefix} that begins the
sublist.  The type and attributes of this {\em prefix} become the
type and attributes of the sublist.

\end{enumerate}


These rules imply that a {\em prefix} that is not in the stack is
in error unless it occurs at the beginning of a {\em prefix-0-list}
or occurs immediately after a {\em prefix} whose type was placed
in the stack.

Thus we have the following example parse of a {\em prefix-0-list}:

\begin{tabular}{lll}
Text	& Separator &  Syntactic Category
\\\hline
\tt \{p\} \{s\} This is a sentence.	& \tt \{p\} & \em prefix-0-list \\
\tt ~~~ \{s\} And another. \\
\tt \{p\} \{s\} And a new \{foo\} paragraph.
\\\hline
\tt \{s\} This is a sentence.	& \tt \{s\} & \em prefix-1-list \\
\tt \{s\} And another.
\\\hline
\tt This is a sentence.	& (none) & \em prefix-2-list
\\\hline
\tt And another. & (none) & \em prefix-2-list
\\\hline
\tt \{s\} And a new \{foo\} paragraph. & \tt \{s\} & \em prefix-1-list
\\\hline
\tt And a new \{foo\} paragraph. & (none) & \em prefix-2-list \\
			       &        & {\tt \{foo\}} is in error \\
			       &        & and is ignored (deleted).
\end{tabular}

The {\em prefix-0-list} in this example is equivalent to:
\begin{indpar}\begin{verbatim}
{|  {p|  {s| This is a sentence . |}
         {s| And another . |} |}
    {p|  {s| And a new paragraph . |} |} |}
             // `{foo}' deleted
\end{verbatim}\end{indpar}

{\em Lists} may be parsed after they have been read.  Operators, including
separators such as the semi-colon `{\tt ;}'
and comma `{\tt ,}', are recognized by such a parse.  As part of parsing,
a list may be reformatted.  See
\itemref{PARSING} for details.

\section{Compound Names}
\label{COMPOUND-NAMES}

\section{Parsing}
\label{PARSING}

A program is written in a text file.  The file is read and
converted to a sequence of lexemes, where each lexeme is tagged
with its line number and the column number of its first character.
This sequence of lexemes is then converted to a datum called an
\key{expression} by a process called parsing.

\ikey{Parsing}{parsing} consists of the following steps which
are done in the given order:

\begin{indpar}[0.1in]
\begin{tabular}{@{}p{1.7in}@{\hspace*{0.3in}}p{4.3in}@{}}
    \begin{tabular}[t]{@{}l@{}}
    Explicit Subexpression\\
    Recognition (\secref{EXPLICIT-SUBEXPRESSION-RECOGNITION})
    \end{tabular}
    & Explicit brackets, indentation marks, and indentation
      are used to group lexemes into subexpressions.
\end{tabular} \\[2ex]
\begin{tabular}{@{}p{1.7in}@{\hspace*{0.3in}}p{4.3in}@{}}
    \begin{tabular}[t]{@{}l@{}}
    Lexeme Replacement\\
    (\secref{LEXEME-REPLACEMENT})
    \end{tabular}
    & Short sequences of lexemes are replaced by other lexemes.
\end{tabular} \\[2ex]
\begin{tabular}{@{}p{1.7in}@{\hspace*{0.3in}}p{4.3in}@{}}
    \begin{tabular}[t]{@{}l@{}}
    Radix Number\\
    Recognition (\secref{RADIX-NUMBER-RECOGNITION})
    \end{tabular}
    & A radix indicator (e.g., \TT{X\#} or \TT{O\#})
      followed by a quoted string is recognized as
      a number with a special radix (e.g., hexadecimal, octal,
      as in \TT{X\#"A5"} and \TT{O\#"07700"}).
\end{tabular} \\[2ex]
\begin{tabular}{@{}p{1.7in}@{\hspace*{0.3in}}p{4.3in}@{}}
    \begin{tabular}[t]{@{}l@{}}
    Scientific Number\\
    Recognition (\secref{SCIENTIFIC-NUMBER-RECOGNITION})
    \end{tabular}
    & A number followed by an exponent (e.g., \TT{e-3} or \TT{E5})
      is recognized as a scientific number (e.g., as in
      \TT{5.74e-3} and \TT{10E5}).
\end{tabular} \\[2ex]
\begin{tabular}{@{}p{1.7in}@{\hspace*{0.3in}}p{4.3in}@{}}
    \begin{tabular}[t]{@{}l@{}}
    Number Pair\\
    Recognition (\secref{NUMBER-PAIR-RECOGNITION})
    \end{tabular}
    & Consecutive numbers (e.g., \TT{42 3/4}) are recognized as
      parts of a single number.
\end{tabular} \\[2ex]
\begin{tabular}{@{}p{1.7in}@{\hspace*{0.3in}}p{4.3in}@{}}
    \begin{tabular}[t]{@{}l@{}}
    Number Unit\\
    Grouping (\secref{NUMBER-UNIT-GROUPING})
    \end{tabular}
    & Consecutive pairs each consisting of a number and a unit are
      recognized as part of the same number (e.g., \TT{4ft 5in}).
\end{tabular} \\[2ex]
\begin{tabular}{@{}p{1.7in}@{\hspace*{0.3in}}p{4.3in}@{}}
    \begin{tabular}[t]{@{}l@{}}
    Unit Multiplication\\
    Insertion (\secref{UNIT-MULTIPLICATION-INSERTION})
    \end{tabular}
    & A multiplication operator (\TT{*})
    is inserted after prefix unit indicators
    and before postfix unit indicators: e.g., \TT{\$4.95} and
    \TT{4ft} become \TT{\$ * 4.95} and \TT{4 * ft}.
\end{tabular} \\[2ex]
\begin{tabular}{@{}p{1.7in}@{\hspace*{0.3in}}p{4.3in}@{}}
    \begin{tabular}[t]{@{}l@{}}
    Expression Parsing
    \end{tabular}
    & Expression parsing is done by a specialized parser, standardly
    either the operators parser or the text parser, that takes an
    expression consisting of a sequence of lexemes and explicit subexpressions
    and finds implicit subexpressions and other structure in it.
\end{tabular} \\[2ex]
\begin{tabular}{@{}p{1.7in}@{\hspace*{0.3in}}p{4.3in}@{}}
    \begin{tabular}[t]{@{}l@{}}
    Operator Parsing\\
    (\secref{OPERATOR-PARSER})
    \end{tabular}
    & Operator parsing is a particular brand of expression
      parsing that recognizes
      operators (e.g. \TT{+} and \TT{*})
      and list separators (e.g., \TT{,} or \TT{;},
      which are treated like operators), and produces algebraic expressions.
\end{tabular} \\[2ex]
\begin{tabular}{@{}p{1.7in}@{\hspace*{0.3in}}p{4.3in}@{}}
    \begin{tabular}[t]{@{}l@{}}
    Text Parsing\\
    (\secref{TEXT-PARSER})
    \end{tabular}
    & Text parsing is a particular brand of expression parsing that recognizes
      text operators and brackets, including named operators
      (e.g., \TT{<p>}), named brackets
      (e.g., \TT{<b|}\ldots\TT{|b>}),
      sentence terminators (e.g., \TT{.} and \TT{?}),
      and phrase separators (e.g., \TT{,} and \TT{;}), and produces
      expressions that represent sentences and paragraphs.
\end{tabular}
\end{indpar}

Expressions are parsed by either the operator parser or the text parser,
or by some user defined parser.  The following syntax categories are
defined for reference:

\begin{indpar}

\begin{tabular}{l}
\emkey{operator-expression} ::= an expression parsable by the operator parser
\label{OPERATOR-EXPRESSION}
\\[1ex]
\emkey{text-expression} ::= an expression parsable by the text parser
\label{TEXT-EXPRESSION}
\\[1ex]
\emkey{$O$-subexpression} ::= \begin{tabular}[t]{l}
	an expression that has no operator or separator \\
	outside brackets with the same or less precedence \\
	than operator or separator $O$
	\end{tabular}
\label{O-SUBEXPRESSION}
\end{tabular}

\end{indpar}

\subsection{Parsing Stacks}
\label{PARSING-STACKS}

Parsing is controlled by parsing definitions, which
are placed in the \key{parsing definition stack}%
\label{PARSING-DEFINITION-STACK}.
The following is a list
of the kinds of parsing definitions:%
\label{PARSING-DEFINITION-KINDS}

\begin{center}
\begin{tabular}{ll}
bracket & \secref{BRACKET-DEFINITION} \\
lexeme replacement & \secref{LEXEME-REPLACEMENT-DEFINITION} \\
radix indicator & \secref{RADIX-INDICATOR-DEFINITION} \\
unit specifier & \secref{UNIT-SPECIFIER-DEFINITION} \\
expression parser & \secref{EXPRESSION-PARSER-DEFINITION} \\
operator & \secref{OPERATOR-DEFINITION} \\
\end{tabular}
\end{center}


At the top level, the file being parsed,
the parser reads and parses one line
at a time.  A \key{top level line} is a \underline{non-indented}
file line.  Indented file lines are treated as continuations of
the previous top level line.  Blank lines and comments are ignored.
(See \pagref{TOP-LEVEL} for a few extra details.)

A \key{parsing definition} can appear only as a top level line.
Once read and parsed, it is recognized as a parsing definition,
pushed into the parsing definition stack, and otherwise ignored.
Thereafter it can affect the parsing of subsequence top level lines.

Not all parsing definitions are effective at any given time.  The set
of parsing definitions that have effect is determined by parsing selectors.
A \key{parsing selector} is just a {\em name} (i.e., a sequence of
{\em symbols} and {\em decimal-natural} lexemes
containing at least one {\em symbol},
see \pagref{NAME}). 
Parsing selectors are attached to parsing definitions,
and at any time during parsing there is a set of parsing selectors called
the `\lkey{current parsing}{selector set}\,' that determines which parsing
definitions are effective.  Specifically, a definition has effect
if a member of the active parsing selector set is attached to the definition.
Such definitions are said to be `\key{active parsing definitions}'.%
\label{ACTIVE-PARSING-DEFINITION}

For example, the
following two parsing definitions are standardly in the
parsing definition stack:

\begin{indpar}\begin{verbatim}
define operator "-" [operator] infix has precedence 5000
define operator "--" [text] nofix has precedence 300
\end{verbatim}\end{indpar}

The \TT{[ ]} brackets in these definitions surround comma
separated lists of parsing selectors that are attached to the
definition.  Here there are two parsing selectors
named `\TT{operator}' and `\TT{text}'.
When the current parsing selector set contains `\TT{text}',
but \underline{not} `\TT{operator}', then the `\TT{define operator "--"}'
definition is effective, but not the `\TT{define operator "-"}'
definition.  When the set does \underline{not}
contain `\TT{text}', but contains `\TT{operator}',
the `\TT{define operator "-"}' definition is effective,
but not the `\TT{define operator "--"}' definition.

The \lkey{current parsing}{selector set} is defined as the topmost entry in
the \key{parsing selector set stack},\label{PARSING-SELECTOR-SET-STACK},
which contains parsing selector sets.  The members of the current
parsing selector set are called
\skey{current parsing selector}s.

If a subexpression begins and ends with matched explicit
brackets, a parsing selector
set determined by the bracket definition (\secref{BRACKET-DEFINITION})
is pushed into the parsing
selector set stack before parsing the subexpression.  At the end of
the subexpression parsing, this selector set is popped from the stack.
A similar thing happens for subexpressions that begin with an
indentation mark (\secref{INDENTATION-MARK-DEFINITION}).

A summary of the standard effect of brackets on the parsing selector
set is:

\begin{center}
\begin{tabular}{l@{~~~~~~}l@{~~~~~~}l}
With      &           			& Sets \\
Parsing   &				& Parsing \\
Selector  & Brackets  			& Selectors To \\[1ex]
-	  & \TT{(}\ldots\TT{)}		& [no change] \\
-	  & \TT{\{}\ldots\TT{\}}	& operator \\
-         & \TT{[}\ldots\TT{]}		& operator \\
-	  & \TT{`}\ldots\TT{'}		& text     \\
\end{tabular}\label{CONTEXT-SWITCHES}
\end{center}

Thus the \TT{\{ \}} brackets, whose definition is always active
(signified by `-' in the above table), pushes into the parsing
selector set stack the set whose only member is the `operator'
parsing selector.

A parsing definition contains \key{parsing selectors}
which are a \TT{[ ]} bracketed
list of the parsing selectors attached to the definition.
Some definitions, like bracket definitions, can
contain \key{new parsing selectors},
which determine a parsing selector set to push into the
parsing selector set stack.  These have the syntax:

\begin{indpar}

\begin{tabular}{l}
\emkey{parsing-selectors} ::= {\em empty}
			     $|$ \TT{[} {\em parsing-selector-list} \TT{]}
\label{PARSING-SELECTORS}
\\[1ex]
\emkey{parsing-selector-list} ::= {\em empty}
    $|$ {\em parsing-selector} \{ \TT{,} {\em parsing-selector} \}$^\star$
\\[1ex]
\emkey{parsing-selector} ::= {\em name} ~~ [see \pagref{NAME}]
\end{tabular}

\begin{tabular}{l}
\emkey{new-parsing-selectors} \\
\hspace*{0.3in}\begin{tabular}[t]{rl}
    ::= & \TT{[} {\em parsing-selector-list} \TT{]} \\
    $|$ & \TT{[} {\em parsing-selector-op} {\em parsing-selector} \\
        & \hspace*{0.3in}
          \{ \TT{,} {\em parsing-selector-op} {\em parsing-selector}
	  \}$^\star$ \TT{]}
    \end{tabular}
\label{NEW-PARSING-SELECTORS}
\\[1ex]
\emkey{parsing-selector-op} ::= \TT{+} $|$ \TT{-} $|$ \TT{\^~}
\end{tabular}

\end{indpar}

If a parsing definition does not give \emkey{parsing selectors}
(i.e., the {\em parsing-selectors} are completely {\em empty}
in the above syntax, with no \TT{[ ]} brackets present), then
the definition is \underline{always} active.  Otherwise each
{\em parsing-selector} listed in the specification is attached to the
definition.

If a definition like a bracket definition gives \emkey{new parsing
selectors}, then this contains instructions how to make
a new parsing selector set.  There are two forms: one with
\emskey{parsing-selector-op}s and one without.  The form without
simply specifies the new parsing selector set literally, by listing
the {\em parsing selectors} in it.  The one with ops, specifies how
to make the new set from the existing current parsing selector set.
The \TT{+} op adds a selector if it was not previously present.
The \TT{-} op deletes a selector if it was previously present.
And the \TT{\^~} op flips a selector, adding it if it was not
previously present, and deleting it if it was previously present.

If a definition like a bracket definition does \underline{not}
give any {\em new-parsing-selectors}, then
the required new selector set is just a copy of the current selector set.

There is \underline{no} way to pop definitions off the parsing definition
stack.
However, you can place parsing definitions
in the stack
that suppress the effect of particular parsing definitions.
Thus if

\begin{indpar}\begin{verbatim}
define operator "-" [operator] infix has precedence 10
\end{verbatim}\end{indpar}

is in the stack, so that the operator expression parser will
recognize `\TT{-}' as an operator, then putting

\begin{indpar}\begin{verbatim}
undefine operator "-" [special operator]
\end{verbatim}\end{indpar}

further toward the top of the stack will cause the lexeme
`\TT{-}' to be not recognized as an operator whenever the
parsing selector set has both the `\TT{operator}' and the
`\TT{special operator}' selectors.

The operator expression parser introduces
\skey{implicit bracket}s.  These
can also be represented explicitly, though this is mostly done
for purposes of debugging.  The implicit brackets
introduced by operators are represented by \TT{(| |)}, and the
implicit brackets introduced by numbers are represented by \TT{(\# \#)}.

For example, the operator expression parser turns
\begin{center}
\verb|x + y - 5 * z|
\end{center}
into
\begin{center}
\verb@x + y - (| 5 * z |)@
\end{center}
Similarly the operator parser turns the number
\begin{center}
\verb|4ft 5 3/4 in|
\end{center}
first into
\begin{center}
\verb|(# 4 * ft + (# 5 + 3/4 #) * in #)|
\end{center}
and then finally into
\begin{center}
\verb@(# (| 4 * ft |) + (| (# 5 + 3/4 #) * in |) #)@
\end{center}

Implicit brackets are represented in parsed expressions as the
\underline{absence} of \TT{.initiator}'s
and \TT{.terminator}'s.  Implicit brackets must be represented
explicitly in text to be parsed if the parser would not otherwise
insert them correctly.

Bracket, indentation mark, and operator
definitions may specify reformatters
which reformat sub\-expressions after they have been normally parsed.
A \key{reformatter}\label{REFORMATTER} is a function that
is called with a parsed subexpression that is surrounded by brackets,
introduced by an indentation mark, or has a lead operator.
The reformatter returns the reformatted subexpression.

Parsing definitions may also specify evaluators
that are functions attached to the parsed subexpressions which
are called later to evaluate the subexpressions.

\subsection{Brackets}
\label{BRACKETS}

Brackets surround an explicitly bracketed
subexpression and specify the parsing
selector set that determines how the subexpression is parsed.
The brackets that are recognized by the parser
are defined by \skey{bracket definition}s which specify

\begin{indpar}[1in]
Bracket Name and Parsing Selectors \\
Optional New Parsing Selectors \\
Optional Reformatter \\
Optional Evaluator
\end{indpar}

The syntax of bracket definitions is:

\begin{indpar}
\emkey{bracket-definition} \\
	\hspace*{0.5in}::= \ttkey{define bracket}
	    \begin{tabular}[t]{@{}l@{}}
	    {\em bracket-name} {\em parsing-selectors} \\
	    {}[ \TT{with parsing-selectors}
	        {\em new-parsing-selectors} ] \\
	    {}[ \TT{with reformatter}
	        {\em reformatter-name} ] \\
	    {}[ \TT{with evaluator} {\em evaluator-name} ] \\
	    \end{tabular}
\label{BRACKET-DEFINITION}
	    \\[1ex]
\emkey{bracket-name} ::=
	{\em opening-bracket-name}
	\TT{...}
	{\em closing-bracket-name}
\label{BRACKET-NAME}
	\\[1ex]
\emkey{opening-bracket-name} ::= {\em name} \\[1ex]
\emkey{closing-bracket-name} ::= {\em name} \\[1ex]
{\em name} ::= see \pagref{NAME} \\[1ex]
{\em parsing-selectors} ::= see \pagref{PARSING-SELECTORS}
	\\[1ex]
{\em new-parsing-selectors} ::= see \pagref{NEW-PARSING-SELECTORS}
	\\[1ex]
\emkey{reformatter-name} ::= {\em function-name }
	\\[1ex]
\emkey{evaluator-name} ::= {\em function-name }
	\\[1ex]
\emkey{function-name} ::= {\em name}
\end{indpar}


A {\em bracket-name}
has two subsequences of lexemes, an
\emkey{opening bracket name} and
a \key{closing bracket name}, separated by 
a `\TT{...}' lexeme.
By abuse of language, 
`\key{opening bracket}\,'
is used as a synonym for `{\em opening bracket name}'
and `\key{closing bracket}\,'
is used as a synonym for `{\em closing bracket name}'.

When a subexpression is surrounded by brackets, the brackets
are included in the subexpression.

The {\em parsing-selectors} in the {\em bracket-definition}
determine when the definition will be active (\pagref{PARSING-SELECTORS}).
The {\em new-parsing-selectors} specify how to compute a new parsing
selector set which is pushed into the parsing selector set stack by
the opening bracket and popped by the closing bracket
(\pagref{NEW-PARSING-SELECTORS}).

A {\em reformatter-name}
is the name of the function that is called with a parsed expression
as its single argument in order to reformat the expression
(\pagref{REFORMATTER}).  After a bracketed subexpression has been
scanned, the expression parser is called to parse the part of the expression
between brackets.  If this returns a list without \TT{.initiator}
or \TT{.terminator}, the opening and closing brackets are added as
\TT{.initiator} and \TT{.terminator} to this list.
Otherwise a new one-element list is created with the opening and
closing brackets as \TT{.initiator} and \TT{.terminator}
and the expression parser result as the single list element.
Then the bracket definition reformatter, if any, is
called to further reformat the resulting list.

If an {\em evaluator-name} is specified by the bracket definition,
it is attached as the \TT{.evaluator} attribute to each final
parsed bracketed subexpression.
The following are standard evaluators:

\begin{indpar}

\ttnbkey{-STANDARD-EVALUATOR-}.  Normal evaluator that calls functions
and executes operators.

\ttnbkey{-QUOTE-EVALUATOR-}.  Does not evaluate expressions, but just
returns the unevaluated expression as its value.  However, does search
for \TT{[ ]} bracketed subexpressions, evaluates them, and replaces
them by their values.  See \pagref{QUOTE-EVALUATOR}.

\end{indpar}

\subsection{Indentation Marks}
\label{INDENTATION-MARKS}

An \key{indentation mark}
introduces an indented subexpression (\pagref{INDENTED-SUBEXPRESSION}).
Indentation marks are
similar to opening brackets, except indentation marks
must appear at the end of a line, indentation is used
in place of a closing bracket, and indentation and line ends
are also used as separators to given an extra list layer
to the indented subexpression.

Indentation marks are defined by indentation mark definitions,
whose syntax is:

\begin{indpar}
\emkey{indentation-mark-definition} \\
	\hspace*{0.5in}::= \TT{define}~
	    \begin{tabular}[t]{@{}l@{}}
	    \TT{indentation mark}\ttindex{define indentation mark} \\
	    {\em indentation-mark-name} {\em parsing-selectors} \\
	    {}[ \TT{with parsing-selectors}
	        {\em new-parsing-selectors} ] \\
	    {}[ \TT{with reformatter}
	        {\em reformatter-name} ] \\
	    {}[ \TT{with evaluator} {\em evaluator-name} ] \\
	    \end{tabular}
\label{INDENTATION-MARK-DEFINITION}
	    \\[1ex]
\emkey{indentation-mark-name} ::=
	{\em mark-name} $|$ {\em gluing-indicator} {\em mark-name}
\label{INDENTATION-MARK-NAME}
	\\[1ex]
\emkey{mark-name} ::= {\em mark} $|$ {\em quoted-string}
	\\[1ex]
\emkey{gluing-indicator} ::= \TT{*}
	\\[1ex]
{\em parsing-selectors} ::= see \pagref{PARSING-SELECTORS}
	\\[1ex]
{\em new-parsing-selectors} ::= see \pagref{NEW-PARSING-SELECTORS}
	\\[1ex]
\emkey{reformatter-name} ::= {\em function-name }
	\\[1ex]
\emkey{evaluator-name} ::= {\em function-name }
	\\[1ex]
\emkey{function-name} ::= {\em name}
        \\[1ex]
{\em name} ::= see \pagref{NAME}
\end{indpar}

The name of an indentation mark is a restricted form of name
(\pagref{NAME}); it can only be a {\em mark} or a quoted {\em mark}.
The {\em gluing-indicator} \TT{*} specifies that the indentation
mark may be glued to the end of a previous {\em mark} in its line.
E.g., the two marks `\TT{= :}' may be replaced by `\TT{=:}'.
This joined {\em mark} must then be the last lexeme on its line.

\subsection{Explicit Subexpression Recognition}
\label{EXPLICIT-SUBEXPRESSION-RECOGNITION}

\ikey{Explicit subexpressions}{explicit subexpression}
are subexpressions surrounded by explicit brackets or subexpressions
introduced by indentation marks and delimited by
indentation.

\ikey{Explicit brackets}{explicit bracket}
are defined by bracket definitions in the
parsing definition stack, and are used to surround
\ikey{explicitly bracketed subexpressions}{explicitly bracketed!subexpression}.
An example bracket definition is

\begin{indpar}\begin{tabular}{@{}l@{~}l}
\tt define  & \verb|bracket "{" ... "}" [operator]| \\
            & \ldots
\end{tabular}\end{indpar}

This specifies that \TT{\{} is an \key{opening bracket}
and \TT{\}} is its corresponding \key{closing bracket}.  More details on
bracket definitions can be found in \secref{BRACKET-DEFINITION}.
The parser recognizes opening explicit brackets in
its input list of lexemes.  Once an opening bracket is recognized,
its corresponding closing bracket can be recognized, as long as it
is not inside another explicit subexpression.

\ikey{Indentation marks}{indentation mark}
are defined by indention mark
definitions in the parsing definition stack and are used to introduce
\skey{indented subexpression}s (\pagref{INDENTED-SUBEXPRESSION}).
An example indention mark definition is

\begin{indpar}\begin{verbatim}
define indentation mark * ":" [operator]
\end{verbatim}\end{indpar}

This specifies that a mark ending in \TT{:}
\underline{that is at the end of a line}
introduces an indented subexpression.  The following
example contains 3 indented subexpressions:

\begin{indpar}\begin{verbatim}
sum from X through Y <-- integer X, integer Y:
    `Sum of integers from X through Y.'
    if ( X > Y ):
        value = 0
    else:
        value = X + sum (X+1) through Y
\end{verbatim}\end{indpar}

Here the \TT{:} at the end of the first line introduces an
indented subexpression consisting of all following lines, and
the \TT{:}'s at the end of the `\TT{if}' and `\TT{else}'
lines each introduce one line indented subexpressions.

The output of explicit subexpression recognigion for the above example is:

\begin{indpar}\begin{verbatim}
@1 = sum from X through Y "<--" integer X "," integer Y @2
@2 = @3 @4 @5 {| .initiator = ":" |}
@3 = Sum of integers from X through Y "."
         {| .initiator = "`"; .terminator = "'" |}
@4 = if @6 @7
@6 = X ">" Y {| .initiator = "("; .terminator = ")" |}
@7 = @8 {| .initiator = ":" |}
@8 = value "=" 0
@5 = else @9
@9 = @10 {| .initiator = ":" |}
@10 = value "=" X "+" sum @11 through Y
@11 = X "+" 1 {| .initiator = "("; .terminator = ")" |}
\end{verbatim}\end{indpar}

This explicit subexpression recognition output is feed into
the rest of the parser which recognizes operators and
transforms the results.
for example, \TT{@3} becomes:

\begin{indpar}\begin{verbatim}
@3 = @12 {| .initiator = "`"; .terminator = "'" |}
@12 = sum of integers from X through Y
         {| .initiator = capital; .terminator = "." |}
\end{verbatim}\end{indpar}

in which \TT{"."} has been recognized as a \TT{.terminator}, and
capitalization has been encoded in as an \TT{.initiator}.

The \mkey{indentation}{of line} of a line is the
column number of the first non-white-space character in the line.

An \key{indented subexpression}\label{INDENTED-SUBEXPRESSION}
is introduced by an \key{indentation mark} that ends a line.  This mark must
be defined by an indention mark definition, as per the
example above.  If the mark is preceded in its definition by
\ttmkey{*}{in indention mark definition}, then it may be
\mkey{glued}{indentation mark}
to another mark immediately preceding it.  For example,
`\TT{= :}' may be written as `\TT{=:}'.

An indented subexpression is a list of non-blank lines;
blank lines in an indented subexpression are ignored.
The \mkey{indentation}{of indented subexpression}
of the subexpression is the indentation of the first non-blank line
after the indentation mark.
All lines in the subexpression list must begin with this indentation.
Any line that has greater indentation continues the line previous
to it.  The indented subexpression ends just before the next line
with less indentation.

In order to describe indented subexpressions in syntax equations,
the syntax categories \ikey{indenta\-tion-beginning}{indentation-beginning},
\key{indentation-separator},
and \key{indentation-end} are used.
An {\em indentation-beginning}\label{INDENTATION-BEGINNING2}
occurs just after the {\em indentation-mark} that introduces the
indented subexpression, and just before the first line of the subexpression.
An {\em indentation-separator}\label{INDENTATION-SEPARATOR2}
occurs just before each line but the first in the indented subexpression.
An {\em indentation-end}\label{INDENTATION-END2}
occurs at the end of the indented subexpression,
in the same place a closing bracket would occur in a
bracketed subexpression.

The output of
the parser for an indented subexpression is a list whose elements
are the output of the parser for each non-blank line, and 
whose \TT{.initiator} is the indention mark that introduced
the subexpression.  This list does \underline{not} have a \TT{.separator}
or \TT{.terminator}. 

The \key{top level},\label{TOP-LEVEL}
the file containing the text being parsed,
is treated similarly
to an indented subexpression introduced by an implied indentation mark
before the
beginning of the file.  Each element of the top level is a
non-blank line indented
the same as the first non-blank
line of the file.  These elements are read and
processed sequentially.  It is an error for a file non-blank
line to have less indentation than the first non-blank line of the file.

Consider the file:

\begin{indpar}\begin{verbatim}
@3 =:
    v =:
        w
        x y
    z =:
@4 = a b c
@5 =:
\end{verbatim}\end{indpar}

When the first element of this file is read using the
parser, it becomes the object \TT{@6} in:

\begin{indpar}\begin{verbatim}
@6 = "@" 3 "=" @7
@7 = @8 @9 {| .initiator  = ":" |}
@8 = v "=" @10
@10 = w @11 {| .initiator = ":" |}
@11 = x y
@9 = z "=" @12
@12 = {| .initiator = ":" |}
\end{verbatim}\end{indpar}

Note the list \TT{@12} introduced by line `\TT{z =:}' is
empty, because the next line is indented by less than
this line, and therefore the indented subexpression containing
this line ends right after the line.

The second element read from the above file is \TT{@13} in:

\begin{indpar}\begin{verbatim}
@13 = "@" 4 "=" a b c
\end{verbatim}\end{indpar}

and the third and last element is \TT{@14} in:

\begin{indpar}\begin{verbatim}
@14 = "@" 5 "=" @15
@15 = {| .initiator = ":" |}
\end{verbatim}\end{indpar}

Here \TT{@15} is the empty list because the file ends
after the line `\TT{@5 =:}' that introduces it.

It is a general rule\label{INDENTATION-EQUIVALENCE-RULE}
of RECKON that lists with \TT{\{~\}} brackets
and `\TT{;}' separator are semantically equivalent to indented
subexpressions introduced by `\TT{:}'.  Thus

\begin{indpar}\begin{verbatim}
@3 =:
    v =:
        w
        x y
    z =:
@4 = a b c
@5 =:
\end{verbatim}\end{indpar}

and

\begin{indpar}\begin{verbatim}
@3 = {
    v = {
        w;
        x y };
    z = {} }
@4 = a b c
@5 = {}
\end{verbatim}\end{indpar}

are semantically equivalent files.  But they do \underline{not}
parse the same.  Also, the lines of the top level may optionally
be ended by `\TT{;}', as in

\begin{indpar}\begin{verbatim}
@3 = {
    v = {
        w;
        x y };
    z = {} };
@4 = a b c;
@5 = {};
\end{verbatim}\end{indpar}

without semantic effect, as long as indentation subexpressions
are not used outside explicit brackets.

\subsubsection{Explicit Subexpression Recognition Algorithm}
\label{EXPLICIT-SUBEXPRESSION-RECOGNITION-ALGORITHM}

The \lkey{explicit subexpression}{recognition algorithm} is the
parsing subalgorithm that recognizes explicitly bracketed
and indented subexpressions.  Here we describe this algorithm, which
runs before the lexeme replacement algorithm is run.

The explicit subexpression recognition algorithm is
applied to the lexeme sequence before lexical replacement.

The algorithm maintains a
stack of subexpression records, called the \key{subexpression stack}.
A \key{subexpression record} contains a pointer to a bracket definition
or an indentation mark definition,
an indentation (column number), a subexpression list, and a line list.
Any of these components may be missing.

The bracket definition or indentation mark definition is the definition
of the brackets or indentation mark that surrounds or initiates the
subexpression currently being scanned.  The subexpression list contains
the lexemes and sub-subexpressions already scanned in this subexpression.
The line list contains the lexemes and sub-subexpressions already
scanned from the subexpression's current line and its continuations.

Initially the subexpression stack contains a single subexpression record with
no definition pointer, indentation equal to 1, subexpression list equal
to the lines read so far at top level, and line list that is either missing
or contains what has been
read so far from the current line.
The stack cannot become empty;
the bottommost subexpression record on the stack is always the same.

The record at the top of the subexpression stack is called the
`\lkey{current subexpression}{record}'.  If it has an indentation, bracket
definition, indentation mark definition, subexpression list, etc., these
are called `current', as in `current indentation',
`current bracket definition', or `current subexpression list'.
The components of the definition are
also called current, as in `current closing bracket'.

At any point during algorithm execution the sequence of remaining input lexemes
are referred to as the current input, and the first of these is
referred to as the current input lexeme.  This lexeme
may be the first or last in its file line, and if first, will
have some indentation (i.e., beginning column number)
with respect to the beginning of its file line.

The explicit subexpression algorithm executes a loop each of whose
iterations execute the following steps in order.

\begin{indpar}

{\bf Indentation Error.}\index{Indentation Error}
\begin{indpar}
If
\begin{list}{}
	     {\setlength{\itemsep}{0ex}%
	      \setlength{\topsep}{0ex}%
	      \setlength{\parsep}{0ex}%
	      \setlength{\leftmargin}{0.5in}%
	      \setlength{\rightmargin}{0.5in}}%
\item[(1)] the current input lexeme is the first lexeme on its line,
\item[(2)] there is a current indentation, and
\item[(3)] the indentation of this lexeme in its line
is 1 less than or 1 greater
than the current indentation,
\end{list}
then a parsing error is announced.
This ensures that when indentation is
used to insert implicit lexemes, important indentation
differences must be by at least
2 columns, and cannot be by just 1 column.
\end{indpar}

{\bf Indentation Mark Ungluing.}%
\index{Indentation Mark Ungluing}
\begin{indpar}
If
\begin{list}{}
	     {\setlength{\itemsep}{0ex}%
	      \setlength{\topsep}{0ex}%
	      \setlength{\parsep}{0ex}%
	      \setlength{\leftmargin}{0.5in}%
	      \setlength{\rightmargin}{0.5in}}%
\item[(1)] the current input lexeme is the last lexeme on its line,
\item[(2)] this lexeme is a mark, and
\item[(3)] there is a current indentation mark definition in the
parsing definition stack which defines a gluing mark that is
at the end of the current input lexeme, but not the whole lexeme
(if there are several such definitions the one with the longest
indentation mark is used),
\end{list}
then the current input lexeme is split in two and replaced by two lexemes.
The second of these is the gluing indentation mark, and the first
is what precedes it in the original lexeme.  The first of these two
lexemes becomes the current input lexeme, and the second (the
indentation mark) becomes the
next lexeme in the current input.
\end{indpar}

{\bf Indented Line Termination.}\index{Indented Line Termination}
\begin{indpar}
If
\begin{list}{}
	     {\setlength{\itemsep}{0ex}%
	      \setlength{\topsep}{0ex}%
	      \setlength{\parsep}{0ex}%
	      \setlength{\leftmargin}{0.5in}%
	      \setlength{\rightmargin}{0.5in}}%
\item[(1)] the current input lexeme is the first lexeme on its line,
\item[(2)] there is a current indentation,
\item[(3)] the indentation of the current input lexeme is less than or equal
to the current indentation, and
\item[(4)] there is a current line list,
\end{list}
then the current line list is terminated and the resulting list
is added to the current subexpression list.  The current line list
is then set to missing.
\end{indpar}

{\bf Indented Subexpression Termination.}%
\index{Indented Subexpression!Termination}
\begin{indpar}
If
\begin{list}{}
	     {\setlength{\itemsep}{0ex}%
	      \setlength{\topsep}{0ex}%
	      \setlength{\parsep}{0ex}%
	      \setlength{\leftmargin}{0.5in}%
	      \setlength{\rightmargin}{0.5in}}%
\item[(1)] the current input lexeme is the first lexeme on its line,
\item[(2)] there is a current indentation, and
\item[(3)] the indentation of the current input lexeme is less than
to the current indentation,
\end{list}
then the current subexpression record is popped from the subexpression
stack and its subexpression list is added as a single element to the
new current line list.  The current parsing selector set is popped
from its stack.  Then this loop iteration is terminated, without
consuming the current input lexeme.
\end{indpar}

{\bf Bracketed Subexpression Termination.}%
\index{Bracketed Subexpression Termination}
\begin{indpar}
If
\begin{list}{}
	     {\setlength{\itemsep}{0ex}%
	      \setlength{\topsep}{0ex}%
	      \setlength{\parsep}{0ex}%
	      \setlength{\leftmargin}{0.5in}%
	      \setlength{\rightmargin}{0.5in}}%
\item[(1)] there is a current bracket definition, and
\item[(2)] the closing bracket in that definition matches a sequence
of lexemes at the beginning of the current input,
\end{list}
then the current subexpression record is popped from the subexpression
stack and its subexpression list is added as a single element to the
new current line list.
The current parsing selector set is popped
from its stack.
The closing bracket is removed from the beginning of the current input and
discarded.
Then this loop iteration is terminated.
\end{indpar}

{\bf Indentation Initiation.}%
\index{Indentation Initiation}
\begin{indpar}
If
\begin{list}{}
	     {\setlength{\itemsep}{0ex}%
	      \setlength{\topsep}{0ex}%
	      \setlength{\parsep}{0ex}%
	      \setlength{\leftmargin}{0.5in}%
	      \setlength{\rightmargin}{0.5in}}%
\item[(1)] the current input lexeme is the first lexeme on its line,
\item[(2)] there is a current indentation mark definition, and
\item[(3)] there is \underline{no} current indentation (meaning this is
the first lexeme encountered after indentation mark),
\end{list}
then the current indentation is set to the indentation of the lexeme.
\end{indpar}

{\bf Indented Line Initiation.}%
\index{Indented Line Initiation}
\begin{indpar}
If
\begin{list}{}
	     {\setlength{\itemsep}{0ex}%
	      \setlength{\topsep}{0ex}%
	      \setlength{\parsep}{0ex}%
	      \setlength{\leftmargin}{0.5in}%
	      \setlength{\rightmargin}{0.5in}}%
\item[(1)] the current input lexeme is the first lexeme on its line,
\item[(2)] there is a current indentation,
\item[(3)] the indentation of the current input lexeme equals
the current indentation, and
\item[(4)] there is no current line list,
\end{list}
then an empty current line list is created.
\end{indpar}

{\bf Indented Subexpression Initiation.}%
\index{Indented Subexpression!Initiation}
\begin{indpar}
If
\begin{list}{}
	     {\setlength{\itemsep}{0ex}%
	      \setlength{\topsep}{0ex}%
	      \setlength{\parsep}{0ex}%
	      \setlength{\leftmargin}{0.5in}%
	      \setlength{\rightmargin}{0.5in}}%
\item[(1)] the current input lexeme is the last lexeme on its line, and
\item[(2)] there is a current indentation mark definition in the
parsing definition stack which defines a mark that matches the
current input lexeme,
\end{list}
then a new subexpression record is pushed into the subexpression stack.
The new record has the current indentation mark definition as its
definition, an empty subexpression list with the indentation mark as
its \TT{.initiator}, missing indentation, and missing line list.
A new parsing selector set is computed using the current
parsing selector set and the indentation mark definition
{\em new-parsing-selectors}, and the new set is pushed into the
parsing selector set stack.
The indentation mark is removed from the current input and
discarded.
Then this loop iteration is terminated.
\end{indpar}

{\bf Bracketed Subexpression Initiation.}%
\index{Bracketed Subexpression Initiation}
\begin{indpar}
If
\begin{list}{}
	     {\setlength{\itemsep}{0ex}%
	      \setlength{\topsep}{0ex}%
	      \setlength{\parsep}{0ex}%
	      \setlength{\leftmargin}{0.5in}%
	      \setlength{\rightmargin}{0.5in}}%
\item[(1)] there is a active bracket definition in the
parsing definition stack which defines an opening bracket that matches an
initial sequence in the current input
(if there are several such definitions the one with the longest
opening bracket is used),
\end{list}
then a new subexpression record is pushed into the subexpression stack.
The new record has the active bracket definition as its
definition, an empty subexpression list with bracket definition's
opening and closing brackets as its \TT{.initiator} and \TT{.ter\-min\-ator},
respectively, missing indentation, and missing line list.
A new parsing selector set is computed using the current
parsing selector set and the bracket definition
{\em new-parsing-selectors}, and the new set is pushed into the
parsing selector set stack.
The opening bracket is removed from the current input and
discarded.
Then this loop iteration is terminated.
\end{indpar}

{\bf Lexeme Consumption.}%
\index{Lexeme Consumption}
\begin{indpar}
The current input lexeme is removed from the current input and
pushed to the end of the current line list, if that exists, or to the
current subexpression list, otherwise.
Then this loop iteration is terminated.
\end{indpar}


\end{indpar}

Note that all other parsing is done after explicit subexpression
recognition, and cannot affect execution of the explicit subexpression
recognition algorithm.

\subsection{Lexeme Replacement}
\label{LEXEME-REPLACEMENT}

The \key{lexeme replacement}
process replaces a string of one or more lexemes by a string of zero or
more lexemes.  Lexeme replacement is done on sequences of lexemes
in each subexpression produced
by the explicit subexpression recognition algorithm
(\secref{EXPLICIT-SUBEXPRESSION-RECOGNITION-ALGORITHM}).
These subexpressions are lists that may contain elements that are
subexpressions, and not lexemes, and lexeme replacement cannot cross over
the boundary created by such subexpression elements.
The lists do \underline{not} include brackets or
indentation marks, which
have become \TT{.initiator}'s and \TT{.terminators} of the subexpression
lists.  However, if a subexpression is just a single lexeme by itself,
that subexpression is treated as a list of one lexeme.

Note that lexeme replacement is done after explicit subexpression recognition,
and cannot affect brackets or indentation marks.

Lexeme replacement may be done by either a dictionary or a function.
Replacement is controlled by \slkey{lexeme replacement}{definition}s
in the parsing definition stack (\secref{PARSING-DEFINITION-STACK}).
The are two kinds of lexeme replacement definitions,
dictionary and function, have the syntax:

\begin{indpar}
\emlkey{lexeme-replacement}{-definition}\,
		     \begin{tabular}[t]{rl}
                     ::= & {\em lexeme-dictionary-definition} \\
		     $|$ & {\em lexeme-function-definition}
		     \end{tabular}
\label{LEXEME-REPLACEMENT-DEFINITION}%
		     \\[1ex]
\emlkey{lexeme-dictionary}{-definition} \\
	\hspace*{0.5in}::= \begin{tabular}[t]{@{}l@{}l@{}}
	                   \TT{define} & \TT{lexeme dictionary}
                                            {\em dictionary-name}
					    {\em parsing-selectors} \\
				& {\em lexeme-dictionary-entries}
		     \end{tabular} \\[1ex]
\emkey{dictionary-name} ::= {\em name}
	\\[1ex]
{\em name} ::= see \pagref{NAME}
	\\[1ex]
{\em parsing-selectors} ::= see \pagref{PARSING-SELECTORS}
	\\[1ex]
\emkey{lexeme-dictionary-entries}
                    ::= \TT{\{}
		        {\em lexeme-dictionary-entry-list}
			\TT{\}}
		    \\[1ex]
\emlkey{lexeme-dictionary}{-entry-list} \\
		     \hspace*{0.5in}\begin{tabular}[t]{@{}rl@{}}
                     ::= & {\em empty} \\
                     $|$ & {\em lexeme-dictionary-entry} \\
		     $|$ & {\em lexeme-dictionary-entry-list} \TT{;}
		           {\em lexeme-dictionary-entry}
		     \end{tabular} \\[1ex]
\emkey{lexeme-dictionary-entry} \\
    \hspace*{0.5in}::=
	{\em replaced-lexemes} \TT{==>} {\em replacing-lexemes}
	$|$ {\em empty}
	\\[1ex]
\emkey{replaced-lexemes} ::= {\em name}
	\\[1ex]
\emkey{replacing-lexemes} ::= {\em empty} $|$ {\em name }
	\\[1ex]
\emkey{lexeme-function-definition} \\
	\hspace*{0.5in}::= \TT{define lexeme function}
				{\em function-name}
				{\em parsing-selectors} \\[1ex]
\emkey{function-name} ::= {\em name}
\label{FUNCTION-NAME}
\end{indpar}

A \emkey{lexeme-dictionary-entry} gives a sequence of lexemes
that is to be replaced
and a sequence of lexemes that replace it.  For example, the entry

\begin{center}
\verb|people ==> person|
\end{center}

causes the word `\TT{people}' to be replaced by the word `\TT{person}'.

Its possible to add entries to an existing dictionary using the
statement:
\begin{indpar}
\emikey{lexeme-dictionary-extension}
       {lexeme-dictionary-@{\em lexeme-extension-}!extension@{\em extension}}
           \\
	\hspace*{0.5in}::= \begin{tabular}[t]{@{}l@{}l@{}}
	                   \TT{define} & \TT{lexeme dictionary}
                                            {\em dictionary-name}
					    \TT{extension} \\
				& {\em lexeme-dictionary-entries}
		           \end{tabular}
\end{indpar}

Such extension statements are not definitions in the strict sense, and
do not appear in the parsing stack.  They must reference dictionaries
that already exist.

A \key{lexeme function} is a function that is called with a list of
lexemes as its single argument and which returns either
`\TT{false}' if the lexeme at the beginning of the list is not to be
replaced, or returns a pair consisting of first a list of replacing
lexemes and second the in input list with the replaced lexemes removed
from its beginning.
For example, given the lexeme function definition

\begin{indpar}
\begin{verbatim}
define lexeme function replace people [operator]
\end{verbatim}
\end{indpar}

and the function definition

\begin{indpar}
\begin{verbatim}
replace people X <-- list ( X ):
    if first X == `people':
        value = ( `person', rest X )
    else:
        value = false
\end{verbatim}
\end{indpar}

then

\begin{center}
\verb|replace people `people with hats'| $\Longrightarrow$
\verb|(`person',`with hats')|

\verb|replace people `fee fie foe fum'| $\Longrightarrow$ \verb|false|
\end{center}


Lexeme replacement is \underline{not} recursive: the replacement lexemes are
not themselves subject to replacement.

A quoted string in a {\em replaced-lexemes} or {\em replacing-lexemes}
sequence of lexemes denotes the lexeme made by removing its outer quotes.
Thus \TT{","} denotes the separator
\TT{,} and \TT{"",""} denotes the quoted string \TT{","}. [TBD]

If several different lexeme replacement definitions could be used to
replace lexemes at the beginning of a lexeme sequence, the topmost
definition in the parsing definition stack
(\secref{PARSING-DEFINITION-STACK}) is used.
If two replacement definitions in the same dictionary could be used,
the one with the longest {\em replaced-lexemes} is used.  It is an error if
two entries in the same dictionary have the same {\em replaced-lexemes}.

The following lexeme dictionaries and functions are
defined in the initial parsing definition stack.
Their definitions are ordered in the
stack so the first given below is at the top of the stack and is the
first that replaces lexemes.

\begin{list}{}{}

\item
\verb|define lexeme dictionary| \\
\verb|       English lexeme dictionary [operator list]|\\[1ex]
This dictionary translates common English irregular plurals,
to their singular form, and decomposes
irregular possessives to their singular decomposed form.
This dictionary also protects irregular singular forms that might be
mistaken for regular plural forms (e.g., `\TT{news}').
Some example translations are:

\begin{center}
\begin{tabular}{l}
\verb|people| $\longrightarrow$ \verb|[person]| \\
\verb|women| $\longrightarrow$ \verb|[woman]| \\
\verb|geese| $\longrightarrow$ \verb|[goose]| \\
\verb|fungi| $\longrightarrow$ \verb|[fungus]| \\
\verb|news| $\longrightarrow$ \verb|[news]| \\
\end{tabular}
\end{center}

\item
\verb|define lexeme function| \\
\verb|       English lexeme function [operator list]|\\[1ex]
This function translates common English standard plurals
to their singular form, and decomposes
standard possessives to their singular decomposed form.
Some example translations are:

\begin{center}
\begin{tabular}{l}
\verb|boys| $\longrightarrow$ \verb|[boy]| \\
\verb|boy's| $\longrightarrow$ \verb|[boy 's]| \\
\verb|boxes| $\longrightarrow$ \verb|[box]| \\
\end{tabular}
\end{center}

\end{list}

Because RECKON, outside the context of quotes,
insists on mapping different forms of a word to a single
word, some subtleties of language are lost.  For example, `\TT{people}'
can be a singular word referring to a group of people, but RECKON will
standardly confuse it with `\TT{person}'.

\subsection{Number Recognition}
\label{NUMBER-RECOGNITION}

Numeric lexemes are decimal numbers with an optional decimal point
or slash
and optional commas every 3 digits.  \ikey{Numbers}{number} are sequences of
lexemes that are identified during \key{lexical number parsing},
which is applied to the output of the lexeme replacement algorithm. 
When a number contains more than one lexeme, it is surrounded by
the implicit \TT{(\# \#)} brackets.

The following are the top level syntax equations for numbers.

\begin{indpar}
\emkey{number} ::= {\em real-number} $|$ {\em number-unit-group} \\[1ex]
\emkey{real-number} ::= {\em decimal-number} $|$ {\em radix-number}
				           $|$ {\em scientific-number}
				           $|$ {\em number-pair}
\end{indpar}%
\label{REAL-NUMBER}

Note that numbers are all unsigned.  Signs are all considered to
be arithmetic operators (except for exponent signs in
{\em scientific-numbers}).

\subsubsection{Decimal Numbers}
\label{DECIMAL-NUMBERS}

\ikey{Decimal numbers}{decimal number} are just number lexemes, which
are sequences of digits with optional commas and
an optional decimal point or slash.

\begin{indpar}
\emkey{decimal-number} \begin{tabular}[t]{rl}
                              ::= & {\em decimal-integer} \\
		              $|$ & {\em decimal-integer}\TT{.}%
		                    {\em decimal-fraction} \\
		              $|$ & \TT{.}{\em decimal-fraction} \\
		              $|$ & {\em decimal-numerator}\TT{/}%
		                    {\em decimal-denominator} \\
		              \end{tabular} \\[1ex]
\emkey{decimal-integer} ::= {\em decimal-natural}\pagref{DECIMAL-NATURAL}
\label{DECIMAL-INTEGER}
\\[1ex]
\emkey{decimal-fraction} \begin{tabular}[t]{rl}
                         ::= & {\em decimal-digits} \\
                         $|$ & {\em digit} {\em digit} {\em digit} \TT{,}
			       {\em decimal-digits}
			 \end{tabular}
\label{DECIMAL-FRACTION}
\\[1ex]
\emkey{decimal-numerator} ::= {\em decimal-natural}
\label{DECIMAL-NUMERATOR}
\\[1ex]
\emkey{decimal-denominator} ::= {\em decimal-natural}
\label{DECIMAL-DENOMINATOR}
\\[1ex]
\emkey{decimal-digits} ::= {\em digit} {\em digit}\,$^\star$
\end{indpar}

Decimal Number Examples:

\begin{indpar}[0.1in]
\tt
\begin{tabular}{l@{~~~}l@{~~~}l@{~~~}l@{~~~}l}
123	& 1,234		& 12,345	& 1,234,567 \\
123.0	& .123		& 0.0		& 1,234.987654	& 1,234.987,654 \\
1/2	& 134/874	& 1,345/3	& 1234/987654   & 1,234/987,645
\end{tabular}
\end{indpar}

In a number lexeme, and therefore in a {\em decimal-number},
a decimal point must be followed by
a digit, commas must be surrounded by digits, and slashes must be surrounded
by digits.

Some number lexemes are \skey{illegal decimal number}s, meaning
that they are number lexemes that cannot be converted to numbers.
A number lexeme with more than one decimal point, more than one
slash, or both a decimal point and a slash is illegal.
Commas are optional, but if present in a {\em decimal-fraction} or
{\em decimal-denominator}, they must also be used in any
{\em decimal-integer} or {\em decimal-numerator} that is part of the
same number lexeme.
In addition, commas if present must be located every 3 digits from the right
end of a {\em decimal-integer}, {\em decimal-denominator}, or
{\em decimal-numerator}, or from the left end of a {\em decimal-fraction}.
Lastly, a {\em decimal-denominator} may not be zero.
Failure to follow the rules of this paragraph will result in an
error when the lexeme is converted to a number,
but is \underline{not} an error of lexeme formation, and
is \underline{not} a parsing error.

The following are examples of illegal decimal numbers:

\begin{indpar}[0.1in]
\tt
\begin{tabular}{l@{~~~}l@{~~~}l@{~~~}l@{~~~}l}
1.2.3	& 1.86,54	& 1,234567.892	& 12345.678,92	& 1.234567,892 \\
3/4/5   & 3/0.5         & 1.45/3        & 1000/3,000    & 5/0
\end{tabular}
\end{indpar}

\subsubsection{Radix Number Recognition}
\label{RADIX-NUMBER-RECOGNITION}

\ikey{Radix-numbers}{radix-number} permit binary, octal, or hexadecimal
radi\-ces to the used instead of decimal.  In fact, other number representation
schemes are permitted.

\begin{indpar}[1em]
\emkey{radix-number} \\
	\hspace*{0.5in}::= {\em radix-indicator}
		        \TT{"} {\em radix-number-mark}
		        {\em radix-number-mark}\,$^\star$ \TT{"}
		        {\em exponent-option} \\[1ex]
\emkey{radix-indicator} ::= {\em symbol} {\em symbol}\,$^\star$ \\[1ex]
\emkey{radix-number-mark} ::= {\em character-representative}
~~~~~ [See Figure \figref{SPECIAL-CHARACTER-REPRESENTATIVES}] \\[1ex]
{\em exponent-option} ::= {\em empty} $|$ {\em exponent} \\[1ex]
{\em exponent} ::= see \pagref{EXPONENT}
\end{indpar}

A {\em radix-number} is thus a {\em radix-indicator} followed by
any quoted string followed optionally by an exponent.
Some examples of legal {\em radix-numbers}
using standard {\em radix-indicators} are:

\begin{indpar}[0.1in]
\tt
\begin{tabular}{@{}l@{~~~}l@{~~~}l@{~~~}l@{}}
B\#"10110100"	& O\#"7534201" & D\#"9758"	& X\#"E8A932B" \\
B\#"01101"	& O\#".7753"   & D\#"97.58"	& X\#".fe8a932b" \\
B\#"0,1101"	& O\#"2,3456"  & D\#".123,5"	& X\#"E8A,932B.7CCD,83" \\
\end{tabular}
\end{indpar}

The following {\em radix-indicators} are standard.

\begin{center}
\begin{tabular}{l@{~~~~~}l@{~~~~~}l@{~~~~~}l}
Radix	& Radix		 & Allowed Number	& Allowed Digits \\
Name	& Indicators     & Marks (Digits)	& Between Commas \\[1ex]
binary	& \tt b\#~~~B\#	 & \tt 0 1		& 3 or 4 \\
octal	& \tt o\#~~~O\#	 & \tt 0 1 2 3 4 5 6 7	& 3 \\
decimal	& \tt d\#~~~D\#	 & \tt 0 1 2 3 4 5 6 7 8 9
						& 3 \\
hexadecimal
	& \tt x\#~~~X\#	 & \tt 0 1 2 3 4 5 6 7 8 9
						& 4 \\
	&		 & \tt a b c d e f A B C D E F
\end{tabular}
\end{center}

Standard {\em radix-indicators} permit a single point, which must
be followed by a digit, or alternatively, a single slash, which must
be surrounded by digits.  Standard radix indicators also permit an
{\em exponent}, which has the same format as in a
{\em scientific-number} (\pagref{SCIENTIFIC-NUMBER}), and indicates
how to shift the point.
Standard {\em radix-indicator}
rules for comma location are the same as for {\em decimal-numbers}
(\secref{DECIMAL-NUMBERS}), except the number of digits between commas may
be 3 or 4, depending on the {\em radix-indicator}.  You cannot mix two
different inter-comma distances, i.e.~both 3 and 4,
in the same {\em radix-number}.

{\em Radix-numbers} may be nonconvertible to numbers.  Such are
called \skey{illegal radix number}s.  The following are some examples
using standard {\em radix-indicators}:

\begin{indpar}[0.1in]
\tt
\begin{tabular}{l@{~~~~~}l@{~~~~~}l@{~~~~~}l}
B\#"5,7b63"	& O\#"2/3.456"	& D\#"-0.1"	& X\#".E8A932B.7CCD"
\end{tabular}
\end{indpar}

When a {\em radix-number} is encountered during number parsing,
it is surrounded by \TT{(\# \#)} implicit brackets.  Thus if
\TT{B\#"10011"} is input to number parsing,
\TT{(\# B \# "10011" \#)} will be output.

{\em Radix-indicators} are defined by \skey{radix indicator definition}s:

\begin{indpar}
\ikey{radix-indicator-definition}{radix-indicator!definition} \\
	\hspace*{0.5in}::= \begin{tabular}[t]{@{}l@{}l@{}}
	                   \TT{define} & \TT{radix indicator}
                                            {\em radix-indicator}
					    {\em parsing-selectors} \\
	    			& \TT{with conversion function}
				    {\em function-name} \\
		     \end{tabular}
\label{RADIX-INDICATOR-DEFINITION}
		     \\[1ex]
\emkey{radix-indicator} ::= {\em name}
	\\[1ex]
{\em parsing-selectors} ::= see \pagref{PARSING-SELECTORS}
	\\[1ex]
{\em function-name} ::= {\em name}
	\\[1ex]
{\em name} ::= see \pagref{NAME}
\end{indpar}

Given such a definition, the defined {\em radix-indicator}
will be recognized as such whenever it is followed by a quoted
string in the input.

The conversion function is passed the quoted string from a
{\em radix-number} and the exponent if present, in that order,
as its arguments, and must return
either a number if conversion is successful, or an error message
otherwise.


\subsubsection{Scientific Number Recognition}
\label{SCIENTIFIC-NUMBER-RECOGNITION}

A {\em scientific-number} is a {\em decimal-number} or a {\em radix-number}
followed by an exponent.

\begin{indpar}
\emkey{scientific-number} \begin{tabular}[t]{rl}
                        ::= & {\em decimal-number} {\em exponent} \\
			$|$ & {\em radix-number} {\em exponent}
		        \end{tabular}
\\[1ex]
\emkey{exponent} ::= {\em exponent-indicator}
		   {\em exponent-sign-and-digits}
\label{EXPONENT}
\\[1ex]
\emkey{exponent-indicator} ::= \TT{e} $|$ \TT{E} \\[1ex]
\emkey{exponent-sign-and-digits} ::= {\em decimal-digits}
			    $|$ {\em sign} {\em decimal-digits}
\end{indpar}

The following are examples of legal {\em scientific-numbers} using
standard radix indicators:

\begin{indpar}[0.1in]
\tt
\begin{tabular}{l@{~~~}l@{~~~}l@{~~~}l}
123e0		& 123e+2	& 123e-321	& 1,234e9 \\
123E0		& 123E+2	& 123E-321	& 0.123,456e-3	\\
.123e0	& .123e+2
				& 0.123,456e-3 & 1,234.567890e6 \\
X\#"a9"e0	& B\#"1011"e-3	& O\#"0.7753"e-5
					    & X\#"0.FE8A,932B,E"e+5 \\
\end{tabular}
\end{indpar}

Note that exponents cannot contain commas.

The digits in an exponent are always decimal, even when the number has
a radix indicator such as \TT{B\#} or \TT{X\#} that indicates a different
radix.  However, the interpretation of the exponent depends upon the
radix indicator.  Standard radix indicators interpret the exponent as
multiplication by their radix to the exponent power.  Thus
\TT{B\#"1101"e-2} and \TT{B\#"11.01"} are both equal to \TT{3.25}.

When a {\em scientific-number} is encountered during number parsing,
it is surrounded by \TT{(\# \#)} implicit brackets.  Thus if
\TT{B\#"1101"e-2} is input to number parsing,
\begin{center}
\verb|(# (# B # "10011" #) e - 2 #)|
\end{center}
will be output.

An \key{illegal scientific number} is a {\em scientific number}
that cannot be converted to a number.  These include
{\em scientific numbers} whose number lexemes are illegal,
and {\em scientific numbers} with no or standard radix indicators
whose number lexemes contain a slash (\TT{/}).
The following are some examples of illegal scientific numbers:

\begin{indpar}[0.1in]
\tt
\begin{tabular}{l@{~~~}l@{~~~}l@{~~~}l@{~~~}l}
1,23e6	& 3/4e2	& B\#"5,7b63"e32  & O\#"2/3"e-2	& X\#".E.7"e-4
\end{tabular}
\end{indpar}

Scientific numbers are recognized after radix numbers have been
recognized.

\subsubsection{Number Pair Recognition}
\label{NUMBER-PAIR-RECOGNITION}

A \key{number pair} is a pair of {\em decimal-numbers}, the first
of which is in integer and the second of which is a fraction
containing a slash.

\begin{indpar}
\emkey{number-pair} ::= {\em decimal-integer}
		   {\em decimal-numerator}\TT{/}{\em decimal-denominator}
		   \\[1ex]
{\em decimal-integer} ::= see \pagref{DECIMAL-INTEGER} \\[1ex]
{\em decimal-numerator} ::= see \pagref{DECIMAL-NUMERATOR} \\[1ex]
{\em decimal-denominator} ::= see \pagref{DECIMAL-DENOMINATOR}
\end{indpar}

Some examples of number pairs are:

\begin{indpar}[0.1in]
\tt
\begin{tabular}{l@{~~~~~}l@{~~~~~}l@{~~~~~}l}
1 1/2	& 55 3/4	& 174 15/16  & 1,234,567 2,875/3,408
\end{tabular}
\end{indpar}

When a {\em number-pair} is encountered during number parsing,
it is surrounded by \TT{(\# \#)} implicit brackets and a \TT{+} is
inserted between its two parts.  Thus if
\TT{41 3/4} is input to number parsing,
\TT{(\# 41 + 3/4 \#)}
will be output.

A number pair is illegal if either of its two parts is illegal.

Number pairs are recognized after scientific numbers have been
recognized.

\subsubsection{Number Unit Grouping}
\label{NUMBER-UNIT-GROUPING}

A {\em number-unit-group} is a sequence of one or more {\em number-unit-pairs}
each of which consists of two lexemes: a {\em real-number}
and a {\em unit-specifier}.
The syntax equations are:

\begin{indpar}
\emkey{number-unit-group} ::= {\em number-unit-pair}
			    {\em number-unit-pair}\,$^\star$ \\[1ex]
\emkey{number-unit-pair} \begin{tabular}[t]{rl}
                     ::= & {\em prefix-unit-specifier} {\em real-number} \\
                     $|$ & {\em real-number} {\em postfix-unit-specifier} \\
		     \end{tabular} \\[1ex]
\emkey{prefix-unit-specifier} ::= {\em name} \\[1ex]
\emkey{postfix-unit-specifier} ::= {\em name} \\[1ex]
\emkey{unit-specifier} ::= {\em prefix-unit-specifier} $|$
                         {\em postfix-unit-specifier} \\[1ex]
{\em name} ::= see \pagref{NAME}
\end{indpar}

In order to be recognized as a {\em unit-specifier} a {\em symbol} sequence
must be defined as a {\em unit-specifier-name} by the following:

\begin{indpar}
\emkey{unit-specifier-definition} \\
	\hspace*{0.5in}::= \TT{define unit specifier}
	    \begin{tabular}[t]{l}
	    {\em unit-specifier-fixity} \\
	    {\em unit-specifier} {\em parsing-selectors}
	    \end{tabular}
\label{UNIT-SPECIFIER-DEFINITION}
	    \\[1ex]
\emkey{unit-specifier-fixity} ::= \ttkey{prefix} $|$ \ttkey{postfix}
	\\[1ex]
{\em parsing-selectors} ::= see \pagref{PARSING-SELECTORS}
\end{indpar}

The \key{number unit grouping} phase of
parsing recognizes {\em number-unit-groups} containing more than
one {\em number-unit-pair}, places
\TT{(\# \#)} implied brackets around them,
and places implied `\TT{+}' operators
between their {\em number-unit-pairs}.

For example, if `\TT{hr}' and `\TT{min}'
are {\em postfix-unit-specifiers},
`\TT{7 hr 30 min}' is a {\em number-unit-group} containing
2 {\em number-unit-pairs} that number unit grouping transforms into
\begin{center}
\verb/(# 7 hr + 30 min #)/
\end{center}
As another example,
if `\TT{ft}' and `\TT{in}' are {\em postfix-unit-specifiers},
`\TT{12ft 11 3/4in}' becomes
\begin{center}
\verb|(# 12 ft + (# 11 + 3/4 #) in #)|
\end{center}

Number unit groups are recognized after number pairs have been
recognized.

\subsubsection{Unit Multiplication Insertion}
\label{UNIT-MULTIPLICATION-INSERTION}

The \lkey{unit multiplication}{insertion} phase of
parsing inserts a multiplication operator lexeme, `\TT{*}',
before a {\em postfix-unit-specifier}, and
after a {\em prefix-unit-specifier}, unless the point at which the
`\TT{*}' is to be inserted is already occupied by a
`\TT{*}' or `\TT{/}' lexeme.  This is done after number unit
grouping (\secref{NUMBER-UNIT-GROUPING}).

For example, if `\TT{sec}', `\TT{ft}', and `\TT{lb}'
are {\em postfix-unit-specifiers},
then
\begin{indpar}\begin{verbatim}
some function ( 3 ft 2 1/4 in / sec,
                9 ft ^ 2 lb / sec,
                $3.50 )
\end{verbatim}\end{indpar}
becomes
\begin{indpar}\begin{verbatim}
some function ( (# 3 * ft + (# 2 + 1/4 #) * in #) / sec,
                9 * ft ^ 2 * lb / sec,
                $ * 3.50 )
\end{verbatim}\end{indpar}

Unit multiplication insertion is done after number unit groups have been
recognized.

\subsection{Expression Parsers}
\label{EXPRESSION-PARSERS}

An \key{expression parser} is a function which when called with
a subexpression returns the subexpression reformatted according to the
operators, sentence terminators, or similar things it finds in the
original subexpression.  The expression parser is called after
explicit subexpression recognition, lexeme replacement, and number
recognition have all been done, so the input subexpression is a sequence
of lexemes, explicit subexpressions, and implicit number subexpressions.
Note that number recognition is done regardless of the expression parser
used, e.g., even inside \TT{` '} quotes.

Expression parsers are defined by
\slkey{expression parser}{definition}s\label{EXPRESSION-PARSER-DEFINITION}.
The topmost active expression parser definition
(\pagref{ACTIVE-PARSING-DEFINITION})
in the parsing stack names the parser used to parse expressions.

Expression parser definitions have the syntax:

\begin{indpar}
\emlkey{expression-parser}{-definition} ::=\\
\hspace*{0.5in}\TT{define expression parser} {\em parser-name}
				               {\em parsing-selectors} \\[1ex]
\emkey{parser-name} ::= {\em name} \\[1ex]
{\em name} ::= see \pagref{NAME} \\[1ex]
{\em parsing-selectors} ::= see \pagref{PARSING-SELECTORS}
\end{indpar}

There are two standard \ikey{expression parsers}{parser!standard expression},
the \key{operator parser} and the \key{text parser}, that have the
definitions:

\begin{indpar}\begin{verbatim}
define expression parser -OPERATOR-PARSER- [operator]
define expression parser -TEXT-PARSER- [text]
\end{verbatim}\end{indpar}

The `\TT{operator}' selector makes the `operator' parser active,
and the `\TT{text}' selector makes the `text' parser active.
Both these parsers are similar, but they appear to behave
differently because the different selectors activate different
operator definitions.  Also the `text' parser recognizes
blank lines as implied paragraph operators in some circumstances,
whereas the `operator' parser does not.

\subsection{The Operator Parser}
\label{OPERATOR-PARSER}

The \key{operator parser} is an expression parser that uses
operators to restructure expressions.  Operators
are defined by operator definitions that can be added to the
parsing definition stack.  List separators, such as `\TT{,}', are treated
as operators, and have operator definitions.

\subsubsection{Operator Definitions}
\label{OPERATOR-DEFINITION}

An \key{operator definition} specifies for each operator the following:

\begin{indpar}[1in]
Name and Selectors \\
Precedence \\
Operator Flags \\
Reformatter \\
Evaluator
\end{indpar}

The syntax of operator definitions is:

\begin{indpar}
\emkey{operator-definition} \\
	\hspace*{0.5in}::= \ttkey{define operator}
	    \begin{tabular}[t]{@{}l@{}}
	    {\em operator-name} {\em parsing-selectors} \\
	    {\em operator-flag}\,$^\star$ \\
	    {}[ \TT{with precedence} {\em precedence} ] \\
	    {}[ \TT{with reformatter} {\em reformatter-name} ] \\
	    \end{tabular}
	    \\[1ex]
\emkey{operator-name} \begin{tabular}[t]{rl}
		    ::= & {\em simple-operator-name} \\
		    $|$ & \TT{bracket} {\em bracket-name} \\
		    $|$ & \TT{indentation mark} {\em indentation-mark-name}
		    \end{tabular}
		    \\[1ex]
{\em simple-operator-name} ::= {\em name}  [see \pagref{NAME}] \\[1ex]
{\em bracket-name} ::= see \pagref{BRACKET-NAME} \\[1ex]
{\em indentation-mark-name} ::= see \pagref{INDENTATION-MARK-NAME} \\[1ex]
\emkey{operator-flag} ::= \ttmkey{prefix}{operator flag}
                    $|$ \ttmkey{infix}{operator flag}
                    $|$ \ttmkey{postfix}{operator flag}
                    $|$ \ttmkey{nofix}{operator flag}
                    $|$ \ttmkey{afix}{operator flag}
	\\[1ex]
\emkey{precedence} ::= {\em sign-option} {\em decimal-natural}
	\\[1ex]
\emkey{sign-option} ::= {\em empty} $|$ \TT{+} $|$ \TT{-}
	\\[1ex]
\emkey{reformatter-name} ::= {\em function-name }
	\\[1ex]
\emkey{function-name} ::= {\em name}
	\\[1ex]
{\em name} ::= see \pagref{NAME}
\end{indpar}

A {\em simple-operator-name} is matched to lexemes in a subexpression
in order to identify occurrences of the operator.
The other forms of {\em operator-name} permit explicit subexpressions
with particular kinds of brackets to be parsed as if they were operators.
Thus in `\TT{x[5]=0}' the explicit subexpression
`\TT{[5]}' can be a postfix operator.  A subexpression
bracketed by `\TT{\{~\}}' is used as an afix (see below) to the
\TT{<--} operator (as is a subexpression introduced by the `\TT{:}'
indentation mark).

By abuse of language, the term `\key{operator}' is often used
as a synonym for `{\em operator-name}'.

Operators can have \skey{operator flag}s that
affect parsing of subexpressions of the operator.  The possible
flags are `\TT{infix}', `\TT{prefix}', `\TT{postfix}',
`\TT{nofix}', and `\TT{afix}'.  By default an operator is `\TT{nofix}'.

An \ttkey{infix} operator must be between two non-empty operands,
while a \ttkey{prefix} operator must precede a non-empty operand,
and a \ttkey{postfix} operator must follow a non-empty operand.

A \ttkey{nofix} operator is like an infix operator but may have
empty operands.  It may appear at the beginning or ending of
an expression, or two nofix operators may be consecutive.

An \ttkey{afix} operator is like a nofix operator but must follow
another operator in the expression that has the same
precedence.  Explicit subexpressions bracketed by `\TT{\{~\}}'
are standard afix operators with the same precedence
as the \TT{<--} operator, so that an expression such as:
\begin{center}
\verb|sum from X through Y <-- integer X, integer Y { ... }|
\end{center}
is parse as
\begin{center}
\verb|(sum from X through Y) <-- (integer X, integer Y) { ... }|
\end{center}
and \underline{not} as
\begin{center}
\verb|(sum from X through Y) <-- (integer X, integer Y { ... })|
\end{center}

Inside a subexpression (with brackets removed),
an operator can be prefix if it begins the subexpression,
or follows another operator that is not postfix.
An operator can be postfix if it ends the
subexpression or precedes another operator that is not prefix.  
An operator can be infix if it does not begin or end the subexpression,
follow an operator that is prefix,
or precede an operator that is postfix.

An\label{FIXITY-RULES}
operator cannot have two kinds of fixity at once, except that
a operator can be both prefix and infix, or both prefix and postfix.
An operator that can be prefix
and either postfix or infix is taken to be prefix if and only if it begins
a subexpression or follows an operator previously
determined in a left-to-right scan to be prefix, infix, nofix, or afix.

The {\em precedence} of an operator is an integer.  Precedence is used to
determine which operators are inside and outside implicit brackets.
Operators with higher precedence are placed inside the 
implicit brackets that surround operands of operators of lower precedence.

The precedence
in an operator definition applies only to the operator when it is used
as an infix, nofix, or afix operator; prefix and postfix operators are always
treated as having precedence higher than any infix, nofix, or afix operator.
If several prefix and postfix operators apply to a single operand,
the postfix operators are all inside the implicit brackets surrounding
the prefix operator operands (i.e., the postfix operators are
`executed first').  Thus `\TT{-x[1]}' is equivalent to `\TT{-(x[1])}'
(where `\TT{[1]}' is treated as a postfix operator).

The {\em reformatter-name} in an {\em operator-definition} names a
function that is called after all other parsing has been done to
reformat a subexpression whose first operator is the defined operator.
For example, given the expression `\TT{-x+6*y}', the subexpression
`\TT{6*y}' is extracted, and as its first operator is `\TT{*}',
the reformatter for that operator is called and yields `\TT{* 6 y}'.
Similarly the subexpression `\TT{-x}' is extracted but the reformatter
for `\TT{-}' does not change it.
Then the reformatter for `\TT{+}' is called
with `\TT{(|-x|)+(|* 6 y|)}', since `\TT{+}' is the first operator in
this subexpression \underline{after} subexpressions have been handled.
This reformatter returns `\TT{+ (|-x|) (|* 6 y|)}'.  Here we have
use parentheses \TT{(|~|)} to indicate implicit parentheses.


\subsubsection{Standard Operators}
\label{STANDARD-OPERATORS}

The following are the standard operators

\begin{center}

\begin{tabular}{rll@{\hspace*{2em}}l@{\hspace*{2em}}l}

precedence & reformatter	& type	& operator	& meaning 
\\[2ex]
-1000	& \ttkey{separator}	& \tt nofix	& \ttkey{;}	& separator \\
+0000	& \ttkey{define}	& \tt nofix	& \ttkey{<-{}-}	& define \\
	&			& \tt afix	& \ttkey{\TT{\{} \ldots \TT{\}}}
								& block \\
+1000	& \ttkey{assign}	& \tt infix	& \ttkey{=}	& assignment \\
     	&               	&          	& \ttkey{+=}	& increment \\
     	&               	&          	& \ttkey{-=}	& decrement \\
     	&               	&          	& \ttkey{*=}	& multiply by \\
     	&               	&          	& \ttkey{/=}	& divide by \\
+2000	& \ttkey{separator}	&		& \ttkey{,}	& separator \\
+3000	& \ttkey{logical}	& \tt nofix	& \ttkey{AND}	& logical and \\
	&			&		& \ttkey{OR}	& logical or \\
	&			&		& \ttkey{NOT}  & logical not \\
	&			&		& \ttkey{BUT}  & logical filler
								 \\
+4000 	& \ttkey{compare}	& \tt infix	& \ttkey{==}	& equal \\
	&			&		& \ttkey{/=}  & not equal \\
	&			&		& \ttkey{!=}	& ditto \\
	&		      	&		& \ttkey{<}	& less than \\
	&			&		& \ttkey{<=}	& less than or
								  equal \\
	&			&		& \ttkey{=<}	& ditto \\
	&		      	&		& \ttkey{>}	& greater than
									\\
	&			&		& \ttkey{>=}	& greater than
								  or equal \\
	&			&		& \ttkey{=>}	& ditto \\
+5000	& \ttkey{sum}		& \tt infix	&  \ttkey{+}	& addition \\
	&			&		& \ttkey{-}	& subtraction \\
+5100	& \ttkey{product}	& \tt infix	& \ttkey{/}	& division \\
+5200	& \ttkey{product}	& \tt infix	& \ttkey{*}
							& multiplication \\
+5300	& \ttkey{product}	& \tt infix	& \ttkey{\^~}
							& exponentiation \\
none	& none			& \tt prefix	&  \ttkey{-}	& minus \\
	& 			& \tt prefix	&  \ttkey{+}	& plus \\
	& 			& \tt prefix	&  \ttkey{@}	& object
	                                                          identifier \\
none	& \ttkey{subscript}	& \tt postfix	&  \ttkey{[...]}
								& subscript \\
\end{tabular}

\end{center}


Below be describe the effects of standard operator reformatters.
We use notation such as

\hspace*{2em}\begin{tabular}{lcl}
\verb|x = y = z + w| & $\Longrightarrow$ & \verb|= x ( = y (+ x w))| \\
\verb|x AND AND y| & $\Longrightarrow$ & error
\end{tabular}

Here $\Longrightarrow$ means `is reformatted as'.  Furthermore, the
parentheses introduced by the rewrite are \underline{implied},
which means that the lists they bracket have \underline{no}
\TT{.initiator} or \TT{.terminator}, and the parentheses are
merely written here to indicate sublists in the expression structure.

Reformatters can detect parsing errors, such the missing operand
in `\TT{x AND AND y}'.

Sometimes \ikey{temporaries}{temporary}\label{TEMPORARY}
are introduced by reformatting.  The syntax involving temporaries is:

\begin{indpar}
\emkey{temporary-definition} ::= {\em temporary} {\em subexpression} \\[1ex]
\emkey{temporary} ::= \TT{\$} {\em decimal-natural} \\[1ex]
{\em decimal-natural} ::= see \pagref{DECIMAL-NATURAL}
\end{indpar}

During reformatting, a subexpression may be replaced by
a {\em temporary-definition} containing the subexpression.  This
defines the {\em temporary} as a name for the value of the subexpression.
Then the {\em temporary} can be used in the reformatted
expression to refer to this value.  An example is

\begin{center}
\verb|x == y + 3 == z| ~~~ $\Longrightarrow$ ~~~
\verb|AND (== x ($ 563 (+ y 3))) (== ($ 563) z)|
\end{center}

Here the temporary has been used to avoid computing \TT{y + 3}
more than once.

The {\em decimal-naturals} in {\em temporaries} must be assigned so no
two {\em temporary-definitions} ever have the same {\em temporary}.

With these things in mind, the reformatters are:

\begin{indpar}[1em]

\newcommand{\OP}[1]{\ttmkey{#1}{reformatting}}
\newcommand{\NBOP}[1]{\ttmnbkey{#1}{reformatting}}

\bigskip

\ttmkey{separator}{reformatter} \hfill \OP{;} ~~~ \OP{,}

\begin{indpar}[0.5em]
Here `\TT{;}' or `\TT{,}' is the \key{separator}.  These have different
precedences, and so cannot appear together in the same expression.

A list of all between-separator subexpressions is made, with empty
between-separator subexpressions being represented by empty lists.
There will be at least two subexpressions: one following
the last separator and one preceding the first separator.
The list of subexpressions is given a
\ttmkey{.separator}{produced by parsing}
attribute with value of the separator (\TT{";"} or \TT{","}),
and is returned as the result of the reformatting.

The standard bracket reformatters will merge the returned list with
their brackets.  Thus given `\TT{(x,y)}', the `\TT{separator}'
reformatter will return
\begin{indpar}\begin{verbatim}
@1 = x y {| .separator = "," |}
\end{verbatim}\end{indpar}
so the input to the \TT{( )} reformatter will be
\begin{indpar}\begin{verbatim}
@2 = @1 {| .initiator = "("; .terminator = ")" |}
@1 = x y {| .separator = "," |}
\end{verbatim}\end{indpar}
and this reformatter will merge the two lists into one,
returning
\begin{indpar}\begin{verbatim}
@3 = x y :|
    .initiator = "("
    .terminator = ")"
    .separator = ","
\end{verbatim}\end{indpar}

\end{indpar}

\bigskip

\ttmkey{define}{reformatter} \hfill \OP{<-{}-} ~~~
	\OP{\{ \}} ~~~ \OP{:}

\begin{indpar}[0.5em]

There will be a \TT{<--} operator (the other operators are afix),
and it is a parsing error
detected by the reformatter if there is more than one.
The one \TT{<--} operator is moved to the front of the expression:

\hspace*{2em}\begin{tabular}{lcl}
\verb|x <-- y { z }| & $\Longrightarrow$ & \verb|<-- x y { z }| \\
\verb|x <-- { z }| & $\Longrightarrow$ & \verb|<-- x { z }| \\
\verb|x <--| & $\Longrightarrow$ & \verb|<-- x|
\end{tabular}

Indented subexpressions introduced by the \TT{:} indentation
mark are parsed like final \TT{\{ \}}
bracketed subexpressions.  Because they are afix operators with the
same precedence as \TT{<--},
`\TT{x <-- y { z }}' does \underline{not}
end up as `\TT{<-- x ( y { z } )}', and instead we get results like:

\hspace*{2em}\begin{tabular}{lcl}

\verb|x <-- u v w { z }| & $\Longrightarrow$ & \verb|<-- x ( u v w ) { z }|
\\[1ex]
\begin{tabular}{@{}l@{}}
\verb|x <-- u v w:| \\
\verb|    z|
\end{tabular}
& $\Longrightarrow$ &
\begin{tabular}{@{}l@{}}
\verb|<-- x ( u v w ):| \\
\verb|    z|
\end{tabular}

\end{tabular}


\end{indpar}

\bigskip


\ttmkey{assign}{reformatter} \hfill \OP{=} ~~~ \OP{+=} ~~~ \OP{-=}
				           ~~~ \OP{*=} ~~~ \OP{/=}

\begin{indpar}[0.5em]
If there is only one operator, it is simply moved to the front.  If there
are several, they are rewritten as one operator subexpressions so the
rightmost executes first.

\hspace*{2em}\begin{tabular}{lcl}
\verb|y = z| & $\Longrightarrow$ & \verb|= y z| \\
\verb|x = y = z| & $\Longrightarrow$ & \verb|= x (= y z)| \\
\verb|x += y *= z| & $\Longrightarrow$ & \verb|+= x (*= y z)|
\end{tabular}
\end{indpar}

\bigskip

\ttmkey{logical}{reformatter} \hfill \NBOP{AND} ~~~ \NBOP{OR} ~~~ \NBOP{NOT}
							      ~~~ \NBOP{BUT}

\begin{indpar}[0.5em]
If there is only one operator and it is at the beginning of the expression,
then the expression is not changed.  It is a reformatter detected parsing
error if this operator is \TT{BUT}, or if the operator is \TT{NOT}
and there are zero or more than one operand.

Otherwise if the expression has only \TT{AND} or only \TT{OR} operators
the expression is rewritten with the operator at the beginning.  It is
a reformatter detected error if there are missing operands, either between
operators, before the first operator, or after the last operator.  Thus:

\hspace*{2em}\begin{tabular}{lcl}
\verb|x AND y| & $\Longrightarrow$ & \verb|AND x y| \\
\verb|x AND y AND z| & $\Longrightarrow$ & \verb|AND x y z| \\
\verb|x OR y| & $\Longrightarrow$ & \verb|OR x y| \\
\verb|x OR y OR z| & $\Longrightarrow$ & \verb|OR x y z| \\
\verb|AND y AND z| & $\Longrightarrow$ & error \\
\verb|x AND AND z| & $\Longrightarrow$ & error \\
\verb|x AND y AND| & $\Longrightarrow$ & error \\
\end{tabular}

Otherwise the expression must have the operator sequence `\ttnbkey{BUT NOT}'
and one of the forms:

\hspace*{2em}\begin{tabular}{l}
$e_1$ \TT{BUT NOT} $e_3$ \\
$e_1$ \TT{BUT NOT} $e_3$ \TT{OR} $e_4$ \TT{OR} \ldots{} \\
$e_1$ \TT{AND} $e_2$ \TT{AND} \ldots{} \TT{BUT NOT} $e_3$ \\
$e_1$ \TT{AND} $e_2$ \TT{AND} \ldots{} \TT{BUT NOT}
$e_3$ \TT{OR} $e_4$ \TT{OR} \ldots{} \\
\end{tabular}

There can be \TT{AND}'s before the \TT{BUT NOT} and \TT{OR}'s after
the \TT{BUT NOT},
but there must be at least one operand before the \TT{BUT NOT}
and at least one after.  These expressions are rewritten using prefix
\TT{AND} and \TT{NOT} operators:

\hspace*{2em}\begin{tabular}{lcl}
\verb|x BUT NOT v| & $\Longrightarrow$ & \verb|AND x (NOT v)| \\
\verb|x AND y BUT NOT v| & $\Longrightarrow$ & \verb|AND x y (NOT v)| \\
\verb|x BUT NOT v OR w| & $\Longrightarrow$ & \verb|AND x (NOT v) (NOT w)| \\
\verb|x AND y BUT NOT v OR w|
    & $\Longrightarrow$ & \verb|AND x y (NOT v) (NOT w)| \\
\end{tabular}

All other forms of expression are reformatter detected parsing errors.

Note that \TT{NOT} is not a classical prefix operator, which would have
higher priority than \TT{=} or \TT{<}.  Also note that \TT{AND}
and \TT{OR} may not be used in the same logical expression without using
explicit brackets, unless there is a \TT{BUT NOT}.  Thus:

\hspace*{2em}\begin{tabular}{lcl}
\verb|x AND y OR z| & $\Longrightarrow$ & error \\
\verb|x AND NOT y| & $\Longrightarrow$ & error \\
\verb|x AND NOT v OR w| & $\Longrightarrow$ & error \\
\verb|NOT x < y| & $\Longrightarrow$ & \verb|NOT (x < y )| \\
\end{tabular}
\end{indpar}

\bigskip

\ttmkey{compare}{reformatter} \hfill
	\OP{=} ~~~ \OP{<} ~~~ \OP{>} ~~~
	\OP{/=} ~~~ \OP{!=} ~~~
	\OP{=>} ~~~ \OP{>=} ~~~
	\OP{=<} ~~~ \OP{<=}

\begin{indpar}[0.5em]
The expression is rewritten using a multi-argument \TT{AND}
function and two-argument compare functions.  Temporaries
(\pagref{TEMPORARY})
are used to name intermediate expression values to
avoid recomputing arguments.

\hspace*{2em}\begin{tabular}{lcl}
\verb|x < y < z| & $\Longrightarrow$ &
    \verb|AND (< x ($ 56 y)) (< ($ 56) z))| \\[1ex]
\verb|w == x != y <= z| & $\Longrightarrow$
             & \begin{tabular}[t]{@{}l@{~}l@{}}
	       \verb|AND| & \verb|(== w ($ 57 x))| \\
			  & \verb|(!= ($ 57) ($ 58 y))| \\
			  & \verb|(<= ($ 58) z)| \\
	       \end{tabular}
\end{tabular}

Note that sequences of comparison operators are treated as they are
in mathematics and not as they are in classical programming languages.
E.g., \TT{x<y<z} means \TT{x<y AND y<z} and \underline{not}
\TT{(x<y)<z}.
\end{indpar}

\bigskip

\ttmkey{sum}{reformatter} \hfill \OP{+} ~~~ \OP{-}

\begin{indpar}[0.5em]
The results are rewritten using the multi-argument summation function \TT{+}
and the unary negation function \TT{-}.

\hspace*{2em}\begin{tabular}{lcl}
\verb|x - y + z - w| & $\Longrightarrow$ & \verb|+ x (- y) z (- w)|
\end{tabular}
\end{indpar}

\bigskip

\ttmkey{product}{reformatter} \hfill \OP{/} ~~~ \OP{*}
					      ~~~ \OP{\^~}

\begin{indpar}[0.5em]
These different operators, \TT{/}, \TT{*}, and \TT{\^~},
have different precedences and therefore
cannot be mixed in the same expression.  There may not be more than one
\TT{/} or \TT{\^~} operator in the expression.
The results are rewritten using
the multi-argument multiplication function \TT{*},
the binary division function \TT{/}, 
or the binary exponentiation function \TT{\^~}. 
E.g.:

\hspace*{2em}\begin{tabular}{lcl}
\verb|x * y * z| & $\Longrightarrow$ & \verb|* x y z| \\
\verb|x / y| & $\Longrightarrow$ & \verb|/ x y| \\
\verb|x ^ y| & $\Longrightarrow$ & \verb|^ x y| \\
\verb|x / y / z| & $\Longrightarrow$ & error \\
\verb|x ^ y ^ z| & $\Longrightarrow$ & error \\
\end{tabular}

\end{indpar}

\bigskip

\ttmkey{subscript}{reformatter} \hfill \OP{[~...~]}

\begin{indpar}[0.5em]
The expression is rewritten using the binary subscript function:

\hspace*{2em}\begin{tabular}{lcl}
\verb|x[y]| & $\Longrightarrow$ & \verb|subscript x y| \\
\end{tabular}

\end{indpar}


\end{indpar}


\subsubsection{The Operator Parser Algorithm}
\label{OPERATOR-PARSER-ALGORITHM}


The operator parser uses an input list which it initializes to the parser's
input argument, and an output list which is initially
empty.  The parser executes a parsing loop that removes lexemes
from the beginning of the input list and adds lexemes and subexpressions
to the end of the output list.  When the parser terminates, the output
list becomes the returned parsed expression.

The operator parser has a helper function that is called with
a single optional argument called the \key{terminating precedence}.
The helper function parses an initial segment of the input list,
discards this segment from the input list, and returns the parsed
result of this segment as the helper function value.
The initial segment is terminated by the end of the input list,
or by an operator whose precedence
is equal to or less than the terminating precedence argument.

The parser proper does nothing but execute the helper function with
a terminating precedence lower than that of any operator.

The operator helper function has an output list which it initializes
to be empty and into which it copies lexemes and subexpressions.
Some of these may be operators.
Operators in the output list are identified when they are moved from beginning
of the input list to the end of the output list.
The first such operator in the output list is called the \key{lead operator},
and its definition is called the \key{lead operator definition}.
This definition provides things like reformatters and evaluators when
the output list is viewed as an expression.

The helper function uses an operation called \lkey{reformatting}{the
output list}.  This consists of calling the reformatter of the lead
operator definition, and replacing the output list with the reformatter's
returned value.  If there is no lead operator, nothing is done.

The helper function also
uses an operation called \key{compacting a list}.
If the list contains zero or just one element, nothing is done.  Otherwise
the list is replaced by a one element list whose only element is
the previous list.

In reading the following algorithm, it may be useful to recall that an
operator can have only one fixity, prefix, postfix, infix, nofix, or afix,
except for the case of a prefix operator, which can also be either infix
or postfix (but not both) (see \pagref{FIXITY-RULES}).

After initializing its the output list to empty,
the helper function executes a \key{parsing loop} that repeats the
following iteration:

\begin{enumerate}

\item The beginning of the input list is inspected to see if it
begins with an active operator (i.e., an operator with an active
operator definition in the parsing stack).  Afix operators are ignored.
If more than one active operator qualifies, the operator whose definition
is nearest the top of the parsing definition stack is selected
(even if it is shorter than the other operator).
If the input list is empty, it does not begin with an operator.

\item If the input list does not begin with a active operator,
and the list is not empty, the lexeme or subexpression at the
beginning of the input list is moved to the end of the output list, and
the parsing loop iterates.

\item If the input list is not empty, it begins with an active operator.
The \mkey{operator fixity}{in parsing loop}
and \mkey{operator precedence}{in parsing loop} are determined as follows:

\begin{enumerate}

\item If the output list is empty, and the operator can be prefix
or nofix, the operator fixity is prefix if the operator can be prefix,
or nofix otherwise (the operator cannot be both prefix and nofix).

\item If the output list is empty
and the operator cannot be prefix or nofix, then an error operand
is inserted into the output list, a parsing error is announced, and
the operator fixity is determined by the following.

\item If the output list is non-empty and the operator can be postfix,
infix, or nofix, the operator fixity is postfix if the operator can
be postfix, infix if the operator can be infix, or nofix if the operator
can be nofix (the operator cannot be more than one of these fixities).

\item If the output list is non-empty
and the operator cannot be postfix, infix, or nofix,
then an error nofix operator is inserted at the \underline{beginning}
of the \underline{input list}, a parsing error is announced,
and the fixity is set to nofix.

\item The operator precedence is set to the precedence
in the active operator definition if the active operator fixity
is infix or nofix,
and is otherwise the error precedence if the operator is an error
nofix operator, the prefix precedence if the operator fixity is
prefix, or the postfix precedence if the operator fixity is
postfix.

\end{enumerate}

\item If the input list is empty, or if
a terminating precedence argument was given, the operator fixity is
not prefix, and the operator precedence
is equal to or less than the terminating precedence argument,
the parsing loop and helper function terminate.
Nothing is removed from the input list.  The output list is reformatted
and returned as the value of the helper function.

\item If the output list is non-empty, it
is reformatted and compacted (becoming the
first operand of the active operator that is infix or nofix, or
the only operand of an active operator that is postfix).
Note that because of what happens below, the output list cannot
consist of one element that is an operator.

\item The operator is removed from the input list and copied
to the output list.  The operator will be the first
operator in the output list, and therefore
becomes the lead operator of the output list.

\item
If the operator fixity is prefix, infix, or nofix, then
a \key{parsing subloop} that repeats the following iteration is executed:

\begin{enumerate}

\item The parsing helper is called with
the operator precedence as its terminating precedence argument.

\item If the returned parsed expression is the empty list, and
the operator fixity is prefix or infix, the returned parsed expression is
replaced by an error operand, and a parsing error is announced.

\item The returned parsed expression is compacted, and then it
is added by concatenation to the end of the output list (thus
zero or one element is added to the output list).

\item If the operator fixity is prefix, or if
the input list now begins with a active operator that cannot be
infix, nofix, or afix, or that has a precedence below the
operator precedence,
the parsing subloop terminates and the parsing loop iterates.

\item The input list must now begin with an infix, nofix, or
afix active operator whose precedence equals the operator precedence.
That operator is moved from the input list to the output list,
and the parsing subloop iterates.

\end{enumerate}

\end{enumerate}

\subsection{Text Parsing}
\label{TEXT-PARSING}

Text parsing is similar to operator parsing except that brackets and
most operators are `named'.
For example, `\TT{<p>}' is a standard paragraph operator,
and `\TT{<indented p>}' is a standard paragraph operator
that is a child of `\TT{<p>}'
and inherits attributes from `\TT{<p>}'.  As another example,
`\TT{<b|} \ldots{} \TT{|b>}' are standard `bold' brackets.

The named text brackets and operators
have the syntax:

\begin{indpar}
\emkey{named-operator} ::=
    \TT{<} {\em text-type} {\em arguments-option} {\em labels-option} \TT{>}
    \\[1ex]
\emkey{named-left-bracket} ::=
    \TT{<} {\em text-type} {\em arguments-option} {\em labels-option} \TT{|}
    \\[1ex]
\emkey{named-right-bracket} ::=
    \TT{|} {\em text-type} {\em arguments-option} {\em labels-option} \TT{>}
    \\[1ex]
{\em text-type} ::= {\em name}
    \\[1ex]
{\em arguments-option} ::= {\em empty} $|$ \TT{(} {\em argument-list} \TT{)}
    \\[1ex]
{\em argument-list} ::= {\em empty}
                    $|$ {\em argument} \{ \TT{,} {\em argument} \}$^\star$
    \\[1ex]
{\em argument} ::= {\em name} $|$ {\em number} $|$ {\em quoted-string}
    \\[1ex]
{\em labels-option} ::= {\em empty} $|$ \TT{:} {\em label}
				\{ \TT{,} {\em label} \}$^\star$
    \\[1ex]
{\em label} ::= {\em name}
    \\[1ex]
{\em name} ::= see \pagref{NAME}
    \\[1ex]
{\em number} ::= see \pagref{NUMBER}
    \\[1ex]
{\em quoted-string} ::= see \pagref{QUOTED-STRING}
\end{indpar}

The names of text brackets and operators are
referred to as `\skey{text type}s'.  For example, `\TT{<p>}' is a text
operator of text type `\TT{p}', and `\TT{<b|}~\ldots~\TT{|b>}'
are text brackets of text type `\TT{b}'.
Text types have attributes
such as `\TT{style}', `\TT{weight}', `\TT{indent}', and `\TT{adjust}',
that are used to format the text for printing and display.
For example `\TT{b}' has a the `\TT{weight}' attribute value
`\TT{heavy} and `\TT{n}', as in
`\TT{<n|}~\ldots~\TT{|n>}',
has a `\TT{weight}' attribute value `\TT{normal}'.

Text types
can also inherit attributes from other text types.  To facilitate this
there are also virtual text types that are never used in the text,
but can be ancestors of other text types and serve as repositories of
attributes.  Lastly it is possible to give several names to the same
text type, and to give names to attribute values (e.g., `\TT{default style}'
is a standard name for a `\TT{style}' attribute value).

If a text type has no value for an attribute, or has the value
`\ttmkey{none}{text attribute value}', a piece of text of that type
has no value for the attribute, and
gets the attribute value if it needs it from the surrounding text, or from an
\mkey{initial value}{for text attribute}
for the attribute if there is no surrounding text.
Thus since `\TT{p}' has no `\TT{weight}' attribute value, surrounding a
paragraph by `\TT{<b|}~\ldots~\TT{|b>}' produces a bold paragraph,
and not surrounding a paragraph by text with any `\TT{weight}' attribute
gets the initial `\TT{weight}' attribute, which is `\TT{normal}'.

Although there are many
standard text types, each with standard attributes, a large piece of
text typically defines new types specific to that text and resets some
attributes of the standard types in a way specific to the particular
text.

Text surrounded by named brackets like `\TT{<b|}~\ldots~\TT{|b>}'
is converted by the text parser
into a list which has the \ttdkey{text-type} and \ttdkey{label}
extra attributes supplied by the named brackets.
Similarly text prefaced by a named operator like `\TT{<p>}'
is converted to such a list.  So, for example, the text

\begin{indpar}\begin{verbatim}
<p>
This is a <b|bold|b> sentence.
\end{verbatim}\end{indpar}

is converted by the text parser to

\begin{indpar}\begin{verbatim}
@1 = @2 {| .text-type = p |}
@2 = this is a @3 sentence :|
    .text-type = s
    .initiator = capital 
    .terminator = "."
@3 = bold {| .text-type = b |}
\end{verbatim}\end{indpar}

Here the named operator `\TT{<p>}' prefaces the text included in \TT{@1},
the unnamed operator `\TT{.}' ends the text included in \TT{@2},
and the named brackets `\TT{<b|}~\ldots~\TT{|b>}' surround the text
included in \TT{@3}.  The unnamed operator `\TT{.}' terminates
a piece of text that is assigned the `\TT{s}' text type,
the `\TT{capital}' \TT{.initiator}, and
the `\TT{.}' \TT{.terminator}.  Here the text type `\TT{s}' denotes
a `sentence', and the result would be the same if
the named operator `\TT{<s>}' were explicitly included just before
`\TT{This}', as in

\begin{indpar}\begin{verbatim}
<p>
<s> This is a <b|bold|b> sentence.
\end{verbatim}\end{indpar}

A piece of text can be given a {\em label} by including the {\em label}
in the named bracket or named operator which gives the piece of text
its text type.
These labels are internal to the document, and not printed.
They are used to create references from one place in the document to
another.  For example:

\begin{indpar}\begin{verbatim}
<p: porch definition>
. . . <b: porch|porch|b> . . .
. . . . . . . . .
. . . <r|porch|r> . . .
. . . . . . . . .
. . . <r|porch definition|r> . . .
. . . . . . . . .
\end{verbatim}\end{indpar}

in which the \TT{<r|  |r>} bracketed {\em labels} are references
to the labeled bold text and labeled paragraph.  For convenience
`\TT{<k|}{\em text}\TT{|k>}' can be used to abbreviate
`\TT{<b:} {\em text}\TT{|}{\em text}\TT{|b>}', for example,
`\TT{<k|porch|k>}' could be used above instead of
`\TT{<b: porch|porch|b>}' (the text type `\ttmkey{k}{text type}'
denotes a `keyword').


The text parser converts text into a list whose elements are lexemes
and sublists, where in general each sublist has elements that are
lexemes and sublists.
The text types end up as \ttdkey{text-type}
attributes of these lists and sublists.
Similarly {\em labels} included in named brackets
or named operators end up as \ttdkey{label}
attributes.  Operators frequently cause additional reformatting
of the parse output.  {\em Arguments} in named operators and
brackets are passed to reformatters which use them to control
the reformatting and may insert them as various attributes in the
parsed output.  As an example, the text

\begin{indpar}\begin{verbatim}
<section(1)|A Section Header|>
<p>
<s: HERE>An important sentence.
Another sentence.
\end{verbatim}\end{indpar}

is converted by the text parser to

\begin{indpar}\begin{verbatim}
@1 = @3 :|
    .text-type = section
    .level = 1
    .title = @2
@2 = A Section Header
@3 = @4 @5 {| .text-type = p |}
@4 = an important sentence :|
    .text-type = s
    .label = HERE
    .initiator = capital 
    .terminator = "."
@5 = another sentence :|
    .text-type = s
    .initiator = capital 
    .terminator = "."
\end{verbatim}\end{indpar}

Here the entire bracketed subexpression
`\TT{<section(1)|} \ldots{} \TT{|>}'
also is the lowest precedence operator which reformats everything that
follows (and in general everything following up to the next operator of
equal or lower precedence or a closing outer bracket) into a single list.
It attaches the bracketed text to this list as the \TT{.title} attribute.
Also the `\TT{<section>}' operator is programmed to attach its argument,
`\verb|1|' in this case, to the list as the \TT{.level} attribute

In general named operators can be used in bracketed form to attach
a bracketed expression as a \TT{.title} attribute to the same text
the operator attaches its \TT{.text-type} to.  In general some
named operators or brackets are programmed to take arguments which
they may use to control formatting or compute text attribute values
(such as \TT{.level} in this example).

Note that closing brackets may omit their name, as `\TT{|>}' does
when it closes `\TT{<section(1)|}' in this example.  Its also allowed to
use either an initial or final segment of the name in a closing
named bracket, as in `\TT{<bold italic|} \ldots{} \TT{|bold>}'
or `\TT{<bold italic|} \ldots{} \TT{|italic>}'.
Arguments may be given in either the opening or closing bracket of a named
bracket, but if given in both, must be identical in both.  E.g.,
\begin{center}
\verb/<section(1)|/ \ldots{} \verb/|section>|/ \\
\verb/<section|/ \ldots{} \verb/|section(1)>|/ \\
\verb/<section(1)|/ \ldots{} \verb/|section(1)>|/ \\
\end{center}
are all acceptable and equivalent, but
\begin{center}
\verb/<section(1)|/ \ldots{} \verb/|section(2)>|/
\end{center}
is illegal.


In the above example,
`\TT{<p>}' is a higher precedence operator than `\TT{<section>}', and
`\TT{<s>}' is higher precedence than `\TT{<p>}'.  Also the sentence
terminator `\TT{.}' has the same precedence as `\TT{<s>}' and these
operators work together to form sentences.  The `\TT{<s>}' operator
is optional and is only given in the example in order to assign a \TT{.label}
attribute to the first sentence.  The second sentence has its `\TT{<s>}'
operator omitted.

Some text operators do \underline{not} set the \TT{.text-type} attribute,
but instead set only a \TT{.separator} attribute.  The `\TT{,}'
operator is an example.  Thus the text

\begin{indpar}\begin{verbatim}
this is, certainly, a phrase
\end{verbatim}\end{indpar}

is converted by the text parser to

\begin{indpar}\begin{verbatim}
@1 = @2 certainly @3 {| .separator = "," |}
@2 = this is
@3 = a phrase
\end{verbatim}\end{indpar}

Because the reformatted expression in this case is a list with
no \TT{.text-type} attribute, it can be assigned a \TT{.text-type}
attribute by a text operator of precedence lower than the
precedent of `\TT{,}'.  Thus the text

\begin{indpar}\begin{verbatim}
<p>
this is, certainly, a phrase
<p>
This is, certainly, a sentence.
\end{verbatim}\end{indpar}

is converted by the text parser to

\begin{indpar}\begin{verbatim}
@1 = @2 @6
@2 = @3 certainly @4 :|
    .separator = ","
    .text-type p
@4 = this is
@5 = a phrase
@6 = @7 {| .text-type p |}
@7 = @8 certainly @9 :|
    .separator = ","
    .initiator = capitalize
    .terminator = "."
    .text-type s
@8 = this is
@9 = a sentence
\end{verbatim}\end{indpar}

Unnamed brackets, namely
`\TT{(} \ldots{} \TT{)}',
`\TT{[} \ldots{} \TT{]}', and
`\TT{\{} \ldots{} \TT{\}}',
produce bracketed subexpressions just as they do for other
parsers.  Thus the text

\begin{indpar}\begin{verbatim}
the book (Bartholomew 2043) previously mentioned
\end{verbatim}\end{indpar}

is converted by the text parser to

\begin{indpar}\begin{verbatim}
@1 = the book @2 previously mentioned
@2 = Bartholomew 2043 :|
    .initiator = "("
    .terminator = ")"
\end{verbatim}\end{indpar}

If you want to eliminate spacing where it would normally occur,
you can use \skey{glue bracket}s, `\TT{<g|} \ldots{} \TT{|g>}',
which can also be implied by the absence of spacing in the input.
Thus

\begin{indpar}\begin{verbatim}
the book[Bartholomew 2043] previously mentioned
\end{verbatim}\end{indpar}

is equivalent to

\begin{indpar}\begin{verbatim}
the <g|book[Bartholomew 2043]|g> previously mentioned
\end{verbatim}\end{indpar}

and both are converted by the text parser to

\begin{indpar}\begin{verbatim}
@1 = the @2 previously mentioned
@2 = book @3 {| .text-type = g |}
@3 = Bartholomew 2043 :|
    .initiator = "["
    .terminator = "]"
\end{verbatim}\end{indpar}

\subsubsection{Standard Text Operators}
\label{STANDARD-TEXT-OPERATORS}

The following are the standard text operators

\begin{center}

\begin{tabular}{rl@{\hspace*{2em}}l@{\hspace*{2em}}l}

precedence & reformatter	& operator	& meaning 
\\[2ex]
-10000+100$n$
	& \ttkey{text-prefix}	& \tttkey{section($n$)}
						& section header \\
-1100	& \ttkey{text-prefix}	& \tttkey{tr}	& table row \\
-1000	& \ttkey{text-prefix}	& \tttkey{ti($m$,$n$)}	& table item \\
-500	& \ttkey{text-prefix}	& \tttkey{li}	& list item \\
0	& \ttkey{text-prefix}	& \tttkey{p($i$)}	& paragraph \\
100	& \ttkey{sentence}	& \tttkey{s}	& sentence \\
	&			& \ttkey{.}	& sentence terminator \\
	&			& \ttkey{!}	& sentence terminator \\
	&			& \ttkey{?}	& sentence terminator \\
200	& \ttkey{text-separator}
				& \ttkey{;}	& subsentence separator \\
	&			& \ttkey{:}	& subsentence separator \\
300	& \ttkey{text-separator}
				& \ttnbkey{--}	& phrase separator \\
	& 			& \ttnbkey{---}	& phrase separator \\
400	& \ttkey{text-separator}
				& \ttkey{,}	& phrase separator \\
\end{tabular}

\end{center}


\begin{indpar}[1em]

\newcommand{\OP}[1]{\tttmkey{#1}{reformatting}}

\bigskip

\ttmkey{text-prefix}{reformatter} \hfill \OP{section($n$)}
~~~ \OP{tr} ~~~ \OP{ti($m$,$n$)}
~~~ \OP{li} ~~~ \OP{p}

\begin{indpar}[0.5em]
These operators have different
precedences, and so cannot appear together in the same expression.

The expression must have the form
\begin{center}
\{ {\em operator} {\em subexpression} {\em subexpression}$^\star$ \}$^\star$
\end{center}

That is, {\em operators}
(e.g., `\TT{<p>}') must begin the expression and may
not be consecutive or end the expression.  Each operator and the
{\em subexpressions} following it are reformatted into a list whose
\TT{.text-type} attribute is given by the operator.  If there is one
{\em operator}, this reformatted list becomes the reformatted expression.
If there is more than one, a list of these reformatted lists
becomes the reformatted expression.

The list of {\em subexpressions} following an {\em operator} is parsed as
an expression.  The result is then converted to a list with no
\TT{.text-type} attribute; if it is not already such, it is made
the sole element of a new list.  Then the \TT{.text-type} and \TT{.label}
attributes of this list are set from the {\em operator} and the result
is the reformatted list for that {\em operator}.

If the operator brackets text, that text becomes the \TT{.title} attribute
value of the reformatted list.

The `\TT{<section>}'
operator takes an additional argument $n$ (default \TT{0})
which becomes the \TT{.level} attribute of the reformated list.  Also,
$100n$ is added to the precedence of the operator.

The `\TT{<ti>}' table item
operator takes an additional arguments $m$ and $n$ (defaults \TT{1} and
\TT{1})
which become the \TT{.rows} and \TT{.columns} attributes, respectively,
of the reformated list.  These specify that the table item is to span
$m$ rows and $n$ columns.  $m$ can be omitted, as in \TT{<ti(}$n$\TT{)>}.

The `\TT{<p>}'
operator takes an additional argument $i$ (default \TT{0})
which becomes the \TT{.indent} attribute of the reformated list.  This
specifies that the entire paragraph is to be indented.

[TBD: maybe not the \TT{.indent} attribute.]

\end{indpar}

\bigskip

\ttmkey{sentence}{reformatter} \hfill \OP{s} ~~~ \ttmkey{.}{reformatting}
					     ~~~ \ttmkey{?}{reformatting}
					     ~~~ \ttmkey{!}{reformatting}

\begin{indpar}[0.5em]

The expression must have the form
\begin{center}
\{ \TT{<s>}{\em -option} {\em subexpression} {\em subexpression}$^\star$
	{\em terminator} \}$^\star$
\end{center}
where the {\em terminator} is one of `\ttmkey{.}{terminator}',
`\ttmkey{?}{terminator}', or `\ttmkey{!}{terminator}'.

That is, it must consist of a sequence of `\skey{sentence}s' each beginning
with an optional `\TT{<s>}', each ending with one of the {\em terminators},
and each being non-empty otherwise.  Each sentence is reformatted into
a list whose \TT{.text-type} is `\ttmkey{s}{\tt .text-type}', whose
\TT{.initiator} may be `\ttmkey{capitalize}{\tt .text-type}', and whose
\TT{.terminator} is the {\em terminator} at the end of the sentence.
If there is just one sentence, its reformatted list becomes the
reformatted expression.  If there
is more than one, a list of these reformatted sentence lists
becomes the reformatted expression.

The list of {\em subexpressions} in a sentence is parsed as
an expression.  The result is then converted to a list with no
\TT{.text-type}, \TT{.initiator}, or \TT{.terminator} attributes;
if it is not already such, it is made
the sole element of a new list.  Then the \TT{.text-type} attribute
of this list is set to `\TT{s}', the \TT{.label}
attribute of this list is set to any value provided by
an optional `\TT{<s:} {\em label\,}\TT{>}' {\em operator},
and the
\TT{.terminator} is set to the {\em terminator}.
If the first element of the list is a capitalized word, it is decapitalized
and the list \TT{.initiator} is set to `\TT{capitalize}'.
This list is then the reformatted list for the sentence.

\end{indpar}

\bigskip

\ttmkey{text-separator}{reformatter} \hfill \ttmnbkey{--}{reformatting}
				   ~~~ \ttmnbkey{---}{reformatting}
				   ~~~ \ttmkey{,}{reformatting}
				   ~~~ \ttmkey{;}{reformatting}
				   ~~~ \ttmkey{:}{reformatting}

\begin{indpar}[0.5em]
Here `\TT{--}' (or `\TT{---}'),
`\TT{,}', and `\TT{;}' (or `\TT{:}') have different
precedences, and so cannot appear together in the same expression.

The expression must have the form
\begin{center}
\{ {\em subexpression} {\em subexpression}$^\star$
	{\em operator} \}$^\star$
{\em subexpression} {\em subexpression}$^\star$
\end{center}
where all the {\em operators} must be the same (i.e., if you
mix `\TT{;}' and `\TT{:}'
or `\TT{--}' and `\TT{---}' in the same expression, the expression
will be declared illegal by the reformatter).

That is, the expression
must consist of a sequence of non-empty {\em subexpression} lists
separated by {\em operators}.  The entire expression is reformatted as
a list whose
\TT{.separator} is the {\em operator}.  The elements of this list
are the lists that are the {\em subexpressions} between operators,
though if there
is only one {\em subexpression} between two operators, it becomes an
element of the final list.

\end{indpar}


\end{indpar}

\subsubsection{Standard Text Brackets}
\label{STANDARD-TEXT-BRACKETS}

\begin{center}

\begin{tabular}{l@{\hspace*{2em}}l}

bracket	& meaning 
\\[2ex]
\tttbkey{b} & boldface text (heavy weight) \\
\tttbkey{n} & normal text (normal weight) \\
\tttbkey{i} & italic text (TBD) \\
\tttbkey{r} & roman text (TBD) \\
\tttbkey{em} & emphasized text (TBD) \\
\tttbkey{table} & table (TBD) \\
\tttbkey{list} & list (TBD) \\
\tttbkey{g} & glued text (TBD) \\
\end{tabular}

\end{center}

\subsubsection{Text Mark Attributes}
\label{TEXT-MARK-ATTRIBUTES}

OBSOLETE - incorporate into above

\ikey{Text parsing}{text parsing} is performed by the \ttkey{-TEXT-PARSER-},
which is the parser for subexpressions of the
\TT{`}...\TT{'}, etc. matchfix operators.
The \TT{|} format separator and sentence and paragraph ends are
recognized by text processing, while
operators, qualifiers, qualifier shortcuts, and
the \TT{::?}, \TT{<:>}, \TT{::>}, \TT{@@}, and
\TT{??} marks are \underline{not} recognized.

Text parsing is normally done in the context of a pair of matched
{\em quotes}, and in this context {\em white-space} pre-lexemes
become lexemes.  Note that {\em white-space} lexemes all consist
of zero or more {\em vertical space} characters followed by zero or
more {\em single-space} characters (reference: TBD: make white space
lexemes sometimes?).
There are three kinds of {\em white-space} lexemes
used by text parsing:

\begin{list}{}{}

\item[{\bf Spacer Lexemes}.]
A \key{spacer} lexeme is a {\em white-space} lexeme containing
only single spaces.  Spacers are used in text parsing if they follow
a \TT{|} format separator on a line.

\item[{\bf Line Separator Lexemes}.]
A \key{line separator} lexeme is a {\em white-space}
lexeme that contains a single {\em line-feed} character and no other
{\em vertical-space} characters.  Such lexemes separate
non-blank lines, and are used by text parsing to end lines containing
a \TT{|} format separator.

\item[{\bf Blank Line Lexemes}.]
A \key{blank line} lexeme is a {\em white-space}
lexeme that contains either two or more {\em line-feed} characters or contains
a {\em vertical-space} character that is not a {\em line-feed} character.
Such lexemes
represent blank lines between non-blank lines, and are used by text parsing
both to end lines containing a \TT{|} format separator and
to separate paragraphs.

\end{list}

\subsubsection{Section, Paragraph, and Sentence Parsing}
\label{SECTION-PARAGRAPH-AND-SENTENCE-PARSING}

OBSOLETE - incorporate into above

If the text being parsed does not contain any format separators,
the text is parsed into phrases, sentences, and paragraphs.

First the text is divided by blank line lexemes into paragraphs.
The sequence of paragraphs comprises a section.

Then in each paragraph, sentence terminators are located.
White-space lexemes in the paragraph are deleted after sentence terminators
are located.
Each sequence
of lexemes or subexpressions ending in a sentence terminator
is made into a sentence, and any
non-empty sequence
of lexemes or subexpressions following the last sentence terminator
is made into a phrase.
The paragraph is then a sequence of zero or more sentences 
possibly followed by a phrase.  However, a paragraph cannot be empty.

The syntax of the result is:

\begin{indpar}
\emkey{section} ::= \TT{[-SECTION-} {\em paragraph} {\em paragraph}\,$^\star$
                  \TT{]} \\[1ex]
\emkey{paragraph}
	\begin{tabular}[t]{rl}
	::= &  \TT{[-PARAGRAPH-} {\em sentence} {\em sentence}\,$^\star$
	       \TT{]} \\
	$|$ &  \TT{[-PARAGRAPH-} {\em sentence}\,$^\star$ {\em phrase}
	       \TT{]}
	\end{tabular} \\[1ex]
\emkey{sentence} ::= \TT{[-SENTENCE-} {\em sentence-non-terminator}\,$^\star$
                                    {\em sentence-terminator}
                  \TT{]} \\[1ex]
\emkey{phrase}
	\begin{tabular}[t]{rl}
	::= &  \TT{[} \begin{tabular}[t]{@{}l@{}}
			{\em sentence-non-terminator}
			{\em sentence-non-terminator} \\
		        {\em sentence-non-terminator}\,$^\star$ \TT{]}
			\end{tabular} \\
	$|$ &  {\em sentence-non-terminator}
	\end{tabular} \\[1ex]
\emkey{sentence-terminator} ::= \TT{.} $|$
                              \TT{?} $|$
                              \TT{!} \\[1ex]
\emkey{sentence-non-terminator} ::= {\em symbol} $|$
                                  {\em subexpression}
\end{indpar}

Note that a {\em phrase} with more than one {\em sentence-non-terminator}
is a list, but a {\em phrase} with just one {\em sentence-non-terminator}
is not a list, but just the single {\em sentence-non-terminator} by itself.

There are several rules that modify the description just given:

{\bf Sentence Terminator Rule.}\index{Sentence Terminator Rule}
A \key{sentence-terminator} is any lexeme that is syntactically
a sentence terminator, that is not preceded by a {\em white-space}
lexeme, and that is followed by a {\em white-space} lexeme, a
{\em closing-mark} lexeme, or the
end of the lexeme sequence.  All other lexemes and all subexpressions are
\skey{sentence-non-terminator}s.

{\bf Initial Capitalization Rule.}\index{Initial Capitalization Rule}
A {\em word} consisting of an initial capital letter followed
by zero or more lower case letters is converted
to an all lower case word if it begins a sentence.
A {\em word} consisting of an initial
\ttkey{\^~} followed by an upper
case letter followed by zero or more lower case letters has the
initial \TT{\^~} removed.

{\bf Text Simplification Rule.}\index{Text Simplification Rule}
If the \TT{-TEXT-PARSER-} is to return a {\em section} with just
one {\em paragraph} and that {\em paragraph} contains nothing but
just one {\em sentence} or {\em phrase},
then just the {\em sentence} or {\em phrase} is returned.
Otherwise, if a {\em section} with just one {\em paragraph} is
to be returned, just the {\em paragraph} is returned.


Some examples follow:

\begin{center}
\begin{tabular}{lcl}

\verb|`the wife of Bob'|
& parses as &
\verb|[-PHRASE- the wife of Bob]|
\\[2ex]
\verb|`She hit the ball.'|
& parses as &
\verb|[-SENTENCE- she hit the ball .]|
\\[2ex]
\begin{tabular}{@{}l@{}}
\verb|`^Bill swung.| \\
\verb|  But he missed!'|
\end{tabular}
& parses as &
\begin{tabular}{@{}l@{}}
\verb|[-PARAGRAPH-| \\
\verb|    [-SENTENCE- Bill swung .]| \\
\verb|    [-SENTENCE- but he missed !]]|
\end{tabular}
\\[5ex]
\begin{tabular}{@{}l@{}}
\verb|`^I liked| \\
\verb|  the party.| \\
\verb|| \\
\verb|  Later, we caught| \\
\verb|  the bus.'|
\end{tabular}
& parses as &
\begin{tabular}{@{}l@{}}
\verb|[-SECTION-| \\
\verb|   [-PARAGRAPH-| \\
\verb|      [-SENTENCE-| \\
\verb|          I liked the party .]]| \\
\verb|   [-PARAGRAPH-| \\
\verb|      [-SENTENCE-| \\
\verb|          later , we caught| \\
\verb|                  the bus .]]]| \\
\end{tabular}

\end{tabular}
\end{center}

Note that capitalized words like proper names and `\TT{I}' need to be
prefixed by `\TT{\^~}' if they begin a sentence or phrase.


\subsubsection{Text with Format Separators}
\label{TEXT-WITH-FORMAT-SEPARATORS}

TBD

\subsection{The Parsing Algorithm}
\label{THE-PARSING-ALGORITHM}
Parsing is done by a recursive descent left-to-right algorithm.
A parser is called to parse each subexpression.  This parser is
given the following explicit arguments:

\begin{center}
\begin{tabular}{l}
a list of lexemes to parse \\
an optional (closing) bracket definition \\
an optional (terminating) operator precedence \\
\end{tabular}
\end{center}

The bracket definition, if given, specifies a closing bracket
which must appear in the list of lexemes.  When the parser
finds this bracket outside other brackets, the parser terminates
the parse.

The operator precedence, if given, specifies that infix or
nofix operators of this and lower precedence will terminate the parsing if
they are encountered in the list of lexemes.

In addition the parser is given the following implicit
arguments:

\begin{center}
\begin{tabular}{l}
the parsing definition stack \\
the parsing selector set stack
\end{tabular}
\end{center}

The parser returns

\begin{center}
\begin{tabular}{l}
the parsed expression \\
the unparsed final segment of the input lexeme list
\end{tabular}
\end{center}

When parsing is terminated by finding a closing bracket matching
the closing bracket definition argument, then the part of the
input lexeme list after this closing bracket is returned as the
unparsed final segment of the input lexeme list.  When parsing is
terminated by finding a terminating operator of precedence equal to or lower
than an operator precedence argument, the part of the input
lexeme list beginning with this terminating operator is returned as the
unparsed final segment of the input lexeme list.  Otherwise the
returned unparsed final segment of the input lexeme list is empty.

There are two standard kinds of parser: the operator parser
and the text parser.  These use somewhat different algorithms.

\subsubsection{The Text Parser}
\label{TEXT-PARSER}

The text parser divides the input into paragraphs that are separated by
blank lines.

Paragraphs are classified as tabular or free-form according
to whether their first line is a tabular format line.
A \key{tabular format line} contains optional whitespace characters,
followed by a `\ttmnbkey{+}{in tabular format line}', followed
by any number of `\TT{+}' or
`\ttmnbkey{-}{in tabular format line}' characters,
followed by a `\TT{+}' that ends the line, except that superfluous
whitespace characters are allowed after the `line ending' {\tt+}.
An example of a tabular paragraph is:


\begin{indpar}\begin{verbatim}
+------------------------+--------+------+
 ice melt                 40 lbs    $4.50
 2x4's, 8ft               10       $27.70
 16d nails                 2 lbs     3.21
\end{verbatim}\end{indpar}


A paragraph that is not tabular is \ikey{free-form}{paragraph}.
Each free-form paragraph is scanned for explicitly bracketed subexpressions,
phrase separators, and sentence terminators.  The paragraph is divided into
sentences using sentence terminators outside brackets, and each sentence
is given \TT{<* *>} implicit brackets.
Each sentence is then divided into
phrases if it has any phrase separators, and 



\section{Expression Evaluation}
\label{EXPRESSION-EVALUATION}

An expression is evaluated by first searching for an expression definition
that matches the expression.  Expression definitions have patterns that
are matched to the expression.  An expression definition may have
guards, which are expressions that must evaluate to true in order for
the expression definition match to succeed, and an expression definition
may have constraint equations, which match subexpressions to patterns or
to each other.
An expression definition may have an expression block that executes
in order to produce a value list for the expression if the definition
matches.  If a matching
expression definition has no expression block, the expression
evaluates to `\ttkey{true}'.  If no expression definition matches an
expression, the expression evaluates to `\ttkey{false}'.

Expression definitions are searched for in a context, which is a list
of expression definitions and pointers to other contexts.
Each point in the program has a lexical context, which is used by default
for expression evaluation. 
By default expressions are evaluated in the
lexical context of the place in the program code where the expression
appears.  In addition, there may be other
contexts in which expressions may be evaluated that effectively implement
either data bases or alternative programming languages.

When an expression definition is found whose pattern matches an expression,
a set of constraints are established that must be satisfied to
complete the match.  There are five kinds of constraints: syntax
equations, pattern equations, default equations, alternative
equations, and guards.
Syntax equations equate expressions that involve syntax variables,
which are names beginning with a \TT{\$} followed by a capital letter.
Pattern equations are like syntax equations but
involve a pattern which can represent one of many possible syntax
expressions.  Default equations assign values to syntax variables that are
discarded when a pattern is unfolded to become the syntax expression
it will actually represent.  Alternative equations specify alternatives
for simple atomic clauses that may be in a pattern.
Guards are just expressions that must evaluate to
\TT{true} in order for the match to succeed.

The syntax equations are solved during the matching process,
to produce values for the syntax variables.  Patterns are unfolded during
the matching process to become the syntax expressions they represent.
Guards are evaluated, and in some cases the value of a syntax variable
value is evaluated.
If the syntax equations or pattern equations are inconsistent and
cannot be solved, or if a guard or syntax variable value that must be
evaluated cannot be evaluated, or if a guard evaluates to \TT{false},
the match fails.  Evaluation of the guards or syntax variable values
may result in additional matches which generate more
constraints involving more syntax variables.

The matching process must consider all possible choices of which definitions
to match to an expression being evaluated.  If all choices fail, the
expression evaluates to \TT{false}.  If only one choice succeeds, that
choice is used to evaluate the expression.  If several choices succeed,
the situation becomes ambiguous, and the evaluation proceeds according
to the matching mode, as is described below
(\secref{MATCHING-ALGORITHM}).

A syntax variable name beginning with
\ttmnbkey{\$}{in syntax variable name} denotes an unevaluated
expression.  The same name without the \TT{\$} denotes the value
of this unevaluated expression when it is evaluated
in the context in which the unevaluated expression appears.
This last value is called the `\key{evaluation}' of the unevaluated
expression.  Thus, for example, \TT{\$X} denotes an unevaluated
expression and \TT{X} denotes the evaluation of that expression.

As an example, given the syntax equation
\begin{center}
\verb|foo(2+2) :=: foo($X)|
\end{center}
(where \TT{:=:} means `is syntactically equal to'), we get
the syntax equation
\begin{center}
\verb|2+2 :=: $X|
\end{center}
that defines \TT{\$X}.  If there is then a guard `\TT{number(X)}',
the expression \TT{\$X}, namely `\TT{2+2}',
will be evaluated in its context, the context in which `\TT{foo(2+2)}'
appeared, to produce the value \TT{4}, which will become the value of
\TT{X}, so the guard will become `\TT{number(4)}'.

An expression cannot be evaluated if it contains any undefined syntax
variables.  For example, if we began with the syntax equation
\begin{center}
\verb|foo(2+$Y) :=: foo($X)|
\end{center}
and guard `\TT{number(X)}', \TT{\$X} would be `\TT{2+\$Y}' which
could not be evaluated.  If at some later time in the matching process
the syntax equation
\begin{center}
\verb|$Y :=: 7|
\end{center}
is generated, then the value of \TT{\$X} becomes `\TT{2+7}'
which can now be evaluated to produce the value \TT{9} for \TT{X}
and allow the guard to become `\TT{number(9)}'.

In the above \TT{\$X} is an `unevaluated syntax variable' and
\TT{X} is its `associated' `evaluated syntax variable'.  It is
possible to use \TT{X} in a definition where \TT{\$X} is actually
meant, but if that is done once, then it must be done for every occurrence
of \TT{\$X} in the definition, and the only computation that may be
performed on the (unevaluated) value of \TT{\$X} is to evaluate it to
produce a value for \TT{X}.

Except for choices of which definitions to match to which expressions,
the entire matching process is monotonic.  This means the order in which
syntax equations are solved, patterns are unfolded, guards are evaluated,
and unevaluated syntax variable values are evaluated does not matter.

In order to make the matching process monotonic, pattern unfolding must
be monotonic.  This means that if undefined syntax variables in a pattern
equation whose pattern has been unfolded are given arbitrary values later,
the pattern unfolding must still be valid and unambiguous.

Similarly guard evaluations must not have side effects.  In other
words, evaluating a guard cannot affect any future valuations.
Side effects can only occur during block execution, so any blocks
executed during the guard evaluation process must not have side effects.

Lastly, required evaluations of unevaluated syntax variable values
must be monotonic.  For example, given the syntax variable \TT{\$X},
if the value of \TT{X} is required, the evaluation of the value of
\TT{\$X} must be monotonic.
In order to ensure this, an unevaluated expression is not evaluated until
all syntax variables it contains have been given values, so that
the expression to be evaluated does not contain any undefined syntax
variables.  Furthermore, evaluation of such an expression may not have
side effects.  Again this last means that any blocks executed during
the evaluation of the expression must not have side effects.
If an evaluation is needed, but the expression to be evaluated contains
a syntax variable that never becomes defined,
then the matching process fails for the expression definition, just as it
would if a guard evaluated to false.

\subsection{Expression Definitions}
\label{EXPRESSION-DEFINITION}

\ikey{Expression definitions}{expression definition} have the syntax:

\begin{indpar}
\emkey{expression-definition} ::=
	{\em pattern} \TT{<--} {\em constraint-list-option} {\em block-option}
	\\[1ex]
{\em pattern} ::= \TT{<--}{\em -subexpression}
	~~~ [see {\em O-subexpression}, \pagref{O-SUBEXPRESSION}] \\[1ex]
{\em pattern} ::= {\em pattern-object}
	~~~ [see \pagref{PATTERN-OBJECT}] \\[1ex]
\emkey{constraint-list-option} ::= {\em empty} $|$ {\em constraint-list} \\[1ex]
\emkey{constraint-list}
    ::= {\em constraint} \{ \TT{,} {\em constraint} \}$^\star$ \\[1ex]
\emkey{constraint} ::= \TT{,}{\em -subexpression}
	~~~ [see {\em O-subexpression}, \pagref{O-SUBEXPRESSION}] \\[1ex]
\emkey{constraint} ::= {\em syntax-equation}
		       \begin{tabular}[t]{@{}l@{}}
		       $|$ {\em pattern-equation} $|$ {\em default-equation} \\
		       $|$ {\em alternative-equation} $|$ {\em guard}
		       \end{tabular} \\[1ex]
\emkey{syntax-equation} ::= {\em syntax-expression}
		\TT{:=:} {\em syntax-expression}
	        ~~~ [see \pagref{SYNTAX-EQUATIONS}]
	 	\\[1ex]
\emkey{pattern-equation} ::= {\em syntax-expression}
		\TT{:=\~~} {\em constraint-pattern}
	        ~~~ [see \pagref{PATTERN-EQUATIONS}]
		\\[1ex]
{\em constraint-pattern} ::= {\em pattern-object}
	~~~ [see \pagref{PATTERN-OBJECT}] \\[1ex]
\emkey{default-equation} ::= {\em syntax-variable}
		\TT{:=?} {\em syntax-expression}
	        ~~~ [see \pagref{DEFAULT-EQUATIONS}]
		\\[1ex]
\emkey{alternative-equation} ::= \\
\hspace*{3em}{\em syntax-variable}
		\TT{:=:} {\em alternative}
		          \TT{|} {\em alternative}
			  \{ \TT{|} {\em alternative} \}$^\star$
	                  ~~~ [see \pagref{ALTERNATIVE-EQUATIONS}]
		\\[1ex]
\emkey{alternative} ::= {\em atom} {\em atom}$^\star$
		\\[1ex]
\emkey{guard} ::= \TT{,}{\em -subexpression}
	~~~ [see {\em O-subexpression}, \pagref{O-SUBEXPRESSION}] \\[1ex]
\emkey{block-option} ::= {\em empty} $|$ \TT{\{ \}} $|$ {\em block} \\[1ex]
\emkey{block} ::= \TT{\{} {\em statement}
                           \{ \TT{;} {\em statement} \}$^\star$ \TT{\}}
	    \\[1ex]
{\em statement} ::= see \pagref{STATEMENT}
\end{indpar}

The \mkey{pattern}{in expression definition} of an expression definition
is the subexpression before the \TT{<--}.  If the expression definition
with pattern $p$ is being matched to the expression $e$,
the pattern equation $p$ \TT{:=\~~} $e$ is asserted, the
constraint syntax and pattern equations in the definition
are asserted, and the definition guards are required to evaluate
to \TT{true}.  Default equations are asserted as necessary.

Just before an expression definition is matched to an expression, the
definition is copied, and the act of copying 
creates a new set of variables that are distinct from any
previous variables.  Thus if \TT{\$X} appears in a definition, each
use of the definition will involve a \underline{different}
variable named \TT{\$X}.

\subsection{Syntax Equations}
\label{SYNTAX-EQUATIONS}

Although pattern equations are asserted before syntax equations are asserted,
a knowledge of syntax equations is required to understand pattern
equations.

A \key{syntax equation} asserts syntactic identity between two
\skey{syntax expression}s.  A syntax expression is a syntax variable,
an atom, or an object whose attribute values are syntax expressions.
The syntax of a syntax equation is:

\begin{indpar}
\emkey{syntax-equation} ::= {\em syntax-expression} \ttnbkey{:=:}
			    {\em syntax-expression}
			    \\[1ex]
\emkey{syntax-expression} ::= {\em syntax-variable}
			   $|$ {\em atom} $|$ {\em object}
			   \\[1ex]
\emkey{syntax-variable}\label{SYNTAX-VARIABLE}
			\begin{tabular}[t]{rl}
			::= & \TT{\$} {\em capitalized-word } \\
			$|$ & \TT{\$} \TT{(} {\em capitalized-word }
			      {\em name-component}\,$^\star$ \TT{)} \\
			$|$ & {\em place-holding-syntax-variable}
			    ~~~ [see \secref{PLACE-HOLDING-SYNTAX-VARIABLES}] \\
			$|$ & {\em evaluated-syntax-variable}
			    ~~~ [see \secref{EVALUATED-SYNTAX-VARIABLES}] \\
			\end{tabular} \\[1ex]
{\em name-component} ::= see \pagref{NAME-COMPONENT}
\end{indpar}

Syntax equations can be consistent or inconsistent according to the:

\begin{indpar}
\begin{list}{}{}
\item[\ikey{Consistency Rule}{consistency rule}:]
A syntax equation is \key{consistent} if it
\begin{enumerate}
\item asserts identity between a syntax variable and a syntax expression, or
\item asserts identity between two identical atoms, or
\item asserts identity between two objects each of which has the same
attribute labels as the other, and all the attributes in both objects
have exactly one value.
\end{enumerate}
However, this rule is applied after applying the Parentheses
and Atom Rules below.

Syntax equations that are not consistent are \key{inconsistent}.
\end{list}
\end{indpar}

The following rules amend the above process of consistency checking:

\begin{indpar}
\begin{list}{}{}
\item[\ikey{Parentheses Rule}{parentheses rule}:]\label{PARENTHESES-RULE}
An object whose \TT{.initiator} is \TT{"("} and whose
\TT{.terminator} is \TT{")"} is treated as if it had no
\TT{.initiator} or \TT{.terminator} attributes.
Also, a syntax variable name in \TT{( )} parentheses is treated
as if there were no parentheses.

\item[\ikey{Atom Rule}{atom rule}:]\label{ATOM-RULE}
In a syntax equation asserting the identity of an atom and an object,
the atom is treated as if it were an object that has
no attributes except one list element equal to the atom.
\end{list}
\end{indpar}

Thus the following identities are consistent:

\begin{center}
\begin{tabular}{r@\TT{~:=:~}l}
\verb/5 + 6/ & \verb/( 5 + 6 )/ \\
\verb/5/ & \verb/( 5 )/ \\
\verb/($X)/ & \verb/{ 5 + 6 }/ \\
\end{tabular}
\end{center}

From a consistent syntax equation asserting the syntax identity
of two objects new equations may be deduced for every attribute
label shared by the two objects.
Given such an attribute label, the values
of the attribute for the two objects are asserted to be syntactically
identical.  This is called \key{propagation}
of the syntax equation, and the rule that permits it is called
the \ikey{Propagation Rule}{propagation rule}\label{PROPAGATION-RULE}.
For example, from

\begin{center}
\verb/sort ($X) {| foo = 5 |} :=: sort ( 5 + 6 ) {| foo = 10 |}/
\end{center}

we can deduce by propagation that

\begin{center}
\begin{tabular}{r@\TT{~:=:~}l}
\verb/sort/ & \verb/sort/ \\
\verb/($X)/ & \verb/( 5 + 6 )/ \\
\verb/5/ & \verb/10/
\end{tabular}
\end{center}

The deduced equations need not be consistent in order to be deduced.
In this case the first two equations are consistent and the third is not.

In addition to the Propagation Rule, we apply the following, where
$v$ is a variable and $e_1$ and $e_2$ are subexpressions of the original
syntax equations:

\begin{indpar}
\begin{list}{}{}
\item [\ikey{Restricted Symmetry Rule}{restricted!symmetry rule}:]%
\label{RESTRICTED-SYMMETRY-RULE}
From $e_1$ \TT{:=:} $v$ we deduce $v$ \TT{:=:} $e_1$.

\item [\ikey{Restricted Transitivity Rule}{restricted!transitivity rule}:]%
\label{RESTRICTED-TRANSITIVITY-RULE}
From $v$ \TT{:=:} $e_1$ and $v$ \TT{:=:} $e_2$
we deduce $e_1$ \TT{:=:} $e_2$.
\end{list}
\end{indpar}

We have now given all the deduction rules used to solve syntax equations.
Note that these rules do \underline{not} create new syntax expressions:
all the syntax expressions in any deduced equation were subexpressions
in previous equations.  Because of this,
an algorithm that keeps making deductions until
no new deductions can be made will stop fairly quickly.

Note, however, that two different subexpressions
are not necessarily \TT{:=:} even if they are syntactically the same.
For example, given the original syntax equation:

\begin{center}
\verb/sort ($X, $Y) :=: sort ( 5, 5 )/
\end{center}

we derive by propagation that

\begin{center}
\begin{tabular}{r@\TT{~:=:~}l}
\verb/sort/ & \verb/sort/ \\
\verb/,/ & \verb/,/ \\
\verb/$X/ & \verb/5/$^1$ \\
\verb/$Y/ & \verb/5/$^2$ \\
\end{tabular}
\end{center}

where we have put superscripts $^1$ and $^2$ on the two \TT{5}'s to
indicate that they are different subexpressions of the original
syntax equation expressions.  But
but we are \underline{not} permitted to apply transitivity
to deduce \TT{\$X := \$Y},
because the two \TT{5}'s are not the \underline{same} subexpression of
the original syntax equation expressions.

However, we do make \TT{:=:} different subexpressions
that are variables with the same name.

\begin{quote}

As a technical matter we note that if we did use unrestricted rules
of symmetry, and transitivity, we would not get any essentially new results.
Specifically, the set of variables $v$ for which there is an equation of the
form $v$ \TT{:=:} $e$ where $e$ is not a variable would not expand.  Here
we assume that the original equations and all equations deduced from
these by Propagation, Restricted Symmetry, and Restricted Transitivity are
consistent.

Proof Sketch: Let $S$ be the original set of syntax equations.  Let $S'$ be
$S$ plus the equations deducible from equations in $S$ by using Propagation,
Restricted Symmetry, and Restricted Transitivity.

Let $S''$ be the set of equations $e_1$ \TT{:=:} $e_n$
such that there exists a sequence of expressions $e_2$, $e_3$,
\ldots, $e_{n-1}$ that are \underline{not} variables such that for $i<n$,
either $e_i$ \TT{:=:} $e_{i+1}$
or $e_{i+1}$ \TT{:=:} $e_i$ is in $S'$.  $n=2$ is allowed.

Let $S'''$ be $S$ plus
the equations deducible from $S$ by Propagation, Symmetry,
and Transitivity, without any restriction.

Then $S\subseteq S'\subseteq S''\subseteq S'''$.

If we can prove that
$S''=S'''$, the result will follow, since for a given $v$ an equation
of the form $v$ \TT{:=:} $e$ with $e$ a non-variable can exist in $S''$ only
if an equation of this form exists in $S'$.

So we need to prove $S'''\subseteq S''$.  We do this by mathematical
induction on the size of the deduction of an equation in $S'''$.
This amounts to applying the general rules, Symmetry, Transitivity,
and Propagation to equations in $S''$ and showing that the resulting
consequent must be an equation in $S''$, under the assumption that the
equations in $S'$ are consistent.

\end{quote}

\subsection{Patterns}
\label{PATTERNS}
\label{PATTERN-EQUATIONS}

A \emkey{pattern} is an object that represents one of
a set of syntax expressions.  Patterns are used in
{\em pattern-equations}, which identify a {\em syntax-expression} with
a {\em pattern}.  The syntax of a pattern equations and patterns is:

\begin{indpar}
\emkey{pattern-equation} ::= {\em syntax-expression} \ttnbkey{:=\~~}
			    {\em pattern}
			    \\[1ex]
\emkey{pattern} ::= {\em pattern-object}
\label{PATTERN}
\\[3ex]
\emkey{pattern-object} ::=
    \begin{tabular}[t]{l}
    {\em pattern-term-option}
        \{ {\em pattern-separator} {\em pattern-term} \}$^\star$ \\
    {\em pattern-attribute-representations}
    \end{tabular}
\label{PATTERN-OBJECT}
    \\[1ex]
\emkey{pattern-term-option} ::= {\em empty} $|$ {\em pattern-term} \\[1ex]
\emkey{pattern-separator} ::= \ttmkey{.}{pattern separator} \\[1ex]
\emkey{pattern-term} ::= {\em pattern-clause} {\em pattern-qualifier-option}
	\\[1ex]
\emkey{pattern-clause} ::= {\em pattern-factor} {\em pattern-factor}\,$^\star$
	\\[1ex]
\emkey{pattern-factor} ::= {\em pattern-object} $|$ {\em atom}
		       $|$ {\em syntax-variable} \\[1ex]
\emkey{pattern-qualifier-option} ::=
	{\em empty} $|$ {\em pattern qualifier} \\[1ex]
\emkey{pattern-qualifier} ::=
		           \ttmkey{?}{pattern qualifier}
		       $|$ \ttmkey{??}{pattern qualifier}
		       $|$ \ttmkey{...}{pattern qualifier}
		       $|$ \ttmkey{...?}{pattern qualifier}
	\\[1ex]
\emlkey{pattern-attribute-}{representations}
\\\hspace*{0.5in}
	\begin{tabular}[t]{rl}
        ::= & {\em empty} \\
	$|$ & \TT{\{| |\}} \\
	$|$ & \TT{\{|}
	      \begin{tabular}[t]{@{}l@{}}
	      {\em pattern-attribute-representation} \\
	      \{ \TT{;}
	              {\em pattern-attribute-representation} \}$^\star$
	      \TT{|\}} \\
	      \end{tabular}
	\end{tabular}
\\[1ex]
\emlkey{pattern-attribute-}{representation} ::=
\\\hspace*{0.5in}
    {\em required-attribute-representation}
    $|$ {\em optional-attribute-representation}
\\[1ex]
\emlkey{required-pattern-attribute-}{representation} ::=
\\\hspace*{0.5in}
	{\em attribute-label} {\em attribute-label-flags-option} \TT{=}
	      {\em pattern}
\\[1ex]
\emlkey{optional-pattern-}{attribute-representation} ::=
\\\hspace*{0.5in}
	{\em attribute-label} {\em attribute-label-flags-option} \TT{=?}
	      {\em pattern}
\end{indpar}

A pattern represents one of many possible syntax expressions.  The
syntax expression it represents is made by concatenating the
{\em pattern-clauses} in different ways.  For example,

\begin{center}
\verb/replace ($X) . in ($Y) . by ($Z)/
\end{center}

represents one of the two syntax expressions:

\begin{center}
\verb/replace ($X) in ($Y) by ($Z)/ \\
or \\
\verb/replace ($X) by ($Z) in ($Y)/ 
\end{center}

The rules for pattern representation are:

\begin{enumerate}
\item The represented {\em syntax-expression} is a sequence of
{\em pattern-clauses} from the {\em pattern} taken in any order,
\underline{except}, if the first {\em pattern-clause} in the
{\em pattern} is not preceded by {\em pattern-separator} `\TT{.}',
it must be first in the {\em syntax-expression}.

\item A {\em pattern-clause} not followed by a {\em pattern-qualifier}
(\TT{?}, \TT{??}, \TT{...}, or \TT{...?})
in the {\em pattern} must appear exactly
once in the represented {\em syntax-expression}.

\item A {\em pattern-clause} followed by `\TT{?}'
in the {\em pattern} is an \key{optional pattern clause}
and must appear exactly once or not at all
in the represented {\em syntax-expression}.
See \secref{DEFAULT-EQUATIONS} for examples.

\item\label{OPTIONAL-TRUTH-VALUE-CLAUSE-RULE}
A {\em pattern-clause} followed by `\TT{??}'
in the {\em pattern} is an
\ikey{optional truth-value pattern clause}{optional truth-value!pattern clause}.
Like an optional pattern clause this must appear exactly once or not at all
in the represented {\em syntax-expression}.
In addition, the {\em pattern-clause} must end with a {\em syntax-variable},
and this may be omitted in the represented {\em syntax-expression}.
See \secref{OPTIONAL-TRUTH-VALUE-PATTERN-CLAUSES} for examples.

\item A {\em pattern-clause} followed by `\TT{...}'
in the {\em pattern} is a \key{repeated pattern clause}
and must appear one or more times
in the represented {\em syntax-expression}.
See \secref{REPEATED-PATTERN-CLAUSES} for examples.

\item A {\em pattern-clause} followed by `\TT{...?}'
in the {\em pattern} is an \lkey{optional repeated}{pattern clause}
and must appear one or more times or not at all
in the represented {\em syntax-expression}.
See \secref{REPEATED-PATTERN-CLAUSES} for examples.

\item A {\em syntax-variable} in a {\em pattern}
that appears in an {\em alternative-equation}
is called an \key{alternative-syntax-variable} and must be replaced
(along with any parentheses surrounding it)
in the represented {\em syntax-ex\-pres\-sion}
by one of the {\em alternatives} from the {\em alternative-equation}.
See \secref{ALTERNATIVE-EQUATIONS} for examples.

\item A {\em required-pattern-attribute-representation}
that has an `\TT{=}' sign
must appear exactly once in the represented {\em syntax-expression}.

\item An {\em optional-pattern-attribute-representation}
that has an `\TT{=?}' sign
and must appear exactly once or not at all
in the represented {\em syntax-expression}.

\end{enumerate}

Patterns appear in pattern equations, which are just
like syntax equations except their right sides are patterns and not
a syntax expressions.  If the syntax expression on the left side of
a pattern equation is an object, then the pattern on the right side
can be \key{unfolded} to match the syntax expression.  Unfolding
means removing the
\skey{pattern separator}s, `\TT{.}',
and \skey{pattern qualifier}s,
`\TT{?}', `\TT{??}', `\TT{...}', and `\TT{...?}',
arranging the pattern clauses in the correct order,
and removing {\em optional-attribute-representations}.
For example, given the pattern equation:

\begin{indpar}
\verb/replace {b} by {5 + c} in (exp 1) :=~/ \\
\verb/    replace ($X) . in ($Y) . by ($Z)/
\end{indpar}

The pattern may be unfolded so the equation becomes:

\begin{indpar}
\verb/replace {b} by {5 + c} in (exp 1) :=~/ \\
\verb/    replace ($X) by ($Z) in ($Y)/
\end{indpar}

The \key{Propagation Rule} (\pagref{PROPAGATION-RULE})
may be applied to a pattern
equation whose right side pattern has been unfolded.  Thus in the
example just given one may may deduce:

\begin{center}
\begin{tabular}{r@{\TT{~:=\~~~}}l}
\verb/{b}/ & \verb/($X)/ \\
\verb/{5 + c}/ & \verb/($Z)/ \\
\verb/(exp 1)/ & \verb/($Y)/ \\
\end{tabular}
\end{center}

Note that this results in pattern equations and \underline{not}
syntax equations.

A pattern that contains pattern separators or qualifiers
(`\TT{.}', `\TT{?}', `\TT{??}', `\TT{...}', or `\TT{...?}')
\underline{outside} subexpressions and {\em attribute-representations},
or that contains {\em optional-attribute-representations}
(with `\TT{=?}' sign),
is said to be `\key{folded}'.  Other patterns are said to be
\key{unfolded}.  Subexpressions of a pattern are also patterns.

A pattern that is unfolded and all of whose subexpressions
and attribute representation patterns are
unfolded, that is, a pattern that contains no pattern qualifiers or
optional attribute representations,
even in subexpressions or attribute representations,
is said to be \key{completely unfolded}.
Such patterns are \key{promoted} to be syntax expressions, and
any pattern equations containing them are promoted to be
syntax equations.  Thus in the above example the last four
pattern equations can be promoted and become the following
four syntax equations:

\begin{center}
\begin{tabular}{c}
\verb/replace {b} by {5 + c} in (exp 1)/ \\
\verb/:=:/ \\
\verb/replace ($X) by ($Z) in ($Y)/ \\
\end{tabular} \\[2ex]
\begin{tabular}{r@\TT{~:=:~}l}
\verb/{b}/ & \verb/($X)/ \\
\verb/{5 + c}/ & \verb/($Z)/ \\
\verb/(exp 1)/ & \verb/($Y)/ \\
\end{tabular}
\end{center}

The Restricted Symmetry Rule (\pagref{RESTRICTED-SYMMETRY-RULE})
and Restricted Transitivity Rule (\pagref{RESTRICTED-TRANSITIVITY-RULE})
cannot be applied to pattern equations, which are inherently asymmetric.
However the following can be applied, where $v$ is a syntax variable, $e$
a syntax expression, and $p$ a pattern:

\begin{indpar}
\begin{list}{}{}
\item [\ikey{Pattern Transitivity Rule}{pattern transitivity rule}:]%
\label{PATTERN-TRANSITIVITY-RULE}
From $v$ \TT{:=:} $e$ and $v$ \TT{:=\~~} $p$
we deduce $e$ \TT{:=\~~} $p$.
\end{list}
\end{indpar}

The Parentheses Rule (\pagref{PARENTHESES-RULE})
and Atom Rule (\pagref{ATOM-RULE}) do apply to pattern equations.
For example, a pattern that is an atom may be treated as if it were
a list whose only element is that atom, and a syntax variable in
\TT{( )} parentheses is treated as a syntax variable.

Finally, we need to state the following more carefully:

\begin{indpar}
\begin{list}{}{}
\item [\ikey{Pattern Unfolding Rule}{pattern unfolding rule}:]%
\label{PATTERN-UNFOLDING-RULE}
If a pattern equation asserts the identity of a syntax expression that
is an object with a pattern, and if the pattern can be unfolded unambiguously
so that the result would be consistent were the pattern equation
instead a syntax equation between
objects, then the pattern is unfolded.  Otherwise nothing is done.

When a pattern is unfolded, \underline{all instances} of the pattern
are unfolded, and this affects all equations containing the pattern.
\end{list}
\end{indpar}

The last sentence of the Pattern Unfolding Rule needs explanation.
Suppose we start with the pattern equation:

\begin{indpar}
\verb/replace {b} [by {5 + c} in (exp 1)] :=~/ \\
\verb/    replace ($X) [. in ($Y) . by ($Z)]/
\end{indpar}

which is similar to our previous equation except the clauses are
now in a subexpression.  At the top level there is only one clause,
so the pattern is already unfolded, and by the Propagation Rule
we get

\begin{center}
\begin{tabular}{r@{\TT{~:=\~~~}}l}
\verb/replace/ & \verb/replace/ \\
\verb/{b}/ & \verb/($X)/ \\
\verb/[by {5 + c} in (exp 1)]/ & \verb/[. in ($Y) . by ($Z)]/ \\
\end{tabular}
\end{center}

Now we have a total of 4 equations.
The pattern in the last of these equations can be unfolded and
when this is done, \underline{all} the equations containing the pattern are
affected, and we have the 4 equations

\begin{center}
\begin{tabular}{c}
\verb/replace {b} [by {5 + c} in (exp 1)]/ \\
\verb/:=~/ \\
\verb/replace ($X) [by ($Z) in ($Y)]/ \\
\end{tabular} \\[2ex]
\begin{tabular}{r@{\TT{~:=\~~~}}l}
\verb/replace/ & \verb/replace/ \\
\verb/{b}/ & \verb/($X)/ \\
\verb/[by {5 + c} in (exp 1)]/ & \verb/[by ($Z) in ($Y)]/ \\
\end{tabular}
\end{center}

In other words, because the pattern in the equation

\begin{center}
\begin{tabular}{r@{\TT{~:=\~~~}}l}
\verb/[by {5 + c} in (exp 1)]/ & \verb/[. in ($Y) . by ($Z)]/ \\
\end{tabular}
\end{center}

was a subexpression of the pattern in the equation

\begin{indpar}
\verb/replace {b} [by {5 + c} in (exp 1)] :=~/ \\
\verb/  replace ($X) [. in ($Y) . by ($Z)]/
\end{indpar}

then what appears to be two copies of the same pattern is in fact
only one copy, and unfolding either of these unfolds the other in
exactly the same way.

This is another aspect of the remark near the end of
Section~\secref{SYNTAX-EQUATIONS} that deduction does not create
new syntax expressions: it merely creates new equations between
existing syntax expressions.  This means the deduction process must
quickly terminate, since the supply of syntax expressions is limited to
those in the the initial equations.  Similarly new patterns are not
created by deduction, only new equations involving existing patterns.
And when a pattern unfolds, the folded pattern is replaced by the
unfolded pattern in all equations involving the pattern.

If after doing all possible deductions on a set of equations
all patterns are unfolded,
then all pattern equations will have been promoted to syntax equations.
If on the other hand, some patterns remain folded, then the pattern
equations involving them are said to be
`\mkey{unsolvable}{pattern equations}'.

A pattern equation between a syntax expression that is not a syntax
variable and a folded pattern is said to be
`\mkey{inconsistent}{pattern equation}' if there is \underline{no}
way to unfold the pattern so that the equation can be viewed as a
consistent syntax equation.  Clearly if a pattern equation is inconsistent
then the pattern equation will be unsolvable, or the pattern equation
will become inconsistent when some other equation causes the pattern
to be unfolded and the pattern equation to be promoted so it becomes
an inconsistent syntax equation.

However, if there is more than one way to unfold a pattern in a pattern
equation so that the equation can be viewed as a consistent syntax equation,
then the equation is said to be `\mkey{ambiguous}{pattern equation}'.
An ambiguous equation cannot be used to unfold a pattern, and may become
unsolvable, but, it is possible that another non-ambiguous pattern equation
may exist or be deduced which will allow the pattern to be unfolded, in
which case at the end of all deductions there may be no unfolded patterns
left and no unsolvable pattern equations.  In this case the
ambiguous pattern equation will have been promoted to be a syntax equation,
which may or may not be consistent.

\subsubsection{Default Equations}
\label{DEFAULT-EQUATIONS}

When a pattern is unfolded, syntax variables in optional pattern clauses
not included in the unfolded pattern are given default values
provided by default equations.  Default equations have the
syntax:

\begin{indpar}
\emkey{default-equation} ::= {\em syntax-variable} \ttnbkey{:=?}
			     {\em default-value}
\\[1ex]
\emkey{default-value} ::= {\em syntax-expression}
\end{indpar}

For example, given the equations:

\begin{center}
\begin{tabular}{rcl}
\verb/sort x/ & \TT{:=\~~} & \verb/sort ($X) . in direction ($Y) ?/ \\
\verb/$Y/ & \tt :=? & \verb|ascending|
\end{tabular}
\end{center}

the pattern in the first equation will be unfolded to give the equation:

\begin{center}
\begin{tabular}{rcl}
\verb/sort x/ & \TT{:=\~~} & \verb/sort ($X)/ \\
\end{tabular}
\end{center}

and because the variable \TT{\$Y} was dropped during the unfolding,
the default equation that defines it will promoted to become the syntax
equation:

\begin{center}
\begin{tabular}{rcl}
\verb/$Y/ & \tt :=: & \verb|ascending|
\end{tabular}
\end{center}

thereby establishing a value for \TT{\$Y}.  Default equations that
are not promoted to become syntax equations by this mechanism are
ignored.  This mechanism does \underline{not} apply to repeated pattern
clauses or optional repeated pattern clauses.

\subsubsection{Alternative Equations}
\label{ALTERNATIVE-EQUATIONS}

An {\em alternative-equation} specifies that a syntax variable must take
one of several alternative values.

\begin{indpar}
\emkey{alternative-equation} ::= \\
\hspace*{3em}{\em syntax-variable}
		\TT{:=:} {\em alternative}
		          \TT{|} {\em alternative}
			  \{ \TT{|} {\em alternative} \}$^\star$
		\\[1ex]
\emkey{alternative} ::= {\em atom} {\em atom}$^\star$
\end{indpar}

For example,
\begin{center}
\verb/DIRECTION :=: ascending | descending/
\end{center}

Note that the {\em alternatives} are simple {\em atom} sequences,
and cannot include subexpressions or {\em syntax-variables}.

The {\em syntax-variable} in an alternative equation is called an
\key{alternative-syntax-variable}.  When such a variable appears
in a pattern it must be replaced by one of the {\em alternatives}
from the {\em alternative-equation} when the pattern is unfolded.
Any parentheses surrounding the variable in the pattern are removed.
The replacing {\em alternative} is integrated into the unfolded
pattern as if it had appeared in the pattern instead of the
{\em alternative-syntax-variable} and any parentheses surrounding it.

For example, given the above {\em alternative-equation} and the
{\em pattern-equation}
\begin{center}
\verb/sort ascending (3,2,7,8) :=~ sort DIRECTION (X)/
\end{center}
the pattern in thus equation can be unfolded to make the {\em syntax-equation}
\begin{center}
\verb/sort ascending (3,2,7,8) :=: sort ascending (X)/
\end{center}

However, given instead the pattern equation
\begin{center}
\verb/sort (SORT DIRECTION) (3,2,7,8) :=~ sort DIRECTION (X)/
\end{center}
the pattern in thus equation \underline{cannot} be unfolded because
there is ambiguity about which {\em alternative}
should replace \TT{DIRECTION}.

Whenever a pattern containing a {\em alternative-syntax-variable}
is unfolded, a particular {\em alternative} replaces the
variable in the pattern, and the syntax equation
\begin{center}
{\em alternative-syntax-variable} \TT{:=:} {\em alternative}
\end{center}
is asserted.  In this equation the unevaluated form of the
{\em alternative-syntax-variable} is used.  Thus in the above
example where the pattern was unfolded, the equation
\begin{center}
\verb/$DIRECTION :=: ascending/
\end{center}
is asserted.



\subsubsection{Optional Truth-Value Pattern Clauses}
\label{OPTIONAL-TRUTH-VALUE-PATTERN-CLAUSES}

An \ikey{optional truth-value pattern clause}%
{optional truth-value!pattern clause}%
\index{truth-value!pattern clause}%
\index{pattern clause!optional truth value}
(with `\TT{??}' {\em clause-qualifier}\,)
must end with a syntax variable $v$,
and this variable is treated specially in the following ways.
First, the guard:
\begin{center}
truth value ($v$)
\end{center}
is asserted.  Second, if the clause is omitted from the unfolded pattern,
the syntax equation
\begin{center}
$v$ \TT{:=:} \TT{false}
\end{center}
is asserted.  Third, the clause without its ending syntax variable
may appear in the unfolded pattern,
according to Rule \itemref{OPTIONAL-TRUTH-VALUE-CLAUSE-RULE},
in which case the syntax equation
\begin{center}
$v$ \TT{:=:} \TT{true}
\end{center}
is asserted.

Here $v$ is usually an evaluated syntax variable
(\pagref{EVALUATED-SYNTAX-VARIABLES}), but it may be
an unevaluated syntax variable.

For example, the pattern equation

\begin{center}
\begin{tabular}{rcl}
\verb/sort x/ & \TT{:=\~~} & \verb/sort ($X) . ascending ASCENDING ??/ \\
\end{tabular}
\end{center}

produces the guard and syntax equation:

\begin{center}
\verb/truth value (ASCENDING)/ \\
\begin{tabular}{rcl}
\verb/ASCENDING/ & \tt :=: & \verb/false/ \\
\end{tabular}
\end{center}

and the pattern equation

\begin{center}
\begin{tabular}{rcl}
\verb/sort x ascending/ & \TT{:=\~~} &
	\verb/sort ($X) . ascending ASCENDING ??/ \\
\end{tabular}
\end{center}

produces the guard and syntax equation:

\begin{center}
\verb/truth value (ASCENDING)/ \\
\begin{tabular}{rcl}
\verb/ASCENDING/ & \tt :=: & \verb/true/ \\
\end{tabular}
\end{center}



\subsubsection{Repeated Pattern Clauses}
\label{REPEATED-PATTERN-CLAUSES}

When a pattern is unfolded, a syntax variable in a
repeated or optional repeated pattern clause is replaced
in the unfolded pattern by new variables that represent elements of a list,
and a new syntax equation setting the original variable to this list
is created.  For example, when the pattern in the equation

\begin{center}
\begin{tabular}{rcl}
\verb/increment x by 5 by 10/ & \TT{:=\~~}
			      & \verb/increment ($X) . by ($Y) ...?/ \\
\end{tabular}
\end{center}

is unfolded, the following equations result:

\begin{center}
\begin{tabular}{rcl}
\verb/increment x by 5 by 10/ & \TT{:=\~~}
			      & \verb/increment ($X) by ($Y$1) by ($Y$2)/ \\
\verb/$Y/ & \tt :=: & \verb|($Y$1, $Y$2)|
\end{tabular}
\end{center}

Note that here `\TT{\$Y\$1}' and `\TT{\$Y\$2\$}' are each a single syntax
variable name, each with two \TT{\$}'s in it.  Users of RECKON should
not use \TT{\$} two or more times in
a syntax variable name in order to avoid conflicting
with this usage.

With an optional repeated pattern clause it is also possible for the
resulting list to be empty.  Thus

\begin{center}
\begin{tabular}{rcl}
\verb/increment x/ & \TT{:=\~~}
			      & \verb/increment ($X) . by ($Y) ...?/ \\
\end{tabular}
\end{center}

yields

\begin{center}
\begin{tabular}{rcl}
\verb/increment x/ & \TT{:=\~~}
			      & \verb/increment ($X)/ \\
\verb/$Y/ & \tt :=: & \verb|()|
\end{tabular}
\end{center}

\subsubsection{Place Holding Syntax Variables}
\label{PLACE-HOLDING-SYNTAX-VARIABLES}

A `\TT{\$}' by itself can be used as a syntax variable called
a \lkey{place holding}{syntax variable} that has the special
property that each of its original equation occurrences
is treated as if it were a \underline{different} variable.  The syntax is:

\begin{indpar}
\emlkey{place-holding}{-syntax-variable} ::= \ttnbkey{\$}
\end{indpar}

More specifically, whenever \TT{\$} appears in an original
equation, it is replaced by a unique new syntax variable name. 
For example, the pattern equation:

\begin{indpar}
\verb/replace {b} by {5 + c} in (exp 1) :=:/ \\
\verb/    replace ($X) . by $ . in $/
\end{indpar}

is treated as if it were

\begin{indpar}
\verb/replace {b} by {5 + c} in (exp 1) :=:/ \\
\verb/    replace ($X) . by ($1$) . in ($2$)/
\end{indpar}

where `\TT{\$1\$}' and `\TT{\$2\$}' are unique new
syntax variable names created by the RECKON system.




\subsubsection{Evaluated Syntax Variables}
\label{EVALUATED-SYNTAX-VARIABLES}

Syntax variables whose names begin with \TT{\$}
take values that are syntax expressions
which are \underline{not} evaluated.  Such syntax variables are called
\lkey{unevaluated}{syntax variables}.  With every unevaluated syntax
variable there can be associated an \key{evaluated syntax variable}
whose name is made by omitting the \TT{\$} from the beginning of the
unevaluated syntax variable name.  Thus \TT{X} is associated with
\TT{\$X}.  The syntax is:

\begin{indpar}
\emlkey{unevaluated-syntax-}{variable}
			\begin{tabular}[t]{rl}
			::= & \TT{\$} {\em capitalized-word } \\
			$|$ & \TT{\$} \TT{(} {\em capitalized-word }
			      {\em name-component}\,$^\star$ \TT{)} \\
			\end{tabular}
\\[1ex]
\emkey{evaluated-syntax-variable} 
			::= {\em capitalized-word }
			{\em name-component}\,$^\star$
\\[1ex]
{\em name-component} ::= {\em non-special-symbol} $|$ {\em decimal-natural}
			 ~~~ [as per \pagref{NAME-COMPONENT}]
\end{indpar}

Informally, an evaluated syntax variable is assigned the value obtained by
evaluating its associated unevaluated syntax variable's value.  In order
for this to happen, the unevaluated syntax variable must be evaluatable.
This means that its value, a syntax expression, must not contain any
unevaluatable syntax variables.

More formally:

\begin{indpar}
\begin{list}{}{}
\item [\ikey{Evaluatable Definition}{evaluatable definition}:]%
\label{EVALUATABLE-DEFINITION}
A syntax variable $v$ is evaluatable if a syntax equation $v$ \TT{:=:} $e$
has been deduced and every syntax variable in $e$ is evaluatable.
In this case $e$ is called the \key{unevaluated value} of $v$, and
the \key{complete unevaluated value} of $v$ is $e$ with all the
syntax variables it contains replaced by their complete unevaluated values.
\item [\ikey{Evaluation Rule}{evaluation rule}:]%
\label{EVALUATION-RULE}
If an evaluated syntax variable $v$ appears in a syntax equation and
its associated unevaluated syntax variable \TT{\$}$v$ is evaluatable,
then the syntax equation $v$ \TT{:=:} $E$ is deduced, where $E$
is the value obtained by evaluating the unevaluated value of
\TT{\$}$v$ in the context
in which the unevaluated value of \TT{\$}$v$ appears.
It is an error if this evaluation has side effects (\pagref{SIDE-EFFECTS}).
\end{list}
\end{indpar}

For example, given the code

\begin{indpar}\begin{verbatim}
sum ($X) and ($Y) <-- number(X), number(Y) { value = X + Y }
. . . . .
z = sum (1+1) and (5+5)
\end{verbatim}\end{indpar}

the call to `\TT{sum}' in the last line is matched with the definition
of `\TT{sum}' in the first line giving rise to a number of deduced
equations, among which are:

\begin{center}
\begin{tabular}{rcl}
\verb/sum (1+1) and (5+5)/ & \TT{:=\~~}
			      & \verb/sum ($X) and ($Y)/ \\
\verb/$X/ & \tt :=: & \verb/(1+1)/ \\
\verb/$Y/ & \TT{:=:\~~} & \verb/(5+5)/ \\
\verb/X/ & \tt :=: & \verb/2/ \\
\verb/Y/ & \TT{:=:\~~} & \verb/10/ \\
\end{tabular}
\end{center}

The last two equations are required to deduce the value of the evaluated
variables \TT{X} and \TT{Y} that are needed for the guards
\TT{number(X)} and \TT{number(Y)} and the block code statement
`\TT{value = X + Y}'.  These last two equations are obtained by
the Evaluation Rule.  For example, to obtain the value \TT{2} for the
evaluated variable \TT{X}, the value `\TT{(1+1)}' of the a associated
unevaluated variable \TT{\$X} is evaluated.  `\TT{(1+1)}' is
evaluatable because it contains no syntax variables and for this reason is
also its own `complete unevaluated value'.

Semantically, evaluated syntax variables are not permitted in patterns.
However, syntactically they can be placed in patterns according to the
following:

\begin{indpar}
\begin{list}{}{}
\item [\ikey{Evaluated Variable Pattern Rule}%
{evaluated variable!pattern rule}:]%
\label{EVALUATED-VARIABLE-PROMOTION-RULE}
If an evaluated syntax variable $v$ appears in a pattern, it is 
replaced in the pattern by its associated unevaluated variable
\TT{\$}$v$, and in addition
any occurrences of \TT{\$}$v$ in the containing expression definition
are treated as errors (i.e., $v$ and not \TT{\$}$v$ must be used
throughout the expression definition).
\end{list}
\end{indpar}

For example, the definition

\begin{indpar}\begin{verbatim}
for every counter:
    on increment THIS . by Y ? <-- number(Y), Y :=? 1:
        next count = count + Y
\end{verbatim}\end{indpar}

is treated as if it were

\begin{indpar}\begin{verbatim}
for every counter:
    on increment $THIS . by $Y ? <-- number(Y), Y :=? 1:
        next count = count + Y
\end{verbatim}\end{indpar}

while the definition

\begin{indpar}\begin{verbatim}
for every counter:
    on increment THIS . by Y ? <-- number(Y), $Y :=? 1:
        next count = count + Y
\end{verbatim}\end{indpar}

would be in error because \TT{Y} is used in the pattern but
\TT{\$Y} is used in the default equation.

\subsection{The Matching Algorithm}
\label{MATCHING-ALGORITHM}

The \key{evaluation algorithm} inputs an expression to be evaluated
and a context.  The context (\secref{CONTEXTS}) provides a list of expression
definitions that may match the expression.

An expression to be evaluated may contain syntax variables that are assigned
values during matching.  The result of matching is both a list of values for
the expression and an assignment of values for these variables.

More than one definition may match an expression.
More than one definition may match a guard,
and different guard definitions may lead to different
values of variables in the original expression being evaluated.
So expression matching is a search process to find a choice
of expression definitions that
leads to success, and more than one choice may succeed.

Note that evaluations of guards and evaluations
used to find values of evaluated syntax variables are required to have
no side effects, so the order of these evaluations does not matter.
Given the choices of which definitions are matched to which expressions,
the outcome of the matching process is uniquely determined, and does not
depend on the order of syntax equation deductions, guard evaluations, etc.,
or on the order in which the choices are tried.

Matching may be done in any of the following \skey{matching mode}s:

\begin{list}{}{}

\item[\ttkey{first-value}]~\\
The first definitions tried that lead to successful matches are the only ones
used.  Definitions are tried in the order they are given in the contexts
used in evaluation.

\item[\ttkey{all-values}]~\\
All possible choices are tried and the
successful results are collected in a set of results.  Each result
in this set consists of a value list for the expression being evaluated
and values for each syntax variable in that expression.

\item[\ttkey{consistent-values}]~\\
All possible choices are tried and the
successful results are collected in a set of results.  Then these results
are tested to see if they are pairwise equal.
All the value lists of the expression
being evaluated must be equal, and all the values of each syntax variable
contained in the expression must be equal.  If all expression value lists or
values of a syntax variable are equal, one of these expression value lists
is returned as the value list of the expression, and one syntax variable value
is returned as the value of the syntax variable.
If some of the expression value lists or syntax variable values are unequal, an
error value giving the context of the evaluation and the unequal value lists
or values is returned as the value of the expression or syntax variable.

\end{list}

If the expression match search process yields no matches at all,
the expression is given the value `\TT{false}', and variables in the
expression are not given any values.

\subsection{Contexts}
\label{CONTEXTS}

An expression is evaluated in a context.  The context is searched
for an expression definition whose pattern matches the expression being
evaluated, and that definition is then used to evaluate the expression.

A \key{context} is either a list or a set of expression definitions and
other contexts.  Context elements that are expression definitions are
matched to the expression being evaluated.  Context elements that are
themselves contexts are searched recursively.

\ikey{Context lists}{list!context} are searched in order if the
matching mode is \TT{first-value}, and are searched exhaustively
otherwise.
\ikey{Context sets}{set!context} are always searched exhaustively.

An expression definition is an object (\secref{OBJECTS})
that consists of a pattern, an optional list of constraints,
an optional block, and an optional context.  An
{\em expression-definition} (\pagref{EXPRESSION-DEFINITION})
computes an expression definition that has no context.
A context can be added to the expression definition later by executing:

\begin{indpar}
\TT{set} {\em expression-definition} \TT{context} {\em context}
\end{indpar}

Once a context has been added to an expression definition, the context
cannot be changed.

A new expression definition can be made from an old one by
the expression:

\begin{indpar}
	\verb|an| \ttkey{expression-definition}
	      {\em expression-definition}
	      {\em context}
\end{indpar}

The new expression definition has a different context, given by
the second argument, than the first argument does.  The special
value \ttmnbkey{UNDEFINED}{argument of an!expression-definition@{\tt
expression-definition}} can be given as the {\em context} argument
to create a new expression definition whose pattern, constraints, and block
are the same as those of {\em expression-definition} argument
but whose context part is missing and can be set later.

There are two kinds of contexts: \mkey{immutable}{context} and
\mkey{mutable}{context}.
An immutable context cannot be modified.  A mutable context can have
its list (or set) modified.
Each kind can be either a set or a list.

A context can be created by:

\begin{indpar}
\verb|a| \ttkey{context}
    \begin{tabular}[t]{@{}l@{}}
    \verb|(| {\em context-element} \{ \verb|,| {\em context-element} \}
	\verb|)| \\
    \ttmkey{is list}{of context!of \TT{context}} {\em list} \\
    \ttmkey{is mutable}{of context!of \TT{context}}
           {\em mutable} \\
    \ttmkey{with contexts missing}{of context!of \TT{context}}
           {\em contexts-missing}
    \end{tabular}
\end{indpar}

in which each {\em context-element} is either an expression definition or
a context, and {\em list}, {\em mutable}, and {\em contexts-missing}
are either `\TT{false}' (the default) or `\TT{true}'.
If {\em contexts-missing} is \TT{false} (the default), any expression
definition {\em context-elements} that do not have their
contexts set will have them set equal to the context being created.

Thus given expression definitions that do not have their contexts set,
the default is to create an immutable context set whose expression definitions
have the new context and therefore can reference each other.  Blocks
containing {\em expression-definitions} perform exactly this kind of
context creation.

The {\em context-item} list of a context object is a list object
(\pagref{LIST}) which can be extracted from the context object by

\begin{indpar}
\verb|the| \ttmkey{list}{of context} \verb|of| {\em context}
\end{indpar}

This list object is a list or set according to whether or not the
context is a list or set, and the list object is immutable or mutable
according to whether or not the context object is immutable or mutable.
If mutable, altering the list object will alter its containing context
object, and this is in fact the only way to mutate a mutable context.

\section{Blocks}
\label{BLOCKS}

A block is a set of variables, values for some of the variables, and
code for computing these values.  Blocks are optional parts of
{\em expression-definitions} (\secref{EXPRESSION-DEFINITION}).

\subsection{Block Syntax}
\label{BLOCK-SYNTAX}

The code of a block has the following syntax:

\begin{indpar}
\emkey{block} ::= \TT{\{} {\em group}
                         \{ {\em sequence-break} {\em group} \}$^\star$
			 \TT{\}} \\[1ex]
\emkey{sequence-break} ::= \ttnbkey{-----}\TT{-}$^\star$
	(1 word consisting of 5 or more \TT{-}'s) \\[1ex]
\emkey{group} ::= {\em declaration-group} $|$ {\em statement-group}
			 \\[1ex]
\emkey{declaration-group}\label{DECLARATION-GROUP} ::= {\em declaration}
    \{ \TT{;} {\em declaration} \}$^\star$ \\[1ex]
\emkey{statement-group} ::= {\em statement}
	\{ \TT{;} {\em statement} \}$^\star$ \\[1ex]
\emkey{declaration} ::= {\em expression-definition} $|$ {\em empty} \\[1ex]
\emkey{expression-definition} ::= see \pagref{EXPRESSION-DEFINITION} \\[1ex]
\emkey{statement}
    \begin{tabular}[t]{rl}
    ::= & {\em unqualified-statement} \\
    $|$ & {\em statement-qualifier} {\em unqualified-statement} \\
    $|$ & {\em empty }
    \end{tabular}
\label{STATEMENT}\\[1ex]
\emkey{statement-qualifier} ::= \ttkey{first}
			    $|$ \ttkey{always}
			    $|$ \ttkey{default}
			    \\[1ex]
\emkey{unqualified-statement}
    \begin{tabular}[t]{rl}
    ::= & {\em assignment-statement} \\
    $|$ & {\em unguarded-subblock} \\
    $|$ & {\em guarded-statement}
    \end{tabular} \\[1ex]
\emkey{assignment-statement}
	\begin{tabular}[t]{rl}
	::= & {\em variable-assignment-statement} \\
	$|$ & {\em pattern-assignment-statement}
	\end{tabular} \\[1ex]
\emlkey{variable}{-assignment-statement} ::=
	{\em output-variable} \ttkey{=} {\em right-side} \\[1ex]
\emkey{right-side} \
    \begin{tabular}[t]{rl}
    ::= & {\em operator-expression} \\
    $|$ & {\em operator-expression} \ttnbkey{=>} {\em output-variable}
		\{ \TT{,} {\em output-variable} \}$^\star$
    \end{tabular} \\[1ex]
{\em operator-expression} ::= see \pagref{OPERATOR-EXPRESSION} \\[1ex]
\emkey{output-variable} ::= {\em variable-name} $|$ {\em next-variable} \\[1ex]
\emkey{next-variable} ::= \ttkey{next} {\em variable-name} \\[1ex]
\emkey{variable-name} ::= {\em name} ~~~~~ [see \pagref{NAME}] \\[1ex]
\emlkey{pattern}{-assignment-statement} ::=
	{\em pattern} \TT{\~~=\~~}\index{~=~@{\TT{\~~=\~~}}}
	{\em right-side} \\[1ex]
{\em pattern} ::= see \pagref{PATTERN} \\[1ex]
\emkey{unguarded-subblock} ::= \TT{\{} {\em statement-group} \TT{\}} \\[1ex]
\emkey{guarded-statement} ::=
      {\em if-statement} $|$ {\em when-statement} \\[1ex]
\emkey{if-statement} ::=
      \begin{tabular}[t]{l}
      \ttkey{if} {\em guard} {\em unguarded-subblock} \\
      {\em else-if-continuation}\,$^\star$ \\
      {\em else-continuation-option}
      \end{tabular} \\[1ex]
\emkey{else-if-continuation} ::=
      \TT{;} \ttkey{else if} {\em guard} {\em unguarded-subblock} \\[1ex]
\emkey{else-continuation-option} ::= {\em empty} $|$
      \TT{;} \ttkey{else} {\em unguarded-subblock} \\[1ex]
\emkey{when-statement} ::=
      \ttkey{when} {\em guard} {\em unguarded-subblock} \\[1ex]
\emkey{guard} ::= {\em right-side}
\end{indpar}

\subsection{Block Variable Names}
\label{BLOCK-VARIABLE-NAMES}

In order to evaluate a block, the 
{\em variable-names} in the block must be identified.
Some {\em variable-names} may be \mkey{inherited}{variable-name}
from a {\em expression-definition} containing the block.
Some are {\em output-variables} in {\em assignment-statements}
or {\em right-sides}.
Some are variables in the {\em patterns} of {\em assign\-ment-patterns}.
All the {\em variable-names}
in the block are inherited or can be identified by looking at the left
sides of {\em variable-assignments}, at the {\em output-variables}
following \TT{=>} in {\em right-sides}, or {\em patterns} in
{\em pattern-assignments}.

When identifying {\em variable-names} in a {\em block}, {\em statements} in a
{\em subblock} of the {\em block} are treated as if they
were in the {\em block} proper.  Thus variables named in the
{\em subblock} are variables named in the {\em block}.\footnote{
RECKON does not have the notion of name space nesting, because the
\TT{\{ \}} brackets that would
indicate nesting can be implied by the \TT{:} construction.}

For example, in

\begin{indpar}[1in]
\verb|sum from X through Y <-- integer X, integer Y| {\em block}
\end{indpar}

the variable names \TT{X} and \TT{Y} are inherited by the {\em block}.

As another example, if the {\em pattern-assignment}

\begin{indpar}[1in]
\verb|$X + $Y ~=~ `5 + ( 7 * y )'|
\end{indpar}

appears in a block,
the variable names \TT{\$X} and \TT{\$Y} are pattern variable names
that are {\em variable-names} of the {\em block}.

The {\em output-variable} names in {\em variable-assignments}
and {\em right-sides} are {\em variable-names}.  For example, in

\begin{indpar}[1in]\begin{verbatim}
when sort x to y => y:
    z = first 
\end{verbatim}\end{indpar}

\TT{y} and \TT{z} are {\em output-variables} and therefore
{\em variable-names}.

Both evaluated and unevaluated pattern variables may be used in
the {\em operator-expressions} that appear in {\em right-sides}.
For example,
\begin{indpar}[1in]\begin{verbatim}
x = $X
\end{verbatim}\end{indpar}

sets the variable \TT{x} to the unevaluated expression stored in
\TT{\$X}.

[TBD: Arrays and array element names]

\subsection{Block Evaluation}
\label{BLOCK-EVALUATION}

\ikey{Blocks}{block!evaluation}
are divided into \ikey{groups}{group!evaluation} by \skey{sequence-break}s.
The {\em groups} are evaluated in order: each group being completely
evaluated before the next group is evaluated.  However,
evaluation within a \mkey{statement-group}{evaluation}
is driven by availability of variable values,
and not by the order of the {\em statements} in the group.

Each variable in a block can be assigned at most one value: it is
an error if the variable is assigned a value more than once during
a block evaluation, even if all the values assigned are the same.

The variables in an {\em operator-expression}
are called \skey{input-variable}s.
Each {\em operator-expres\-sion} in a {\em statement-group}
is evaluated only when \underline{all} its input variables have values.
When the {\em operator-expression} of an {\em assignment-statement} or
{\em right-side}
is evaluated, the {\em output-variables} and pattern variables in the
{\em assignment-statement} or {\em right-side} are given values.

None of the statements in an {\em if-statement}
{\em unguarded-block} are
evaluated until the block's {\em guard} has been evaluated to true.
If the guard evaluates to false, no statement in the
{\em unguarded-block} is ever evaluated.  An {\em else-if-continuation}
{\em guard} is not evaluated until all {\em guards}
in any preceding {\em if-statement}
or {\em else-if-continuations} in the same {\em guard-statement}
have been evaluated to false.  The {\em unguarded-block} of an
{\em else-continuation} is evaluated if and only if
all {\em guards} in any preceding {\em if-statement}
or {\em else-if-continuation} in the same {\em if-statement}
have been evaluated to false.

An example application of these rules is:

\begin{indpar}\begin{verbatim}
{
  z = y1
  z = y2
  if X > 5:
    y1 = 9
  else:
    y2 = 10
}
\end{verbatim}\end{indpar}

where \TT{X} is an inherited variable name.  If \TT{X > 5} is true,
the variable \TT{y1} is given the value \TT{9} and then
\TT{z} is given this value, while the variable \TT{y2}
is never given a value.  If \TT{X > 5} is false,
the variable \TT{y2}
is given the value \TT{10} and then \TT{z} is given this
value, while the variable \TT{y1} is never given a value.

A {\em when-statement} is just like an {\em if-statement} that has
no {\em else-if-continuation} or {\em else-continu\-a\-tion}.
[TBD: what about making a variable true if it has ANY value, for the
purposes of a {\em when-statement}?]

A {\em statement-group} terminates when all the
{\em right-side-expressions} in it have either been evaluated or
cannot be evaluated because of lack of an input variable value or
because of {\em guards}.
Once a {\em statement-group}
terminates, no part of the group can be evaluated, even if another group
later in the block defines that part's input variables.

However, group evaluation is additionally modified by {\em statement-qualifiers}
(\secref{DEFAULT-STATEMENTS}, \secref{ITERATION}).

The \ikey{declarations}{declaration!evaluation} of a
\mkey{declaration-group}{evaluation} are evaluated in order.  Evaluation of a
{\em declaration} just adds its definition to the current context.
The {\em declaration-group} terminates when its last {\em declaration}
has evaluated.  There are no {\em guards} or block variables in a declaration
group (the variables of a definition are not variables of the block).

\ikey{Empty-statements}{empty-statement!evaluation} and
\ikey{empty-declarations}{empty-declaration!evaluation} do nothing
when they evaluate.

The {\em groups} of a {\em block} are evaluated in order.  No part of
a {\em group}
can evaluate until all previous {\em groups} of the block have completely
finished evaluating.  Once a {\em group} starts to evaluate, no part of
a previous {\em group} can evaluate.

A {\em block} terminates when its last group terminates.

When a block terminates, the \mkey{value}{of block} of the block is the
value of its \TT{value} variable\index{value variable@\TT{value} variable},
if any.  Thus the block

\begin{center}
\verb|{ value = X + Y }|
\end{center}

which inherits the variables \TT{X} and \TT{Y} will return
the sum of its inherited variables as the value of the block.

If a block finishes without producing a value for a variable named
\TT{value}, the value of the block is \ttmkey{true}{block value}.

Block evaluation is additionally modified by {\em statement-qualifiers}
and {\em next-variables}
(\secref{DEFAULT-STATEMENTS} and \secref{ITERATION}).

\subsection{Default Statements}
\label{DEFAULT-STATEMENTS}

The \ttkey{default} {\em statement-qualifier} modifies group execution.
A statement qualified by \TT{default}
is called a \key{default statement}.  Default statements in a {\em group}
are initially inactive, meaning that they are treated as if they do not exist,

After the {\em group} without its default statements finishes executing,
any default statement in the {\em group} that has
\underline{no} output or pattern variable with a value
is made active.  All default statements that can be made active in this
way are made active at the same time.  Then the {\em group}, which now
consists of all non-default statements and all active default statements,
continues executing, until no more non-default or active default statement
can be executed.

Since all default statements that become active in a group become active
at the same time, it is possible for an error to occur if two such
statements assign values the same variable.

An example application of these rules is:

\begin{indpar}\begin{verbatim}
{
  if X > 5:
    value = `true'
  default value = `false'
}
\end{verbatim}\end{indpar}

where \TT{X} is an inherited variable name.  If \TT{X > 5} is true,
the value of the block is `\TT{true}' and the \TT{default}
{\em assignment-statement} remains inactive, but if \TT{X > 5} is false,
the \TT{default} {\em assignment-statement} becomes active and
the value of the block is `\TT{false}'.

\subsection{Iteration}
\label{ITERATION}

A block can \key{iterate}, meaning that it generates another block
that is the next block in a sequence of blocks.  A block
iterates if it does \underline{not} produce a value of a \TT{value}
variable and if it does produce a value for a {\em next-variable}.
The sequence of blocks are called the
\skey{iteration}s of the sequence.  Evaluation of a block can always
be thought of as producing a sequence of iterations, though this
sequence might include only one block which does not iterate.

A {\em next-variable} is named by a {\em variable-name} preceded by
the `\ttkey{next}' keyword.  A {\em next-variable}
is effectively a new variable with a name derived from the
{\em variable-name}.  We will used the notation `\TT{next }$V$'
to denote the {\em next-variable} made from the variable name $V$.
The value of \TT{next }$V$ at the end of execution of the
current block iteration becomes the value of $V$ at the beginning
of execution of the next block iteration.  In order for there to be
a next iteration, the current iteration must compute the value of
some {\em next-variable}, and the current iteration must not compute
the value of the \TT{value} variable.

{\em Next-variables} can be both output and input variables.
When used as input variables they are just like other input variables.
The \TT{next} unary operator can be applied to an expression that does not
consist solely of a {\em variable-name}.  When this is done, it is
as if the \TT{next} keyword had instead been prefaced to every
{\em variable-name} in the expression.  Thus `\TT{next(x+y)}' is
the equivalent of `\TT{next x + next y}'.

If a default statement outputs a {\em next-variable}, the statement
cannot become active unless some other {\em next-variable} has already
been given a value.  Thus the decision to iterate cannot be made inside
a default statement.

A statement of the form

\begin{center}
\verb|default next |$V$\verb| = |$V$
\end{center}

is implied in the last group of a block
for every inherited {\em variable-name} $V$ provided
no other default statement in the last group of the block
outputs \TT{next }$V$.
Thus inherited variables are normally propagated unchanged from
one iteration to the next.

If a {\em next-variable} is given the value of
the expression `\ttkey{UNDEFINED}',\label{UNDEFINED}
the variable will become undefined
at the beginning of the next iteration.  Thus the statement

\begin{center}
\verb|default next |$V$\verb| = UNDEFINED|
\end{center}

for an inherited {\em variable-name} $V$ will keep the inherited
variable from being propagated from one iteration to the next.
The expression `\TT{UNDEFINED}' cannot be used to set a
non-{\em next-variable}.

A \ttkey{first} qualified {\em statement} is only visible in the
first iteration of a block sequence.

An \ttkey{always} qualified {\em statement} is equivalent to the {\em statement}
qualified by \TT{first} plus additional {\em statements} of the form

\begin{center}
\verb|default next |$V$\verb| = |$V$
\end{center}

for every {\em variable-name} $V$ that can be assigned by the
\TT{always} qualified {\em statement}.  Thus the
\TT{always} qualified {\em statement} will assign values on the first
iteration, and these values will then be propagated to subsequent iterations.


\section{Objects}
\label{OBJECTS}

An object is a typed block that can be used as a value.
A typed block, or object, has a type and inherits code from its type.

An \key{object} can be created by an {\em object-expression}:


\begin{indpar}
\emkey{object-expression} ::= \{ \ttkey{a} $|$ \ttkey{an} \} {\em type-name}
		              {\em block-option} \\[1ex]
\emkey{type-name} ::= {\em name} ~~~~~ [see \pagref{NAME}]
\end{indpar}

The code in the {\em block} becomes a permanent part of the object.
The variable values defined by this code become \skey{component}s of the object.
These components can be retrieved by expressions of the form:

\begin{center}
\ttmkey{the}{the of@\TT{the} \ldots \TT{of}}
{\em variable-name}
\ttmkey{of}{the of@\TT{the} \ldots \TT{of}}
{\em object}
\end{center}

where {\em variable-name} names a variable whose value is the location
of the object.

Objects are updated by adding code to them either permanently or temporarily.
Whenever code is added to an object, the code executes as much as it
can to define variable values that are then components of the object.
When the code can execute no further (\secref{BLOCK-EVALUATION},
\secref{DEFAULT-STATEMENTS}, \secref{ITERATION}), any
variables that do not have values become undefined components.  If some of
undefined components are given values later, any code that is a permanent
part of the object may restart and produce additional variable values that
define additional components.

Recall that the concept of being a variable of a block
of code is defined syntactically and independently of which variable values
the block actually computes (\secref{BLOCK-VARIABLE-NAMES}).
The components of an object are more precisely the variables
of the code added permanently to the object, whether or not these
variables have values defined by code added permanently or temporarily
to the object.  Variables of code added temporarily that are not
also variables of code added permanently are
\underline{not} components of the object,
and are not visible outside the temporarily added code.

[TBD: We need a better way to declare an object component
without giving it a value in permanent code.]

The permanent code of an object all belongs to two groups: a
{\em declaration-group} and a {\em statement-group} in that
order (i.e., with declarations first).
When code is added to the block, the added code can also
have two groups: a {\em declaration-group} that is appended to the
permanent {\em declaration-group} and a following {\em statement-group} that
is appended to the permanent {\em statement-group}.  This is true whether
the code is being added permanently or temporarily.  Of course either
group can be empty.

A statement of the form:

\begin{indpar}
\ttkey{for every} {\em type-name} {\em block} 
\end{indpar}

adds the code in its block permanently to every object of the given type,
including both existing objects and objects that are
created in the future.  The code in the block is associated with the
type and is said to be `\skey{inherit}{ed}' by every object of that type.

A statement of the form:

\begin{indpar}
\ttkey{update} {\em variable-name} {\em block} 
\end{indpar}\label{UPDATE}

where {\em variable-name} evaluates to the location of an
object adds the code in the
{\em block} temporarily to the object.  The code is added and all
code in the object executes until it can do nothing more.  Then
the temporary code is removed from the object.

When code is added to an object and executes, the statement qualifier
\TT{default} acts when execution stops to enable execution of \TT{default}
statements, as per \secref{DEFAULT-STATEMENTS}.  Similarly
`\TT{next}' variables can be used to create iterations of the
object.  Each iteration replaces the previous iteration of the object
wherever the object is referenced.  Thus if two variables equal
the object, and one is used to cause the object to iterate, both variable
values will become the new iterated object.

A statement of the form

\begin{center}
\verb|default| \verb|next |$C$\verb| = |$C$
\end{center}

is implied in the permanent code
for every component name $C$ of an object, provided
no other default statement in the permanent code
outputs `\TT{next }$C$'.
Thus components are normally propagated unchanged from
one object iteration to the next.  A statement of the form

\begin{center}
\verb|default| \verb|next |$C$\verb| = UNDEFINED|
\end{center}

can be used to override this behavior to
make $C$ have no value at the beginning of the next object
iteration.

When an iteration of an object is created by temporary code, the
sequence of actions is:

\begin{center}
\begin{tabular}{lp{5.5in}}
(1) & Add the temporary code to the object. \\
(2) & Execute all object code until it terminates. \\
(3) & If any \TT{next} component values were defined by the
      execution in step (2), create
      the next iteration of the object, giving this
      iteration only the permanent code of the object. \\
(4) & In the next iteration of the object execute all
      code until it terminates.
\end{tabular}
\end{center}

Code can be temporarily added to an object by invoking methods.
A \key{method} is defined by a \key{method definition}
that is an expression definition which is part of the {\em declaration-group}
of the object code (it can be either permanent or temporary).
The method is callable from code inside or outside the object code block.
The syntax for a method definition is:

\begin{center}
\emkey{method-definition} ::= \ttkey{on} {\em expression-definition}
\end{center}

When the method definition is called, the method code block
is added temporarily to the code that contained
the method definition.  The object whose code this is
may be referred to within its
code by the name \ttnbkey{SELF}, which may or may not also be an argument
of the method definition.  If it is an argument, the method definition
has an implicit guard that requires the \TT{SELF} argument value to be
equal to the object whose code contains the method definition.

If there is no \TT{SELF} argument, a new object
is created when the method is called, and the permanent code plus
method code is executed for that object.  The permanent code must
contain the method definition in this case.  Such a method is
called a \TT{constructor}, and the object created is said to be
constructed by the method execution.  Constructor executions usually return
the object they construct, but this is not required by the language.
Constructors usually
have patterns that begin with `\{ \TT{a} $|$ \TT{an} \} {\em type-name}',
where {\em type-name} names the type of object they construct, but
this is not required by the language either.

TBD: protection; protection zones.


\section{Side Effects}
\label{SIDE-EFFECTS}

A \key{side effect} is an action that changes memory, inputs information from
the outside world, or outputs information to the outside world.
When an expression is evaluated, it may or may not have side effects.

The order in which side effects are executed is determined by
{\em sequence-breaks} that divide a {\em block} into {\em groups}
further (\secref{BLOCK-EVALUATION}).  A programmer typically writes code
so there is at most one side effect per {\em group}, in order to
ensure side effects execute in the desired order.

TBD: could this last rule be enforced.

The \key{side effect mode} controls the execution of side effects.
It has three settings: \TT{execute}, \TT{delay}, and \TT{error}.
In \ttkey{execute mode} a side effect simply executes.  In
\ttkey{error mode} an attempt to execute a side effect raises an error,
and the side effect is not executed.

In \ttkey{delay mode} input and memory change side effects execute,
but put operations on an \TT{undo} list that can undo their effects,
while output side effects do not execute, but are instead put on a
\TT{todo} list.

There are two lists maintained that permit side effects to be delayed
or undone.  The \ttmkey{todo}{list} list is a list of delayed output
actions that have been delayed.  The \ttmkey{undo}{list} list is
a list of input and memory change actions that can be undone.
The position of these lists can be recorded and an undo
operation can be performed that backs up to previously recorded positions
by deleting actions from the end of the \TT{todo} list and undoing
actions on the end of the \TT{undo} list.

To control the side effect mode there is a \key{side effect mode stack}.
This contains items each of which contains a side effect mode and
positions in the \TT{todo} and \TT{undo} stacks.  The side effect mode
of the top item on the side effect mode stack is the effective side
effect mode for current execution.
Whenever an item is pushed to the side effect mode stack, the current
positions of the \TT{todo} and \TT{undo} lists are recorded in the
item.

The following statements operate on the side effect mode stack:

\begin{list}{}{}
\item[\ttlkey{begin executing}{side effects}]~~~Push a new item with side effect
execute mode onto the side effect mode stack.  Before the push the
stack must be empty or the top item in the stack must have execute or
error mode.

\item[\ttlkey{end executing}{side effects}]~~~Pop the top item from
the side effect mode stack.  This top item must have
execute mode.

\item[\ttlkey{begin forbidding}{side effects}]~~~Push
a new item with side effect
error mode onto the side effect mode stack.  Before the push the
stack must be empty or the top item in the stack must have execute or
error mode.

\item[\ttlkey{end forbidding}{side effects}]~~~Pop the top item from the
side effect mode stack.  This top item must have
error mode.

\item[\ttlkey{delay}{side effects}]~~~Push a new item with side effect
delay mode onto the side effect mode stack.

\item[\ttlkey{commit}{side effects}]~~~Pop the top item from the
side effect mode stack.  This top item must have
delay mode.  It the resulting stack has a new top item that is not
delay mode, discard the contents of the \TT{undo} stack, and execute
and then discard the contents of the \TT{todo} stack.

\item[\ttlkey{abort side}{effects}]~~~Pop the item from the
the side effect mode stack.  This top item must have
delay mode.  Consider the \TT{todo} and \TT{undo} list positions
of the new item at the top of the stack, or take these positions to be
the beginning of the lists if the stack has become empty.  Remove
elements from ends of the lists until these considered positions become
the current list positions.  When removing an element from the end of the
\TT{undo} list, perform the undo action specified by the element.

\end{list}

\section{Debugging}

Design:

Debugging is based on the notion that almost all
RECKON programs will run quickly.
Input checkpointing is used to record all inputs to a computation
so the computation can be deterministically rerun.  Detailed
traces can be generated which explain for each value how it was generated.
Values have a sequence number that identifies the point in the execution
where they were generated.  It is therefore possible to ask for a detailed
accounting of how any value was generated, provided the run is short enough
to be repeated once or a few times so the computer can turn the history
tracing on appropriately.

\section{Design Notes}

These are some detailed design rules to be incorporated in the language
definition later.

\begin{list}{}{}

\item
{\bf Blank Algebraic Operators}.
The blank, or missing operator, denotes \TT{*} when it precedes a word,
as in \TT{5x} being equivalent to \TT{5*x}.  When it is between a
preceding integer and a following ratio, it adds the ratio to the integer,
as in \TT{41 1/3}.

\end{list}

\section{To Do}

Describe matrix expression scanning that has no separators.
Maybe it should not recognize operators outside parentheses?

Describe blank lines as paragraph operators in text parsing.

Should temporaries be full-fledged names.

Describe the quote evaluator.\label{QUOTE-EVALUATOR}

Why doesn't `\TT{define qualifier xxx}' mean define expressions equal
to `{qual\-i\-fier\EOL{} xxx}'.

\TT{missing(\#X)} is true if \TT{\#X} is a null node.
\TT{integer(\#X)} is true if \TT{\#X} is an integer.

Qualifier shortcuts should be conditioned on the first words of
the expression being qualified.  E.g., if these words are
`\TT{define operator}' the shortcut `\TT{left => }\TT{with
associativity [left]}' would be defined.

Expressions to be evaluated can have sets of possible values.

Imaginary Units\label{IMAGINARY-UNITS}

Visible Side Effects\label{VISIBLE-SIDE-EFFECTS}

List Objects\label{LIST}

Qualifier Definition\label{QUALIFIER-DEFINITION}

Qualifier Shortcut Definition\label{QUALIFIER-SHORTCUT-DEFINITION}

Automatic Optional Marks\label{AUTOMATIC-OPTIONAL-MARKS}

Describe Garbage Collection\label{GARBAGE-COLLECTION}

Manual Deletion\label{MANUAL-DELETION}, the stub is marked deleted,
and gc's make pointers to the stub either NULL or point them at
a standard deleted object so the deleted stub can be collected.

\bibliographystyle{plain}
\bibliography{reckon}

\printindex

\end{document}

