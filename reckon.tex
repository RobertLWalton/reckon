% Personal Calculation and Simulation Langauge (PCASL)
%
% File:         pcasl.tex
% Author:       Bob Walton (walton@deas.harvard.edu)
% Date:		See \date below.
  
\documentclass[12pt]{article}

\usepackage{makeidx}

\makeindex

\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}
\raggedbottom

\setlength{\unitlength}{1in}

\pagestyle{headings}
\setlength{\parindent}{0.0in}
\setlength{\parskip}{1ex}

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}
\newcommand{\subsubsubsection}[1]{\paragraph[#1]{#1.}}
\newcommand{\subsubsubsubsection}[1]{\subparagraph[#1]{#1.}}

% Begin \tableofcontents surgery.

\newcount\AtCatcode
\AtCatcode=\catcode`@
\catcode `@=11	% @ is now a letter

\renewcommand{\contentsname}{}
\renewcommand\l@section{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\l@table{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\tableofcontents{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}}%
    \item\@starttoc{toc}%
    \end{list}}
\renewcommand\listoftables{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}%
	      }%
    \item\@starttoc{lot}%
    \end{list}}

\catcode `@=\AtCatcode	% @ is now restored

% End \tableofcontents surgery.

\newcommand{\CN}[2]%	Change Notice.
    {\hspace*{0in}\marginpar{\sloppy \raggedright \it \footnotesize
     $^{\mbox{#1}}$#2}}
    % Change notice.

\newcommand{\key}[1]{{\em #1}\index{#1}}
\newcommand{\mkey}[2]{{\em #1}\index{#1!#2}}
\newcommand{\skey}[2]{{\em #1#2}\index{#1}}
\newcommand{\ikey}[2]{{\em #1}\index{#2}}
\newcommand{\ttkey}[1]{{\tt #1}\index{#1@{\tt #1}}}
\newcommand{\ttmkey}[2]{{\tt #1}\index{#1@{\tt #1}!#2}}
\newcommand{\ttfkey}[2]{{\tt #1}\index{#1@{\tt #1}!for #2@for {\tt #2}}}
\newcommand{\ttakey}[2]{{\tt #1}\index{#2@{\tt #1}}}
\newcommand{\ttamkey}[3]{{\tt #1}\index{#2@{\tt #1}!#3}}
\newcommand{\ttindex}[1]{\index{#1@{\tt #1}}}
\newcommand{\ttmindex}[2]{\index{#1@{\tt #1}!#2}}
\newcommand{\emkey}[1]{{\em #1}\index{#1@{\em #1}}}
\newcommand{\emindex}[1]{\index{#1@{\em #1}}}

\newcommand{\EOL}{\penalty \exhyphenpenalty}

\newcount\TildeCatcode
\TildeCatcode=\catcode`\~
\catcode`~=12
\newcommand{\Tilde}{~}
\catcode`~=\TildeCatcode

\newcount\CurlyBraCatcode
\newcount\CurlyKetCatcode
\newcount\SquareBraCatcode
\newcount\SquareKetCatcode
\CurlyBraCatcode=\catcode`{
\CurlyKetCatcode=\catcode`}
\SquareBraCatcode=\catcode`[
\SquareKetCatcode=\catcode`]

\catcode`{=\SquareBraCatcode
\catcode`}=\SquareKetCatcode
\catcode`[=\CurlyBraCatcode
\catcode`]=\CurlyKetCatcode

\newcommand[\CurlyBra][{]
\newcommand[\CurlyKet][}]

\catcode`{=\CurlyBraCatcode
\catcode`}=\CurlyKetCatcode
\catcode`[=\SquareBraCatcode
\catcode`]=\SquareKetCatcode

\newcommand{\ttbrackets}{
    \renewcommand{\{}{\CurlyBra}
    \renewcommand{\}}{\CurlyKet}}

\newlength{\figurewidth}
\setlength{\figurewidth}{\textwidth}
\addtolength{\figurewidth}{-0.40in}

\newsavebox{\figurebox}

\newenvironment{boxedfigure}[1][!btp]%
	{\begin{figure*}[#1]
	 \begin{lrbox}{\figurebox}
	 \begin{minipage}{\figurewidth}

	 \vspace*{1ex}}%
	{
	 \vspace*{1ex}

	 \end{minipage}
	 \end{lrbox}
	 \begin{center}
	 \fbox{\hspace*{0.1in}\usebox{\figurebox}\hspace*{0.1in}}
	 \end{center}
	 \end{figure*}}

\newenvironment{indpar}[1][0.3in]%
	{\begin{list}{}%
		     {\setlength{\itemsep}{0in}%
		      \setlength{\topsep}{0in}%
		      \setlength{\parsep}{1ex}%
		      \setlength{\labelwidth}{#1}%
		      \setlength{\leftmargin}{#1}%
		      \addtolength{\leftmargin}{\labelsep}}%
	 \item}%
	{\end{list}}

\begin{document}
        
\title{Personal\\Calculation and Simulation\\Language\\[2ex]PCASL\\[2ex]
       (Draft 1a)}

\author{Robert L. Walton\thanks{This document was partly inspired
by teaching courses at Suffolk University.}}

\date{January 7, 2004}
 
\maketitle

\tableofcontents 

\newpage

\section{Introduction}

This document describes PCASL, the Personal Calculation and Simulation
Language, that is informally referred to as P-Castle, Personal Castle, or just
Castle.

PCASL is designed for naive programmers: that is, for people who may never
be able to program computers well.  It is a simple language that has
powerful data types which make it easier to write small programs
that do a variety of tasks that a person might want to do.  Generally
the tasks fall into the categories of calculating things (taxes,
probabilities, statistics) or simulating things
(computer games, construction designs, mathematics demonstrations).
Included are:

\begin{center}
\begin{tabular}{l}
Calculations that might be done with a spreadsheet. \\
Drawing pictures. \\
Simulating popular board games and creating new ones. \\
Creating simple computer games, including dialog games. \\
Computing and analysing documents. \\
Doing elementary algebra and calculus problems. \\
Calculating basic probabilities and statistics. \\
Simulating two and three dimensional objects. \\
Simulating simple electrical, mechanical, chemical, and biological systems.\\
Solving problems in elementary logic. \\
\end{tabular}
\end{center}

There are many computer languages that have some powerful data type that adapts
them for a specific kind of computation.  PCASL tries to combine these.
Some previous computer languages that have influenced PCASL, and
the data types they particularly support, are:

\begin{center}
\begin{tabular}{l@{\hspace{0.5in}}l}
Various Spreadsheets		& Spreadsheets \\
Various Data Base Languages	& Data Bases \\
Matlab				& Matrices \\
Mathematica			& Expressions \\
TCL				& Character Strings and Lists \\
Lisp				& Words and Phrases \\
Prolog				& Logical Expressions \\
\end{tabular}
\end{center}

PCASL is \underline{not} designed to be a computer-efficient language.
It is designed to be person-efficient, and to do small calculations
rapidly enough with inexpensive modern computers.

\section{Remarks}

PCASL was created as an answer to the question: what programming language
should you teach beginning programming students who do not have the talent
or inclination to become good programmers?  The inital answer, that it does
not matter provided you implement some powerful types of data in the
language you choose, has a flaw.  The flaw is that without the right powerful
data types, the language will be useless to the students after the course
is over.  So what is needed is a programming language that will be useful
to students after a first course in programming, and the essence of
such a language is the integration within it of many powerful and useful
data types.

The current version of PCASL is not stable, because it has not been
implemented, and because, unlike most programming languages, PCASL
has lots of subtle important interactions between its various features.  The
hope is that with implementation and experimentation, a stable sensible
version of PCASL integrating all its data types can be achieved.

\section{Overview}

PCASL has two major kinds of data: expressions and blocks.  Numbers are
the simplest expressions.  More complex expressions are math
expressions or document expressions.  Blocks are sets of variables
each of which can have a value, which is an expression, and also
a definition, which is a set of guarded expressions.
Each guarded expression consists of a guard, which is an expression that
evaluates to true or false, and a value expression, which is an expression
that is evaluated if the guard is true to produce the value of the variable.
The definitions of a block, taken all
together, are called the `code' of the block.

You can use PCASL as a calculator by typing into it expressions to
be evaluated and assignments of values and definitions to variables.
Some examples involving numbers are:

\begin{indpar}\begin{verbatim}
> 9
9
> 9 + 8
17
> x = 9
9
> y = 9 + 8
17
> x + y
26
\end{verbatim}\end{indpar}

Here the `\verb|> |' at the beginning of some lines is the PCASL \key{prompt}
that tells you its OK to input an expression to be evaluated.

At somewhat the opposite extreme from numbers are words, phrases, sentences,
and paragraphs.  You can calculate with these `\skey{document expression}s'.

\begin{indpar}
\verb|> g = `hello'| \\
\verb|`|hello\verb|'| \\
\verb|> `<<g>> there'| \\
\verb|`|hello there\verb|'| \\
\verb|> z = ``I thought he said `<<g>>'.''| \\
\verb|``|I thought he said `hello'.\verb|''| \\
\verb/> notice = ``|This document is meant to be read./ \\
\verb/+            |Reading this document is good, but.../ \\
\verb/+            |<<z>>.''/ \\
\verb|``|This document is meant to be read. \\
\verb|  |Reading this document is good, but\ldots \\
\verb|  |I thought he said `hello'.\verb|''| \\
\verb|> `When you add <<x>> and <<y>> you get <<x+y>>.'| \\
\verb|`|When you add 9 and 17 you get 26.\verb|'|
\end{indpar}

Modern math computes with expressions, and not just numbers.
You can compute with \skey{math expression}s in PCASL.

\begin{indpar}
\verb|> f = {10x^2 - 3.67x - 0.04}| \\
\verb|{|$10x^2-3.67x-0.04$\verb|}| \\
\verb|> h = (- 0.96 + 0.67x) in x| \\
\verb|{|$-0.96+0.67x$\verb|}| \\
\verb|> (f + h) in x| \\
\verb|{|$10x^2-3x-1$\verb|}| \\
\verb|> solve (f + h = 0) for x| \\
\verb|{|$x = (-0.2, 0.5)$\verb|}| \\
\verb|> (f + h) at (x = (3, 4, 5))| \\
\verb|(78.95, 145.28, 231.61)| \\
\verb|> g = {integral (x ^ 2 dx)}| \\
\verb|{|$\int x^2 dx$\verb|}| \\
\verb|> simplify g| \\
\verb|{|$\frac{1}{3} x^3$\verb|}| \\
\verb|> v = g from (x = 1) to (x = 5)| \\
\verb|41 1/3| \\
\verb|> out = `The value of {<<<g>>> from (x = 1) to (x = 5)} is <<v>>.'| \\
\verb|`|The value of $\int_{x = 1}^{x = 5} x^2 dx$ is $41\frac{1}{3}$.\verb|'| \\
\verb|> raw out| \\
\verb|[sentence the value of| \\
\verb|          {(integral (x ^ 2 * dx)) from (x = 1) to (x = 5)}| \\
\verb|          is 124/3]|
\end{indpar}

Another kind of datum you can compute with in PCASL is
the \key{block}:

\begin{indpar}
\verb|> a person {| \\
\verb|+     name = `Jack'| \\
\verb|+     weight = 123 lb| \\
\verb|+     height = 5' 9"| \\
\verb|+     age = 23 yr 2 mo }| \\
\begin{tabular}{|r|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000000 & Jack & \tt 123 lb & \tt 5' 9" & \tt 23 yr 2 mo \\
\hline
\end{tabular} \\
\verb|> a person {| \\
\verb|+     name = `Jill'| \\
\verb|+     weight = 110 lb| \\
\verb|+     height = 5' 7"| \\
\verb|+     age = 21 yr 8 mo }| \\
\begin{tabular}{|r|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000001 & Jill & \tt 110 lb & \tt 5' 7" & \tt 21 yr 8 mo \\
\hline
\end{tabular} \\
\verb|> all persons| \\
\begin{tabular}{|r|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000000 & Jack & \tt 123 lb & \tt 5' 9" & \tt 23 yr 2 mo \\
\tt @1000001 & Jill & \tt 110 lb & \tt 5' 7" & \tt 21 yr 8 mo \\
\hline
\end{tabular} \\
\verb|> the person Jack| \\
\begin{tabular}{|r|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000000 & Jack & \tt 123 lb & \tt 5' 9" & \tt 23 yr 2 mo \\
\hline
\end{tabular} \\
\verb|> the person named Jack's height| \\
\verb|5' 9"| \\
\verb|> the weight of the person named Jack| \\
\verb|123 lb| \\
\verb|> @1000001| \\
\begin{tabular}{|r|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000001 & Jill & \tt 110 lb & \tt 5' 7" & \tt 21 yr 8 mo \\
\hline
\end{tabular} \\
\verb|> the weight of @1000001| \\
\verb|110 lb|
\end{indpar}

It is possible to add code to a type such as `{\tt person}':

\begin{indpar}
\verb|> a person <-- {| \\
\verb|+     body-mass-index = 703.06958 * weight in lbs| \\
\verb|+                     / (height in inches)^2 }| \\
\verb|> all persons| \\
\begin{tabular}{|r|l|r|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} &
\multicolumn{1}{|c|}{\bf \shortstack{body-mass-\\index}} \\
\hline
\tt @1000000 & Jack & \tt 123 lb & \tt 5' 9" & \tt 23 yr 2 mo & \tt 18.163738 \\
\tt @1000001 & Jill & \tt 110 lb & \tt 5' 7" & \tt 21 yr 8 mo & \tt 17.228258 \\
\hline
\end{tabular}
\end{indpar}

One can use definitions to define expressions that compute values:

\begin{indpar}
\verb|> sum from X through Y <-- integer X, integer Y {| \\
\verb|+     `Sum of integers from X through Y.'| \\
\verb|+     if ( X > Y ):| \\
\verb|+         value = 0| \\
\verb|+     else:| \\
\verb|+         value = X + sum (X+1) through Y }| \\
\verb|> sum from 5 through 10| \\
\verb|45| \\
\verb|> all (sums from X through Y)| \\
\begin{tabular}{|r|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf X} &
\multicolumn{1}{|c}{\bf Y} &
\multicolumn{1}{|c|}{\bf value} \\
\hline
\tt @1000002 & \tt 5	& \tt	10	& \tt 45 \\
\tt @1000003 & \tt 6	& \tt	10	& \tt 40 \\
\tt @1000004 & \tt 7	& \tt	10	& \tt 34 \\
\tt @1000005 & \tt 8	& \tt	10	& \tt 27 \\
\tt @1000006 & \tt 9	& \tt	10	& \tt 19 \\
\tt @1000007 & \tt 10	& \tt	10	& \tt 10 \\
\tt @1000008 & \tt 11	& \tt	10	& \tt 0 \\
\hline
\end{tabular} \\
\verb|> sum from 1 through 2| \\
\verb|3| \\
\verb|> all (sums from X through Y)| \\
\begin{tabular}{|r|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf X} &
\multicolumn{1}{|c}{\bf Y} &
\multicolumn{1}{|c|}{\bf value} \\
\hline
\tt @1000002 & \tt 5	& \tt	10	& \tt 45 \\
\tt @1000003 & \tt 6	& \tt	10	& \tt 40 \\
\tt @1000004 & \tt 7	& \tt	10	& \tt 34 \\
\tt @1000005 & \tt 8	& \tt	10	& \tt 27 \\
\tt @1000006 & \tt 9	& \tt	10	& \tt 19 \\
\tt @1000007 & \tt 10	& \tt	10	& \tt 10 \\
\tt @1000008 & \tt 11	& \tt	10	& \tt 0 \\
\tt @1000009 & \tt 1	& \tt	2	& \tt 3 \\
\tt @1000010 & \tt 2	& \tt	2	& \tt 2 \\
\tt @1000011 & \tt 3	& \tt	2	& \tt 0 \\
\hline
\end{tabular}
\end{indpar}

Executions can be examined in detail because
when an expression is computed, the block that computes it is remembered
for some time.  However, as memory is finite, eventually these
computations are forgotten as they can always be regenerated if
needed.

The sum above was computed by recursion: to compute the sum of 5 through 10
one computes the sum of 6 through 10.  One can also compute sums by
iteration.

\begin{indpar}
\verb|> sum from X through Y <-- integer X, integer Y {| \\
\verb|+     `Sum of integers from X through Y.'| \\
\verb|+     first sum = 0| \\
\verb|+     if ( X <= Y ):| \\
\verb|+         next sum = sum + X| \\
\verb|+         next X = X + 1| \\
\verb|+     else:| \\
\verb|+         value = sum }| \\
\verb|> sum from 5 through 10| \\
\verb|45| \\
\verb|> all (sums from 5 through 10)| \\
\begin{tabular}{|r|r|r|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf previous} &
\multicolumn{1}{|c}{\bf X} &
\multicolumn{1}{|c}{\bf Y} &
\multicolumn{1}{|c}{\bf sum} &
\multicolumn{1}{|c|}{\bf value} \\
\hline
\tt @1000012 &              & \tt 5	& \tt 10   & \tt 0	& \\
\tt @1000013 & \tt @1000012 & \tt 6	& \tt 10   & \tt 5	& \\
\tt @1000014 & \tt @1000013 & \tt 7	& \tt 10   & \tt 11	& \\
\tt @1000015 & \tt @1000014 & \tt 8	& \tt 10   & \tt 18	& \\
\tt @1000016 & \tt @1000015 & \tt 9	& \tt 10   & \tt 26	& \\
\tt @1000017 & \tt @1000016 & \tt 10	& \tt 10   & \tt 35	& \\
\tt @1000018 & \tt @1000017 & \tt 11	& \tt 10   & \tt 45	& \tt 45 \\
\hline
\end{tabular}
\end{indpar}

One can also iterate over data.

\begin{indpar}
\verb|> average weight of X <-- tuple X of persons {| \\
\verb|+     first count = 0| \\
\verb|+     first sum = 0| \\
\verb|+     if X = ():| \\
\verb|+         if count = 0:| \\
\verb|+             value = error `Cannot average 0 things.'| \\
\verb|+         else:| \\
\verb|+             value = sum / count| \\
\verb|+     else:| \\
\verb|+         next count = count + 1| \\
\verb|+         next sum = sum + the weight of (first X)| \\
\verb|+         next X = rest X }| \\
\verb|> average weight of (all persons)| \\
\verb|116.5 lbs|
\end{indpar}

In case you wonder how some of the above works, here are some hints.

PCASL tends to ignore word endings: thus `{\tt person}' and
`{\tt persons}' are to PCASL the same word.
PCASL can even be told that `{\tt person}'
and `{\tt people}' are the same word.
`{\tt Jack's}', on the other hand, is treated an abbreviation
of two separate words `{\tt Jack 's}', where `{\tt 's}' is
a separate word by itself.

Expressions are just strings of words and subexpressions.  Subexpressions
must be parenthesized unless they consist of a single word, or unless
they are delimited by operators.

Lists of values can be stored in tuples, which are computed by comma
separted lists in parentheses.  Thus

\begin{indpar}
\verb|> (the person named Jill, the person named Jack)| \\
\begin{tabular}{|r|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000001 & Jill & \tt 110 lb & \tt 5' 7" & \tt 21 yr 8 mo \\
\tt @1000000 & Jack & \tt 123 lb & \tt 5' 9" & \tt 23 yr 2 mo \\
\hline
\end{tabular} \\
\verb|> (the person named Jack, the person named Jill)| \\
\begin{tabular}{|r|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000000 & Jack & \tt 123 lb & \tt 5' 9" & \tt 23 yr 2 mo \\
\tt @1000001 & Jill & \tt 110 lb & \tt 5' 7" & \tt 21 yr 8 mo \\
\hline
\end{tabular} \\
\verb|> raw (all persons)| \\
\verb|(the person named Jack, the person named Jill)|
\end{indpar}

The `{\tt raw}' form of a value is a form that prints as you could
input it in a way that reveals its internal structure.  Thus
`{\tt all persons}' denotes the tuple of all persons.

`{\tt the person named Jack}' is a printed representation of the
internal name of a block.  Such printed representations are chosen
automatically from the set of all possible representations, which
in this case include `{\tt the person weighing 123 lbs}' and
`{\tt the person named Jack weighing 123 lbs}'.

A single non-tuple value is equivalent to a tuple with one element.
Tuples cannot have other tuples as elements; instead attempts to
compute such tuples are \key{flattened}:

\begin{indpar}
\verb|> x = (1,(2,3),4)| \\
\verb|(1,2,3,4)| \\
\verb|> first x| \\
\verb|1| \\
\verb|> rest x| \\
\verb|(2,3,4)| \\
\verb|> rest (rest x)| \\
\verb|(3,4)| \\
\verb|> rest (rest (rest x))| \\
\verb|3| \\
\verb|> rest 9| \\
\verb|()|
\end{indpar}

PCASL has many different kinds of quotes or brackets.  Some of these,
\verb|{|\ldots\verb|}|, \verb|`|\ldots\verb|'|, and \verb|{{|\ldots\verb|}}|,
turn evalution off, while \verb|<<|\ldots\verb|>>|,
\verb|<<<|\ldots\verb|>>>|, \verb|<<<<|\ldots\verb|>>>>|, etc.
turn evaluation on.
Some,
\verb|`|\ldots\verb|'| and \verb|{{|\ldots\verb|}}|,
turn recognition of operators (e.g., \verb|+| and \verb|=|) off, while others,
\verb|<<|\ldots\verb|>>| and \verb|{|\ldots\verb|}|,
turn recognition of operators on.
\verb|`|\ldots\verb|'|,
\verb|``|\ldots\verb|''|, \verb|```|\ldots\verb|'''|, etc.
also do other things, like insert implicit operations (e.g., \verb|sentence|).

PCASL stores information as expressions.  For example:

\begin{indpar}
\verb|> (a person named `Jack') is husband of (a person named `Jill') <--| \\
\verb|> Y is wife of X <-- X is husband of Y| \\
\verb|> (a person named `Jill') is wife of (a person named `Jack') ?| \\
\verb|true| \\
\verb|> (a person named `Jack') is wife of (a person named `Jill') ?| \\
\verb|false| \\
\verb|> (a person named X) is wife of (a person named `Jack') ?| \\
\verb|X = `|Jill\verb|'| \\
\verb|> X is wife of (a person named `Jack') ?| \\
\verb|X = (a person named `Jill')| \\
\verb|> @1000001 is wife of (a person named `Jack') ?| \\
\verb|true| \\
\verb|> @1000001 = (a person named `Jill') ?| \\
\verb|true| \\
\verb|> @1000001 = (a person named `Jack') ?| \\
\verb|false|
\end{indpar}

PCASL also supports pictorial data
that are computed like expressions.

\begin{indpar}
\verb|> x = {circle 0.4}| \\
\begin{picture}(0.4,0.4)
\put(0.2,0.2){\circle{0.4}}
\end{picture} \\
\verb|> y = {rectangle (0.4,0.2)}| \\
\begin{picture}(0.4,0.2)
\put(0,0){\framebox(0.4,0.2){}}
\end{picture} \\
\verb|> z = {(circle 0.4) labeled `Jack'}| \\
\begin{picture}(0.4,0.4)
\put(0.2,0.2){\circle{0.4}}
\put(0.0,0.0){\makebox(0.4,0.4){Jack}}
\end{picture} \\
\verb|> {(<<x>> right of <<y>>) above <<z>>}| \\
\begin{picture}(0.8,0.8)
\put(0.6,0.6){\circle{0.4}}
\put(0.0,0.5){\framebox(0.4,0.2){}}
\put(0.4,0.2){\circle{0.4}}
\put(0.2,0.0){\makebox(0.4,0.4){Jack}}
\end{picture} \\
\verb|> {row(<<x>>,<<y>>,<<z>>)}| \\
\begin{picture}(1.4,0.4)
\put(0.2,0.2){\circle{0.4}}
\put(0.5,0.1){\framebox(0.4,0.2){}}
\put(1.2,0.2){\circle{0.4}}
\put(1.0,0.0){\makebox(0.4,0.4){Jack}}
\end{picture} \\
\verb|> p = {column (row(<<x>>,<<y>>,<<z>>), row(<<z>>,<<y>>,<<x>>))}| \\
\begin{picture}(1.4,0.9)
\put(0.2,0.7){\circle{0.4}}
\put(0.5,0.6){\framebox(0.4,0.2){}}
\put(1.2,0.7){\circle{0.4}}
\put(1.0,0.5){\makebox(0.4,0.4){Jack}}
\put(1.2,0.2){\circle{0.4}}
\put(0.5,0.1){\framebox(0.4,0.2){}}
\put(0.2,0.2){\circle{0.4}}
\put(0.0,0.0){\makebox(0.4,0.4){Jack}}
\end{picture} \\
\verb|> raw x| \\
\verb|{circle 0.4}| \\
\verb|> raw p| \\
\verb|{column (row (circle 0.4,| \\
\verb|              rectangle (0.4,0.2),| \\
\verb|              (circle 0.4) labeled `Jack'),| \\
\verb|         row ((circle 0.4) labeled `Jack',| \\
\verb|              rectangle (0.4,0.2),| \\
\verb|              circle 0.4))}|
\end{indpar}

You can also change how an expression is displayed.

\begin{indpar}
\newlength{\ovalraise}
\setlength{\ovalraise}{-0.1in}
\addtolength{\ovalraise}{0.8ex}
\verb|> display (a person named X) as ((oval (0.4,0.2)) labelled X) <--| \\
\verb|> (a person named `Jack')| \\
\begin{picture}(0.4,0.2)
\put(0.2,0.1){\oval(0.4,0.2)}
\put(0.0,0.0){\makebox(0.4,0.2){Jack}}
\end{picture} \\
\verb|> ``(a person named `Jill') is wife of (a person named `Jack')''| \\
\verb|``|
\raisebox{\ovalraise}{\begin{picture}(0.4,0.2)
\put(0.2,0.1){\oval(0.4,0.2)}
\put(0.0,0.0){\makebox(0.4,0.2){Jill}}
\end{picture}}
{is the wife of}
\raisebox{\ovalraise}{\begin{picture}(0.4,0.2)
\put(0.2,0.1){\oval(0.4,0.2)}
\put(0.0,0.0){\makebox(0.4,0.2){Jack}}
\end{picture}}
\verb|''|
\end{indpar}

Displays can be used to make demonstrations:

\begin{indpar}
\verb|> a demo {| \\
\verb|+     angle = 30 degrees }| \\
\verb|display (a demo with angle X) as TBD <--|
\end{indpar}

TBD: example of a simple game.


\section{Lexical Scans}

A PCASL program is a sequence of characters which is scanned from
left to right to produce a sequence of pre-lexemes.  The sequence
of pre-lexemes is then scanned from left to right to produce
a sequence of lexemes.  The sequence of lexemes is then subject to
a left to right lexical parsing scan to produce a final set of lexemes
that is input for expression parsing.

\subsection{Pre-Lexemes}

Pre-lexemes are defined as follows:

\begin{indpar}
\key{pre-lexeme}
	\begin{tabular}[t]{rl}
	::= & \key{pre-word} \\
	$|$ & \key{opening-mark} \\
	$|$ & \key{closing-mark} \\
	$|$ & \key{format-separator} \\
	$|$ & \key{white-space}
	\end{tabular}
	\\[1ex]
\key{pre-word} ::= {\em word-character} {\em word-character}$^\star$ \\[1ex]
\key{word-character} \begin{tabular}[t]{rl}
                       ::= & {\em letter} $|$ {\em digit} \\
		       $|$ &    \verb|+|%
		             $|$\verb|-|%
		             $|$\verb|*|%
		             $|$\verb|/|%
		             $|$\verb|\|%
		             $|$\verb|~|%
		             $|$\verb|@|%
		             $|$\verb|#|%
		             $|$\verb|$|%
		             $|$\verb|%|%
		             $|$\verb|^|%
		             $|$\verb|&|%
		             $|$\verb|=|%
		             $|$\verb/|/%
		             $|$\verb|<|%
		             $|$\verb|>|%
		             $|$\verb|_|%
		             $|$\verb|"|%
		             $|$\verb|`|%
		             $|$\verb|'|%
		             $|$\verb|!|%
		             $|$\verb|?|%
			     $|$\verb|;|%
			     $|$\verb|:|%
			     $|$\verb|,|%
		             $|$\verb|.|
			\end{tabular}\\[1ex]
\key{letter} ::= {\em lower-case-letter} $|$ {\em upper-case-letter} \\[1ex]
\key{lower-case-letter} ::=    \verb|a|%
			    $|$\verb|b|%
			    $|$\verb|c|%
			    $|$\verb|d|%
			    $|$\verb|e|%
			    $|$\verb|f|%
			    $|$\verb|g|%
			    $|$\verb|h|%
			    $|$\verb|i|%
			    $|$\verb|j|%
			    $|$\verb|k|%
			    $|$\verb|l|%
			    $|$\verb|m|%
			    $|$\verb|n|%
			    $|$\verb|o|%
			    $|$\verb|p|%
			    $|$\verb|q|%
			    $|$\verb|r|%
			    $|$\verb|s|%
			    $|$\verb|t|%
			    $|$\verb|u|%
			    $|$\verb|v|%
			    $|$\verb|w|%
			    $|$\verb|x|%
			    $|$\verb|y|%
			    $|$\verb|z|
			    \\[1ex]
\key{upper-case-letter} ::=    \verb|A|%
			    $|$\verb|B|%
			    $|$\verb|C|%
			    $|$\verb|D|%
			    $|$\verb|E|%
			    $|$\verb|F|%
			    $|$\verb|G|%
			    $|$\verb|H|%
			    $|$\verb|I|%
			    $|$\verb|J|%
			    $|$\verb|K|%
			    $|$\verb|L|%
			    $|$\verb|M|%
			    $|$\verb|N|%
			    $|$\verb|O|%
			    $|$\verb|p|%
			    $|$\verb|Q|%
			    $|$\verb|R|%
			    $|$\verb|S|%
			    $|$\verb|T|%
			    $|$\verb|U|%
			    $|$\verb|V|%
			    $|$\verb|W|%
			    $|$\verb|X|%
			    $|$\verb|Y|%
			    $|$\verb|Z|
			    \\[1ex]
\key{digit} ::=    \verb|0|%
		$|$\verb|1|%
		$|$\verb|2|%
		$|$\verb|3|%
		$|$\verb|4|%
		$|$\verb|5|%
		$|$\verb|6|%
		$|$\verb|7|%
		$|$\verb|8|%
		$|$\verb|9|
		\\[1ex]
\key{opening-mark} ::=     \verb|(|
	       	       $|$ \verb|[|
	       	       $|$ \verb|{|
	       	       $|$ {\em opening-quote}
	       	       $|$ {\em opening-angle}
	       	       \\[1ex]
\key{closing-mark} ::=     \verb|)|
	       	       $|$ \verb|]|
	       	       $|$ \verb|}|
	       	       $|$ {\em closing-quote}
	       	       $|$ {\em closing-angle}
	       	       \\[1ex]
\key{opening-quote} \begin{tabular}[t]{rl}
		     ::= & {\em opening-quote-character}
		           {\em opening-quote-character}$^\star$ \\
		     \end{tabular}
		     \\[1ex]
\key{opening-quote-character} ::= \verb|`| \\[1ex]
\key{closing-quote} \begin{tabular}[t]{rl}
		     ::= & {\em closing-quote-character}
		           {\em closing-quote-character}$^\star$ \\
		     \end{tabular}
		     \\[1ex]
\key{closing-quote-character} ::= \verb|'| \\[1ex]
\key{quote} ::= {\em opening-quote} $|$ {\em closing-quote} \\[1ex]
\key{opening-angle} \begin{tabular}[t]{rl}
		     ::= & {\em opening-angle-character}
		           {\em opening-angle-character} \\
		         & {\em opening-angle-character}$^\star$ \\
		     \end{tabular}
		     \\[1ex]
\key{opening-angle-character} ::= \verb|<| \\[1ex]
\key{closing-angle} \begin{tabular}[t]{rl}
		     ::= & {\em closing-angle-character}
		           {\em closing-angle-character} \\
		         & {\em closing-angle-character}$^\star$ \\
		     \end{tabular}
		     \\[1ex]
\key{closing-angle-character} ::= \verb|>| \\[1ex]
\key{angle-character} ::= \verb|<| $|$ \verb|>| \\[1ex]
\key{opening-character} ::=     \verb|(|
		            $|$ \verb|[|
		            $|$ \verb|{|
		            $|$ \verb|`|
		            $|$ \verb|<|
			    \\[1ex]
\key{closing-character} ::=     \verb|)|
		            $|$ \verb|]|
		            $|$ \verb|}|
		            $|$ \verb|'|
		            $|$ \verb|>|
			    \\[1ex]
\key{format-separator} ::= {\em format-separator-character}
			   {\em format-separator-character}$^\star$ \\[1ex]
\key{format-separator-character} ::=    \verb\|\
				        \\[1ex]
\key{white-space} ::= {\em white-space-character}
                     {\em white-space-character}$^\star$ \\[1ex]
\key{white-space-character} ::=
    \key{horizontal-space-character} $|$ \key{vertical-space-character} \\[1ex]
\key{horizontal-space-character} ::=
    \key{space} $|$ \key{horizontal-tab} $|$ \key{carriage-return} \\[1ex]
\key{vertical-space-character} ::=
    \key{line-feed} $|$ \key{vertical-tab} $|$ \key{form-feed}
\end{indpar}


The following sections give rules involving pre-lexemes.

\subsubsection{Lexical Matching and Pre-Lexical Context}
\label{LEXICAL-MATCHING}

{\em Opening-marks} and {\em closing-marks} are both pre-lexemes
and also lexemes.  Rules for matching pre-lexemes in a pre-lexeme
sequence are the same as rules for matching lexemes in a lexeme sequence.
Here we will state the rules for lexemes, and leave it to the reader
to reformulate them for pre-lexemes.

{\bf Lexeme Matching Rule.}\index{Lexeme Matching Rule}
An {\em opening-mark} with $N$ characters $C$
must have a matching {\em closing-mark} with $N$ characters each the
mirror of $C$.  Here
the mirror of \verb|`| is \verb|'|,
the mirror of \verb|{| is \verb|}|,
the mirror of \verb|[| is \verb|]|,
the mirror of \verb|(| is \verb|)|,
and the mirror of \verb|<| is \verb|>|.
Each {\em closing-mark} must match exactly one
{\em opening-mark} and the {\em opening-mark} must precede the
{\em closing-mark}.

Two lexemes are said to be \mkey{matched}{lexemes} if and only if
they are matched opening and closing marks.

{\bf Matched Lexeme Nesting Rule.}\index{Matched Lexeme Nesting Rule}
If one lexeme in a pair $P_2$ of matched lexemes is in between the
lexemes of another pair $P_1$ of matched lexemes, then both lexemes
in $P_2$ must be in between the lexemes of $P_1$.  In this case
$P_2$ is said to be \mkey{nested}{lexemes} inside of $P_1$.

During the scan a character $C$ is said to be in the
\key{lexical context} of a pair $P$ of matched lexemes
if and only if $C$ is between the matched lexemes of $P$,
and $C$ is not between any other pair of matched
lexemes that is nested inside of $P$.  For example,
in \verb|{ x [ y ] z }|, \verb|{ }| are in the outermost pre-lexical
context, \verb|x [ ] z| are in the middle pre-lexical context whose
matched lexemes are \verb|{ }|, and
\verb|y| is in the innermost pre-lexical context whose matched lexemes
are \verb|[ ]|.

For a sequence of pre-lexemes, \mkey{matched}{pre-lexemes} pre-lexemes
and \key{pre-lexical context} are defined as for a sequence of lexemes.

\subsubsection{Character Disambiguation Rules}

Several characters in pre-lexemes are ambiguous in the
pre-lexeme syntax equations.  The following rules disambiguate these
characters.

{\bf Opening Quote Rule.}\index{Opening Quote Rule}
An \key{opening-quote-character} must be preceeded by a
{\em white-space-character},
an {\em opening-character}, or a {\em format-separator-character}.
Otherwise it is a {\em word-character}.

{\bf Closing Quote Rule.}\index{Closing Quote Rule}
A \key{closing-quote-character} must be part of a sequence of
{\em closing-quote-characters} that is of exactly the right length to be the
matching pre-lexeme for the last previous unmatched {\em opening-mark},
which must be an {\em opening-quote}.
Otherwise the potential {\em closing-quote-character}
is a {\em word-character}.

{\bf Format Separator Rule.}\index{Format Separator Rule}
A {\em format-separator-character} must be in the pre-lexical context of
a pair of matched {\em quotes}.  Otherwise it is a {\em word-character}.

{\bf Angle Rule.}\index{Angle Rule}
An {\em angle-character} must be either preceded by or followed by a copy
of itself.  Otherwise it is a {\em word-character}.

\subsubsection{Pre-Lexeme Examples}

Quote Examples:

\begin{indpar}[0.1in]
\begin{tabular}{@{}l@{\hspace*{0.3in}}l}
			& Pre-Lexeme Sequence		\\
Input String		& with {\em spaces} represented by \verb|_|'s \\[1ex]
\verb|I said `Hello'.|	& \tt I~~\verb|_|~~said~~\verb|_|~~`~~Hello~~'~~.	\\
\verb|Re`op 'tis.  But!|
			& \tt Re`op~~\verb|_|~~'tis.%
			  ~~\verb|__|~~But! \\
\verb|`Like 'tis'.|	& \tt `~~Like~~\verb|_|~~'~~tis'.	\\
\verb|``Like 'tis''.|	& \tt ``~~Like~~\verb|_|~~'tis~~''~~.	\\
\verb|`Like me''.|	& \tt `~~Like~~\verb|_|~~me''.		\\
\verb|`` `Hello' is a word.''|
			& \tt ``~~\verb|_|~~`~~Hello~~'~~\verb|_|~~is%
			  ~~\verb|_|~~a~~\verb|_|~~word.~~'' \\
\end{tabular}
\end{indpar}

Other rules of PCASL (\ref{LEXEMES})
limit the semantic content
of {\em white-space}, so that there is no problem putting
space between the \verb|``| and \verb|`| in the last example.

Angle and Format Separator Examples:

\begin{indpar}[0.1in]
\begin{tabular}{@{}l@{\hspace*{0.6in}}l}
			& Pre-Lexeme Sequence		\\
Input String		& with {\em spaces} represented by \verb|_|'s \\[1ex]
\verb|x <= y |		& \tt x \verb|_| \verb|<=| \verb|_| y	\\
\verb|x <<= y |		& \tt x \verb|_| \verb|<<| = \verb|_| y	\\
\verb/x = y|z/		& \tt x \verb|_| = \verb|_| \verb/y|z/ \\
\verb/x = `y|z'/	& \tt x \verb|_| = \verb|_|
                              \verb|`| y \verb/|/ z \verb|'| \\
\end{tabular}
\end{indpar}

\subsubsection{White Space Conversion}

A \key{white-space} pre-lexeme does not have exactly the same characters
that were input to create it, unlike other pre-lexemes.  The
sequence of {\em white-space-characters} input to create a
{\em white-space} pre-lexeme is modified as follows to create the pre-lexeme:

{\bf Line End Spaces Rule.}\index{Line End Spaces Rule}
All {\em horizontal-space} characters preceeding a {\em vertical-space}
character are deleted.  Thus spaces at line ends are ignored.

{\bf Carriage Return Rule.}\index{Carriage Return Rule}
Each {\em carriage-return} and all {\em horizontal-spaces} preceding
it are deleted.  Thus the pre-lexeme has no {\em carriage-returns}.

{\bf Horizontal Tab Rule.}\index{Horizontal Tab Rule}
Each {\em horizontal-tab} is replace by {\em spaces} assuming that
horizontal tab stops are set every 8 columns.
Thus the pre-lexeme has no {\em horizontal-tabs}.

Note that these rules do \underline{not} alter the printed appearance
of the {\em white-space} pre-lexeme.

After these rules are applied, a {\em white-space} pre-lexeme consists of
only of {\em vertical-space-characters} followed by {\em space} characters.

{\em White-space} pre-lexemes are used to create indentation lexemes
when pre-lexemes are converted to lexemes (\ref{INDENTATION-LEXEMES}).
{\em White-space} pre-lexemes that contain only {\em space} characters
become lexemes if they are after a {\em format-separator} \verb/|/ on
a line.  All other {\em white-space} pre-lexemes are ignored when
pre-lexemes are converted to lexemes, and all {\em white-space} pre-lexemes
that are not after a {\em format-separator} on a line are discarded and do
not become lexemes.

The rules for forming lexemes from pre-lexemes ensure that all
non-empty sequences of {\em vertical-space} characters are equivalent.


\subsection{Lexemes}
\label{LEXEMES}

The sequence of pre-lexemes is converted to a sequence of lexemes
according to the following rules, which we will describe in the
order given:

\begin{indpar}[1in]
Numbers \\
Post Separators \\
Indentation Lexemes
\end{indpar}

The syntax equations defining a lexeme are:

\begin{indpar}
\key{lexeme} ::= {\em word} $|$ {\em separator}
		$|$ {\em opening-mark}
		$|$ {\em closing-mark}
		$|$ {\em white-space} \\[1ex]
\key{separator} ::= {\em format-separator}
		$|$ {\em post-separator} \\[1ex]
\key{indentation-lexeme} ::= \verb|;|
			 $|$ \verb|{|
			 $|$ \verb|}|
\end{indpar}

{\em Post-separators} are single characters removed from the
ends of {\em pre-words}.  A {\em Word} is what is left of
a {\em pre-word} after any {\em post-separators}
are removed from its end.
{\em Words} and {\em post-separators} are defined
below in \ref{POST-SEPARATORS}.


The {\em indentation-lexemes} are lexemes implied by indentation, and
are not distinguishable from explicit lexemes, namely the post-separator
\verb|;|, the {\em opening-mark} \verb|{|, and the {\em closing-mark}
\verb|}|.  They are defined below in
\ref{INDENTATION-LEXEMES}.

{\em White-space} pre-lexemes are used to define indentation and
create {\em indentation-lexemes}.
{\em White-space} pre-lexemes become lexemes if they appear between a
{\em format-separator} and a following line ending {\em white-space}
pre-lexeme (\ref{TEXT-PARSING}).
All other {\em white-space} pre-lexemes are discarded when pre-lexemes
are scanned to lexemes.

{\em Format-separators}, {\em opening-marks}, and {\em closing-marks}
are both pre-lexemes and lexemes.

\subsubsection{Number Lexemes}
\label{NUMBER-LEXEMES}

The rule for spliting a {\em pre-word} into a {\em word}
and a {\em separator} makes reference to {\em words} that are
{\em numbers}, saying that splitting is preferred if the {\em word}
resulting from the split is a {\em number}.  Some of the syntax equations
defining {\em numbers} are as follows.

\begin{indpar}
\key{number} ::= {\em real-number} $|$ {\em unit-number}
				   $|$ {\em complex-number} \\[1ex]
\key{real-number} ::= {\em decimal-number} $|$ {\em radix-number}
				           $|$ {\em ratio}
				           $|$ {\em scientific-number}
\end{indpar}

\subsubsubsection{Decimal Numbers}
\label{DECIMAL-NUMBERS}

Decimal numbers are sequences of digits with optional commas,
an optional decimal point, and an optional sign.

\begin{indpar}
\key{decimal-number} ::= {\em unsigned-decimal-number}
                     $|$ {\em sign} {\em unsigned-decimal-number} \\[1ex]
\key{sign} ::= \verb|+| $|$ \verb|-| \\[1ex]
\key{unsigned-decimal-number} \begin{tabular}[t]{rl}
                              ::= & {\em decimal-natural} \\
		              $|$ & {\em decimal-natural} \verb|.|
		                    {\em decimal-natural} \\
		              $|$ & \verb|.| {\em decimal-natural}
		              \end{tabular} \\[1ex]
\key{decimal-natural} ::= {\em decimal-digits}
		     $|$ {\em decimal-natural} \verb|,| {\em decimal-digits}
		     \\[1ex]
\key{decimal-digits} ::= {\em digit} {\em digit}$^\star$ \\[1ex]
\key{decimal-ratio} ::= {\em decimal-natural} \verb|/|
			{\em decimal-natural}
\end{indpar}

Decimal Number Examples:

\begin{indpar}[0.1in]
\tt
\begin{tabular}{l@{~~~~~}l@{~~~~~}l@{~~~~~}l@{~~~~~}l}
123	& -123		& +123		& 1,234		& -1,234,567 \\
123.0	& -.123		& +0.0		& +.000		& 1,234.987,654 \\
1,2	& -1.86,54	& 1,234567.89	& 12345.678,9	& +1.234567,892
\end{tabular}
\end{indpar}

In a {\em decimal-number} lexeme, the decimal point must be followed by
a digit, and commas must be surrounded by digits.

In addition, commas must be located
every 3 digits from the decimal point, or every 3 digits
from the right end if there is no decimal point.
If there are any commas at all, there must be commas every 3 digits
in the integer part, while the fraction part may be comma free,
or may contain commas every 3 digits.
Failure to follow the rules of this paragraph will result in an
error when the lexeme is converted to a number,
but is \underline{not} an error of lexeme formation.  The last line of
examples above are therefore legal lexemes that will give errors when
converted to numbers.

\subsubsubsection{Radix Numbers}
\label{RADIXED-NUMBERS}

\ikey{Radix-numbers}{radix-number} permit binary, octal, or hexadecimal
radices to the used instead of decimal.  In fact, other number representation
schemes are permitted.

\begin{indpar}
\key{radix-number} ::= {\em unsigned-radix-number}
		   $|$ {\em sign} {\em unsigned-radix-number} \\[1ex]
\key{unsigned-radix-number} ::= {\em radix-indicator}
		        \verb|#| {\em radix-number-mark}
		        {\em radix-number-mark}$^\star$ \verb|#|
		        \\[1ex]
\key{radix-indicator} ::= {\em letter} {\em letter-or-digit}$^\star$ \\[1ex]
\key{letter-or-digit} ::= {\em letter} $|$ {\em digit} \\[1ex]
\key{radix-number-mark} ::= {\em word-character} except
	\{ \verb|#| $|$ \verb/|/ $|$ \verb|<| $|$ \verb|>|
	            $|$ \verb|`| $|$ \verb|'| \}
\end{indpar}

Radix Number Examples:

\begin{indpar}[0.1in]
\tt
\begin{tabular}{l@{~~~~~}l@{~~~~~}l@{~~~~~}l}

B\#10110100\#	& O\#77534201\# & D\#19758\#	& X\#FE8A932B\# \\
B\#101101\#	& O\#0.7753\#	& D\#197.58\#	& X\#0.fe8a932b\# \\
B\#10,1101\#	& O\#12,3456\#  & D\#0.123,5\#	& X\#FE8A,932B.7CCD,83\# \\
B\#a5,7b63\#	& O\#12/3456\#	& D\#+0.1\#	& X\#F.E8A932B.7CCD\# \\
\end{tabular}
\end{indpar}


The following {\em radix-indicators} are standard.

\begin{center}
\begin{tabular}{l@{~~~~~}l@{~~~~~}l@{~~~~~}l}
Radix	& Radix		 &			& Allowed Digits \\
Name	& Indicators     & Allowed Digits	& Between Commas \\[1ex]
binary	& \tt b~~~B	 & \tt 0 1		& 4 or 8 \\
octal	& \tt o~~~O	 & \tt 0 1 2 3 4 5 6 7	& 3 \\
decimal	& \tt d~~~D	 & \tt 0 1 2 3 4 5 6 7 8 9
						& 3 \\
hexadecimal
	& \tt x~~~X	 & \tt 0 1 2 3 4 5 6 7 8 9
						& 4 or 8 \\
	&		 & \tt a b c d e f A B C D E F
\end{tabular}
\end{center}

The rules for comma location are the same as for {\em decimal-numbers}
(\ref{DECIMAL-NUMBERS}), except the number of digits between commas may
be 4 or 8 instead of 3.

{\em Radix-numbers} can be legal lexemes and still be unconvertable to
numbers because their {\em radix-indicators} are undefined, they
have {\em radix-number-marks} (e.g., digits)
not defined for the given {\em radix-indicator}, they
have too many decimal points, and so forth.
These errors are detected when the lexemes are converted to numbers.
The last line of {\em radix-number} examples above are legal lexemes that
will give errors when converted to numbers.
Note that standard radix indicators only allow commas, a decimal point,
and digits as {\em radix-number-marks}.

On the other hand, it
is possible to define non-standard converters for converting
{\em radix-number} lexemes to numbers, and thereby increase the
space of number representations.

\subsubsubsection{Ratios}
\label{RATIOS}

A {\em ratio} consists of two strings of decimal digits, the numerator
and denominator, separated by a slash (`\verb|/|'),
with an optional sign.

\begin{indpar}
\key{ratio} ::= {\em unsigned-ratio}
	    $|$ {\em sign} {\em unsigned-ratio} \\[1ex]
\key{unsigned-ratio} ::= {\em numerator} \verb|/| {\em denominator} \\[1ex]
\key{numerator} ::= {\em decimal-natural} \\[1ex]
\key{denominator} ::= {\em decimal-natural}
\end{indpar}

Ratio Examples:

\begin{indpar}[0.1in]
\tt
\begin{tabular}{l@{~~~~~}l@{~~~~~}l@{~~~~~}l@{~~~~~}l}
1/2	& -3/4		& +1,234/5	& 1,234/5,432	& -53/000 \\
\end{tabular}
\end{indpar}

If the denominator equals zero, the ratio is still a legal lexeme, but
will cause an error when it is interpreted as a number.
\verb|-53/000| is an example.

\subsubsubsection{Scientific Numbers}
\label{SCIENTIFIC-NUMBERS}

A {\em scientific-number} is a {\em decimal-number} or a {\em radix-number}
followed by an exponent.

\begin{indpar}
\key{scientific-number} \begin{tabular}[t]{rl}
                        ::= & {\em decimal-number} {\em exponent} \\
			$|$ & {\em radix-number} {\em exponent}
		        \end{tabular} \\[1ex]
\key{exponent} ::= {\em exponent-indicator}
		   {\em exponent-sign-and-digits} \\[1ex]
\key{exponent-indicator} ::= \verb|e| $|$ \verb|E| $|$ \verb|^| \\[1ex]
\key{exponent-sign-and-digits} ::= {\em decimal-digits}
			    $|$ {\em sign} {\em decimal-digits}
\end{indpar}

Scientific Number Examples:

\begin{indpar}[0.1in]
\tt
\begin{tabular}{l@{~~~~~}l@{~~~~~}l@{~~~~~}l@{~~~~~}l}
123e0		& -123e+2	& +123e-321	& 1,234e9 \\
123E0		& -123E+2	& +123E-321	& -0.123,456e-3	\\
123\verb|^|0	& -123\verb|^|+2
				& -0.123,456e-3 & -1,234.567890\verb|^|6 \\
X\#a9\#e0	& B\#1011\#e-3	& O\#0.7753\#e-5
					    & X\#0.FE8A,932B,E\#\verb|^|+5 \\
\end{tabular}
\end{indpar}

Note that exponents cannot contain commas.

\subsubsubsection{Unit Numbers}
\label{UNIT-NUMBERS}

\ikey{Unit-numbers}{unit-number} are just {\em decimal-numbers} or {\em ratios}
with a {\em unit-indicator} prefixed or postfixed.  A {\em sign} may be before
or after a prefix {\em unit-indicator}.

\begin{indpar}
\key{unit-number} \begin{tabular}[t]{rl}
		  ::= & {\em pre-unit-indicator} {\em unit-base-number} \\
		  $|$ & {\em sign} {\em pre-unit-indicator}
		  		   {\em unsigned-unit-base-number} \\
		  $|$ & {\em unit-base-number} {\em post-unit-indicator}
		  \end{tabular} \\[1ex]
\key{unit-base-number} ::= {\em decimal-number} $|$ {\em ratio} \\[1ex]
\key{unsigned-unit-base-number} ::= {\em unsigned-decimal-number}
                                $|$ {\em unsigned-ratio} \\[1ex]
\key{pre-unit-indicator} ::= \verb|$| $|$ {\tt \pounds} \\[1ex]
\key{post-unit-indicator} ::= \verb|'| $|$ \verb|"| $|$ \verb|%|
                          $|$ $^\circ$ \\[1ex]
\key{unit-indicator} ::= {\em pre-unit-indicator}
		     $|$ {\em post-unit-indicator}
\end{indpar}

However, unit numbers are not lexemes.

{\bf Unit Number Rule.}\index{Unit Number Rule}
If a {\em unit-number} is to be output as a {\em word} lexeme, then instead
the {\em unit-number} is split into two {\em word} lexemes, one of which
is the {\em real-number} part and the other of which is a 1-character
{\em word} consisting of the {\em unit-indicator}.

Unit Number Examples:

\begin{indpar}[0.1in]
\begin{tabular}{@{}l@{\hspace*{0.3in}}l}
Unit Number		& Lexeme Sequence	\\[1ex]
\tt \$5.71		& \tt \$~~5.71 \\
\tt \pounds -5.71	& \tt \pounds ~~-5.71 \\
\tt 15'			& \tt 15~~' \\
\tt -2.543e3"		& \tt -2.543e3~~" \\
\tt 72\%		& \tt 72~~\% \\
\tt X\#BE63\#$^\circ$	& \tt X\#BE63\#~~$^\circ$
\end{tabular}
\end{indpar}

Note that {\em ratios} and {\em scientific-numbers} cannot have units
as part of their pre-lexeme.  This is to reduce confusion: the units can
always be given separated by a space from the number, as in `\verb|5e3 %|'.

\subsubsubsection{Complex Numbers}
\label{COMPLEX-NUMBERS}

An {\em imaginary-number} is just a {\em decimal-number}, {\em radix-number},
or {\em scientific-number} with an
{\em imaginary-indicator}, e.g.~\verb|j|, post-fixed.  A
{\em complex-number} is either an {\em imaginary-number}
or is a {\em decimal-number}, {\em radix-number}, or
{\em scientific-number} followed by signed
a {\em imaginary-number}.

\begin{indpar}
\key{complex-number} \begin{tabular}[t]{rl}
		     ::= & {\em imaginary-number} \\
		     $|$ & {\em complex-base-number}
		         {\em sign} {\em unsigned-imaginary-number}
		     \end{tabular} \\[1ex]
\key{imaginary-number} \begin{tabular}[t]{rl}
		     ::= & {\em unsigned-imaginary-number} \\
		     $|$ & {\em sign} {\em unsigned-imaginary-number}
		     \end{tabular} \\[1ex]
\key{complex-base-number} \begin{tabular}[t]{rl}
			  ::= & {\em unsigned-complex-base-number} \\
			  $|$ & {\em sign} {\em unsigned-complex-base-number}
			  \end{tabular} \\[1ex]
\key{unsigned-imaginary-number} ::=
		{\em unsigned-complex-base-number}
		{\em imaginary-indicator} \\[1ex]
\key{unsigned-complex-base-number} \begin{tabular}[t]{rl}
			   ::= & {\em unsigned-decimal-number} \\
			   $|$ & {\em unsigned-radix-number} \\
			   $|$ & {\em unsigned-scientific-number}
			   \end{tabular} \\[1ex]
\key{imaginary-indicator} ::=     \verb|I|
			      $|$ \verb|i|
			      $|$ \verb|J|
			      $|$ \verb|j|
\end{indpar}

Complex Number Examples:

\begin{indpar}[0.1in]
\tt
\begin{tabular}{l@{~~~~~}l@{~~~~~}l}

3i		& +3j		& -X'FE90.34D2'I		\\
2+3i		& -3+3.345e10j	& 35-X'FE90.34D2'J		\\
\end{tabular}
\end{indpar}

Note that {\em ratios} cannot be parts of complex numbers.
This is to reduce confusion: the {\em imaginary-indicator} can be used
as a separate unit lexeme as in `\verb|5 + 3/4 j|'.

\subsubsection{Post Separators}
\label{POST-SEPARATORS}

Informally, a post-separator is a 1-character separator that immediately
follows a word and could be part of that word.  Examples are the comma, period,
and the exclamation point.  There are two kinds of post separators:
weak and strong.  The Post Separator Rule
given below tells when a {\em pre-word} ending
in a {\em post-separator-character}
must be split into a smaller {\em pre-word} and a 1-character
{\em separator}.  This rule makes reference to {\em words} that are
{\em numbers}, saying that splitting is preferred when the
{\em post-separator-character} is weak if the {\em pre-word}
resulting from the split is a {\em number}.

The syntax equations required are:

\begin{indpar}
\key{separator} ::= {\em format-separator}
		$|$ {\em post-separator} \\[1ex]
\key{post-separator} ::= {\em post-separator-character} \\[1ex]
\key{post-separator-character} \begin{tabular}[t]{rl}
                     ::= & {\em strong-post-separator-character} \\
		     $|$ & {\em weak-post-separator-character}
		     \end{tabular} \\[1ex]
\key{strong-post-separator-character} ::=     \verb|,|
			                $|$ \verb|;|
					\\[1ex]
\key{weak-post-separator-character} ::=     \verb|!|
				        $|$ \verb|?|
			                $|$ \verb|:|
			                $|$ \verb|.|
					\\[1ex]
\key{pre-word} ::= {\em word}
		$|$ {\em pre-word} {\em post-separator-character}
\end{indpar}

{\bf Post Separator Rule.}\index{Post Separator Rule}
A {\em pre-word} of 2 or more characters
that ends with a {\em post-separator-character}
is split into a smaller {\em pre-word} and a {\em post-separator}
if (1) the {\em post-separator-character} is strong, or if
(2) the smaller {\em pre-word} ends with a
{\em strong-post-separator-character}, or if
(3) the smaller {\em pre-word} is a {\em number}, or if
(4) the smaller {\em pre-word} does 
\underline{not} contain a copy of the {\em post-separator-character}.
If the {\em pre-word} is not split, it becomes a {\em word} lexeme.

The following rule handles the case of 1-character {\em pre-words}.

{\bf Isolated Post Separator Rule.}\index{Isolated Post Separator Rule}
A {\em pre-word} that consists of a single {\em post-separator-character}
is a {\em post-separator} lexeme.


Examples:

\begin{indpar}[0.1in]
\begin{tabular}{@{}l@{\hspace*{0.3in}}l@{~~~}l@{\hspace*{0.6in}}l}
Pre-Word		& \multicolumn{2}{@{}l@{}}{Lexeme Sequence}
							& Splits?	\\[1ex]
\verb|hello.|		& \tt hello 		& \tt .	& yes		\\
\verb|X,|		& \tt X 		& \tt ,	& yes		\\
\verb|h.e.l.l.o.|	& \tt h.e.l.l.o.	&	& no		\\
\verb|e.g.|		& \tt e.g.		&	& no		\\
\verb|5.0.|		& \tt 5.0		& \tt .	& yes		\\
\verb|1,234.5,|		& \tt 1,234.5		& \tt ,	& yes		\\
\verb|1,234.5,,|	& \tt 1,234.5		& \tt ,~~,
							& yes, twice	\\
\verb|1,234.5.,|	& \tt 1,234.5		& \tt .~~,
							& yes, twice	\\
\verb|1,234.5,.|	& \tt 1,234.5		& \tt ,~~.
							& yes, twice	\\
\verb|help!|		& \tt help		& \tt !	& yes		\\
\verb|!help!|		& \tt !help!		&	& no		\\
\verb|help.!|		& \tt help		& \tt .~~!
							& yes, twice	\\
\verb|.help.!|		& \tt .help.		& \tt !
							& yes, once	\\
\verb|!.help.!|		& \tt !.help.!		&	& no		\\
\end{tabular}
\end{indpar}

\subsubsection{Indentation Lexemes}
\label{INDENTATION-LEXEMES}

{\em Indentation-lexemes} are implied by indentation.  The
\mkey{indentation}{of line} of a line is the
the number of {\em space} characters in the {\em white-space}
pre-lexeme just before the first non-{\em white-space} pre-lexeme
of the line.  Note that lines cannot be empty; empty lines are
merged into {\em white-space} pre-lexemes.

At any given point in the scan converting pre-lexemes to lexemes, there is a
stack of indentation records, called the \key{indentation stack}.
An \key{indentation record} is a number of
columns, a pre-lexical context, and a flag.
The number of columns is called the \key{indentation}.
The flag is called the \key{implicit bracket flag}, and indicates whether
or not an implied \verb|{| lexeme was inserted at the same time the
indentation record was pushed onto the indentation stack.

Initially the indentation stack contains a single indentation record with
0 indentation, the outermost pre-lexical context,
and an off implicit bracket flag.
The stack cannot become empty; any operation that would
pop the last indentation off the stack announces an error and leaves the
stack alone.  Thus the bottommost indentation on the stack is always
the same.

The indentation in the indentation record at the top of the indentation
stack is called the \key{current indentation}, and the pre-lexical
context in that record is called the \key{current indentation context}.

The rules for creating indentation records are such that the pre-lexical
contexts in such records are either pre-lexical contexts of some \verb|{ }|
bracket pair, or are the outermost pre-lexical context, which therefore behaves
like the context of a \verb|{ }| bracket pair as far as indentation is
concerned.

{\bf Semi-Colon Rule.}\index{Semi-Colon Rule}
If the first non-{\em white-space} pre-lexeme of a line is not \verb|}|,
if the beginning of the line is in the current indentation context
(the first pre-lexeme of the line would be in the current indentation
context if it did not end a sub-context),
if the indentation of the line is the current indentation,
and if the last lexeme output was not
a \verb|;| {\em separator} lexeme or a \verb|{| {\em opening-mark}
lexeme (including an implied {\em opening-mark} as in the
Implicit-Bracket Rule below), then a \verb|;| implied {\em separator}
lexeme is output
before any lexemes generated by the line are output.

{\bf Explicit-Bracket Rule.}\index{Explicit-Bracket Rule}
If the last pre-lexeme of a line is \verb|{|, then an indentation record
is pushed into the indentation stack just after the \verb|{| lexeme
is output.  The indentation in the record is the indentation of the next
line, the pre-lexical context is that in effect just after the \verb|{|,
and the implicit bracket flag is off.
The pushed indentation record is popped just after its pre-lexical context
ends; that is, just before reading the \verb|}| pre-lexeme that matches the
\verb|{| pre-lexeme that pushed the indentation record.

{\bf Implicit-Bracket Rule.}\index{Implicit-Bracket Rule}
If the last lexeme output for a line would be a separator \verb|:| in
the current indentation context,
then a \verb|{| implied {\em opening-mark} lexeme
is output instead of the \verb|:|, and an indentation
record is pushed into the indentation stack.  The indentation of the
record is the indentation of the next line, the implicit bracket flag
of the record is on, and the
pre-lexical context of the record is that of the \verb|:|.
The pushed record is popped (1) just before the first line such that
the line beginning pre-lexeme is in the record's pre-lexical context
and the line's indentation is less than the record's indentation,
or (2) at the end of the input pre-lexeme stream.
When the record is popped, a \verb|}| implied {\em closing-mark}
lexeme is output.

In order to avoid subtle errors created by indentation, there
is a {\tt minimum-indentation} parameter and the following rule.

{\bf Minimum-Indentation Rule.}\index{Minimum-Indentation Rule}
The indentation of any line whose beginning is in the current indentation
context (the first pre-lexeme of the line would be in the current indentation
context if it did not end a sub-context) must equal the current indentation
or differ from it by at least the value of the
\ttkey{minimum-indentation} parameter.  The {\tt minimum-indentation}
parameter defaults to {\tt 4}.


Indentation Lexeme Examples:

\begin{indpar}[0.1in]
\tt \ttbrackets
\begin{tabular}{@{}p{2in}@{~~~~~~~~~~}l}
{\rm Input String}		& {\rm Output Lexemes} \\[1ex]
hi \{ x; y z; w \}		& \tt hi \{ x ; y z ; w \} \\[1ex]
hi \{				& hi \{ \\
~~~~x				& x \\
~~~~y z				& ; y z \\
~~~~w \}			& ; w \}
\end{tabular}
\end{indpar}
\begin{indpar}[0.1in]
\tt \ttbrackets
\begin{tabular}{@{}p{2in}@{~~~~~~~~~~}l}
hi				& hi \\
\{				& \{ \\
~~~~x				& x \\
~~~~y z				& ; y z \\
~~~~w				& ; w \\
\}				& \}
\end{tabular}
\end{indpar}
\begin{indpar}[0.1in]
\tt \ttbrackets
\begin{tabular}{@{}p{2in}@{~~~~~~~~~~}l}
hi:				& hi \{ \\
~~~~x				& x \\
~~~~y z				& ; y z \\
~~~~w				& ; w \\
				& \}
\end{tabular}
\end{indpar}
\begin{indpar}[0.1in]
\tt \ttbrackets
\begin{tabular}{@{}p{2in}@{~~~~~~~~~~}l}
hi \{				& hi \{ \\
~~~~x				& x \\
~~~~y `this			& ; y ` this \\
is another pre-lexical		& is another pre-lexical \\
context.			& context . \\
' foo bar			& ' foo bar \\
~~~~w \}			& ; w \}
\end{tabular}
\end{indpar}
\begin{indpar}[0.1in]
\tt \ttbrackets
\begin{tabular}{@{}p{2in}@{~~~~~~~~~~}l}
hi \{				& hi \{ \\
~~~~x				& x \\
~~~~\{				& ; \{ \\
ho				& ho \\
hum \} y			& ; hum \} y \\
~~~~z \}			& ; z \}
\end{tabular}
\end{indpar}


\subsection{Lexical Parsing}
\label{LEXICAL-PARSING}

After pre-lexemes are scanned to produce lexemes, the lexemes are
scanned to perform the following:

\begin{indpar}[1in]
Spelling Regularization \\
Possessive Splitting \\
Number Unit Grouping
\end{indpar}

We describe these below in order.

The scan that performs the above actions is called
\key{lexical parsing}\index{parsing!lexical},
because it does intial parse steps
at the level of individual lexemes and short sequences of lexemes, and
because it is controlled by definitions in the parsing stack

(\pageref{PARSING-STACK}).

\subsubsection{Spelling Regularization}
\label{SPELLING-REGULARIZATION}

\subsubsection{Possessive Splitting}
\label{POSSESSIVE-SPLITTING}

\subsubsection{Number Unit Grouping}
\label{NUMBER-UNIT-GROUPING}

\section{Expression Parsing}\index{parsing!expression}
\label{EXPRESSION-PARSING}

An expression is a sequence of words, separators, and subexpressions.
A subexpression is a pair of matched lexemes and all the lexemes in
between.

Expressions and subexpressions can contain operators.  When they do,
matched implied parentheses are inserted into the expressions or subexpressions
according to rules of operator precedence and associativity, and these
implied parentheses create new subexpressions.

Expressions and subexpressions that do not contain operators may contain
argument lists and qualifying phrases.  The order in which qualifying
phrases appear does not matter, and sometimes the order of arguments
in an argument list does not matter.

Expressions containing operators are restructured, both by inserting
implied parentheses and in other ways.  Subexpressions surrounded by
particular matching lexemes, such as \verb|`'|, are restructured in
special ways.

The process of restructuring expressions is called
\key{expression parsing}\index{parsing!expression}.
Expression parsing takes an expression as input, and produces as output a raw
expression that contains nothing that will trigger further restructuring.

\subsection{Subexpressions}
\label{SUBEXPRESSIONS}

The first step in parsing is to identify \skey{subexpression}s within
an expression, without restructuring the expression, by applying
the following syntax equations.

\begin{indpar}
\key{expression} ::= {\em expression-item}$^\star$ \\[1ex]
\key{expression-item} ::= {\em word} $|$ {\em separator}
				     $|$ {\em subexpression} \\[1ex]
\key{subexpression} ::= {\em opening-mark} {\em expression}
			{\em closing-mark}
\end{indpar}

{\bf Subexpression Rule.}\index{Subexpression Rule}
The {\em opening-mark} lexeme that begins a subexpression must lexically match
(\ref{LEXICAL-MATCHING}) the {\em closing-mark} lexeme that
ends a subexpression.

\subsection{Expression Structure Overview}
\label{EXPRESSION-STRUCTURE-OVERVIEW}

Expression structure is affected by five special marks.
The \key{optional argument mark} `\ttkey{?:?}' is used in expression
definitions
to separate arguments that are required from those that can be optional,
as in the expression `\verb|find-max LIST ?:? COMPARATOR|', in which the
the `\verb|LIST|' argument is required but the `\verb|COMPARATOR|' argument
is optional.
The \key{reorder mark} `\ttkey{<:>}' is used in expression definitions
to separate arguments whose order can be switched,
as in the expression `\verb|element LIST <:> INDEX|' in which the
`\verb|LIST|' and `\verb|INDEX|' argument can be switched.
The \key{remainder mark} `\ttkey{::>}' preceeds a final argument in an
expression definition that represents the list of remaining arguments in a use
of the definition, as in the expression `\verb|max ::> ARGS|',
where \verb|ARGS| represents
the list of all the arguments given to \verb|max|.
The \key{required qualifier mark}\index{qualifier mark!required}
`\ttkey{@@}' signals that the following
expression item is a required qualifier, as in the expression
`\verb|sort x @@ with order ascending |',
and is implied by qualifiers (e.g. \verb|with|, \verb|has|)
in an expression.
The \key{optional qualifier mark}\index{qualifier mark!optional}
`\ttkey{??}' signals that the following
expression item is an optional qualifier, as in the expression
`\verb|sort X ?? with order O|'.  When default values are provided in
definitions, required qualifier marks may be converted automatically to
optional qualifier marks and an optional argument mark may be inserted into an
argument list automatically (\ref{TBD}).

Expressions are restructured if they contain operators (e.g.,
\verb|+|,
\verb|-|,
\verb|*|,
\verb|/|),
qualifiers (e.g.,
\verb|with|,
\verb|has|),
or qualifier shortcuts (e.g., \verb|ascending|, which is a shortcut for
`{\tt with order ascending}').
A \key{raw expression} (\ref{RAW-EXPRESSIONS})
is a particular kind of expression that will not be
restructured.  The only special marks that may be in a raw expression
are the five special marks:
the optional argument mark (\verb|?:?|), the reorder mark (\verb|<:>|),
the remainder mark (\verb|::>|),
and the qualifier marks (\verb|@@|, \verb|??|).
Translating
an expression into a raw expression is called \key{parsing}.

Some operators are matchfix operators, which surround their single
argument like parentheses.  Some matchfix operators have special
affects on parsing.  An informal summary of the standard matchfix
operators is:

\begin{center}
\begin{tabular}{l@{~~~~~~}l@{~~~~~~}l@{~~~~~~}l@{~~~~~~}l}
		& \multicolumn{4}{c}{Turns} \\ \cline{2-5}
		& operators	& \verb/|/	& \verb|<:> ::>| \\
Brackets	& qualifiers	& text		& \verb|@@  ??|
								& eval \\[1ex]

\verb|(|\ldots\verb|)|
		& --		& --		& --		& -- \\
\verb|{|\ldots\verb|}|
		& on		& off		& on		& off \\
\verb|[|\ldots\verb|]|
		& off		& off		& on		& off \\
\verb|{{|\ldots\verb|}}|
		& on		& off		& on		& -- \\
\verb|[[|\ldots\verb|]]|
		& off		& off		& on		& -- \\
\verb|<<|\ldots\verb|>>|
		& on		& off		& on		& on \\
\verb|<<<|\ldots\verb|>>>|
		& on		& off		& on		& on twice \\
\verb|<<<<|\ldots\verb|>>>>|
		& on		& off		& on		& on thrice \\
\verb|`|\ldots\verb|'|
		& off		& on		& off		& off \\
\verb|``|\ldots\verb|''|
		& off		& on		& off		& off \\
\verb|```|\ldots\verb|'''|
		& off		& on		& off		& off \\
\end{tabular}
\end{center}

Other matching lexemes may be made to affect parsing by introducing
operator definitions (\ref{OPERATOR-DEFINITIONS}).

Parsing is controlled by the \key{parsing stack},\label{PARSING-STACK}
which contains definitions of parsers, operators, qualifiers, and
qualifier shortcuts.  An operator may push definitions into the parsing
stack.  After the expression containing the operator has been parsed,
these definitions will be popped from the parsing stack.

A \key{parser definition} just names a parser.  The most recent parser
definition in the parsing stack names the parser used to parse expressions.
There are three standard \ikey{parsers}{parser!standard}:
the \key{marks parser} \ttkey{-MARKS-PARSER-},
where only the optional argument mark (\verb|?:?|), reorder mark (\verb|<:>|),
remainder mark (\verb|::>|), required qualifier mark (\verb|@@|),
and optional qualifier mark (\verb|??|), are recognized;
the \key{operators parser} \ttkey{-OPERATORS-PARSER-},
where these marks
are recognized along with operators, qualifiers, and qualifier shortcuts;
and the \key{text parser} \ttkey{-TEXT-PARSER-},
where only the format-separator (\verb/|/) and punctuation are recognized.

From the parsing point of view there are several types of
expression restructuring that can occur.  One, text restructuring,
is done by the text parser (\ref{TEXT-PARSING}), which is invoked by
\verb|`'| quotes, and does things like turn
\verb|`I am!'| into \verb|[sentence I am !]|.  Other kinds of
restructuring are done by the operators parser (\ref{OPERATORS}).
The operators `\verb|+|', `\verb|-|', and `\verb|*|' in the expression
\verb|x + y - 5 * z| cause this expression to be restructured as
\verb|[- [+ x y] [* 5 z]]|.  The qualifier `\verb|with|' in the
expression \verb|sort x with order ascending| cause this expression
to be restructured as \verb|[sort x @@ with order ascending]|.
And the qualifier shortcut `\verb|ascending|' in the expression
\verb|sort x| \verb|ascending| cause this expression to be
restructured as \verb|[sort x @@ with order ascending]|.

In expressions that cannot contain operators,
words and separators that would be recognized elsewhere as operators,
qualifiers, or qualifier shortcuts are not recognized as such.  Thus in
\verb|[word +]| the \verb|+| is not recognized as an operator, and
in \verb|[item ascending]| \verb|ascending| is not recognized as
a qualifier shortcut.

Some of the matchfix operators above affect evaluation (eval).
Evaluation differs from parsing in that it is managed by a
counter and not a stack; if evaluation is
turned off twice, it must be turned on twice to be in effect.
Thus in a context in which evaluation is on, the \verb|X| in
\verb|{ <<X>> = 5 }| and \verb|{ y = `<< <<X>> >>' }| will be evaluated
but the \verb|X| in \verb|{ y = `<<X>>' }| will not be.  There is
an \key{evaluation counter} value that is
incremented (decremented) by an opening mark
that turns evaluation on (off), and decremented (incremented) by the
corresponding closing mark.  This counter sticks at +1: matching
lexemes that would increment the counter have no affect if the counter
is at +1.

The brackets `\verb|<<<|\ldots\verb|>>>|' are equivalent to
`\verb|<< <<|\ldots\verb|>> >>|' and thus turn evaluation on twice.
Thus \verb|{ y = `<< <<X>> >>' }| is equivalent to \verb|{ y = `<<<X>>>' }|.
Similarly the brackets `\verb|<<<<|\ldots\verb|>>>>|'
are equivalent to `\verb|<< << <<|\ldots\verb|>> >> >>|' and
turn evaluation on thrice.

Evaluation is not part of parsing; the evaluation counter is
used during expression evaluation, which occurs after expression parsing.
Parsing does insert the wrappers (\ref{OPERATOR-WRAPPER})
\ttkey{-EVAL-ON-} and \ttkey{-EVAL-OFF-} around expressions to inform
the evaluator when to increment or decrement the evaluation counter.

\subsection{Raw Expressions}
\label{RAW-EXPRESSIONS}

A raw expression is an expression that contains no operators,
qualifiers, qualifier shortcuts, or text parsing contexts that
induce restructuring.
Raw expressions can be directly represented using the \verb|[]|
matching lexemes and the \verb|?:?| optional argument,
\verb|<:>| reorder, \verb|::>| remainder,
\verb|@@| required qualifier, and \verb|??| optional qualifier marks.

When an expression is parsed, the output is a raw expression.
The following are examples, all of which are assumed to
appear in the context of \verb|{}| matching lexemes (so
operators, qualifiers, and qualifier shortcuts
are turned on and text parsing is turned off):

\begin{center}
\begin{tabular}{ll}
Input Expression	& Raw Expression Equivalent \\[1ex]
\verb|3 * x * x + 5|	& \verb|[+ [* [* 3 x] x] 5]| \\
\verb|x = y = 10|	& \verb|[= x [= y 10]]| \\
\verb|0 < x <= 5 |	& \verb|[-COMPARE- 0 < x <= 5]| \\
\verb|x = `Hello <<y>>.' |
			& \begin{tabular}[t]{@{}l}
	    \verb|[= x [-EVAL-OFF-| \\
	    \verb|      [sentence Hello| \\
	    \verb|                [-EVAL-ON- y]| \\
	    \verb|                .]]]| \\
	    \end{tabular}
\end{tabular}
\end{center}

The syntax of raw expressions is defined as follows:

\begin{indpar}
\key{raw-expression} ::= {\em word} $|$ {\em separator}
				     $|$ {\em raw-subexpression} \\[1ex]
\key{raw-subexpression} ::=
	\begin{tabular}[t]{@{}ll}
	\verb|[| & {\em raw-expression-head} \\
		 & {\em raw-argument-list} \\
		 & {\em raw-qualifier-phrase}$^\star$ \verb|]| \\
	\end{tabular} \\[1ex]
\key{raw-expression-head} ::= {\em raw-expression} \\[1ex]
\key{raw-argument-list}
        \begin{tabular}[t]{@{}rl}
	::= & {\em raw-base-argument-list}
	      {\em raw-argument-remainder-option} \\
	$|$ & \begin{tabular}[t]{@{}l}
	      {\em raw-base-argument-list}
	      {\em optional-argument-mark} \\
	      {\em non-empty-raw-base-argument-list} \\
	      {\em raw-argument-remainder-option}
	      \end{tabular}
	\end{tabular} \\[1ex]
\key{optional-argument-mark} ::= \verb|?:?| \\[1ex]
\key{raw-base-argument-list}
	::= {\em empty} $|$ {\em non-empty-raw-base-argument-list} \\[1ex]
\key{raw-non-empty-base-argument-list}
        \begin{tabular}[t]{@{}rl}
	::= & {\em raw-argument} \\
	    & \{ {\em reorder-mark-option} {\em raw-argument} \}$^\star$
	\end{tabular} \\[1ex]
\key{reorder-mark-option} ::= {\em empty} $|$ \verb|<:>| \\[1ex]
\key{reorder-argument-remainder-option} ::=
	{\em empty} $|$ \verb|::>| {\em raw-argument} \\[1ex]
\key{raw-argument} ::= {\em raw-expression} \\[1ex]
\key{raw-qualifier-phrase} ::=
	{\em qualifier-mark} {\em raw-qualifier-head}
			     {\em raw-argument-list} \\[1ex]
\key{qualifier-mark} ::= {\em required-qualifier-mark}
			 $|$ {\em optional-qualifier-mark} \\[1ex]
\key{required-qualifier-mark} ::= \ttkey{@@} \\[1ex]
\key{optional-qualifier-mark} ::= \ttkey{??} \\[1ex]
\key{raw-qualifier-head} ::= {\em raw-expression}
\end{indpar}

The order of {\em raw-qualifier-phrases}
in a {\em raw-expression} does not matter.
The order of arguments separated by {\em reorder-marks} (\verb|<:>|) does
not matter.  The {\em optional-argument-mark} (\verb|?:?|),
{\em reorder-mark} (\verb|<:>|), {\em remain\-der-mark}
(\verb|::>|), and {\em optional-qualifier-mark} (\verb|??|)
can only occur in a pattern (\ref{CALL-UNIFICATION}).

\subsection{Operators}
\label{OPERATORS}

Operators restructure expressions in which they occur.  Operators
are defined by operator definitions that can be added to the
parsing stack by some operators.

\subsubsection{Operator Definitions}
\label{OPERATOR-DEFINITIONS}

\ikey{Operator definitions}{operator definition} can be pushed into
the parsing stack, and are used by the operators parser.
An operator definition specifies for each operator the following:

\begin{indpar}[1in]
Fixity \\
Name \\
Precedence \\
Associativity \\
Parser \\
Control Flags \\
Wrapper \\
Subdefinitions
\end{indpar}


\subsubsubsection{Operator Fixity}\ttmindex{fixity}{of operator}
\label{OPERATOR-FIXITY}
An operator has one of the following fixities:

\begin{indpar}
\begin{tabular}{@{}p{1in}@{~~~}p{4in}@{}}
\ttkey{infix}		& E.g., \verb|+| in \verb|x + 5|.\\
\ttkey{prefix}		& E.g., \verb|-| in \verb|- 5|.\\
\ttkey{postfix}		& E.g., \verb|!| in \verb|x!|.\\
\ttkey{matchfix}	& E.g., \verb/[| |]/ in \verb/[| x - 5 |]/.
\end{tabular}
\end{indpar}

An infix operator is placed between its two operands;
a prefix operator is placed before its one operand;
a postfix operator is placed after its one operand;
and a matchfix operator surrounds its one operand.
Operands of prefix, infix, and postfix
operators may not be empty; but the operand of a matchfix operator
may be empty.
An infix operator may not begin or end an expression;
a prefix operator must begin an expression;
a postfix operator must end an expression;
and a matchfix operator has two parts: an opening operator
that must begin an expression and a closing operator that must end
the same expression.

\subsubsubsection{Operator Name}\ttmindex{name}{of operator}
\label{OPERATOR-NAME}
An operator definition has a sequence of lexemes that is the
{\em name} of the operator.  The operator
inside a subexpression is just this sequence of lexemes, except for
matchfix operators, which have two sequences of lexemes, an
\key{opening operator name} that must begin the subexpression and
a \key{closing operator name} that must end the subexpression.

By abuse of language, the term `\key{operator}' is often used
as a synonym for `operator name'.  Similarly `\key{opening operator}'
is used as a synonym for `opening operator name' and `\key{closing operator}'
is used as a synonym for `closing operator name'.

The opening and closing names of a matchfix
operator are bundled into a single operator name that is
sequence of lexemes consisting of
the opening operator name followed by a `\verb/.../' lexeme
followed by the closing operator name.
For example, the
matchfix operator named `\verb/[ | ... | ]/' permits subexpressions
like `\verb/[| x - 5 |]/'.  Here the opening operator name
is `\verb/[|/' and the closing operator name is `\verb/|]/'.

Opening and closing marks cannot be part of an operator name
unless the operator is a matchfix operator.
If opening and closing marks are part of a matchfix operator
name, they must begin and end the name, and they must \underline{not} be
parentheses \verb|()|.

When a subexpression is tested
for matchfix operators, any opening and closing marks that begin and
end the subexpression are included in the subexpression, unless they are
parentheses \verb|()|, which are always removed (recursively) when they
begin and end a subexpression, and are thus invisible.  Thus
the matchfix operator `\verb/| ... |/' could be invoked by
the expression `\verb/x + (| y |)/', but not by the expression
`\verb/x + [| y |]/'.  Operator names are not permitted
to include parentheses \verb|()|, so names such as `\verb/(| ... |)/'
are erroneous.
Generally, including extra pairs of parentheses
\verb|()| has no affect on expression parsing or expression meaning,
though the explicit parentheses in `\verb/[(|x|)]/' will prevent 
a matchfix operator named `\verb/[| ... |]/' from being recognized.

\subsubsubsection{Operator Precedence}\ttmindex{precedence}{of operator}
\label{OPERATOR-PRECEDENCE}
The precedence of an operator is an integer.  Precedence is used in
selecting which infix operators in an expression to consider
(\ref{OPERATOR-SELECTION}).
Only infix operators have precedence.

\subsubsubsection{Operator Associativity}\ttmindex{associativity}{of operator}
\label{OPERATOR-ASSOCIATIVITY}
An infix operator has an {\em associativity} that is
a sequence of lexemes.
Three associativities, {\tt left}, {\tt right}, and
{\tt none}, have special meaning.  If an infix operator has some
other associativity, it is said to have \key{named associativity}.
Only infix operators have associativity.

If more than one infix operator is selected in an expression by the operator
selection algorithm\EOL (\ref{OPERATOR-SELECTION}),
all the infix operators that are selected
must have the identical operator definitions except for operator names,
and the associativity in these definitions
must not be {\tt none}\ttmindex{none}{associativity}.

If all operators are {\tt left} associative%
\index{left associative@{\tt left} associative},
all the infix operators but the rightmost are deselected,
so it is as if operators to the left had
higher precedence than those to the right.

If all operators are {\tt right} associative%
\index{right associative@{\tt right} associative},
all the infix operators but the leftmost are deselected,
so it is as if operators to the right had
higher precedence than those to the left.

If all operators are of \key{named associativity}, all remain selected, and 
implicitly parenthesized subexpressions will be created between the
operators as well as between the beginning of the expression and the
first operator and between the last operator and the end of the expression.
Then the associativity, as a lexeme sequence, is prepended to the expression.
Thus if the infix operators \verb|<| and \verb|<=| have associativity
\verb|-COMPARE-|, the expression \verb|0 < x - 3 <= 5| will
be rewritten as \verb|[-COMPARE- 0 < (x - 3) <= 5]|.

\subsubsubsection{Operator Parser}\ttmindex{parser}{of operator}
\label{OPERATOR-PARSER}

A parser is the name of the function that is called with an expression
as its single argument in order to parse the expression.

Parsers can be pushed into the parsing stack.
The parser used for subexpressions of an expression is the parser
nearest the top of the parsing stack.

The \verb|parser| of an operator definition is an optional word that
names a parser.  If present, the word is pushed into the parsing
stack before subexpressions are parsed, and popped from the parsing stack
after subexpressions have been parsed.

The following are standard parsers:

\begin{indpar}

The \key{operators parser} \ttkey{-OPERATORS-PARSER-}.
Operators, qualifiers, qualifier shortcuts,
and the \verb|?:?| optional argument,
\verb|<:>| reorder, \verb|::>| remainder,
\verb|@@| required qualifier, and
\verb|??| optional qualifier marks are recognized.  The special constructs
of text parsing, e.g., the \verb/|/ format separator,
are \underline{not} recognized.

The \key{marks parser} \ttkey{-MARKS-PARSER-}.
The \verb|?:?| optional argument,
\verb|<:>| reorder, \verb|::>| remainder,
\verb|@@| required qualifier, and
\verb|??| optional qualifier marks are recognized.  Operators, qualifiers,
qualifier shortcuts, and the special constructs
of text parsing, e.g., the \verb/|/ format separator,
are \underline{not} recognized.

The \key{text parser} \ttkey{-TEXT-PARSER-}.
The special constructs of text parsing (\ref{TEXT-PARSING}) are
recognized.  Operators, qualifiers, qualifier shortcuts, and
the \verb|?:?| optional argument,
\verb|<:>| reorder, \verb|::>| remainder,
\verb|@@| required qualifier, and
\verb|??| optional qualifier marks are \underline{not} recognized.

\end{indpar}

\subsubsubsection{Operator Control Flags}\ttmindex{control flag}{of operator}
\label{OPERATOR-CONTROL-FLAGS}
Operators can be associated with \skey{operator control flag}s that
affect parsing of subexpressions of the operator.

\begin{indpar}

{\bf definitions}\index{definitions flag@{\tt definitions} flag}~~~~~
This flag may only be given for a right associative infix operator.
It causes the
left operand of the operator to be inspected to see if it is a definition
that should be pushed into the parsing stack.  This can be an operator,
qualifier, qualifier shortcut, or parser definition, or
a lexical parsing definition (\ref{TBD}).
If no, nothing special is done.
If yes, the expression containing
the infix operator is replaced by just its right operand, the definition
in the left operand
is pushed onto the parsing stack, the right operand is
parsed, and then the definition is popped off the parsing stack.

\end{indpar}

\subsubsubsection{Operator Wrapper}\ttmindex{wrapper}{of operator}
\label{OPERATOR-WRAPPER}

An operator wrapper is a raw expression containing the lexeme `\verb|...|'.
If operator selection for an expression selects a single operator with a
wrapper, the expression is restructured to be a copy of the wrapper
with its `\verb|...|' lexeme replaced by the parse of the expression
being restructured.

For example, if the matchfix operator `\verb|<< ... >>|' has the
wrapper `\verb|-EVAL-ON- ...|', then the expression `\verb|<<x>>|'
will be restructured to be `\verb|-EVAL-ON- x|'.

\subsubsubsection{Operator Subdefinitions}\ttmindex{definition}{of operator}
\label{OPERATOR-SUBDEFINITIONS}

An operator definition can contain a list of definitions
that are pushed into the parsing stack before the subexpressions
of the operator are parsed, and are popped from the stack after the
subexpressions are parsed.  To avoid name confusion, these definitions
are called \skey{subdefinition}s.

Note that subdefinitions can include any definitions that can be 
pushed into the parsing stack, and can also include undefinitions, that
inactivate all definitions with particular names in the stack
(\ref{TBD}).


\subsubsection{Operator Definition Syntax}
\label{OPERATOR-DEFINITION-SYNTAX}

\subsubsection{Operator Selection}
\label{OPERATOR-SELECTION}

The operator selection algorithm is run by the
the \mkey{operators parser}{operator selection}
\ttmkey{-OPERATORS-PARSER-}{operator selection} to check an expression
for operators.
This algorithm selects operators whose name appears in the expression,
and then applies rules to deselect some selected operators.  If at the end
of the algorithm there is exactly one operator selected, the definition
of that operator is used to restructure the expression.  If there is more
than one operator selected, it is a parse error unless the definitions of
all selected operators are identical except for operator names.

The operator selection algorithm uses the current parsing definition stack
to determine which operators are defined.  The most important parts of each
operator definition are the operator name and operator fixity.

In the algorithm the concepts of prefix sequence and postfix sequence
are used.  A \key{prefix sequence} is a sequence of defined prefix operator
names.  A \key{postfix sequence} is a sequence of defined postfix operator
names.

In the \key{operator selection algorithm}, which is defined as follows,
the steps are executed in the order given, and
each step is repeated until it does nothing.

\begin{enumerate}

\item
Select any defined matchfix operator whose opening name
begins the expression and whose closing name ends the expression.

\item
If two matchfix operators are selected, the opening operator name
of the first is longer than the opening operator name of the second,
and the closing operator name
of the first is longer than the closing operator name of the second,
then the second operator is deselected.

Thus if `\verb/[| ... |]/' and `\verb/[ ... ]/' are two selected
matchfix operators, the second will be deselected.

\item
If more than one matchfix operator is still selected, the parse is in error.

\item
If a matchfix operator is selected, and the expression begins with
a prefix sequence that is not shorter than the opening name of the
matchfix operator, the parse is in error.
Similarly if a matchfix operator is selected, and the expression ends with
a postfix sequence that is not shorter than the closing name of the
matchfix operator, the parse is in error.

Thus if `\verb|- < ... > -|' is a defined matchfix operator and
`\verb|-|' is a defined prefix operator, but there is no defined
prefix operator whose name begins with the lexeme `\verb|<|',
parses of expressions containing the matchfix operator
will \underline{not} be in error.
But if there is another defined prefix operator named `\verb|<|',
parses of these expressions will be in error.

\item
If a matchfix operator is selected, the algorithm terminates successfully
at this point, without selecting any other operators.
The part of the expression between the opening operator name and closing
operator name is the sole operand of the matchfix operator.  This operand
is implicitly parenthesized, and may be empty.

\item
Select all defined infix operators that occur in the expression.

\item
Deselect any selected infix operator that overlaps or abuts
a prefix sequence that begins the expression.
Deselect any selected infix operator that overlaps or abuts
a postfix sequence that ends the expression.

Note that the empty sequence is both a prefix and a postfix sequence,
so infix operators that begin or end the expression are deselected.
For example, in the expression `\verb|+ x * y|' the prefix operator
`\verb|+|' is
deselected, and in the expression `\verb|+ + + x * y|' all the `\verb|+|'s are
deselected.

\item
On the set of selected infix operators define the \key{infix conflict relation}
to be the smallest equivalence relation such that two selected infix operators
conflict if they overlap or abut.

\item
Deselect any infix operator if it is not followed by a prefix sequence that
contains all other infix operators that conflict with the infix operator.
Deselect any infix operator if it is not preceded by a postfix sequence that
contains all other infix operators that conflict with the infix operator.
In checking for conflicting operators, check any infix operator selected
at the end of the previous step, whether or not it has been deselected
in this step.

Since the empty sequence is a prefix and postfix sequence, any infix operator
that does not conflict with any other infix operator will still be selected
at the end of this step.

The parse is in error if there is an equivalence class of
conflicting operators all
of whose members are deselected by this step.

\item
The parse is in error if two conflicting infix operators are still selected at
this point.

\item
If two infix operators are selected, and the first has strictly lower
precedence than the second, deselect the second.

\item
If several infix operators are still selected at this point, all these
operators must have the same associativity, which must not be `\verb|none|'.
Otherwise the parse is in error.

\item
If several infix operators are selected at this point and their common
associativity is `\verb|left|', all but the rightmost infix operator
are deselected.
Similarly if several infix operators are selected at this point and their common
associativity is `\verb|right|', all but the leftmost infix operator
are deselected.

\item
If several infix operators are still selected at this point, all these
operators must have the same definitions except for operator names.
Otherwise the parse is in error.

\item
If any infix operators are still selected at this point, the algorithm
terminates successfully.
The parts of the expression between the operators, before the first
operator, and after the last operator are the operands, and are
implicitly parenthesized.  No operand is empty.
If the common associativity of the infix operators is not
`\verb|left|',
`\verb|right|', or
`\verb|none|', this associativity as a lexeme sequence is prepended to the
expression, before the first operand.

\item
Select all prefix operators that begin the expression, and all postfix
operators that end the expression.

\item
If two prefix operators are selected, and one is longer than the other,
deselect the shorter.
Similarly, if two postfix operators are selected,
and one is longer than the other,
deselect the shorter.

\item
If both prefix and postfix operators are selected at this point, the postfix
operators are deselected.  Thus postfix operators are in effect
given precedence over prefix operators.

\item
If more than one operator is selected at this point, the parse is in error.
This would be the result of ambiguity amoung prefix operators, or ambituity
among postfix operators.

\item
If one operator is selected at this point, and the operator name
is the entire expression, deselect the operator.  Thus
in the expression `\verb|x = (+)|', `\verb|+|' will be deselected
when the subexpression `\verb|(+)|' is parsed.

\item
The algorithm terminates successfully
at this point with zero operators selected,
or with one prefix or postfix operator selected.
If there is one selected operator, the part of the expression
that is not the operator name is the sole operand, and is implicitly
parenthesized.  Note this operand cannot be empty.

\end{enumerate}


The rules just given produce a result that is often the same as the
more common context free grammar rules for parsing expressions.  However,
there is a difference: in PCASL an operator can change the parsing stack
used to parse its operand subexpressions.  See the sections on
operator parsers (\ref{OPERATOR-PARSER}),
operator control flags (\ref{OPERATOR-CONTROL-FLAGS}),
and operator subdefinitions (\ref{OPERATOR-SUBDEFINITIONS})
above.

\subsubsection{Post Operator Selection Processing}
\label{POST-OPERATOR-SELECTION-PROCESSING}

Post operator selection processing is done after operator selection by
the \mkey{operators parser}{post operator selection}
\ttmkey{-OPERATORS-PARSER-}{post operator selection},
whether or not any operators are selected.
After operators are selected without a parse error, all the selected
operators have identical definitions except for operator name.
The common part of these definitions, which we will refer to as
`the operator definition', is used to control post operator selection
processing of the expression containing the operators.  If no operators are
selected, a definition containing no optional parts (no named associativity,
no parser, no control flags, no wrapper, no subdefinitions) is used
to control post operator selection processing.

Post operator selection processing is done in the following steps.

\begin{enumerate}

\item
If the operator definition has a parser, this is pushed into the
parsing parser stack.

\item
If the operator definition has subdefinitions, these are pushed into the
parsing definition stack.


\item
Subexpressions are parsed left to right by calling the parser at the
top of the parsing parser stack.  If the operator definition has the
\ttmkey{definitions}{control flag} control flag (note the operator must
be right associative), after the first subexpression is parsed,
it is checked to see if it is an definition that can be pushed into the
parsing stack.  If yes, this definition is pushed
into the parsing stack before the second subexpression is parsed.

\item
If a definition in the first subexpression was pushed into
the parsing stack, the expression is replaced by its parsed
second subexpression.  Otherwise all subexpressions in the expression
are replaced by their parsed versions.

\item
If the operator definition has a named associativity, this is prefixed
to the expression.

\item
If the operator definition has a wrapper, the expression is
replaced by its wrapper with the word \verb|...| in the wrapper
replaced by the expression.

\item
If anything was pushed into the parsing stack above, these things
are popped from the stack.

\item
The expression is returned as the result of parsing the expression.

\end{enumerate}

\subsection{Text Parsing}
\label{TEXT-PARSING}


\section{Expression Graphs}
\label{EXPRESSION-GRAPHS}

Expression graphs store expressions.  An \key{expression graph}
is a directed possibly cyclic graph with labels on all arrows and on some
nodes, plus a set of graph node valued variables.

Expression graph arrow and node labels 
must be single words or separators.  Labelled nodes cannot be the source
of any arrow.  Several arrows with the same source node may have the same
arrow label.

A node that does not have a label and is not the source of any arrows
is called a \key{null node}.

An expression graph variable has a name, a value, and a default.
Variable names must be single words or separators.
Both the value and the default are graph nodes.  The default may be
missing.  Variable values are often, but by no means always, null nodes.

All graph nodes are reachable from from either the value or the default
of some variable.

There is always a variable named \ttkey{-ROOT-} whose value
is a graph node called the \mkey{root}{of expression graph}
of the expression graph.  The \verb|-ROOT-| variable does not have a default.

If there is only one variable, \verb|-ROOT-|, and no node is the destination
of more than one arrow, the graph is a tree.  In this case it is called
an \key{expression tree}.

There is a correspondence between raw expressions and expression trees
that is one-to-one, except that two raw expressions differing only
in the order of their qualifier clauses and the order of their reordered
arguments correspond to the same expression tree.

There are several operations that convert expression trees into general
expression graphs.  All these use a designated operator, which defaults
to \ttkey{//}, to identify expression graph variables and their values.
The most commonly used conversion operation also uses the convention that
words beginning with a capital letter designate
expression graph variables.

\subsection{Expression Graph Notation}
\label{EXPRESSION-GRAPH-NOTATION}

The following is an example of the notation we will use to represent
expression graphs:%
\footnote{This notation is standard for feature structures:
e.g., see Bob Carpenter, {\em The Logic of Typed Feature Structures},
1992, Cambridge University Press}

\newcommand{\Glabel}[1]{\mbox{\tt #1}}
\newcommand{\Gvariable}[1]{\fbox{\tt #1}}
\newsavebox{\Gfbox}
\newcommand{\Gdefault}[1]{%
    \sbox{\Gfbox}{\fbox{\tt #1}}%
    {\setlength{\fboxsep}{0.01in}%
     \fbox{\usebox{\Gfbox}}%
    }}
\newenvironment{Graph}%
    { \( \left[ \begin{array}{l}}%
    {\end{array} \right] \) }
\newenvironment{Gchild}[1]%
    {\mbox{\tt #1}:
     \begin{array}{l}
     \rule{0in}{0in} \vspace{-0.15in} \\
     \left[ \begin{array}{l}}%
    {\end{array} \right] \\
     \rule{0in}{0in} \vspace{-0.15in}
     \end{array}}

\begin{center}

\begin{Graph}
    \Gvariable{-ROOT-} \\
    \begin{Gchild}{fee}
	\Gvariable{X} \\
	\Glabel{\$5} \\
    \end{Gchild} \\
    \begin{Gchild}{fie}
	\Gvariable{X} \\
    \end{Gchild} \\
\end{Graph}
\hspace{0.3in}
\begin{Graph}
    \Gdefault{X} \\
    \begin{Gchild}{1}
	\Glabel{foe} \\
    \end{Gchild} \\
    \begin{Gchild}{2}
	\Glabel{fum} \\
    \end{Gchild} \\
\end{Graph}
\hspace{0.3in}
\begin{Graph}
    \Gvariable{Y} \\
    \Gdefault{Y} \\
    \begin{Gchild}{1}
	\Gvariable{\protect\CurlyBra 1\protect\CurlyKet} \\
    \end{Gchild} \\
    \begin{Gchild}{2}
	\begin{Gchild}{*}
	    \Gvariable{\protect\CurlyBra 1\protect\CurlyKet} \\
	\end{Gchild} \\
    \end{Gchild} \\
\end{Graph}


\end{center}

In this notation, the representation of a graph node is a set of lines
enclosed in [] brackets.

If the node is the value or default of some variables,
the names of those variables, each enclosed in a box or double box, are the top
lines of the representation of the node.
A variable name is boxed if the node is the value of
a variable, and double boxed if the node is the default of the
variable.
In our example \Gvariable{-ROOT-}, \Gvariable{X}, and \Gvariable{Y}
designate nodes that are variable values and
\Gdefault{X} and \Gdefault{Y} designate nodes that are variable defaults.
A single node can be the value or default of several variables: in the
example one node is both the value and the default of \verb|Y|.

The example expression graph has three variables, \verb|-ROOT-|, \verb|X|,
and \verb|Y|.  While all nodes in the expression graph must be reachable
from the value or default of some variable in the graph, all nodes
need not be reachable from the value of \verb|-ROOT-|.  The above example
is a single expression graph with three variables, and \underline{not}
three expression graphs.

Two nodes with the same boxed variable name in their representation
are actually the same node in the graph, and
similarly two nodes with the same doubly boxed variable name in their
representation are actually the same node in the graph.  When several
nodes are the same in this sense, all but one of these must have only
boxed or doubly boxed variable names in its representation.

Sometimes it is necessary to indicate that two nodes are the same for
a node that is not the value or default of any variable.
This is done by creating an
\key{expression graph pseudo-variable}\index{pseudo-variable!expression graph}%
\label{PSEUDO-VARIABLES}
whose name is a word or separator in curly brackets.  In the example,
\verb|{1}| is such a pseudo-variable name.  Such pseudo-variable names
are always boxed, and never double boxed.

If a node has a label, that is the last line in the node's representation,
and is
immediately below any boxed or doubly boxed variable names.
There are no other lines in the representation.
In the above example, \Glabel{\$5} labels
the node that is the value of the variable \verb|X|.

If a node is the source of arrows in the directed graph,
representations of each arrow appear below any boxed or doubly
boxed variable names in the
representation of the node.  Each arrow representation consists of the
label of the arrow followed by a colon (:) followed by
a representation of the target node of the arrow.  This later
is of course surrounded by [] brackets.

\subsection{Pure Unification}
\label{PURE-UNIFICATION}

Informally, expression graphs may be thought of
as expressions of information, and the unification of
two expression graphs is then an expression graph whose information content
is the least upper bound of the information content of each of
the two graphs taken separately.

PCASL uses two forms of expression graph unification to represent expression
graphs.  The pure form, called `\key{pure unification}',
is just the standard labeled graph unification
algorithm, and is specified in this section.  The other form, which
has a special merge operation for nodes representing calls on
functions or builtin PCASL operations, is called `call unification',
and is described in \ref{CALL-UNIFICATION}.

Unification of two expression graphs
either succeeds and produces a unique expression
graph as its result, or fails and produces no result.

If X and Y are expression graphs then their pure unification, Z,
is computed by the following \key{pure unification algorithm}.%
\label{PURE-UNIFICATION-ALGORITHM}.
This algorithm assumes that all expression graphs are stored in
a common graph memory that contains nodes and arrows, but
each expression graph has its own distinct set of variables.

\begin{enumerate}

\item
X is replaced by a copy of X, and Y is replaced by a copy
of Y.  Each copy has nodes,
arrows, and variables that are distinct from those
of any other expression graph.  

\item
The set of nodes and arrows of Z is initialized to the union
of the sets of nodes and arrows of X and Y.  Note that since
X and Y are now copies of the original, the nodes and arrows
of X and Y are all now distinct.

\item
There is a set called the \key{merge set}
of node pairs called \skey{merge pair}s that is
used by the algorithm.  This is initialized to the empty set.

\item
The set of variables of Z is initialized to the set of
variables in X.

\item
Each variable V in Y is added to the variable set of Z using
the following method.  If V is not already in the variable set of Z,
it is simply added to that set.  If V is already in the set,
let V in the variable set of Z have value XV and default XD
(because V must have come from X),
and let V in the variable set of Y have value YV and default YD,
where XD and/or YD may be missing.  Then add the merge pair (XV,YV)
to the merge set.  If YD is not missing but XD is missing,
set the default of V in the variable set of Z to equal YD.  If
neither YD or XD is missing, add the merge pair (XD,YD) to the merge set.

\item
For each merge pair (M,N) in the merge set,
perform the following \key{node merge algorithm}.%
\label{NODE-MERGE-ALGORITHM}
Do this recursively until the merge set is empty.

\begin{enumerate}

\item
Remove (M,N) from the merge set.

\item
If M and N are the same node, terminate the node merge algorithm.

\item
\label{UNIFICATION-LABEL-FAILURE}
If and N are labeled nodes with different labels, the unification
algorithm fails.

\item
If either M or N is a labeled node and the other node is the
source of some arrows, the unification algorithm fails.

\item
\label{UNIFICATION-AMBIGUITY-FAILURE}
If there is an arrow label L such that one of the nodes M or N
is the source of two or more arrows labeled L and the other node is the
source of one or more arrows labeled L, the unification algorithm fails.
Intuitively, when we try to match the arrows sourced at one of the
two nodes with arrows sourced at the other of the two nodes so
that matched arrows have the same arrow label, then we must get a
unique answer.

\item
If M is a labeled node with label L, and N is unlabeled, label N with L.

\item
For every arrow sourced at M do the following.
Let the arrow be labeled L and point at target node MT.
If N is not the source of an arrow labeled L,
make a new arrow labeled L pointing from N to MT.
But if N is the source of an arrow labelled L with target NT, add the
merge pair (MT,NT) to the merge set.

\item
Replace M by a forwarding pointer that points at N.
This means that henceforth any attempt to reference M will be forwarded
to N, so M is effectively merged with N.

\end{enumerate}

\end{enumerate}

Note that the running time of the pure unification algorithm is bounded by

\[
\begin{array}{c}
T_1(\mbox{number of variables in X} + \mbox{number of variables in Y}) \\
+ \\
T_2(\mbox{number of nodes in X} + \mbox{number of nodes in Y}) \\
\times \\
(\mbox{number of distinct arrow labels in either X or Y})^2
\end{array}
\]

where $T_1$ and $T_2$ are small constant times (typically a few microseconds).
The total number of nodes in X and Y bounds the number of node merge
operations, and the
last factor bounds the time to form the union of the arrow labels of
any two nodes that are being merged.  The bound just given is typically
a substantial overestimate, and can be improved to:

\[
\begin{array}{c}
T_1(\mbox{number of variables in X} + \mbox{number of variables in Y}) \\
+ \\
T_2(\mbox{number of nodes in X} + \mbox{number of nodes in Y}
				- \mbox{number of nodes in Z}) \\
\times \\
(\mbox{maximum number of arrows sourced at any one node in Z})^2
\end{array}
\]

\subsection{Raw Expression Trees}
\label{RAW-EXPRESSION-TREES}

Raw expressions represent expression trees.  For example, the expression

\begin{center}
\verb|[max x y z]|
\end{center}

represents the expression tree

\begin{center}
\begin{Graph}
    \Gvariable{-ROOT-} \\
    \begin{Gchild}{-ARITY-}
	\Glabel{3} \\
    \end{Gchild} \\
    \begin{Gchild}{0}
	\Glabel{max} \\
    \end{Gchild} \\
    \begin{Gchild}{1}
	\Glabel{x} \\
    \end{Gchild} \\
    \begin{Gchild}{2}
	\Glabel{y} \\
    \end{Gchild} \\
    \begin{Gchild}{3}
	\Glabel{z} \\
    \end{Gchild} \\
\end{Graph}
\end{center}

The raw expression is represented by the root node of an expression tree.
The raw expression head, `\verb|max|', is represented by a node labeled
`\verb|max|' that is the target of an arrow labeled `\verb|0|' from the root.
Here `\verb|0|' is called the \key{head index} of the root node, the
arrow it labels is called the \key{head arrow} of the root node,
and the target of that arrow is called the \key{head} of the root node.

The three arguments become targets of three arrows from the root labeled
`\verb|1|', `\verb|2|', and `\verb|3|'.
Each argument in this case is a single
word, and is represented by a node labeled with that word.
Here non-zero natural numbers are
\ikey{unreordered argument indices}{unreordered argument index} of the
root that label
\skey{unreordered argument arrow}s of the root, and the targets of these
arrows are the \skey{unreordered argument}s of the root.  Reordered
and rest arguments are introduced below.

An arrow labeled `\ttkey{-ARITY-}' is added to the root node to point
at a node labeled with the number of arguments in the raw expression.
This arrow is called the \key{arity arrow} of the root node,
its target is called the \key{arity target} of the root, and
the label of that target is called the \key{arity} of the root.

A second example is the expression

\begin{center}
\verb|[sort x @@ with key weight @@ with comparator]|
\end{center}

which is represented by the expression tree

\begin{center}
\begin{Graph}
    \Gvariable{-ROOT-} \\
    \begin{Gchild}{-ARITY-}
	\Glabel{1} \\
    \end{Gchild} \\
    \begin{Gchild}{0}
	\Glabel{sort} \\
    \end{Gchild} \\
    \begin{Gchild}{1}
	\Glabel{x} \\
    \end{Gchild} \\
    \begin{Gchild}{-REQUIRED-QUALIFIER-}
	\begin{Gchild}{-ARITY-}
	    \Glabel{2}
	\end{Gchild} \\
	\begin{Gchild}{0}
	    \Glabel{with}
	\end{Gchild} \\
	\begin{Gchild}{1}
	    \Glabel{key}
	\end{Gchild} \\
	\begin{Gchild}{2}
	    \Glabel{weight}
	\end{Gchild} \\
    \end{Gchild} \\
    \begin{Gchild}{-REQUIRED-QUALIFIER-}
	\begin{Gchild}{-ARITY-}
	    \Glabel{2}
	\end{Gchild} \\
	\begin{Gchild}{0}
	    \Glabel{with}
	\end{Gchild} \\
	\begin{Gchild}{1}
	    \Glabel{comparator}
	\end{Gchild} \\
	\begin{Gchild}{2}
	    \Glabel{<}
	\end{Gchild} \\
    \end{Gchild} \\
\end{Graph}\label{QUALIFIER-EXAMPLE}
\end{center}

Here each qualifier becomes the target of an arrow labeled
`\ttkey{-REQUIRED-QUALIFIER-}' because
the `\verb|@@|' \key{required-qualifier-mark} is used (the arrow label
would be `{\tt -OPTIONAL-QUALIFIER-}' if the `\verb|??|'
optional-qualifier-mark had been used).
The arrows with these labels are called \skey{qualifier arrow}s of the
root node and their targets are called \skey{qualifier}s of the root.
In this case there are two \skey{required qualifier arrow}s and
two \skey{required qualifier}s.
Each qualifier sources arity, head, and unreordered argument arrows
analogous to those of the root node, and could source qualifier,
reordered argument (see below), and rest argument (see below) arrows.

A third example is the expression

\begin{center}
\verb|[sort x @@ with key weight ?? with order X]|
\end{center}

which is represented by the expression tree

\begin{center}
\begin{Graph}
    \Gvariable{-ROOT-} \\
    \begin{Gchild}{-ARITY-}
	\Glabel{1} \\
    \end{Gchild} \\
    \begin{Gchild}{0}
	\Glabel{sort} \\
    \end{Gchild} \\
    \begin{Gchild}{1}
	\Glabel{x} \\
    \end{Gchild} \\
    \begin{Gchild}{-REQUIRED-QUALIFIER-}
	\begin{Gchild}{-ARITY-}
	    \Glabel{2}
	\end{Gchild} \\
	\begin{Gchild}{0}
	    \Glabel{with}
	\end{Gchild} \\
	\begin{Gchild}{1}
	    \Glabel{key}
	\end{Gchild} \\
	\begin{Gchild}{2}
	    \Glabel{weight}
	\end{Gchild} \\
    \end{Gchild} \\
    \begin{Gchild}{-OPTIONAL-QUALIFIER-}
	\begin{Gchild}{-ARITY-}
	    \Glabel{2}
	\end{Gchild} \\
	\begin{Gchild}{0}
	    \Glabel{with}
	\end{Gchild} \\
	\begin{Gchild}{1}
	    \Glabel{order}
	\end{Gchild} \\
	\begin{Gchild}{2}
	    \Glabel{X}
	\end{Gchild} \\
    \end{Gchild} \\
\end{Graph}
\end{center}

This is the same as the last example except one qualifier is an
`\ttkey{-OPTIONAL-QUALIFIER-}' because the
`\verb|??|' \key{optional-qualifier-mark} is used.
In this case there is one \skey{required qualifier arrow},
one \skey{required qualifier}, one \key{optional qualifier arrow}, and
one \key{optional qualifier}.  The only difference between
required and optional qualifiers is the label on the arrow to the qualifier
node.  This label is either `\ttkey{-REQUIRED-QUALIFIER-}'
or `\ttkey{-OPTIONAL-QUALIFIER-}'.

A fourth example is the expression

\begin{center}
\verb|[fill Prefix ?:? Matrix <:> Value Postfix ::> Runs]|
\end{center}

which is represented by the expression tree

\begin{center}
\begin{Graph}
    \Gvariable{-ROOT-} \\
    \begin{Gchild}{-ARITY-}
	\Glabel{1-4} \\
    \end{Gchild} \\
    \begin{Gchild}{0}
	\Glabel{fill} \\
    \end{Gchild} \\
    \begin{Gchild}{1}
	\Glabel{Prefix} \\
    \end{Gchild} \\
    \begin{Gchild}{2-3}
	\Glabel{Matrix} \\
    \end{Gchild} \\
    \begin{Gchild}{2-3}
	\Glabel{Value}
    \end{Gchild} \\
    \begin{Gchild}{4}
	\Glabel{Postfix}
    \end{Gchild} \\
    \begin{Gchild}{-REST-}
	\Glabel{Runs}
    \end{Gchild} \\
\end{Graph}
\end{center}

Arguments appearing after the \key{optional argument mark} \ttkey{?:?} are
optional.  This is indicated by the arity `\verb|1-4|' that indicates
that argument `\verb|1|' is the last required argument and there are
`\verb|4|' arguments total.  In general, the arity can have the form
`$m$\verb|-|$n$', where $0\leq m<n$, $m$ is the
\skey{number of required argument}s, $n$ is the
\skey{total number of argument}s,%
\label{TOTAL-NUMBER-OF-ARGUMENTS}
and $n-m$ is the number of optional arguments.

If there are no optional arguments and the arity is just a natural
number $n$, then $n$ is both the number of required arguments and the
total number of arguments.

Consecutive arguments separated by the \key{reorder mark} \ttkey{<:>} can
be reordered.  These arguments are indicated by argument indices that
describe the positions the arguments can occur in.  Thus in the example
the two arguments with index `\verb|2-3|' can each appear as either the
2nd or 3rd argument.  In general,
an argument index that is a range of the form
`$i$\verb|-|$j$', where $0\leq i<j\leq n$, and
$n$ is the total number of arguments, indicates that the argument can
be the $i$'th through $j$'th argument position.
These argument indices are called the
\ikey{reordered argument indices}{reordered argument index} of the
root node,
the arrows they label are called \skey{reordered argument arrow}s
of the root,
and the targets of these arrows are called \skey{reordered argument}s
of the root.

Note that if an argument has index `$i$\verb|-|$j$', then the $i$'th
and $j$'th argument must be either both required or both optional.
That is, if there are optional arguments and
$m$ is the number of required arguments, either
$j\leq m$ or $m<i$.

The argument after a \key{remainder mark} \ttkey{::>} is
given the special argument index `\ttkey{-REST-}' and names a list of
all arguments that occur after the total number of arguments specified
by the arity.  Here \verb|-REST-|
is called the \key{rest argument index} of the root node, the arrow it labels
is called the \key{rest argument arrow} of the root, 
and the target of this arrow is called the \key{rest argument} of the
The rest argument is not counted in the arity.

\subsection{Call Nodes and the Call Check}
\label{CALL-NODES-AND-CHECK}

During expression inference (\ref{EXPRESSION-INFERENCE})
and evaluation (\ref{EXPRESSION-EVALUATION})
expressions are matched using a variant of unification called
`call unification' (\ref{CALL-UNIFICATION}).

Call unification treats graph nodes called `call nodes'
differently than pure unification (\ref{PURE-UNIFICATION}) does.
A \key{call node} is a node that has
an \mkey{arity arrow}{of call node}.
That is, it is the source of an arrow labeled
\ttmkey{-ARITY-}{of call node}.  Call unification
replaces the node merge algorithm
(page~\pageref{NODE-MERGE-ALGORITHM})
with the call merge algorithm described below if one of the nodes
being merged is a call node.

The call merge algorithm performs a subalgorithm called
the \key{call check algorithm} that checks whether a call node
is legal.  Specifically, a call node N passes the call check
algorithm if and only if the following are true:

\begin{enumerate}

\item
The arity of N is either a natural number $n$ (string of digits without
high order zeros) or has the form $m$\verb|-|$n$ where $m$ and $n$
are natural numbers and $m<n$.  In either case $m$ is called the
\key{minimum arity} of N and $n$ is called the
\key{maximum arity} of N.

\item
N has exactly one head arrow.

\item
There exists a 1-1 map between the set of unreordered and reordered
(but not rest) argument arrows of N and the set of
natural numbers from \verb|1| through $n$, where $n$ is the
maximum arity of N, such that if $i$ is a natural number
from \verb|1| through $n$, the arrow mapped to $i$
is either an unreordered argument arrow labeled $i$, 
or is a reordered argument arrow labeled $j$\verb|-|$k$
where $j\leq i\leq k$.

Such a mapping is called a \key{argument order assignment} of N.%
\label{ARGUMENT-ORDER-ASSIGNMENT}
If there are any reordered arguments of N, there will be
more than one argument order assignment of N.

\item
\label{NULL-REST-ARGUMENT}
N has at most one rest argument arrow.  If N has a rest argument
arrow, the rest argument of N is a null node (a node with no label
that is the source of no arrows).

\item
N can have any number of qualifier arrows (required or optional).

\item
There are no arrows sourced at N other than those with labels
enumerated above.  That is, any arrow sourced at N is either an arity
arrow, a head arrow, an argument arrow (unreordered, reordered, or rest),
or a qualifier arrow (required or optional).

\item
The qualifiers of N (targets of qualifier arrows)
pass the call check algorithm recursively.  The call check
algorithm allows cycles in the graph, e.g. the case that N and one
of its qualifiers are the same node.

Note that raw expressions cannot represent call nodes that have
qualifiers which in turn have qualifiers, but the conversions
of \ref{EXPRESSION-GRAPH-REPRESENTATION} can represent such call nodes.
Because of the difficulty of representing them, such call nodes are
of mostly theoretical interest.

\end{enumerate}

\subsection{Paths and Witnesses}
\label{PATHS-AND-WITNESSES}

A \ikey{non-empty path}{path!non-empty}
is a sequence of one or more arrows in some expression graph,
such that if A1 and A2 are consecutive
arrows in the sequence, the target of A1 is the source of A2.
The \mkey{path name}{of non-empty path}
of the path is the
sequence of words and separators that are the arrow labels of the
arrows of the path.  The source node of the first arrow in the path
is the \mkey{source}{of non-empty path} of the path.
The target node of the last
arrow in the path is the \mkey{target}{of non-empty path} of the path.
Note that the path name and source node of a path are together
not adequate to determine the path in all cases, since we allow
a node to source several arrows with the same label.

An \ikey{empty path}{path!empty} is just a node.  This node is both
the \mkey{source}{of empty path} of the empty path and
the \mkey{target}{of empty path} of the empty path.
The \mkey{path name}{of empty path} of the path is the empty sequence.

A \key{path name} is just a possibly empty sequence of words or separators.
A \key{node label} is just any word or separator.

A \key{witness} is a path name and a node label.
We use `{\em path-name}: {\em node-label}' to name the witness.
A \mkey{witness}{of node} of a node S in an expression graph is a witness
P:~L with path name P and node label L such that there is a path with source S,
path name P, and target that has node label L.

For example, consider the graph of

\begin{center}
\verb|[sort x @@ with key weight @@ with comparator]|
\end{center}

on page~\pageref{QUALIFIER-EXAMPLE}.  The value of the \verb|-ROOT-|
variable has `\verb|0|: \verb|sort|' as one of its witnesses and
`\verb|-REQUIRED-QUALIFIER- 0|: \verb|with|' as another.  There are
actually two distinct paths corresponding to this second witness.

Two witnesses are said to be \mkey{incompatible}{witness}
if they have the same path name but have different labels.
Two witnesses are said to be \mkey{compatible}{witness}
if they are not incompatible: that is, if they have different path
names, or if they have both the same path names and the same labels.
For example, `\verb|0|: sort' and `\verb|1|: x' are compatible while
`\verb|0|: sort' and `\verb|0|: switch' are incompatible.

It is not true that all witnesses for a node in an expression graph
are compatible.  This is because we allow one node to source several
arrows with the same label.  In the example expression graph
on page~\pageref{QUALIFIER-EXAMPLE},
`\verb|-REQUIRED-QUALIFIER- 1|: \verb|key|' and
`\verb|-REQUIRED-QUALIFIER- 1|: \verb|comparator|' are incompatible
witnesses for the value of \verb|-ROOT-|.  However, for an expression
graph in which no node sources two arrows with the same label, it can
be easily proved that all witnesses of every node are compatible.

Two expression graph nodes, S1 and S2, possibly the same node, and possibly
in different expression graphs,
are said to be \key{witness compatible} if and only if every
witness for S1 is compatible with every witness for S2.  Otherwise
S1 and S2 are said to be \key{witness incompatible}.

For an integer N$\geq$0, an N-witness is a witness whose path name
has at most N arrow labels.
Two expression graph nodes, S1 and S2,
are said to be \key{N-witness compatible} if and only if every
N-witness for S1 is compatible with every N-witness for S2.  Otherwise
S1 and S2 are said to be \key{N-witness incompatible}.

It is possible for
a node to be 1-witness incompatible with itself, without being witness
incompatible with many other nodes.  For example, a node whose only
witnesses are the incompatible witnesses `\verb|1|:~\verb|fee|' and
`\verb|1|:~\verb|fie|' would be witness compatible with any
node that was not the source of any arrow with arrow label `\verb|1|'.

It can be easily proved that if two expression graphs can be unified
(\ref{PURE-UNIFICATION}) then any two nodes that are merged during
unification are 1-witness compatible.  This is because
step \ref{UNIFICATION-AMBIGUITY-FAILURE} of the unification algorithm
means that if the nodes have incompatible 1-witnesses then the nodes each
source only one arrow with the withness arrow label and therefore
the targets of these two arrows must merge which is forbidden by
step \ref{UNIFICATION-LABEL-FAILURE}.

It can even be proved that if two expression graphs can be unified
(\ref{PURE-UNIFICATION}) then any two nodes that are merged during
unification are witness compatible.  This is because
if there are two incompatible witnesses of the two nodes, there
would be two paths with the same path name,
one for each witness, with consecutive
nodes on the two paths being merged, because
step \ref{UNIFICATION-AMBIGUITY-FAILURE}
requires that along each of the two paths each node sources exactly
one arrow with the next arrow label on the paths.
The two paths would end at two nodes that
would have different labels, but would have to be merged, causing
the unification algorithm to fail by step \ref{UNIFICATION-LABEL-FAILURE}.

In the unification algorithm,
arrow labels are used to match arrows to be merged.  More specifically,
when two nodes M and N are merged, arrows sourced at M are matched
with arrows sourced at N by arrow label.  If this match cannot be done,
step \ref{UNIFICATION-AMBIGUITY-FAILURE} of the unification algorithm
causes unification to fail.  In order to merge qualifier nodes,
we need to avoid this failure, and we do this in \ref{CALL-UNIFICATION}
by using some of the
the 1-witnesses of the qualifier nodes to make the match.
The 1-witnesses we use include the qualifier head, if that
is a node with a label, and any unreordered non-rest
qualifier argument that is simply a node with a label.

\subsection{Call Unification}
\label{CALL-UNIFICATION}

\ikey{Call unification}{call unification}\index{unification!call}
is a variant of pure unification (\ref{PURE-UNIFICATION}) that differs
from pure unification when merging nodes that have qualifiers or that have
optional, reordered, or rest arguments.  Call unification is
used in the inference algorithm (\ref{INFERENCE-ALGORITHM}).

Call unification is identical to pure unification (\ref{PURE-UNIFICATION})
with two differences.  The first difference is that when one of two nodes
being merged is a call node (\ref{CALL-NODES-AND-CHECK}), call unification
replaces the node merge algorithm (page~\pageref{NODE-MERGE-ALGORITHM})
with the call merge algorithm described below.

The second difference is that call unification makes choices during its
execution, because the call merge algorithm makes choices.  Each
set of possible choices over the whole call unification algorithm
leads to a separate algorithm execution that either succeeds or fails.

TBD

The \key{call merge algorithm} for a merge pair (M,N) in the merge set,
where either M or N or both is a call node,
with a particular choice, is as follows.

\begin{enumerate}

\item
Remove (M,N) from the merge set.

\item
If either M or N fails to pass a call check, the unification algorithm
fails.

\item
If M and N are the same node, terminate the call merge algorithm.

\item
A call node is said to be of \key{indeterminant arity} if it has
an optional, reordered, or rest argument.  Otherwise the node is said
to be of \key{determinant arity}.

If \underline{both} M and N are of indeterminant arity,
the unification algorithm fails.

Otherwise, if just N is of indeterminant arity, switch M and N so that
only N is of determinant arity.

Later in this call merge algorithm M will be replaced by a forwarding
pointer to N, and N will not be given any optional, rest, or reordered
arguments, so the result of the merge will be of determinant arity.

\item
If M is of determinant arity and the arities of M and N are not equal,
the unification algorithm fails.

If M has more required arguments than N has arguments, the unification
algorithm fails.

\item
For the rest of this algorithm,  let MT be the total number of arguments
(page~\pageref{TOTAL-NUMBER-OF-ARGUMENTS})
of M and NT be the total number of arguments of N

\item
If M has a rest argument R, then
For each natural number I from MT$+$1 through NT, an arrow
an arrow labeled I$-$MT is added that has R as its source and the
I'th argument of N as its target.
Note that before this is done R is a null node
(step \ref{NULL-REST-ARGUMENT} of the call check algorithm on
page~\pageref{NULL-REST-ARGUMENT}).

\item
Choose an argument order assignment (page~\pageref{ARGUMENT-ORDER-ASSIGNMENT})
for M.  For \verb|1|$\leq$I$\leq$MT, let MI let the assigned
I'th argument of M.

\item
Let T be the minimum of MT and NT.
For \verb|1|$\leq$I$\leq$T, let
NI be the I'th argument of N,
and add the merge pair (MI,NI) to the merge set.
For T$<$I$\leq$NT (if T$<$NT), add an arrow labeled I from N to MI.

\item
Let MH be the head of M and NH be the head of N.  Add a merge pair
(MH,NH) to the merge set.

\item
If there is any qualifier arrow of M whose target is
is 1-witness compatible with the target of more than one qualifier arrow
of N, the unification algorithm fails.  Ditto with M and N switched:
if there is any qualifier arrow of N whose target is
is 1-witness compatible with the target of more than one qualifier arrow
of M, the unification algorithm fails.

\item
For each qualifier arrow MA of M whose target is 1-witness compatible with
the target of exactly one qualifier arrow NA of N, let MQ be the target
MA and NQ bet the target of NA.

Then add (MQ,NQ) to the merge set.  Also, if NA is an optional
qualifier arrow and MA is a required qualifier arrow, change
the arrow label of NA to be {\tt -REQUIRED-\EOL QUALIFIER-}, making
it a required qualifier arrow.

\item
For each qualifier arrow MA of M whose target is 1-witness compatible with
the targets of no qualifier arrows N, let MQ be the target of MA,
and make an arrow from N to MQ
that has the same label as MA (\verb|-REQUIRED-QUALIFIER| or
\verb|-OPTIONAL-QUALIFIER-|).

\item
Replace M by a forwarding pointer that points at N.
This means that henceforth any attempt to reference M will be forwarded
to N, so M is effectively merged with N.

\end{enumerate}

\subsection{Expression Graph Representation}
\label{EXPRESSION-GRAPH-REPRESENTATION}

Raw expressions can be used to represent expression graphs.  This is
done by defining \skey{graph creation conversion}s that convert
expression trees corresponding directly to raw expressions to
arbitrary expression graphs.

A graph creation conversion is performed
by first converting the raw expression to an expression tree plus
a set of variables where each variable has not a single value or
single optional default, but instead has a set of one or more values
and zero or more defaults.  Then all the values of each variable
are unified using pure unification, and all the defaults of each
variable with defaults are similarly unified.  The result after
unification is an expression graph.

In converting a raw expression to an expression tree,
the rules for representing raw expressions as expression trees
(\ref{RAW-EXPRESSION-TREES})
are followed, with the following exceptions:

\begin{indpar}
\begin{list}{}{}

\item[{\tt [}{\tt //} {\em variable-name} {\em variable-value}{\tt]}]~\\
This expression converts to the same tree that the {\em variable-value}
converts to, and adds the root node of this tree to the value set of
the named variable.

\item[{\tt [}\ttkey{//} {\em variable-name}{\tt]}]~\\
This expression converts to a tree consisting of a single null root
node, and adds this node to the value set of the named variable.

\item[{\em variable-name}~~~(where {\em variable-name} is a word
			     beginning with a capital letter)]~\\
For implicit conversion this is
treated as the equivalent of `\verb|[// |{\em variable-name}\verb|]|'.
For explicit conversion this is converts to a tree with a single node
labeled with a word that is not in general a variable name.

\item[{\tt [\Tilde\Tilde}\index{~~@{\tt \protect\Tilde\protect\Tilde}}
           {\em variable-name} {\em variable-default} {\tt]}]~\\
This expression converts to a tree consisting of a single null root
node, and adds this node to the value set of the named variable.
This expression also adds the root node of the tree that {\em variable-default}
converts to the default set of the named variable.

\item[{\tt [}\ttkey{\#\#\#\#}
      \{ {\em arrow-label} {\em target-value} \}$^\star${\tt]}]~\\
This expression converts to a tree whose root is an unlabeled node
that is the source of arrows labeled with the {\em arrow-labels}.
The target of each arrow is the tree obtained by converting
the {\em target-value} raw expression that follows the arrow's
{\em arrow-label}.

\item[{\tt [}\ttkey{++++}
      {\em expression-graph} {\em expression-graph}$^\star${\tt]}]~\\
This expression converts to the tree that the first {\em expression-graph}
converts to.  The other expression-graphs are also converted to trees.
Before the variable value and default sets are unified, the union
of all the variables, variable value sets, and variable default sets
is taken over all the {\em expression-graphs}.

More explicitly, any variable of any {\em expression-graph} is a variable
of the result, any variable value of any {\em expression-graph} is in the
set of values for that variable that are unified to produce the value
of the variable in the result,
and any variable default of any {\em expression-graph}
is in the set of defaults for that variable that are unified to produce
the default for the variable in the result.

Thus {\em expression-graphs} other than the first can provide
variable values or defaults that are not reachable from the root of the
result.

\end{list}
\end{indpar}

Note that during creation of the expression tree before unification
the roots of various subtrees are not treated as values of a variable
named \verb|-ROOT-|.  More explicitly, no variable is permitted that
has the name \verb|-ROOT-|, and tree roots are tracked by means other
than variables.  The resulting expression tree has a root but no
\verb|-ROOT-| variable.  It is an error if any of the special expressions
listed above specifies \verb|-ROOT-| as a variable name.

After the expression tree is created,
a \ttmkey{-ROOT-}{of conversion} variable is created
whose sole value is the root of the expression tree, and whose set of
default values is empty.

Then pure unification is performed as
described in \ref{PURE-UNIFICATION}, except that the merge set is initialized
to merge pairs that merge the values of each variable and the
defaults of each variable.  It is a conversion error if this
unification fails or if any variable has an empty set of values
before unification is attempted.  After unification a variable has a default
if and only if its set of default values before unification was non-empty.

There are two kinds of graph creation conversions: explicit and implicit.
In \ikey{implicit conversions}{implicit conversion!to expression graph}
nodes labeled by a word L beginning with
a capital letter are treated as the equivalent of `\verb|[// |L\verb|]|'.
Thus L is a variable name and its name in the raw expression
represents a null node that is a value of the variable named L.
For \ikey{explicit conversions}{explicit conversion!to expression graph}
no such special provision is made for labeled nodes.

The exact operation names used in graph creation conversions may be different
from those given above.  The names to be used are given as arguments to the
conversion operations, with the names used above as defaults.  These
default names and the descriptive names of the operations are:

\begin{center}
\begin{tabular}{l@{~~~~~}l}
\verb|//|	& \key{graph variable value operation} \\
\verb|~~|	& \key{graph variable default operation} \\
\verb|####|	& \key{graph source construction operation} \\
\verb|++++|	& \key{graph concatenation operation} \\
\end{tabular}
\end{center}

\ikey{Pseudo-variable}{expression graph pseudo-variable}%
\index{pseudo-variable!expression graph}
names (page~\pageref{PSEUDO-VARIABLES})
of the form `\verb|{|{\em word-or-separator}\verb|}|' can be used
with the `\verb|//|' operation
to merge nodes that are not the value or default of any real variable.
This use simply
creates variables with names that are not single words or separators
which are discarded at the end of conversion.  Pseudo-variables cannot
be given defaults.

Some examples of expression trees represented by raw expressions and the
expression graphs they convert to are as follows:

\begin{indpar}

\begin{tabular}{p{2.5in}@{~~~~~}l}
\begin{tabular}{l}
\verb|[z [// X foo] X]| \\
implicit conversion
\end{tabular}
&
\begin{Graph}
    \Gvariable{-ROOT-} \\
    \begin{Gchild}{-ARITY-}
	\Glabel{2} \\
    \end{Gchild} \\
    \begin{Gchild}{0}
	\Glabel{z} \\
    \end{Gchild} \\
    \begin{Gchild}{1}
	\Gvariable{X} \\
	\Glabel{foo}
    \end{Gchild} \\
    \begin{Gchild}{2}
	\Gvariable{X} \\
    \end{Gchild} \\
\end{Graph}
\end{tabular}

\medskip

\begin{tabular}{p{2.5in}@{~~~~~}l}
\begin{tabular}{l}
\verb|[z [// X foo] X]| \\
explicit conversion
\end{tabular}
&
\begin{Graph}
    \Gvariable{-ROOT-} \\
    \begin{Gchild}{-ARITY-}
	\Glabel{2} \\
    \end{Gchild} \\
    \begin{Gchild}{0}
	\Glabel{z} \\
    \end{Gchild} \\
    \begin{Gchild}{1}
	\Gvariable{X} \\
	\Glabel{foo}
    \end{Gchild} \\
    \begin{Gchild}{2}
	\Glabel{X} \\
    \end{Gchild} \\
\end{Graph}
\end{tabular}

\medskip

\begin{tabular}{p{2.5in}@{~~~~~}l}
\begin{tabular}{l}
\verb|[z [~~ X foo] X]| \\
implicit conversion
\end{tabular}
&
\begin{Graph}
    \Gvariable{-ROOT-} \\
    \begin{Gchild}{-ARITY-}
	\Glabel{2} \\
    \end{Gchild} \\
    \begin{Gchild}{0}
	\Glabel{z} \\
    \end{Gchild} \\
    \begin{Gchild}{1}
	\Gvariable{X} \\
    \end{Gchild} \\
    \begin{Gchild}{2}
	\Gvariable{X} \\
    \end{Gchild} \\
\end{Graph}
~~~
\begin{Graph}
    \Gdefault{X} \\
    \Glabel{foo} \\
\end{Graph}
\end{tabular}

\medskip

\begin{tabular}{p{2.5in}@{~~~~~}l}
\begin{tabular}{@{}l@{}}
\verb|[++++| \\
\verb|  [#### fee [// X $5]| \\
\verb|        fie X]| \\
\verb|  [~~ X [#### 1 foe 2 fum]]| \\
\verb|  [~~ Y| \\
\verb|    [// Y| \\
\verb|      [#### 1 [// {1}]| \\
\verb|            2 [####| \\
\verb|                *| \\
\verb|                [// {1}]]| \\
\verb|            ]]]]| \\[1ex]
implicit conversion
\end{tabular}
&
\begin{tabular}{@{}l@{}}
\begin{Graph}
    \Gvariable{-ROOT-} \\
    \begin{Gchild}{fee}
	\Gvariable{X} \\
	\Glabel{\$5} \\
    \end{Gchild} \\
    \begin{Gchild}{fie}
	\Gvariable{X} \\
    \end{Gchild} \\
\end{Graph}
\hspace{0.1in}
\begin{Graph}
    \Gdefault{X} \\
    \begin{Gchild}{1}
	\Glabel{foe} \\
    \end{Gchild} \\
    \begin{Gchild}{2}
	\Glabel{fum} \\
    \end{Gchild} \\
\end{Graph}
\\
~\\
\begin{Graph}
    \Gvariable{Y} \\
    \Gdefault{Y} \\
    \begin{Gchild}{1}
	\Gvariable{\protect\CurlyBra 1\protect\CurlyKet} \\
    \end{Gchild} \\
    \begin{Gchild}{2}
	\begin{Gchild}{*}
	    \Gvariable{\protect\CurlyBra 1\protect\CurlyKet} \\
	\end{Gchild} \\
    \end{Gchild} \\
\end{Graph}
\end{tabular}

\end{tabular}
\end{indpar}

\section{Expression Inference}
\label{EXPRESSION-INFERENCE}

Expression inference is done for three reasons:

\begin{indpar}

{\bf Logic Inference}.\index{logic inference}The expression is
inferred to discover whether the expression is true or false.

{\bf Evaluation Inference}.\index{evaluation inference}The expression is
inferred to discover a code block that is to be used to evaluate the expression.

{\bf Reduction Inference}.\index{reduction inference}The expression is
inferred to discover a reduction of the expression, which is another
expression that is substituted for the original expression.

\end{indpar}

All three forms of inference run an inference algorithm on the
expression and a set of inference rules.  This algorithm matches
the expression to an inference rule, and then generates a new set of
expressions that must be logically inferred in order for the matching
to be a success.

There are four differences between the three kinds of inference.
The first is in which inference rules are checked against the expression
to be inferred.  There are logic rules, evaluation rules, and reduction
rules.  An expression to be logically inferred is matched only against
logic rules; an expression to be evaluated is matched only against
evaluation rules; and an expression to be reduced is matched only
against reduction rules.  Note that if a matching is successful and a new set
expressions is generated to be logically inferred, these secondary
expressions must be logically inferred using only logic rules.

The second difference lies in what is done after inferrence succeeds.
For logic inference, true is returned.  For evaluation inference, a code
block assoicated with the matching rule is evaluated.  For reduction
inference, a reduced expression associated with the reduction rule replaces
the original expression.

The third difference lies in what is done should inferrence fail.
For logic inference, false is returned.  For evaluation inferrence,
the expression evaluates to an error value.
For reduction inference, the original expression is left alone and not
replaced, as if it reduced to itself.

The fourth difference is in what is done should an expression be inferrable
in more than one way.  In logic inference, true is returned.  In evaluation
inference, the code blocks of the separate inferences must be the same
indentical code block, else the expression evaluates to an error value.
For reduction inference, the reduced expressions, an arbitrary
one of the several reduced expressions is used to replace the original
expression; it is up to PCASL programmers to code confluent%
\footnote{`Confluent' means that all ways of recursively reducing
an expression lead to the same final result.}
reduction rules.

\subsection{The Inference Algorithm}
\label{INFERENCE-ALGORITHM}
\label{INFERENCE-RULE}

The \key{inference algorithm} inputs an expression to be inferred
and a set of inference rules.

Rules are collected into contexts.  An expression is
usually inferred in the context in which the expression occurs,
though it is possible to explicitly designate the context in which an
expression is to be inferred.

An \key{inference rule} consists of single head and a possibly empty
set of goals, in the format

\begin{center}
{\em head} \verb|<===| {\em goal}\verb|,| {\em goal}\verb|,|
			\ldots\verb|,| {\em goal}
\end{center}

The head is
an expression that is matched against the expression to be inferred.
A goal is an expression that must be logically inferred to make
inference involving the rule a success.  The intuition is that
the head is true when all the goals are true, and if the head
can be matched against the expression to be inferred, then
the expression to be inferred is true if all the goals can be
logically inferred.

The head may contain variables that receive values during matching.
The goals may contain these same variables which are replaced by
their values before the goals are logically inferred.

Expression inference consists of the following steps.

\begin{enumerate}

\item Reduce the expression.  Initially, all subexpressions of the
expression are marked as reducible.  For logic and evaluation inferences,
the expression itself is considered to be a subexpression, but this is
not done for reduction inferences.  The reduction algorithm
selects a reducible subexpression S that does not contain any reducible
subexpression, and reduces S using reduction inference.  If S is successfully
reduced, it is replace in the original expression by its reduction, and
the reduction and all its subexpressions are marked reducible.  If S is
not successfully reduced, its `reducible mark' is removed, so it becomes
irreducible.  This step is repeated until there are no reducible subexpressions
left (including the entire expression itself).

\item

Match the expression to the head of some inference rule of suitable type
(logic, evaluation, or reduction).  Matching assigns values to variables
in the expression being inferred and to variables in the head of the
inference rule.

\item
Expand the goal expressions of the inference rule whose head matched,
by replacing variables in these expressions that were assigned values
by the matching with their values.

\item
Logically infer each expanded goal.

\end{enumerate}



\subsection{Inference Rules}
\label{INFERENCE-RULES}

An \key{inference rule} has the form:

\begin{center}
\key{consequent-expression} \verb|<--|
    \key{condition-expression} \{ \verb|,| {\em condition-expression} \}
\end{center}

An \key{inference step} takes as input one of the reduced goal-expressions
in the goal set and one inference rule,
such that the reduced goal-expression unifies with the
consequent-expression of the inference rule.  The unification variables in the
goal-set and inference-rule are replaced by their values computed
by this unification.  The goal-expression is removed the goal set, and
all the condition-expressions of the inference rule are added to the goal
set.

\subsection{Reduction Rules}
\label{REDUCTION-RULES}

A \key{reduction rule} has the form:

\begin{center}
\key{result-expression} \verb|<==|
\key{consequent-expression} \verb|<--|
    \key{condition-expression} \{ \verb|,| {\em condition-expression} \}
\end{center}

A reduction rule contains within it the equivalent of an inference rule,
which is obtained by removing the result-expression and following \verb|<==|
from the reduction rule.

A subexpression is \key{reduced} by finding for it inferences in which
the first rule applied to the original expression is a reduction rule.
If the result-expressions of all such inferences found unify, their
unification replaces the expression being reduced.  If no inferences
are found, the expression is not replaced.  It is an error
if several inferences are found but their result-expressions fail to unify.

An expression is \key{reduced} by reducing all its subexpressions, smallest
first, until lastly the whole expression is reduced as a subexpression of
itself.

\section{Expression Evaluation}
\label{EXPRESSION-EVALUATION}

\section{Design Notes}

These are some detailed design rules to be incorporated in the language
definition later.

\begin{list}{}{}

\item
{\bf Quotes}.  \verb|`'| are word, phrase, sentence, paragraph quotes.
\verb|[]| are math expression quotes.   Quotes are in left-right pairs
and can be nested.

\item
{\bf Multiple Quotes}.  Quotes can be multiplied $N$ times: e.g.,
\verb|[[...]]|, \verb|[[[...]]]|, etc.  It is possible to begin a quoted
phrase with a quoted phrase by following the initial $N$-left-quote by
space.  E.g., \verb|`` `Hello' 'tis a good word.''|.

\item
{\bf Algebraic Expressions}.
An expression may or may not be algebraic.  Algebraic expressions have
operators that determine structure.  Atoms in these are sequences of
words, numbers, and parenthesized or bracketted subexpressions.

\item
{\bf N-tuples and Flatening}.
The comma operator forms N-tuples, e.g., \verb|(x,y,z)| is a 3-tuple.

Tuples flatten.  It is not possible for a tuple to be a component of
a tuple: instead the tuples are flattened.  E.g., \verb|(x,(y,z),w)|
is the same value as \verb|(x,y,z,w)|.  There is no such thing as a
1-tuple, but any non-tuple behaves like a 1-tuple.

\item
{\bf Blank Algebraic Operators}.
The blank, or missing operator, denotes \verb|*| when it precedes a word,
as in \verb|5x| being equivalent to \verb|5*x|.  When it is between a
preceding integer and a following ratio, it adds the ratio to the integer,
as in \verb|41 1/3|.

\end{list}



\bibliographystyle{plain}
\bibliography{pcasl}

\printindex

\end{document}

