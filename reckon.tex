% Personal Calculation and Simulation Langauge (PCASL)
%
% File:         pcasl.tex
% Author:       Bob Walton (walton@deas.harvard.edu)
% Date:		See \date below.
  
\documentclass[12pt]{article}

\usepackage{makeidx}

\makeindex

\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}
\raggedbottom

\setlength{\unitlength}{1in}

\pagestyle{headings}
\setlength{\parindent}{0.0in}
\setlength{\parskip}{1ex}

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}
\newcommand{\subsubsubsection}[1]{\paragraph[#1]{#1.}}
\newcommand{\subsubsubsubsection}[1]{\subparagraph[#1]{#1.}}

% Begin \tableofcontents surgery.

\newcount\ATCATCODE
\ATCATCODE=\catcode`@
\catcode `@=11	% @ is now a letter

\renewcommand{\contentsname}{}
\renewcommand\l@section{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\l@table{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\tableofcontents{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}}%
    \item\@starttoc{toc}%
    \end{list}}
\renewcommand\listoftables{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}%
	      }%
    \item\@starttoc{lot}%
    \end{list}}

\catcode `@=\ATCATCODE	% @ is now restored

% End \tableofcontents surgery.

\newcommand{\CN}[2]%	Change Notice.
    {\hspace*{0in}\marginpar{\sloppy \raggedright \it \footnotesize
     $^{\mbox{#1}}$#2}}
    % Change notice.

\newcommand{\key}[1]{{\em #1}\index{#1}}
\newcommand{\mkey}[2]{{\em #1}\index{#1!#2}}
\newcommand{\skey}[2]{{\em #1#2}\index{#1}}
\newcommand{\ikey}[2]{{\em #1}\index{#2}}
\newcommand{\ttkey}[1]{{\tt #1}\index{#1@{\tt #1}}}
\newcommand{\ttmkey}[2]{{\tt #1}\index{#1@{\tt #1}!#2}}
\newcommand{\ttfkey}[2]{{\tt #1}\index{#1@{\tt #1}!for #2@for {\tt #2}}}
\newcommand{\ttakey}[2]{{\tt #1}\index{#2@{\tt #1}}}
\newcommand{\ttamkey}[3]{{\tt #1}\index{#2@{\tt #1}!#3}}
\newcommand{\ttindex}[1]{\index{#1@{\tt #1}}}
\newcommand{\ttmindex}[2]{\index{#1@{\tt #1}!#2}}
\newcommand{\emkey}[1]{{\em #1}\index{#1@{\em #1}}}
\newcommand{\emindex}[1]{\index{#1@{\em #1}}}

\newcommand{\EOL}{\penalty \exhyphenpenalty}

\newsavebox{\leftbracket}
\begin{lrbox}{\leftbracket}
\verb|{|
\end{lrbox}

\newsavebox{\rightbracket}
\begin{lrbox}{\rightbracket}
\verb|}|
\end{lrbox}

\newcommand{\ttbrackets}{
    \renewcommand{\{}{\usebox{\leftbracket}}
    \renewcommand{\}}{\usebox{\rightbracket}}}

\newlength{\figurewidth}
\setlength{\figurewidth}{\textwidth}
\addtolength{\figurewidth}{-0.40in}

\newsavebox{\figurebox}

\newenvironment{boxedfigure}[1][!btp]%
	{\begin{figure*}[#1]
	 \begin{lrbox}{\figurebox}
	 \begin{minipage}{\figurewidth}

	 \vspace*{1ex}}%
	{
	 \vspace*{1ex}

	 \end{minipage}
	 \end{lrbox}
	 \begin{center}
	 \fbox{\hspace*{0.1in}\usebox{\figurebox}\hspace*{0.1in}}
	 \end{center}
	 \end{figure*}}

\newenvironment{indpar}[1][0.3in]%
	{\begin{list}{}%
		     {\setlength{\itemsep}{0in}%
		      \setlength{\topsep}{0in}%
		      \setlength{\parsep}{1ex}%
		      \setlength{\labelwidth}{#1}%
		      \setlength{\leftmargin}{#1}%
		      \addtolength{\leftmargin}{\labelsep}}%
	 \item}%
	{\end{list}}

\begin{document}
        
\title{Personal\\Calculation and Simulation\\Language\\[2ex]PCASL\\[2ex]
       (Draft 1a)}

\author{Robert L. Walton\thanks{This document is was partly inspired
teaching courses at Suffolk University.}}

\date{September 3, 2003}
 
\maketitle

\tableofcontents 

\newpage

\section{Introduction}

This document describes PCASL, the Personal Calculation and Simulation
Language, that is informally referred to as P-Castle, Personal Castle, or just
Castle.

PCASL is designed for naive programmers: that is, for people who may never
be able to program computers well.  It is a simple language that has
powerful data types which make it easier to write small programs
that do a variety of tasks that a person might want to do.  Generally
the tasks fall into the categories of calculating things (taxes,
probabilities, statistics) or simulating things
(computer games, construction designs, mathematics demonstrations).
Included are:

\begin{center}
\begin{tabular}{l}
Calculations that might be done with a spreadsheet. \\
Drawing pictures. \\
Simulating popular board games and creating new ones. \\
Creating simple computer games, including dialog games. \\
Computing and analysing documents. \\
Doing elementary algebra and calculus problems. \\
Calculating basic probabilities and statistics. \\
Simulating two and three dimensional objects. \\
Simulating simple electrical, mechanical, chemical, and biological systems.\\
Solving problems in elementary logic. \\
\end{tabular}
\end{center}

There are many computer languages that have some powerful data type that adapts
them for a specific kind of computation.  PCASL tries to combine these.
Some previous computer languages that have influenced PCASL, and
the data types they particularly support, are:

\begin{center}
\begin{tabular}{l@{\hspace{0.5in}}l}
Various Spreadsheets		& Spreadsheets \\
Various Data Base Languages	& Data Bases \\
Matlab				& Matrices \\
Mathematica			& Expressions \\
TCL				& Character Strings and Lists \\
Lisp				& Words and Phrases \\
Prolog				& Logical Expressions \\
\end{tabular}
\end{center}

PCASL is \underline{not} designed to be a computer-efficient language.
It is designed to be person-efficient, and to do small calculations
rapidly enough with inexpensive modern computers.

\section{Data}

PCASL has two major kinds of data: expressions and blocks.  Numbers are
the simplest expressions.  More complex expressions are math
expressions or document expressions.  Blocks are sets of variables
each of which can have a value, which is an expression, and also
a definition, which is another expression that is used to compute the
value when the value is needed.  The definitions of a block, taken all
together, are called the `code' of the block.

You can use PCASL as a calculator by typing into it expressions to
be evaluated and assignments of values and definitions to variables.
Some examples involving numbers are:

\begin{indpar}\begin{verbatim}
> 9
9
> 9 + 8
17
> x = 9
9
> y = 9 + 8
17
> x + y
26
\end{verbatim}\end{indpar}

Here the `\verb|> |' at the beginning of some lines is the PCASL \key{prompt}
that tells you its OK to input an expression to be evaluated.

At somewhat the opposite extreme from numbers are words, phrases, sentences,
and paragraphs.  You can calculate with these `\skey{document expression}s'.

\begin{indpar}
\verb|> g = `hello'| \\
\verb|`|hello\verb|'| \\
\verb|> `<<g>> there'| \\
\verb|`|hello there\verb|'| \\
\verb|> z = ``I thought he said `<<g>>'.''| \\
\verb|``|I thought he said `hello'.\verb|''| \\
\verb/> notice = ``|This document is meant to be read./ \\
\verb/+            |Reading this document is good, but.../ \\
\verb/+            |<<z>>.''/ \\
\verb|``|This document is meant to be read. \\
\verb|  |Reading this document is good, but\ldots \\
\verb|  |I thought he said `hello'.\verb|''| \\
\verb|> `When you add <<x>> and <<y>> you get <<x+y>>.'| \\
\verb|`|When you add 9 and 17 you get 26.\verb|'|
\end{indpar}

Modern math computes with expressions, and not just numbers.
You can compute with \skey{math expression}s in PCASL.

\begin{indpar}
\verb|> f = {10x^2 - 3.67x - 0.04}| \\
\verb|{|$10x^2-3.67x-0.04$\verb|}| \\
\verb|> h = (- 0.96 + 0.67x) in x| \\
\verb|{|$-0.96+0.67x$\verb|}| \\
\verb|> (f + h) in x| \\
\verb|{|$10x^2-3x-1$\verb|}| \\
\verb|> solve (f + h = 0) for x| \\
\verb|{x = (-0.2, 0.5)}| \\
\verb|> (f + h) at (x = (3, 4, 5))| \\
\verb|(78.95, 145.28, 231.61)| \\
\verb|> g = {integral (x^2 dx)}| \\
\verb|{|$\int x^2 dx$\verb|}| \\
\verb|> simplify g| \\
\verb|{|$\frac{1}{3} x^3$\verb|}| \\
\verb|> v = g from (x=1) to (x=5)| \\
\verb|41 1/3| \\
\verb|> out = `The value of (<<g>> from (x=1) to (x=5)) is <<v>>.'| \\
\verb|`|The value of $\int_{x=1}^{x=5} x^2 dx$ is $41\frac{1}{3}$.\verb|'| \\
\verb|> raw out| \\
\verb|{sentence (the value of ((integral (x^2*dx)) from (x=1) to (x=5))| \\
\verb|           is 124/3)}|
\end{indpar}

Another kind of datum you can compute with in PCASL, which is
the \key{block}:

\begin{indpar}
\verb|> a person {| \\
\verb|+     name = `Jack'| \\
\verb|+     weight = 123 lb| \\
\verb|+     height = 5'9"| \\
\verb|+     age = 23 yr 2 mo }| \\
\begin{tabular}{|r|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000000 & Jack & \tt 123 lb & \tt 5'9" & \tt 23 yr 2 mo \\
\hline
\end{tabular} \\
\verb|> a person {| \\
\verb|+     name = `Jill'| \\
\verb|+     weight = 110 lb| \\
\verb|+     height = 5'7"| \\
\verb|+     age = 21 yr 8 mo }| \\
\begin{tabular}{|r|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000001 & Jill & \tt 110 lb & \tt 5'7" & \tt 21 yr 8 mo \\
\hline
\end{tabular} \\
\verb|> all persons| \\
\begin{tabular}{|r|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000000 & Jack & \tt 123 lb & \tt 5'9" & \tt 23 yr 2 mo \\
\tt @1000001 & Jill & \tt 110 lb & \tt 5'7" & \tt 21 yr 8 mo \\
\hline
\end{tabular} \\
\verb|> the person Jack| \\
\begin{tabular}{|r|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000000 & Jack & \tt 123 lb & \tt 5'9" & \tt 23 yr 2 mo \\
\hline
\end{tabular} \\
\verb|> the person named Jack's height| \\
\verb|5'9"| \\
\verb|> the weight of the person named Jack| \\
\verb|123 lb| \\
\verb|> @1000001| \\
\begin{tabular}{|r|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000001 & Jill & \tt 110 lb & \tt 5'7" & \tt 21 yr 8 mo \\
\hline
\end{tabular} \\
\verb|> the weight of @1000001| \\
\verb|110 lb|
\end{indpar}

It is possible to add code to a type such as `{\tt person}':

\begin{indpar}
\verb|> a person <-- {| \\
\verb|+     body-mass-index = 703.06958 * weight in lbs| \\
\verb|+                     / (height in inches)^2 }| \\
\verb|> all persons| \\
\begin{tabular}{|r|l|r|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} &
\multicolumn{1}{|c|}{\bf \shortstack{body-mass-\\index}} \\
\hline
\tt @1000000 & Jack & \tt 123 lb & \tt 5'9" & \tt 23 yr 2 mo & \tt 18.163738 \\
\tt @1000001 & Jill & \tt 110 lb & \tt 5'7" & \tt 21 yr 8 mo & \tt 17.228258 \\
\hline
\end{tabular}
\end{indpar}

One can use definitions to define expressions that compute values:

\begin{indpar}
\verb|> sum from X through Y <-- integer X, integer Y {| \\
\verb|+     `Sum of integers from X through Y.'| \\
\verb|+     if ( X > Y ):| \\
\verb|+         value = 0| \\
\verb|+     else:| \\
\verb|+         value = X + sum (X+1) through Y }| \\
\verb|> sum from 5 through 10| \\
\verb|45| \\
\verb|> all (sums from X through Y)| \\
\begin{tabular}{|r|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf X} &
\multicolumn{1}{|c}{\bf Y} &
\multicolumn{1}{|c|}{\bf value} \\
\hline
\tt @1000002 & \tt 5	& \tt	10	& \tt 45 \\
\tt @1000003 & \tt 6	& \tt	10	& \tt 40 \\
\tt @1000004 & \tt 7	& \tt	10	& \tt 34 \\
\tt @1000005 & \tt 8	& \tt	10	& \tt 27 \\
\tt @1000006 & \tt 9	& \tt	10	& \tt 19 \\
\tt @1000007 & \tt 10	& \tt	10	& \tt 10 \\
\tt @1000008 & \tt 11	& \tt	10	& \tt 0 \\
\hline
\end{tabular} \\
\verb|> sum from 1 through 2| \\
\verb|3| \\
\verb|> all (sums from X through Y)| \\
\begin{tabular}{|r|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf X} &
\multicolumn{1}{|c}{\bf Y} &
\multicolumn{1}{|c|}{\bf value} \\
\hline
\tt @1000002 & \tt 5	& \tt	10	& \tt 45 \\
\tt @1000003 & \tt 6	& \tt	10	& \tt 40 \\
\tt @1000004 & \tt 7	& \tt	10	& \tt 34 \\
\tt @1000005 & \tt 8	& \tt	10	& \tt 27 \\
\tt @1000006 & \tt 9	& \tt	10	& \tt 19 \\
\tt @1000007 & \tt 10	& \tt	10	& \tt 10 \\
\tt @1000008 & \tt 11	& \tt	10	& \tt 0 \\
\tt @1000009 & \tt 1	& \tt	2	& \tt 3 \\
\tt @1000010 & \tt 2	& \tt	2	& \tt 2 \\
\tt @1000011 & \tt 3	& \tt	2	& \tt 0 \\
\hline
\end{tabular}
\end{indpar}

Executions can be examined in detail because
when an expression is computed, the block that computes it is remembered
for some time.  However, as memory is finite, eventually these
computations are forgotten as they can always be regenerated if
needed.

The sum above was computed by recursion: to compute the sum of 5 through 10
one computes the sum of 6 through 10.  One can also compute sums by
iteration.

\begin{indpar}
\verb|> sum from X through Y <-- integer X, integer Y {| \\
\verb|+     `Sum of integers from X through Y.'| \\
\verb|+     first sum = 0| \\
\verb|+     if ( X <= Y ):| \\
\verb|+         next sum = sum + X| \\
\verb|+         next X = X + 1| \\
\verb|+     else:| \\
\verb|+         value = sum }| \\
\verb|> sum from 5 through 10| \\
\verb|45| \\
\verb|> all (sums from 5 through 10)| \\
\begin{tabular}{|r|r|r|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf previous} &
\multicolumn{1}{|c}{\bf X} &
\multicolumn{1}{|c}{\bf Y} &
\multicolumn{1}{|c}{\bf sum} &
\multicolumn{1}{|c|}{\bf value} \\
\hline
\tt @1000012 &              & \tt 5	& \tt 10   & \tt 0	& \\
\tt @1000013 & \tt @1000012 & \tt 6	& \tt 10   & \tt 5	& \\
\tt @1000014 & \tt @1000013 & \tt 7	& \tt 10   & \tt 11	& \\
\tt @1000015 & \tt @1000014 & \tt 8	& \tt 10   & \tt 18	& \\
\tt @1000016 & \tt @1000015 & \tt 9	& \tt 10   & \tt 26	& \\
\tt @1000017 & \tt @1000016 & \tt 10	& \tt 10   & \tt 35	& \\
\tt @1000018 & \tt @1000017 & \tt 11	& \tt 10   & \tt 45	& \tt 45 \\
\hline
\end{tabular}
\end{indpar}

One can also iterate over data.

\begin{indpar}
\verb|> average weight of X <-- tuple X of persons {| \\
\verb|+     first count = 0| \\
\verb|+     first sum = 0| \\
\verb|+     if X = ():| \\
\verb|+         if count = 0:| \\
\verb|+             value = error `Cannot average 0 things.'| \\
\verb|+         else:| \\
\verb|+             value = sum / count| \\
\verb|+     else:| \\
\verb|+         next count = count + 1| \\
\verb|+         next sum = sum + the weight of (first X)| \\
\verb|+         next X = rest X }| \\
\verb|> average weight of (all persons)| \\
\verb|116.5 lbs|
\end{indpar}

In case you wonder how some of the above works, here are some hints.

PCASL tends to ignore word endings: thus `{\tt person}' and
`{\tt persons}' are to PCASL the same word.
PCASL can even be told that `{\tt person}'
and `{\tt people}' are the same word.
`{\tt Jack's}', on the other hand, is treated an abbreviation
of two separate words `{\tt Jack 's}', where `{\tt 's}' is
a separate word by itself.

Expressions are just strings of words and subexpressions.  Subexpressions
must be parenthesized unless they consist of a single word, or unless
they are delimited by operators.

Lists of values can be stored in tuples, which are computed by comma
separted lists in parentheses.  Thus

\begin{indpar}
\verb|> (the person named Jill, the person named Jack)| \\
\begin{tabular}{|r|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000001 & Jill & \tt 110 lb & \tt 5'7" & \tt 21 yr 8 mo \\
\tt @1000000 & Jack & \tt 123 lb & \tt 5'9" & \tt 23 yr 2 mo \\
\hline
\end{tabular} \\
\verb|> (the person named Jack, the person named Jill)| \\
\begin{tabular}{|r|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000000 & Jack & \tt 123 lb & \tt 5'9" & \tt 23 yr 2 mo \\
\tt @1000001 & Jill & \tt 110 lb & \tt 5'7" & \tt 21 yr 8 mo \\
\hline
\end{tabular} \\
\verb|> raw (all persons)| \\
\verb|(the person named Jack, the person named Jill)|
\end{indpar}

The `{\tt raw}' form of a value is a form that prints as you could
input it in a way that reveals its internal structure.  Thus
`{\tt all persons}' denotes the tuple of all persons.

`{\tt the person named Jack}' is a printed representation of the
internal name of a block.  Such printed representations are chosen
automatically from the set of all possible representations, which
in this case include `{\tt the person weighing 123}' and
`{\tt the person named Jack weighing 123}'.

A single non-tuple value is equivalent to a tuple with one element.
Tuples cannot have other tuples as elements; instead attempts to
compute such tuples are \key{flattened}:

\begin{indpar}
\verb|> x = (1,(2,3),4)| \\
\verb|(1,2,3,4)| \\
\verb|> first x| \\
\verb|1| \\
\verb|> rest x| \\
\verb|(2,3,4)| \\
\verb|> rest (rest x)| \\
\verb|(3,4)| \\
\verb|> rest (rest (rest x))| \\
\verb|3| \\
\verb|> rest 9| \\
\verb|()|
\end{indpar}

\newpage

PCASL stores information as expressions.  For example:

\begin{indpar}
\verb|> (a person named `Jack') is husband of (a person named `Jill') <--| \\
\verb|> Y is wife of X <-- X is husband of Y| \\
\verb|> (a person named `Jill') is wife of (a person named `Jack') ?| \\
\verb|true| \\
\verb|> (a person named `Jack') is wife of (a person named `Jill') ?| \\
\verb|false| \\
\verb|> (a person named X) is wife of (a person named `Jack') ?| \\
\verb|X = `|Jill\verb|'| \\
\verb|> X is wife of (a person named `Jack') ?| \\
\verb|X = (a person named `Jill')| \\
\verb|> @1000001 is wife of (a person named `Jack') ?| \\
\verb|true| \\
\verb|> @1000001 = (a person named `Jill') ?| \\
\verb|true| \\
\verb|> @1000001 = (a person named `Jack') ?| \\
\verb|false|
\end{indpar}

In PCASL also supports pictorial data
that are computed like expressions.

\begin{indpar}
\verb|> x = circle 0.4| \\
\begin{picture}(0.4,0.4)
\put(0.2,0.2){\circle{0.4}}
\end{picture} \\
\verb|> y = rectangle (0.4,0.2)| \\
\begin{picture}(0.4,0.2)
\put(0,0){\framebox(0.4,0.2){}}
\end{picture} \\
\verb|> z = (circle 0.4) labeled `Jack'| \\
\begin{picture}(0.4,0.4)
\put(0.2,0.2){\circle{0.4}}
\put(0.0,0.0){\makebox(0.4,0.4){Jack}}
\end{picture} \\
\verb|> (x right of y) above z| \\
\begin{picture}(0.8,0.8)
\put(0.6,0.6){\circle{0.4}}
\put(0.0,0.5){\framebox(0.4,0.2){}}
\put(0.4,0.2){\circle{0.4}}
\put(0.2,0.0){\makebox(0.4,0.4){Jack}}
\end{picture} \\
\verb|> row(x,y,z)| \\
\begin{picture}(1.4,0.4)
\put(0.2,0.2){\circle{0.4}}
\put(0.5,0.1){\framebox(0.4,0.2){}}
\put(1.2,0.2){\circle{0.4}}
\put(1.0,0.0){\makebox(0.4,0.4){Jack}}
\end{picture} \\
\verb|> p = column (row(x,y,z), row(z,y,x))| \\
\begin{picture}(1.4,0.9)
\put(0.2,0.7){\circle{0.4}}
\put(0.5,0.6){\framebox(0.4,0.2){}}
\put(1.2,0.7){\circle{0.4}}
\put(1.0,0.5){\makebox(0.4,0.4){Jack}}
\put(1.2,0.2){\circle{0.4}}
\put(0.5,0.1){\framebox(0.4,0.2){}}
\put(0.2,0.2){\circle{0.4}}
\put(0.0,0.0){\makebox(0.4,0.4){Jack}}
\end{picture} \\
\verb|> raw x| \\
\verb|{circle 0.4}| \\
\verb|> raw p| \\
\verb|{column (row (circle 0.4,| \\
\verb|              rectangle (0.4,0.2),| \\
\verb|              (circle 0.4) labeled `Jack'),| \\
\verb|         row ((circle 0.4) labeled `Jack',| \\
\verb|              rectangle (0.4,0.2),| \\
\verb|              circle 0.4))}|
\end{indpar}

You can also change how an expression is displayed.

\begin{indpar}
\verb|> display (a person named X) as ((oval (0.4,0.2)) labelled X) <--| \\
\verb|> (a person named `Jack')| \\
\begin{picture}(0.4,0.2)
\put(0.2,0.1){\oval(0.4,0.2)}
\put(0.0,0.0){\makebox(0.4,0.2){Jack}}
\end{picture} \\
\verb|> ``(a person named `Jill') is wife of (a person named `Jack')''| \\
\begin{picture}(2.0,0.2)
\put(0.2,0.1){\oval(0.4,0.2)}
\put(0.0,0.0){\makebox(0.4,0.2){Jill}}
\put(0.4,0.0){\makebox(1.2,0.2){is the wife of}}
\put(1.8,0.1){\oval(0.4,0.2)}
\put(1.6,0.0){\makebox(0.4,0.2){Jack}}
\end{picture}
\end{indpar}


\section{Lexemes}

A PCASL program is a sequence of characters which is scanned from
left to right to produce a sequence of pre-lexemes.  The sequence
of pre-lexemes is then scanned from left to right to produce
a sequence of lexemes.

\subsection{Pre-Lexemes}

Primarly lexemes are defined as follows:

\begin{indpar}
\key{pre-lexeme}
	\begin{tabular}[t]{rl}
	::= & \key{pre-word} \\
	$|$ & \key{separator} \\
	$|$ & \key{left-quote} \\
	$|$ & \key{right-quote} \\
	$|$ & \key{white-space}
	\end{tabular}
	\\[1ex]
\key{pre-word} ::= {\em word-character} {\em word-character}$^\star$ \\[1ex]
\key{word-character} \begin{tabular}[t]{rl}
                       ::= & {\em letter} $|$ {\em digit} \\
		       $|$ &    \verb|+|%
		             $|$\verb|-|%
		             $|$\verb|*|%
		             $|$\verb|/|%
		             $|$\verb|\|%
		             $|$\verb|~|%
		             $|$\verb|@|%
		             $|$\verb|#|%
		             $|$\verb|$|%
		             $|$\verb|%|%
		             $|$\verb|^|%
		             $|$\verb|&|%
		             $|$\verb|=|%
		             $|$\verb/|/%
		             $|$\verb|<|%
		             $|$\verb|>|%
		             $|$\verb|_|%
		             $|$\verb|"|%
		             $|$\verb|`|%
		             $|$\verb|'|%
		             $|$\verb|!|%
		             $|$\verb|?|%
			     $|$\verb|;|%
			     $|$\verb|:|%
			     $|$\verb|,|%
		             $|$\verb|.|
			\end{tabular}\\[1ex]
\key{letter} ::= {\em lower-case-letter} $|$ {\em upper-case-letter} \\[1ex]
\key{lower-case-letter} ::=    \verb|a|%
			    $|$\verb|b|%
			    $|$\verb|c|%
			    $|$\verb|d|%
			    $|$\verb|e|%
			    $|$\verb|f|%
			    $|$\verb|g|%
			    $|$\verb|h|%
			    $|$\verb|i|%
			    $|$\verb|j|%
			    $|$\verb|k|%
			    $|$\verb|l|%
			    $|$\verb|m|%
			    $|$\verb|n|%
			    $|$\verb|o|%
			    $|$\verb|p|%
			    $|$\verb|q|%
			    $|$\verb|r|%
			    $|$\verb|s|%
			    $|$\verb|t|%
			    $|$\verb|u|%
			    $|$\verb|v|%
			    $|$\verb|w|%
			    $|$\verb|x|%
			    $|$\verb|y|%
			    $|$\verb|z|
			    \\[1ex]
\key{upper-case-letter} ::=    \verb|A|%
			    $|$\verb|B|%
			    $|$\verb|C|%
			    $|$\verb|D|%
			    $|$\verb|E|%
			    $|$\verb|F|%
			    $|$\verb|G|%
			    $|$\verb|H|%
			    $|$\verb|I|%
			    $|$\verb|J|%
			    $|$\verb|K|%
			    $|$\verb|L|%
			    $|$\verb|M|%
			    $|$\verb|N|%
			    $|$\verb|O|%
			    $|$\verb|p|%
			    $|$\verb|Q|%
			    $|$\verb|R|%
			    $|$\verb|S|%
			    $|$\verb|T|%
			    $|$\verb|U|%
			    $|$\verb|V|%
			    $|$\verb|W|%
			    $|$\verb|X|%
			    $|$\verb|Y|%
			    $|$\verb|Z|
			    \\[1ex]
\key{digit} ::=    \verb|0|%
		$|$\verb|1|%
		$|$\verb|2|%
		$|$\verb|3|%
		$|$\verb|4|%
		$|$\verb|5|%
		$|$\verb|6|%
		$|$\verb|7|%
		$|$\verb|8|%
		$|$\verb|9|
		\\[1ex]
\key{opening-lexeme} ::=     \verb|(|
	       		 $|$ \verb|[|
	       		 $|$ \verb|{|
	       		 $|$ {\em opening-quote}
	       		 $|$ {\em opening-angle}
	       		 \\[1ex]
\key{closing-lexeme} ::=     \verb|)|
	       		 $|$ \verb|]|
	       		 $|$ \verb|}|
	       		 $|$ {\em closing-quote}
	       		 $|$ {\em closing-angle}
	       		 \\[1ex]
\key{opening-quote} \begin{tabular}[t]{rl}
		     ::= & {\em opening-quote-character}
		           {\em opening-quote-character}$^\star$ \\
		     \end{tabular}
		     \\[1ex]
\key{opening-quote-character} ::= \verb|`| \\[1ex]
\key{closing-quote} \begin{tabular}[t]{rl}
		     ::= & {\em closing-quote-character}
		           {\em closing-quote-character}$^\star$ \\
		     \end{tabular}
		     \\[1ex]
\key{closing-quote-character} ::= \verb|'| \\[1ex]
\key{quote} ::= {\em opening-quote} $|$ {\em closing-quote} \\[1ex]
\key{opening-angle} \begin{tabular}[t]{rl}
		     ::= & {\em opening-angle-character}
		           {\em opening-angle-character} \\
		         & {\em opening-angle-character}$^\star$ \\
		     \end{tabular}
		     \\[1ex]
\key{opening-angle-character} ::= \verb|<| \\[1ex]
\key{closing-angle} \begin{tabular}[t]{rl}
		     ::= & {\em closing-angle-character}
		           {\em closing-angle-character} \\
		         & {\em closing-angle-character}$^\star$ \\
		     \end{tabular}
		     \\[1ex]
\key{closing-angle-character} ::= \verb|>| \\[1ex]
\key{angle-character} ::= \verb|<| $|$ \verb|>| \\[1ex]
\key{opening-character} ::=     \verb|(|
		            $|$ \verb|[|
		            $|$ \verb|{|
		            $|$ \verb|`|
		            $|$ \verb|<|
			    \\[1ex]
\key{closing-character} ::=     \verb|)|
		            $|$ \verb|]|
		            $|$ \verb|}|
		            $|$ \verb|'|
		            $|$ \verb|>|
			    \\[1ex]
\key{format-separator} ::= {\em format-separator-character}
			   {\em format-separator-character}$^\star$ \\[1ex]
\key{format-separator-character} ::=    \verb\|\
				        \\[1ex]
\key{white-space} ::= {\em white-space-character}
                     {\em white-space-character}$^\star$ \\[1ex]
\key{white-space-character} ::=
    \key{horizontal-space-character} $|$ \key{vertical-space-character} \\[1ex]
\key{horizontal-space-character} ::=
    \key{space} $|$ \key{horizontal-tab} $|$ \key{carriage-return} \\[1ex]
\key{vertical-space-character} ::=
    \key{line-feed} $|$ \key{vertical-tab} $|$ \key{form-feed}
\end{indpar}


The following sections give rules involving pre-lexemes.

\subsubsection{Matching and Pre-Lexical Context}
\label{MATCHING}

{\bf Lexeme Matching Rule.}\index{Lexeme Matching Rule}
An {\em opening-lexeme} with $N$ characters $C$
must have a matching {\em closing-lexeme} with $N$ characters each the
mirror of $C$.  Each {\em closing-lexeme} must match exactly one
{\em opening-lexeme} and the {\em opening-lexeme} must proceed the
{\em closing-lexeme}.

Two lexemes are said to be \mkey{matched}{lexemes} if and only if
the are matched opening and closing lexemes.

{\bf Lexeme Nesting Rule.}\index{Lexeme Nesting Rule}
If one lexeme in a pair $P_2$ of matching lexemes is in between the
lexemes of another pair $P_1$ of matching lexemes, then both lexemes
in $P_2$ must be in between the lexemes of $P_1$.  In this case
$P_2$ is said to be \mkey{nested}{lexemes} inside of $P_1$.

During the scan a character $C$ is said to be in the
\key{pre-lexical context} of a pair $P$ of matched lexemes
if and only if $C$ is between the matched lexemes of $P$,
and $C$ is neither part of or between any other pair of matched
lexemes that is nested inside of $P$.

\subsubsection{Character Disambiguation Rules}

Several characters in pre-lexemes are ambiguous in the
lexeme syntax equations.  The following rules disambiguate these
characters.

{\bf Opening Quote Rule.}\index{Opening Quote Rule}
An \key{opening-quote-character} must be preceeded by a
{\em white-space-character},
an {\em opening-character}, or a {\em format-separator-character}.
Otherwise it is a {\em word-character}.

{\bf Closing Quote Rule.}\index{Closing Quote Rule}
A \key{closing-quote-character} must be part of a sequence of
{\em closing-quote-characters} that is of exactly the right length to be the
matching lexeme for the last previous unmatched {\em opening-lexeme},
which must be an {\em opening-quote}.
Otherwise the potential {\em closing-quote-character}
is a {\em word-character}.

{\bf Format Separator Rule.}\index{Format Separator Rule}
A {\em format-separator-character} must be in the pre-lexical context of
a pair of matching {\em quotes}.  Otherwise it is a {\em word-character}.

{\bf Angle Rule.}\index{Angle Rule}
An {\em angle-character} must be either proceeded by or followed by a copy
of itself.  Otherwise it is a {\em word-character}.

Quote Examples:

\begin{indpar}[0.1in]
\begin{tabular}{@{}l@{\hspace*{0.3in}}l}
			& Pre-Lexeme Sequence		\\
Input String		& with {\em spaces} represented by \verb|_|'s \\[1ex]
\verb|I said `Hello'.|	& \tt `~~Hello~~'			\\
\verb|Re`op 'tis.  But!|
			& \tt Re`op~~\verb|_|~~'tis.%
			  ~~\verb|__|~~But! \\
\verb|`Like 'tis'|	& \tt `~~Like~~\verb|_|~~'~~tis'	\\
\verb|``Like 'tis''|	& \tt ``~~Like~~\verb|_|~~'tis~~''	\\
\verb|`Like me''|	& \tt `~~Like~~\verb|_|~~me''		\\
\verb|`` `Hello' is a word.''|
			& \tt ``~~\verb|_|~~`~~Hello~~'~~\verb|_|~~is%
			  ~~\verb|_|~~a~~\verb|_|~~word.~~'' \\
\end{tabular}
\end{indpar}

Other rules of PCASL (\ref{TBD}) cause {\em white-space} following an
{\em opening-lexeme} or preceding a {\em closing-lexeme} to
be ignored.  As a consequence, there is no problem putting
space between the \verb|``| and \verb|`| in the last example.

Angle and Format Separator Examples:

\begin{indpar}[0.1in]
\begin{tabular}{@{}l@{\hspace*{0.6in}}l}
			& Pre-Lexeme Sequence		\\
Input String		& with {\em spaces} represented by \verb|_|'s \\[1ex]
\verb|x <= y |		& \tt x \verb|_| \verb|<=| \verb|_| y	\\
\verb|x <<= y |		& \tt x \verb|_| \verb|<<| = \verb|_| y	\\
\verb/x = y|z/		& \tt x \verb|_| = \verb|_| \verb/y|z/ \\
\verb/x = `y|z'/	& \tt x \verb|_| = \verb|_|
                              \verb|`| y \verb/|/ z \verb|'| \\
\end{tabular}
\end{indpar}

\subsubsection{White Space Conversion}

A \key{white-space} lexeme does not have exactly the same characters
that were input to create it, unlike other pre-lexemes.  The
sequence of {\em white-space-characters} input to create a
{\em white-space} lexeme is modified as follows to create the lexeme:

{\bf Line End Spaces Rule.}\index{Line End Spaces Rule}
All {\em horizontal-space} characters preceeding a {\em vertical-space}
character are deleted.  Thus spaces at line ends are ignored.

{\bf Carriage Return Rule.}\index{Carriage Return Rule}
Each {\em carriage-return} and all {\em horizontal-spaces} preceding
it are deleted.  Thus the lexeme has no {\em carriage-returns}.

{\bf Horizontal Tab Rule.}\index{Horizontal Tab Rule}
Each {\em horizontal-tab} is replace by {\em spaces} assuming that
horizontal tab stops are set every 8 columns.
Thus the lexeme has no {\em horizontal-tabs}.

Note that these rules do \underline{not} alter the printed appearance
of the {\em white-space} lexeme.

After these rules are applied, a {\em white-space} lexeme consists of
only of {\em vertical-space-characters} followed by {\em space} characters.
{\em White-space} lexemes are only pre-lexemes; they are deleted
when pre-lexemes are converted to lexemes.  The rules that
form the lexeme sequence ensure that all
{\em vertical-space} characters are equivalent: see \ref{TBD}.


\subsection{Lexemes}

The sequence of pre-lexemes is converted to a sequence of lexemes
according to the following rules, which we will describe in the
order given:

\begin{indpar}[1in]
Numbers \\
Post Separators \\
Indentation Lexemes
\end{indpar}

The syntax equations defining a lexeme are:

\begin{indpar}
\key{lexeme} ::= {\em word} $|$ {\em separator}
		$|$ {\em opening-lexeme}
		$|$ {\em closing-lexeme} \\[1ex]
\key{separator} ::= {\em format-separator}
		$|$ {\em post-separator}
		$|$ {\em indentation-lexeme}
\end{indpar}

{\em Ambigous-separators} are single characters removed from the
ends of {\em pre-words}.  A {\em Word} is what is left of
a {\em pre-word} after any {\em post-separator}
is removed from its end.
{\em Words} and {\em post-separators} are defined
below in \ref{POST-SEPARATORS}.

{\em Indentation-lexemes} are implied by indentation, and are defined below in
\ref{INDENTATION-LEXEMES}.

{\em White-space} pre-lexemes are used only to define indentation and
create {\em indentation-lexemes}.
Then {\em white-space} pre-lexemes are
discarded: they are not {\em lexemes}.

{\em Format-separators}, {\em opening-lexemes}, and {\em closing-lexemes}
are both pre-lexemes and lexemes.

\subsubsection{Number Lexemes}
\label{NUMBER-LEXEMES}

The rule for spliting a {\em pre-word} into a {\em word}
and a {\em separator} makes reference to {\em words} that are
{\em numbers}, saying that splitting is preferred if the {\em word}
resulting from the split is a {\em number}.  The syntax equations
for defining {\em numbers} are as follows.

\begin{indpar}
\key{number} ::= {\em real-number} $|$ {\em unit-number}
				   $|$ {\em complex-number} \\[1ex]
\key{real-number} ::= {\em unsigned-real-number}
                  $|$ {\em sign} {\em unsigned-real-number}
		      \\[1ex]
\key{sign} ::= \verb|+| $|$ \verb|-| \\[1ex]
\key{unsigned-real-number} ::= {\em unexponented-number}
		$|$ {\em unexponented-number} {\em exponent} \\[1ex]
\key{unexponented-number} ::= {\em decimal-number}
			  $|$ {\em radixed-number} \\[1ex]
\key{radixed-number}::= {\em radix-indicator}
		        \verb|`| {\em radixed-digmark}
		        {\em radix-digmark}$^\star$ \verb|'|
		        \\[1ex]
\key{radix-indicator} ::= {\em letter} {\em letter}$^\star$ \\[1ex]
\key{radixed-digmark} ::= {\em digit} $|$ {\em letter}
                      $|$ \verb|.| $|$ \verb|,| \\[1ex]
\key{decimal-number} \begin{tabular}[t]{rl}
                     ::= & {\em decimal-integer} \\
		     $|$ & {\em decimal-integer} \verb|.|
		           {\em decimal-integer} \\
		     $|$ & \verb|.| {\em decimal-integer}
		     \end{tabular} \\[1ex]
\key{decimal-integer} ::= {\em decimal-digits}
		     $|$ {\em decimal-integer} \verb|,| {\em decimal-digits}
		     \\[1ex]
\key{decimal-digits} ::= {\em digit} {\em digit}$^\star$ \\[1ex]
\key{exponent} ::= {\em exponent-indicator}
		   {\em exponent-digits} \\[1ex]
\key{exponent-indicator} ::= \verb|e| $|$ \verb|E| $|$ \verb|^| \\[1ex]
\key{exponent-digits} ::= {\em decimal-digits}
			    $|$ {\em sign} {\em decimal-digits} \\[1ex]
\key{unit-number} ::= {\em pre-unit} {\em real-number}
		  $|$ {\em real-number} {\em post-unit} \\[1ex]
\key{pre-unit} ::= \verb|$| $|$ {\tt \pounds} \\[1ex]
\key{post-unit} ::= \verb|'| $|$ \verb|"| $|$ $^\circ$ \\[1ex]
\key{complex-number} ::= {\em imaginary-number}
		$|$ {\em real-number} {\em signed-imaginary-number} \\[1ex]
\key{imaginary-number} ::= {\em unsigned-imaginary-number}
		$|$ {\em signed-imaginary-number} \\[1ex]
\key{signed-imaginary-number} ::=
		{\em sign} {\em unsigned-imaginary-number} \\[1ex]
\key{unsigned-imaginary-number} ::=
		{\em unsigned-real-number} {\em imaginary-indicator} \\[1ex]
\key{imaginary-indicator} ::=     \verb|I|
			      $|$ \verb|i|
			      $|$ \verb|J|
			      $|$ \verb|j|
\end{indpar}


Note that decimal points and commas in a {\em decimal-number}
must be followed by a digit.  Commas in a {\em decimal-number}
must be every 3 digits from the decimal point, or every three digits
from the end if there is no decimal point.
Incorrect numbers of digits between commas will result in an
error when the lexeme is converted to a number,
but is \underline{not} an error of lexeme formation.

{\em Radixed-numbers} are converted to numbers in a context which defines
ways of doing this for different {\em radix-indicators}: see \ref{TBD}.
The following are standard:

\begin{center}
\begin{tabular}{l@{~~~~~}l@{~~~~~}l@{~~~~~}l}
Radix	& Radix		 &			& Allowed Digits \\
Name	& Indicators     & Allowed Digits	& Between Commas \\[1ex]
binary	& \tt b~~~B	 & \tt 0 1		& 4 or 8 \\
octal	& \tt o~~~O	 & \tt 0 1 2 3 4 5 6 7	& 4 or 8 \\
decimal	& \tt d~~~D	 & \tt 0 1 2 3 4 5 6 7 8 9
						& 3 \\
hexadecimal
	& \tt x~~~X	 & \tt 0 1 2 3 4 5 6 7 8 9
						& 4 or 8 \\
	&		 & \tt a b c d e f A B C D E F
\end{tabular}
\end{center}

{\em Radixed-numbers} can be legal lexemes and still be unconvertable to
numbers because their {\em radix-indicators} are undefined, they
have digits not defined for the given {\em radix-indicator}, they
have too many decimal points, and so forth.  These errors are detected
when the lexemes are converted to numbers.

\subsubsection{Post Separators}
\label{POST-SEPARATORS}

Informally, a post-separator is a one character separator that immediately
follows a word, and could be part of the word.  Examples are the period
and the exclamation point.  The Post Separator Rule
given below tells when to split a {\em pre-word} that ends with an
post-separator character into a {\em word} and a one character
{\em separator}.  The rule makes reference to {\em words} that are
{\em numbers}, saying that splitting is preferred if the {\em word}
resulting from the split is a {\em number}.

The formal definitions required are:

\begin{indpar}
\key{separator} ::= {\em format-separator}
		$|$ {\em post-separator} \\[1ex]
\key{post-separator} ::= {\em post-separator-character} \\[1ex]
\key{post-separator-character} ::=     \verb|!|
				        $|$ \verb|?|
			                $|$ \verb|;|
			                $|$ \verb|:|
			                $|$ \verb|,|
			                $|$ \verb|.|
					\\[1ex]
\key{pre-word} ::= {\em word}
		$|$ {\em word} {\em post-separator}
		$|$ {\em post-separator}
\end{indpar}

The following rule handles the case of 1-character {\em pre-words}.

{\bf Isolated Post Separator Rule.}\index{Isolated Post Separator Rule}
A {\em pre-word} consists of a single {\em post-separator-character}
is a {\em post-separator}.

The following rule controls when to split a {\em pre-word}
of 2 or more characters into a {\em word} and an {\em post-separator}.

{\bf Post Separator Rule.}\index{Post Separator Rule}
A {\em pre-word} or 2 or more characters
that ends with an {\em post-separator-character}
is split into a {\em word} and an {\em post-separator} if the {\em word}
does \underline{not} contain a copy of the {\em post-separator} character,
or if the {\em post-separator} is a period
and the {\em word} is a {\em number}.
Otherwise the {\em pre-word} is not split and becomes a {\em word}.


Examples:

\begin{indpar}[0.1in]
\begin{tabular}{@{}l@{\hspace*{0.3in}}l@{~~~}l@{\hspace*{0.6in}}l}
Pre-Word		& \multicolumn{2}{@{}l@{}}{Lexeme Sequence}
							& Splits?	\\[1ex]
\verb|hello.|		& \tt hello 		& .	& yes		\\
\verb|h.e.l.l.o.|	& \tt h.e.l.l.o.	&	& no		\\
\verb|e.g.|		& \tt e.g.		&	& no		\\
\verb|5.0.|		& \tt 5.0		& .	& yes		\\
\verb|help!|		& \tt help		& !	& yes		\\
\verb|!help!|		& \tt !help!		&	& no		\\
\end{tabular}
\end{indpar}

\subsubsection{Indentation Lexemes}
\label{INDENTATION-LEXEMES}

{\em Indentation-lexemes} are implied by indentation.  The
\mkey{indentation}{of line} of a line is the
the number of {\em space} characters in the {\em white-space}
pre-lexeme just before the first non-{\em white-space} pre-lexeme
of the line.  Note that lines cannot be empty; such lines would
be merged into a single {\em white-space} pre-lexeme.

At any given point in the scan of pre-lexemes, there is a
stack of indentation records, called the \key{indentation stack}.
An \key{indentation record} is a number of
columns, a pre-lexical context, and a flag.
The number of columns is called the \key{indentation}.
The flag is called the \key{implicit bracket flag}, and indicates whether
or not an implied \verb|{| lexeme was inserted at the same time the
indentation record was pushed onto the indentation stack.

Initially the indentation stack contains a single indentation record with
0 indentation, the outermost pre-lexical context,
and an off implicit bracket flag.
The stack cannot become empty; any operation that would
pop the last indentation off the stack announces an error leaves the
stack along.  The bottommost indentation on the stack is always
the same.

The indentation in the indentation record at the top of the indentation
stack is called the \key{current indentation}, and the pre-lexical
context in that record is calle the \key{current pre-lexical context}.

{\bf Semi-Colon Rule.}\index{Semi-Colon Rule}
If the first non-{\em white-space} pre-lexeme of a line is neither
\verb|{| nor \verb|}|, if the first pre-lexeme of the line is in
the current pre-lexical context, and if the indentatoin of the line
is the current indentation, then a \verb|;| implied lexeme is output
before any lexemes generated by the line are output.

{\bf Explicit-Bracket Rule.}\index{Explicit-Bracket Rule}
If the last pre-lexeme of a line is \verb|{|, then an indentation record
is pushed into the indentation stack just after the \verb|{| lexeme
is output.  The indentation in the record is the indentation of the next
list, the pre-lexical context is that of the \verb|{|,
and the implicit bracket flag is off.
The pushed indentation record is popped just after is pre-lexical context
ends; that is, just after reading the \verb|}| pre-lexeme that matches the
\verb|{| pre-lexeme that pushed the indentation record.

{\bf Implicit-Bracket Rule.}\index{Implicit-Bracket Rule}
If the last lexeme output for a line would be a post-separator \verb|:|,
then a \verb|{| implied lexeme
is output instead of the \verb|:|, and an indentation
record is pushed into the indentation stack.  The indentation of the
record is the indentation of the next line, and the implicit bracket flag
or the record is on.
The pre-lexical context of the record is that of the \verb|:|.
The pushed record is popped just before the first line such that
the line beginning pre-lexeme is in the record's pre-lexical context
and the line indentation is equal to or less than the record's indentation.
When the record is popped, a \verb|}| implied lexeme is output.

Examples:


\section{Expressions}

An expression is a sequence of words, separators, and subexpressions.
A subexpression is a pair of matching lexemes and all the lexemes in
between.

Expressions and subexpressions can contain operators.  When they do,
matching implied parentheses are inserted into the expressions or subexpressions
according to rules of operator precedence and associativity, and these
implied parentheses create new subexpressions.

\subsection{Subexpressions}

Expressions and subexpressions are defined by the following syntax equations.

\begin{indpar}
\key{expression} ::= {\em expression-item}$^\star$ \\[1ex]
\key{expression-item} ::= {\em word} $|$ {\em separator}
				     $|$ {\em subexpression} \\[1ex]
\key{subexpression} \begin{tabular}[t]{rl}
		    ::= & \verb|(| {\em expression} \verb|)| \\
		    $|$ & \verb|[| {\em expression} \verb|]| \\
		    $|$ & \verb|{| {\em expression} \verb|}| \\
		    $|$ & {\em opening-quote} {\em expression} {\em closing-quote} \\
		    $|$ & {\em opening-angle} {\em expression} {\em closing-angle}
		    \end{tabular}
\end{indpar}

{\bf Subexpression Rule.}\index{Subexpression Rule}
The beginning and ending lexemes of a subexpression must match (\ref{MATCHING}).

\subsection{Operators}

\section{Rules}

These are some detailed design rules to be incorporated in the language
definition later.

\begin{list}{}{}

\item
{\bf Quotes}.  \verb|`'| are word, phrase, sentence, paragraph quotes.
\verb|[]| are math expression quotes.   Quotes are in left-right pairs
and can be nested.

\item
{\bf Multiple Quotes}.  Quotes can be multiplied $N$ times: e.g.,
\verb|[[...]]|, \verb|[[[...]]]|, etc.  It is possible to begin a quoted
phrase with a quoted phrase by following the initial $N$-left-quote by
space.  E.g., \verb|`` `Hello' 'tis a good word.''|.

\item
{\bf Algebraic Expressions}.
An expression may or may not be algebraic.  Algebraic expressions have
operators that determine structure.  Atoms in these are sequences of
words, numbers, and parenthesized or bracketted subexpressions.

\item
{\bf N-tuples and Flatening}.
The comma operator forms N-tuples, e.g., \verb|(x,y,z)| is a 3-tuple.

Tuples flatten.  It is not possible for a tuple to be a component of
a tuple: instead the tuples are flattened.  E.g., \verb|(x,(y,z),w)|
is the same value as \verb|(x,y,z,w)|.  There is no such thing as a
1-tuple, but any non-tuple behaves like a 1-tuple.

\item
{\bf Blank Algebraic Operators}.
The blank, or missing operator, denotes \verb|*| when it precedes a word,
as in \verb|5x| being equivalent to \verb|5*x|.  When it is between a
preceding integer and a following ratio, it adds the ratio to the integer,
as in \verb|41 1/3|.

\end{list}



\bibliographystyle{plain}
\bibliography{pcasl}

\printindex

\end{document}

