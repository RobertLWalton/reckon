% Personal Calculation and Simulation Langauge (PCASL)
%
% File:         pcasl.tex
% Author:       Bob Walton (walton@deas.harvard.edu)
% Date:		See \date below.
  
\documentclass[12pt]{article}

\usepackage{makeidx}

\makeindex

\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}
\raggedbottom

\setlength{\unitlength}{1in}

\pagestyle{headings}
\setlength{\parindent}{0.0in}
\setlength{\parskip}{1ex}

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}
\newcommand{\subsubsubsection}[1]{\paragraph[#1]{#1.}}
\newcommand{\subsubsubsubsection}[1]{\subparagraph[#1]{#1.}}

% Begin \tableofcontents surgery.

\newcount\ATCATCODE
\ATCATCODE=\catcode`@
\catcode `@=11	% @ is now a letter

\renewcommand{\contentsname}{}
\renewcommand\l@section{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\l@table{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\tableofcontents{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}}%
    \item\@starttoc{toc}%
    \end{list}}
\renewcommand\listoftables{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}%
	      }%
    \item\@starttoc{lot}%
    \end{list}}

\catcode `@=\ATCATCODE	% @ is now restored

% End \tableofcontents surgery.

\newcommand{\CN}[2]%	Change Notice.
    {\hspace*{0in}\marginpar{\sloppy \raggedright \it \footnotesize
     $^{\mbox{#1}}$#2}}
    % Change notice.

\newcommand{\key}[1]{{\em #1}\index{#1}}
\newcommand{\mkey}[2]{{\em #1}\index{#1!#2}}
\newcommand{\skey}[2]{{\em #1#2}\index{#1}}
\newcommand{\ikey}[2]{{\em #1}\index{#2}}
\newcommand{\ttkey}[1]{{\tt #1}\index{#1@{\tt #1}}}
\newcommand{\ttmkey}[2]{{\tt #1}\index{#1@{\tt #1}!#2}}
\newcommand{\ttfkey}[2]{{\tt #1}\index{#1@{\tt #1}!for #2@for {\tt #2}}}
\newcommand{\ttakey}[2]{{\tt #1}\index{#2@{\tt #1}}}
\newcommand{\ttamkey}[3]{{\tt #1}\index{#2@{\tt #1}!#3}}
\newcommand{\ttindex}[1]{\index{#1@{\tt #1}}}
\newcommand{\ttmindex}[2]{\index{#1@{\tt #1}!#2}}
\newcommand{\emkey}[1]{{\em #1}\index{#1@{\em #1}}}
\newcommand{\emindex}[1]{\index{#1@{\em #1}}}

\newcommand{\EOL}{\penalty \exhyphenpenalty}

\newsavebox{\leftbracket}
\begin{lrbox}{\leftbracket}
\verb|{|
\end{lrbox}

\newsavebox{\rightbracket}
\begin{lrbox}{\rightbracket}
\verb|}|
\end{lrbox}

\newcommand{\ttbrackets}{
    \renewcommand{\{}{\usebox{\leftbracket}}
    \renewcommand{\}}{\usebox{\rightbracket}}}

\newlength{\figurewidth}
\setlength{\figurewidth}{\textwidth}
\addtolength{\figurewidth}{-0.40in}

\newsavebox{\figurebox}

\newenvironment{boxedfigure}[1][!btp]%
	{\begin{figure*}[#1]
	 \begin{lrbox}{\figurebox}
	 \begin{minipage}{\figurewidth}

	 \vspace*{1ex}}%
	{
	 \vspace*{1ex}

	 \end{minipage}
	 \end{lrbox}
	 \begin{center}
	 \fbox{\hspace*{0.1in}\usebox{\figurebox}\hspace*{0.1in}}
	 \end{center}
	 \end{figure*}}

\newenvironment{indpar}[1][0.3in]%
	{\begin{list}{}%
		     {\setlength{\itemsep}{0in}%
		      \setlength{\topsep}{0in}%
		      \setlength{\parsep}{1ex}%
		      \setlength{\labelwidth}{#1}%
		      \setlength{\leftmargin}{#1}%
		      \addtolength{\leftmargin}{\labelsep}}%
	 \item}%
	{\end{list}}

\begin{document}
        
\title{Personal\\Calculation and Simulation\\Language\\[2ex]PCASL\\[2ex]
       (Draft 1a)}

\author{Robert L. Walton\thanks{This document is was partly inspired
teaching courses at Suffolk University.}}

\date{August 03, 2003}
 
\maketitle

\tableofcontents 

\newpage

\section{Introduction}

This document describes PCASL, the Personal Calculation and Simulation
Language, that is informally referred to as P-Castle, Personal Castle, or just
Castle.

PCASL is designed for naive programmers: that is, for people who may never
be able to program computers well.  It is a simple language that has
powerful data types which make it easier to write small programs
that do a variety of tasks that a person might want to do.  Generally
the tasks fall into the categories of calculating things (taxes,
probabilities, statistics) or simulating things
(computer games, construction designs, mathematics demonstrations).
Included are:

\begin{center}
\begin{tabular}{l}
Calculations that might be done with a spreadsheet. \\
Drawing pictures. \\
Simulating popular board games and creating new ones. \\
Creating simple computer games, including dialog games. \\
Computing and analysing documents. \\
Doing elementary algebra and calculus problems. \\
Calculating basic probabilities and statistics. \\
Simulating two and three dimensional objects. \\
Simulating simple electrical, mechanical, chemical, and biological systems.\\
Solving problems in elementary logic. \\
\end{tabular}
\end{center}

There are many computer languages that have some powerful data type that adapts
them for a specific kind of computation.  PCASL tries to combine these.
Some previous computer languages that have influenced PCASL, and
the data types they particularly support, are:

\begin{center}
\begin{tabular}{l@{\hspace{0.5in}}l}
Various Spreadsheets		& Spreadsheets \\
Various Data Base Languages	& Data Bases \\
Matlab				& Matrices \\
Mathematica			& Expressions \\
TCL				& Character Strings and Lists \\
Lisp				& Words and Phrases \\
Prolog				& Logical Expressions \\
\end{tabular}
\end{center}

PCASL is \underline{not} designed to be a computer-efficient language.
It is designed to be person-efficient, and to do small calculations
rapidly enough with inexpensive modern computers.

\section{Data}

PCASL has two major kinds of data: expressions and blocks.  Numbers are
the simplest expressions.  More complex expressions are math
expressions or document expressions.  Blocks are sets of variables
each of which can have a value, which is an expression, and also
a definition, which is another expression that is used to compute the
value when the value is needed.  The definitions of a block, taken all
together, are called the `code' of the block.

You can use PCASL as a calculator by typing into it expressions to
be evaluated and assignments of values and definitions to variables.
Some examples involving numbers are:

\begin{indpar}\begin{verbatim}
> 9
9
> 9 + 8
17
> x = 9
9
> y = 9 + 8
17
> x + y
26
\end{verbatim}\end{indpar}

Here the `\verb|> |' at the beginning of some lines is the PCASL \key{prompt}
that tells you its OK to input an expression to be evaluated.

At somewhat the opposite extreme from numbers are words, phrases, sentences,
and paragraphs.  You can calculate with these `\skey{document expression}s' too:

\begin{indpar}
\verb|> g = `hello'| \\
\verb|`|hello\verb|'| \\
\verb|> `<g> there'| \\
\verb|`|hello there\verb|'| \\
\verb|> z = ``I thought he said `<g>'.''| \\
\verb|``|I thought he said `hello'.\verb|''| \\
\verb/> notice = ``|This document is meant to be read./ \\
\verb/+            |Reading this document is good, but.../ \\
\verb/+            |<z>.''/ \\
\verb|``|This document is meant to be read. \\
\verb|  |Reading this document is good, but\ldots \\
\verb|  |I thought he said `hello'.\verb|''| \\
\verb|> `When you add <x> and <y> you get <x+y>.'| \\
\verb|`|When you add 9 and 17 you get 26.\verb|'|
\end{indpar}

Modern math computes with expressions, and not just numbers.
You can compute with \skey{math expression}s in PCASL too:

\begin{indpar}
\verb|> f = [10x^2 - 3.67x - 0.04]| \\
\verb|[|$10x^2-3.67x-0.04$\verb|]| \\
\verb|> h = [- 0.96 + 0.67x]| \\
\verb|[|$-0.96+0.67x$\verb|]| \\
\verb|> f + h| \\
\verb|[|$10x^2-3x-1$\verb|]| \\
\verb|> solve [f + h = 0]| \\
\verb|[x = (-0.2, 0.5)]| \\
\verb|> evaluate [f + h] at [x = (3, 4, 5)]| \\
\verb|(78.95, 145.28, 231.61)| \\
\verb|> g = [integral (x^2 dx)]| \\
\verb|[|$\int x^2 dx$\verb|]| \\
\verb|> simplify g| \\
\verb|[|$\frac{1}{3} x^3$\verb|]| \\
\verb|> v = evaluate g from [x=1] to [x=5]| \\
\verb|41 1/3| \\
\verb|> out = `The value of <definite g from [x=1] to [x=5]> is <v>.'| \\
\verb|`|The value of $\int_{x=1}^{x=5} x^2 dx$ is $41\frac{1}{3}$.\verb|'| \\
\verb|> raw out| \\
\verb|[sentence [the value of [definite [integral [x^2*dx]]| \\
\verb|                                  from [x=1] to [x=5]] is 124/3]]|
\end{indpar}

Another kind of datum you can compute with in PCASL, which is
the \key{block}:

\begin{indpar}
\verb|> a person {| \\
\verb|+     name = `Jack'| \\
\verb|+     weight = 123 lb| \\
\verb|+     height = 5'9"| \\
\verb|+     age = 23 yr 2 mo }| \\
\begin{tabular}{|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
Jack & \tt 123 lb & \tt 5'9" & \tt 23 yr 2 mo \\
\hline
\end{tabular} \\
\verb|> a person {| \\
\verb|+     name = `Jill'| \\
\verb|+     weight = 110 lb| \\
\verb|+     height = 5'7"| \\
\verb|+     age = 21 yr 8 mo }| \\
\begin{tabular}{|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
Jill & \tt 110 lb & \tt 5'7" & \tt 21 yr 8 mo \\
\hline
\end{tabular} \\
\verb|> all persons| \\
\begin{tabular}{|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
Jack & \tt 123 lb & \tt 5'9" & \tt 23 yr 2 mo \\
Jill & \tt 110 lb & \tt 5'7" & \tt 21 yr 8 mo \\
\hline
\end{tabular} \\
\verb|> the person Jack| \\
\begin{tabular}{|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
Jack & \tt 123 lb & \tt 5'9" & \tt 23 yr 2 mo \\
\hline
\end{tabular} \\
\verb|> the person named Jack's height| \\
\verb|5'9"| \\
\verb|> the weight of the person named Jack| \\
\verb|123 lb|
\end{indpar}

It is possible to add code to a type such as `{\tt person}':

\begin{indpar}
\verb|> define (a person) {| \\
\verb|+     body-mass-index = 703.06958 * weight in lbs| \\
\verb|+                     / (height in inches)^2 }| \\
\verb|> all persons| \\
\begin{tabular}{|l|r|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} &
\multicolumn{1}{|c|}{\bf body-mass-index} \\
\hline
Jack & \tt 123 lb & \tt 5'9" & \tt 23 yr 2 mo & \tt 18.163738 \\
Jill & \tt 110 lb & \tt 5'7" & \tt 21 yr 8 mo & \tt 17.228258 \\
\hline
\end{tabular}
\end{indpar}

One can use definitions to define expressions that compute values:

\begin{indpar}
\verb|> define (the sum from X through Y)| \\
\verb|+         -: integer X, integer Y {| \\
\verb|+     # Sum of integers from X through Y.| \\
\verb|+     if ( X > Y ):| \\
\verb|+         value = 0| \\
\verb|+     else:| \\
\verb|+         value = X + sum (X+1) through Y }| \\
\verb|> the sum from 5 through 10| \\
\verb|45| \\
\verb|> all sums from X through Y| \\
\begin{tabular}{|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf X} &
\multicolumn{1}{|c}{\bf Y} &
\multicolumn{1}{|c|}{\bf value} \\
\hline
\tt 5	& \tt	10	& \tt 45 \\
\tt 6	& \tt	10	& \tt 40 \\
\tt 7	& \tt	10	& \tt 34 \\
\tt 8	& \tt	10	& \tt 27 \\
\tt 9	& \tt	10	& \tt 19 \\
\tt 10	& \tt	10	& \tt 10 \\
\tt 11	& \tt	10	& \tt 0 \\
\hline
\end{tabular} \\
\verb|> the sum from 1 through 2| \\
\verb|3| \\
\verb|> all sums from X through Y| \\
\begin{tabular}{|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf X} &
\multicolumn{1}{|c}{\bf Y} &
\multicolumn{1}{|c|}{\bf value} \\
\hline
\tt 5	& \tt	10	& \tt 45 \\
\tt 6	& \tt	10	& \tt 40 \\
\tt 7	& \tt	10	& \tt 34 \\
\tt 8	& \tt	10	& \tt 27 \\
\tt 9	& \tt	10	& \tt 19 \\
\tt 10	& \tt	10	& \tt 10 \\
\tt 11	& \tt	10	& \tt 0 \\
\tt 1	& \tt	2	& \tt 3 \\
\tt 2	& \tt	2	& \tt 2 \\
\tt 3	& \tt	2	& \tt 0 \\
\hline
\end{tabular}
\end{indpar}

Executions can be examined in detail because
when an expression is computed, the block that computes it is remembered
for some time.  However, as memory is finite, eventually these
computations are forgotten.

The sum above was computed by recursion: to compute the sum of 5 through 10
one computes the sum of 6 through 10.  One can also compute sums by
iteration:

\begin{indpar}
\verb|> define (the sum from X through Y)| \\
\verb|+         -: integer X, integer Y {| \\
\verb|+     # Sum of integers from X through Y.| \\
\verb|+     first sum = 0| \\
\verb|+     if ( X <= Y ):| \\
\verb|+         next sum = sum + X| \\
\verb|+         next X = X + 1| \\
\verb|+     else:| \\
\verb|+         value = sum| \\
\verb|+     next Y = Y }| \\
\verb|> the sum from 5 through 10| \\
\verb|45| \\
\verb|> all sums from X through Y| \\
\begin{tabular}{|r|r|r|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf X} &
\multicolumn{1}{|c}{\bf Y} &
\multicolumn{1}{|c}{\bf sum} &
\multicolumn{1}{|c}{\bf next X} &
\multicolumn{1}{|c}{\bf next sum} &
\multicolumn{1}{|c|}{\bf value} \\
\hline
\tt 5	& \tt 10	& \tt 0		& \tt 6		& \tt 5		& \\
\tt 6	& \tt 10	& \tt 5		& \tt 7		& \tt 11	& \\
\tt 7	& \tt 10	& \tt 11	& \tt 8		& \tt 18	& \\
\tt 8	& \tt 10	& \tt 18	& \tt 9		& \tt 26	& \\
\tt 9	& \tt 10	& \tt 26	& \tt 10	& \tt 35	& \\
\tt 10	& \tt 10	& \tt 35	& \tt 11	& \tt 45	& \\
\tt 11	& \tt 10	& \tt 45	& 		& 		& \tt 45 \\
\hline
\end{tabular}
\end{indpar}

One can also iterate over data.

\begin{indpar}
\verb|> define (the average weight of X)| \\
\verb|+         -: tuple X of persons {| \\
\verb|+     first count = 0| \\
\verb|+     first sum = 0| \\
\verb|+     if X = ():| \\
\verb|+         if count = 0:| \\
\verb|+             value = error `Cannot average 0 things.'| \\
\verb|+         else:| \\
\verb|+             value = sum / count| \\
\verb|+     else:| \\
\verb|+         next count = count + 1| \\
\verb|+         next sum = sum + the weight of (first X)| \\
\verb|+         next X = rest X }| \\
\verb|> the average weight of (all persons)| \\
\verb|116.5 lbs|
\end{indpar}

In case you wonder how some of the above works, here are some hints.

PCASL tends to ignore word endings: thus `{\tt person}' and
`{\tt persons}' are to PCASL the same word.
PCASL can even be told that `{\tt person}'
and `{\tt people}' are the same word.
`{\tt Jack's}', on the other hand, is treated an abbreviation
of two separate words `{\tt Jack 's}', where `{\tt 's}' is
a separate word by itself.

Expressions are just strings of words and subexpressions.  Subexpressions
must be parenthesized unless they consist of a single word, or unless
they are delimited by operators.

Lists of values can be stored in tuples, which are computed by comma
separted lists in parentheses.  Thus

\begin{indpar}
\verb|> (the person named Jill, the person named Jack)| \\
\begin{tabular}{|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
Jill & \tt 110 lb & \tt 5'7" & \tt 21 yr 8 mo \\
Jack & \tt 123 lb & \tt 5'9" & \tt 23 yr 2 mo \\
\hline
\end{tabular} \\
\verb|> (the person named Jack, the person named Jill)| \\
\begin{tabular}{|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
Jack & \tt 123 lb & \tt 5'9" & \tt 23 yr 2 mo \\
Jill & \tt 110 lb & \tt 5'7" & \tt 21 yr 8 mo \\
\hline
\end{tabular} \\
\verb|> raw (all persons)| \\
\verb|(the person named Jack, the person named Jill)|
\end{indpar}

The `{\tt raw}' form of a value is a form that prints as you could
input it in a way that reveals its internal structure.  Thus
`{\tt all persons}' denotes the tuple of all persons.

`{\tt the person named Jack}' is a printed representation of the
internal name of a block.  Such printed representations are chosen
automatically from the set of all possible representations, which
in this case include `{\tt the person weighing 123}' and
`{\tt the person named Jack weighing 123}'.

A single non-tuple value is equivalent to a tuple with one element.
Tuples cannot have other tuples as elements; instead attempts to
compute such tuples are \key{flattened}:

\begin{indpar}
\verb|> x = (1,(2,3),4)| \\
\verb|(1,2,3,4)| \\
\verb|> first x| \\
\verb|1| \\
\verb|> rest x| \\
\verb|(2,3,4)| \\
\verb|> rest (rest x)| \\
\verb|(3,4)| \\
\verb|> rest (rest (rest x))| \\
\verb|3| \\
\verb|> rest 9| \\
\verb|()|
\end{indpar}

\newpage

In addition to the above PCASL also supports pictorial data.

\begin{indpar}
\verb|> x = [circle 0.4]| \\
\begin{picture}(0.4,0.4)
\put(0.2,0.2){\circle{0.4}}
\end{picture} \\
\verb|> x = [rectangle (0.4,0.2)]| \\
\begin{picture}(0.4,0.2)
\put(0,0){\framebox(0.4,0.2){}}
\end{picture}
\end{indpar}


\section{Rules}

These are some detailed design rules to be incorporated in the language
definition later.

\begin{list}{}{}

\item
{\bf Quotes}.  \verb|`'| are word, phrase, sentence, paragraph quotes.
\verb|[]| are math expression quotes.   Quotes are in left-right pairs
and can be nested.

\item
{\bf Multiple Quotes}.  Quotes can be multiplied $N$ times: e.g.,
\verb|[[...]]|, \verb|[[[...]]]|, etc.  It is possible to begin a quoted
phrase with a quoted phrase by following the initial $N$-left-quote by
space.  E.g., \verb|`` `Hello' 'tis a good word.''|.

\item
{\bf Algebraic Expressions}.
An expression may or may not be algebraic.  Algebraic expressions have
operators that determine structure.  Atoms in these are sequences of
words, numbers, and parenthesized or bracketted subexpressions.

\item
{\bf N-tuples and Flatening}.
The comma operator forms N-tuples, e.g., \verb|(x,y,z)| is a 3-tuple.

Tuples flatten.  It is not possible for a tuple to be a component of
a tuple: instead the tuples are flattened.  E.g., \verb|(x,(y,z),w)|
is the same value as \verb|(x,y,z,w)|.  There is no such thing as a
1-tuple, but any non-tuple behaves like a 1-tuple.

\item
{\bf Blank Algebraic Operators}.
The blank, or missing operator, denotes \verb|*| when it precedes a word,
as in \verb|5x| being equivalent to \verb|5*x|.  When it is between a
preceding integer and a following ratio, it adds the ratio to the integer,
as in \verb|41 1/3|.

\end{list}



\bibliographystyle{plain}
\bibliography{pcasl}

\printindex

\end{document}

