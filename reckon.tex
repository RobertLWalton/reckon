% Personal Calculation and Simulation Langauge (PCASL)
%
% File:         pcasl.tex
% Author:       Bob Walton (walton@deas.harvard.edu)
% Date:		See \date below.
  
\documentclass[12pt]{article}

\usepackage{makeidx}

\makeindex

\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}
\raggedbottom

\setlength{\unitlength}{1in}

\pagestyle{headings}
\setlength{\parindent}{0.0in}
\setlength{\parskip}{1ex}

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}
\newcommand{\subsubsubsection}[1]{\paragraph[#1]{#1.}}
\newcommand{\subsubsubsubsection}[1]{\subparagraph[#1]{#1.}}

% Begin \tableofcontents surgery.

\newcount\ATCATCODE
\ATCATCODE=\catcode`@
\catcode `@=11	% @ is now a letter

\renewcommand{\contentsname}{}
\renewcommand\l@section{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\l@table{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\tableofcontents{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}}%
    \item\@starttoc{toc}%
    \end{list}}
\renewcommand\listoftables{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}%
	      }%
    \item\@starttoc{lot}%
    \end{list}}

\catcode `@=\ATCATCODE	% @ is now restored

% End \tableofcontents surgery.

\newcommand{\CN}[2]%	Change Notice.
    {\hspace*{0in}\marginpar{\sloppy \raggedright \it \footnotesize
     $^{\mbox{#1}}$#2}}
    % Change notice.

\newcommand{\key}[1]{{\em #1}\index{#1}}
\newcommand{\mkey}[2]{{\em #1}\index{#1!#2}}
\newcommand{\skey}[2]{{\em #1#2}\index{#1}}
\newcommand{\ikey}[2]{{\em #1}\index{#2}}
\newcommand{\ttkey}[1]{{\tt #1}\index{#1@{\tt #1}}}
\newcommand{\ttmkey}[2]{{\tt #1}\index{#1@{\tt #1}!#2}}
\newcommand{\ttfkey}[2]{{\tt #1}\index{#1@{\tt #1}!for #2@for {\tt #2}}}
\newcommand{\ttakey}[2]{{\tt #1}\index{#2@{\tt #1}}}
\newcommand{\ttamkey}[3]{{\tt #1}\index{#2@{\tt #1}!#3}}
\newcommand{\ttindex}[1]{\index{#1@{\tt #1}}}
\newcommand{\ttmindex}[2]{\index{#1@{\tt #1}!#2}}
\newcommand{\emkey}[1]{{\em #1}\index{#1@{\em #1}}}
\newcommand{\emindex}[1]{\index{#1@{\em #1}}}

\newcommand{\EOL}{\penalty \exhyphenpenalty}

\newsavebox{\leftbracket}
\begin{lrbox}{\leftbracket}
\verb|{|
\end{lrbox}

\newsavebox{\rightbracket}
\begin{lrbox}{\rightbracket}
\verb|}|
\end{lrbox}

\newcommand{\ttbrackets}{
    \renewcommand{\{}{\usebox{\leftbracket}}
    \renewcommand{\}}{\usebox{\rightbracket}}}

\newlength{\figurewidth}
\setlength{\figurewidth}{\textwidth}
\addtolength{\figurewidth}{-0.40in}

\newsavebox{\figurebox}

\newenvironment{boxedfigure}[1][!btp]%
	{\begin{figure*}[#1]
	 \begin{lrbox}{\figurebox}
	 \begin{minipage}{\figurewidth}

	 \vspace*{1ex}}%
	{
	 \vspace*{1ex}

	 \end{minipage}
	 \end{lrbox}
	 \begin{center}
	 \fbox{\hspace*{0.1in}\usebox{\figurebox}\hspace*{0.1in}}
	 \end{center}
	 \end{figure*}}

\newenvironment{indpar}[1][0.3in]%
	{\begin{list}{}%
		     {\setlength{\itemsep}{0in}%
		      \setlength{\topsep}{0in}%
		      \setlength{\parsep}{1ex}%
		      \setlength{\labelwidth}{#1}%
		      \setlength{\leftmargin}{#1}%
		      \addtolength{\leftmargin}{\labelsep}}%
	 \item}%
	{\end{list}}

\begin{document}
        
\title{Personal\\Calculation and Simulation\\Language\\[2ex]PCASL\\[2ex]
       (Draft 1a)}

\author{Robert L. Walton\thanks{This document was partly inspired
by teaching courses at Suffolk University.}}

\date{November 5, 2003}
 
\maketitle

\tableofcontents 

\newpage

\section{Introduction}

This document describes PCASL, the Personal Calculation and Simulation
Language, that is informally referred to as P-Castle, Personal Castle, or just
Castle.

PCASL is designed for naive programmers: that is, for people who may never
be able to program computers well.  It is a simple language that has
powerful data types which make it easier to write small programs
that do a variety of tasks that a person might want to do.  Generally
the tasks fall into the categories of calculating things (taxes,
probabilities, statistics) or simulating things
(computer games, construction designs, mathematics demonstrations).
Included are:

\begin{center}
\begin{tabular}{l}
Calculations that might be done with a spreadsheet. \\
Drawing pictures. \\
Simulating popular board games and creating new ones. \\
Creating simple computer games, including dialog games. \\
Computing and analysing documents. \\
Doing elementary algebra and calculus problems. \\
Calculating basic probabilities and statistics. \\
Simulating two and three dimensional objects. \\
Simulating simple electrical, mechanical, chemical, and biological systems.\\
Solving problems in elementary logic. \\
\end{tabular}
\end{center}

There are many computer languages that have some powerful data type that adapts
them for a specific kind of computation.  PCASL tries to combine these.
Some previous computer languages that have influenced PCASL, and
the data types they particularly support, are:

\begin{center}
\begin{tabular}{l@{\hspace{0.5in}}l}
Various Spreadsheets		& Spreadsheets \\
Various Data Base Languages	& Data Bases \\
Matlab				& Matrices \\
Mathematica			& Expressions \\
TCL				& Character Strings and Lists \\
Lisp				& Words and Phrases \\
Prolog				& Logical Expressions \\
\end{tabular}
\end{center}

PCASL is \underline{not} designed to be a computer-efficient language.
It is designed to be person-efficient, and to do small calculations
rapidly enough with inexpensive modern computers.

\section{Remarks}

PCASL was created as an answer to the question: what programming language
should you teach beginning programming students who do not have the talent
or inclination to become good programmers?  The inital answer, that it does
not matter provided you implement some powerful types of data in the
language you choose, has a flaw.  The flaw is that without the right powerful
data types, the language will be useless to the students after the course
is over.  So what is needed is a programming language that will be useful
to students after a first course in programming, and the essence of
such a language is the integration within it of many powerful and useful
data types.

The current version of PCASL is not stable, because it has not been
implemented, and because, unlike most programming languages, PCASL
has lots of subtle interactions between its various features.  The
hope is that with implementation and experimentation, a stable sensible
version of PCASL integrating all its data types can be achieved.

\section{Data}

PCASL has two major kinds of data: expressions and blocks.  Numbers are
the simplest expressions.  More complex expressions are math
expressions or document expressions.  Blocks are sets of variables
each of which can have a value, which is an expression, and also
a definition, which is another expression that is used to compute the
value when the value is needed.  The definitions of a block, taken all
together, are called the `code' of the block.

You can use PCASL as a calculator by typing into it expressions to
be evaluated and assignments of values and definitions to variables.
Some examples involving numbers are:

\begin{indpar}\begin{verbatim}
> 9
9
> 9 + 8
17
> x = 9
9
> y = 9 + 8
17
> x + y
26
\end{verbatim}\end{indpar}

Here the `\verb|> |' at the beginning of some lines is the PCASL \key{prompt}
that tells you its OK to input an expression to be evaluated.

At somewhat the opposite extreme from numbers are words, phrases, sentences,
and paragraphs.  You can calculate with these `\skey{document expression}s'.

\begin{indpar}
\verb|> g = `hello'| \\
\verb|`|hello\verb|'| \\
\verb|> `<<g>> there'| \\
\verb|`|hello there\verb|'| \\
\verb|> z = ``I thought he said `<<g>>'.''| \\
\verb|``|I thought he said `hello'.\verb|''| \\
\verb/> notice = ``|This document is meant to be read./ \\
\verb/+            |Reading this document is good, but.../ \\
\verb/+            |<<z>>.''/ \\
\verb|``|This document is meant to be read. \\
\verb|  |Reading this document is good, but\ldots \\
\verb|  |I thought he said `hello'.\verb|''| \\
\verb|> `When you add <<x>> and <<y>> you get <<x+y>>.'| \\
\verb|`|When you add 9 and 17 you get 26.\verb|'|
\end{indpar}

Modern math computes with expressions, and not just numbers.
You can compute with \skey{math expression}s in PCASL.

\begin{indpar}
\verb|> f = {10x^2 - 3.67x - 0.04}| \\
\verb|{|$10x^2-3.67x-0.04$\verb|}| \\
\verb|> h = (- 0.96 + 0.67x) in x| \\
\verb|{|$-0.96+0.67x$\verb|}| \\
\verb|> (f + h) in x| \\
\verb|{|$10x^2-3x-1$\verb|}| \\
\verb|> solve (f + h = 0) for x| \\
\verb|{|$x = (-0.2, 0.5)$\verb|}| \\
\verb|> (f + h) at (x = (3, 4, 5))| \\
\verb|(78.95, 145.28, 231.61)| \\
\verb|> g = {integral (x^2 dx)}| \\
\verb|{|$\int x^2 dx$\verb|}| \\
\verb|> simplify g| \\
\verb|{|$\frac{1}{3} x^3$\verb|}| \\
\verb|> v = g from (x=1) to (x=5)| \\
\verb|41 1/3| \\
\verb|> out = `The value of {<<g>> from (x=1) to (x=5)} is <<v>>.'| \\
\verb|`|The value of $\int_{x=1}^{x=5} x^2 dx$ is $41\frac{1}{3}$.\verb|'| \\
\verb|> raw out| \\
\verb|[sentence the value of {(integral (x^2*dx)) from (x=1) to (x=5)}| \\
\verb|          is 124/3]|
\end{indpar}

Another kind of datum you can compute with in PCASL is
the \key{block}:

\begin{indpar}
\verb|> a person {| \\
\verb|+     name = `Jack'| \\
\verb|+     weight = 123 lb| \\
\verb|+     height = 5'9"| \\
\verb|+     age = 23 yr 2 mo }| \\
\begin{tabular}{|r|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000000 & Jack & \tt 123 lb & \tt 5'9" & \tt 23 yr 2 mo \\
\hline
\end{tabular} \\
\verb|> a person {| \\
\verb|+     name = `Jill'| \\
\verb|+     weight = 110 lb| \\
\verb|+     height = 5'7"| \\
\verb|+     age = 21 yr 8 mo }| \\
\begin{tabular}{|r|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000001 & Jill & \tt 110 lb & \tt 5'7" & \tt 21 yr 8 mo \\
\hline
\end{tabular} \\
\verb|> all persons| \\
\begin{tabular}{|r|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000000 & Jack & \tt 123 lb & \tt 5'9" & \tt 23 yr 2 mo \\
\tt @1000001 & Jill & \tt 110 lb & \tt 5'7" & \tt 21 yr 8 mo \\
\hline
\end{tabular} \\
\verb|> the person Jack| \\
\begin{tabular}{|r|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000000 & Jack & \tt 123 lb & \tt 5'9" & \tt 23 yr 2 mo \\
\hline
\end{tabular} \\
\verb|> the person named Jack's height| \\
\verb|5'9"| \\
\verb|> the weight of the person named Jack| \\
\verb|123 lb| \\
\verb|> @1000001| \\
\begin{tabular}{|r|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000001 & Jill & \tt 110 lb & \tt 5'7" & \tt 21 yr 8 mo \\
\hline
\end{tabular} \\
\verb|> the weight of @1000001| \\
\verb|110 lb|
\end{indpar}

It is possible to add code to a type such as `{\tt person}':

\begin{indpar}
\verb|> a person <-- {| \\
\verb|+     body-mass-index = 703.06958 * weight in lbs| \\
\verb|+                     / (height in inches)^2 }| \\
\verb|> all persons| \\
\begin{tabular}{|r|l|r|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} &
\multicolumn{1}{|c|}{\bf \shortstack{body-mass-\\index}} \\
\hline
\tt @1000000 & Jack & \tt 123 lb & \tt 5'9" & \tt 23 yr 2 mo & \tt 18.163738 \\
\tt @1000001 & Jill & \tt 110 lb & \tt 5'7" & \tt 21 yr 8 mo & \tt 17.228258 \\
\hline
\end{tabular}
\end{indpar}

One can use definitions to define expressions that compute values:

\begin{indpar}
\verb|> sum from X through Y <-- integer X, integer Y {| \\
\verb|+     `Sum of integers from X through Y.'| \\
\verb|+     if ( X > Y ):| \\
\verb|+         value = 0| \\
\verb|+     else:| \\
\verb|+         value = X + sum (X+1) through Y }| \\
\verb|> sum from 5 through 10| \\
\verb|45| \\
\verb|> all (sums from X through Y)| \\
\begin{tabular}{|r|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf X} &
\multicolumn{1}{|c}{\bf Y} &
\multicolumn{1}{|c|}{\bf value} \\
\hline
\tt @1000002 & \tt 5	& \tt	10	& \tt 45 \\
\tt @1000003 & \tt 6	& \tt	10	& \tt 40 \\
\tt @1000004 & \tt 7	& \tt	10	& \tt 34 \\
\tt @1000005 & \tt 8	& \tt	10	& \tt 27 \\
\tt @1000006 & \tt 9	& \tt	10	& \tt 19 \\
\tt @1000007 & \tt 10	& \tt	10	& \tt 10 \\
\tt @1000008 & \tt 11	& \tt	10	& \tt 0 \\
\hline
\end{tabular} \\
\verb|> sum from 1 through 2| \\
\verb|3| \\
\verb|> all (sums from X through Y)| \\
\begin{tabular}{|r|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf X} &
\multicolumn{1}{|c}{\bf Y} &
\multicolumn{1}{|c|}{\bf value} \\
\hline
\tt @1000002 & \tt 5	& \tt	10	& \tt 45 \\
\tt @1000003 & \tt 6	& \tt	10	& \tt 40 \\
\tt @1000004 & \tt 7	& \tt	10	& \tt 34 \\
\tt @1000005 & \tt 8	& \tt	10	& \tt 27 \\
\tt @1000006 & \tt 9	& \tt	10	& \tt 19 \\
\tt @1000007 & \tt 10	& \tt	10	& \tt 10 \\
\tt @1000008 & \tt 11	& \tt	10	& \tt 0 \\
\tt @1000009 & \tt 1	& \tt	2	& \tt 3 \\
\tt @1000010 & \tt 2	& \tt	2	& \tt 2 \\
\tt @1000011 & \tt 3	& \tt	2	& \tt 0 \\
\hline
\end{tabular}
\end{indpar}

Executions can be examined in detail because
when an expression is computed, the block that computes it is remembered
for some time.  However, as memory is finite, eventually these
computations are forgotten as they can always be regenerated if
needed.

The sum above was computed by recursion: to compute the sum of 5 through 10
one computes the sum of 6 through 10.  One can also compute sums by
iteration.

\begin{indpar}
\verb|> sum from X through Y <-- integer X, integer Y {| \\
\verb|+     `Sum of integers from X through Y.'| \\
\verb|+     first sum = 0| \\
\verb|+     if ( X <= Y ):| \\
\verb|+         next sum = sum + X| \\
\verb|+         next X = X + 1| \\
\verb|+     else:| \\
\verb|+         value = sum }| \\
\verb|> sum from 5 through 10| \\
\verb|45| \\
\verb|> all (sums from 5 through 10)| \\
\begin{tabular}{|r|r|r|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf previous} &
\multicolumn{1}{|c}{\bf X} &
\multicolumn{1}{|c}{\bf Y} &
\multicolumn{1}{|c}{\bf sum} &
\multicolumn{1}{|c|}{\bf value} \\
\hline
\tt @1000012 &              & \tt 5	& \tt 10   & \tt 0	& \\
\tt @1000013 & \tt @1000012 & \tt 6	& \tt 10   & \tt 5	& \\
\tt @1000014 & \tt @1000013 & \tt 7	& \tt 10   & \tt 11	& \\
\tt @1000015 & \tt @1000014 & \tt 8	& \tt 10   & \tt 18	& \\
\tt @1000016 & \tt @1000015 & \tt 9	& \tt 10   & \tt 26	& \\
\tt @1000017 & \tt @1000016 & \tt 10	& \tt 10   & \tt 35	& \\
\tt @1000018 & \tt @1000017 & \tt 11	& \tt 10   & \tt 45	& \tt 45 \\
\hline
\end{tabular}
\end{indpar}

One can also iterate over data.

\begin{indpar}
\verb|> average weight of X <-- tuple X of persons {| \\
\verb|+     first count = 0| \\
\verb|+     first sum = 0| \\
\verb|+     if X = ():| \\
\verb|+         if count = 0:| \\
\verb|+             value = error `Cannot average 0 things.'| \\
\verb|+         else:| \\
\verb|+             value = sum / count| \\
\verb|+     else:| \\
\verb|+         next count = count + 1| \\
\verb|+         next sum = sum + the weight of (first X)| \\
\verb|+         next X = rest X }| \\
\verb|> average weight of (all persons)| \\
\verb|116.5 lbs|
\end{indpar}

In case you wonder how some of the above works, here are some hints.

PCASL tends to ignore word endings: thus `{\tt person}' and
`{\tt persons}' are to PCASL the same word.
PCASL can even be told that `{\tt person}'
and `{\tt people}' are the same word.
`{\tt Jack's}', on the other hand, is treated an abbreviation
of two separate words `{\tt Jack 's}', where `{\tt 's}' is
a separate word by itself.

Expressions are just strings of words and subexpressions.  Subexpressions
must be parenthesized unless they consist of a single word, or unless
they are delimited by operators.

Lists of values can be stored in tuples, which are computed by comma
separted lists in parentheses.  Thus

\begin{indpar}
\verb|> (the person named Jill, the person named Jack)| \\
\begin{tabular}{|r|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000001 & Jill & \tt 110 lb & \tt 5'7" & \tt 21 yr 8 mo \\
\tt @1000000 & Jack & \tt 123 lb & \tt 5'9" & \tt 23 yr 2 mo \\
\hline
\end{tabular} \\
\verb|> (the person named Jack, the person named Jill)| \\
\begin{tabular}{|r|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000000 & Jack & \tt 123 lb & \tt 5'9" & \tt 23 yr 2 mo \\
\tt @1000001 & Jill & \tt 110 lb & \tt 5'7" & \tt 21 yr 8 mo \\
\hline
\end{tabular} \\
\verb|> raw (all persons)| \\
\verb|(the person named Jack, the person named Jill)|
\end{indpar}

The `{\tt raw}' form of a value is a form that prints as you could
input it in a way that reveals its internal structure.  Thus
`{\tt all persons}' denotes the tuple of all persons.

`{\tt the person named Jack}' is a printed representation of the
internal name of a block.  Such printed representations are chosen
automatically from the set of all possible representations, which
in this case include `{\tt the person weighing 123}' and
`{\tt the person named Jack weighing 123}'.

A single non-tuple value is equivalent to a tuple with one element.
Tuples cannot have other tuples as elements; instead attempts to
compute such tuples are \key{flattened}:

\begin{indpar}
\verb|> x = (1,(2,3),4)| \\
\verb|(1,2,3,4)| \\
\verb|> first x| \\
\verb|1| \\
\verb|> rest x| \\
\verb|(2,3,4)| \\
\verb|> rest (rest x)| \\
\verb|(3,4)| \\
\verb|> rest (rest (rest x))| \\
\verb|3| \\
\verb|> rest 9| \\
\verb|()|
\end{indpar}

PCASL has many different kinds of quotes or brackets.  Some of these,
\verb|{...}|, \verb|`...'|, and \verb|[...]|, turn evalution off,
while \verb|<<...>>| turns evaluation on.  Some,
\verb|`...'| and \verb|[...]|, turn recognition of operators (e.g., \verb|+|
and \verb|=|) off, while others,
\verb|{...}| and \verb|<<...>>|, turn recognition of operators on.
\verb|`...'| (and \verb|``...''|, \verb|```...'''|, etc.), also do other
things, like insert implicit operations (e.g., \verb|sentence|).

PCASL stores information as expressions.  For example:

\begin{indpar}
\verb|> (a person named `Jack') is husband of (a person named `Jill') <--| \\
\verb|> Y is wife of X <-- X is husband of Y| \\
\verb|> (a person named `Jill') is wife of (a person named `Jack') ?| \\
\verb|true| \\
\verb|> (a person named `Jack') is wife of (a person named `Jill') ?| \\
\verb|false| \\
\verb|> (a person named X) is wife of (a person named `Jack') ?| \\
\verb|X = `|Jill\verb|'| \\
\verb|> X is wife of (a person named `Jack') ?| \\
\verb|X = (a person named `Jill')| \\
\verb|> @1000001 is wife of (a person named `Jack') ?| \\
\verb|true| \\
\verb|> @1000001 = (a person named `Jill') ?| \\
\verb|true| \\
\verb|> @1000001 = (a person named `Jack') ?| \\
\verb|false|
\end{indpar}

PCASL also supports pictorial data
that are computed like expressions.

\begin{indpar}
\verb|> x = {circle 0.4}| \\
\begin{picture}(0.4,0.4)
\put(0.2,0.2){\circle{0.4}}
\end{picture} \\
\verb|> y = {rectangle (0.4,0.2)}| \\
\begin{picture}(0.4,0.2)
\put(0,0){\framebox(0.4,0.2){}}
\end{picture} \\
\verb|> z = {(circle 0.4) labeled `Jack'}| \\
\begin{picture}(0.4,0.4)
\put(0.2,0.2){\circle{0.4}}
\put(0.0,0.0){\makebox(0.4,0.4){Jack}}
\end{picture} \\
\verb|> {(<<x>> right of <<y>>) above <<z>>}| \\
\begin{picture}(0.8,0.8)
\put(0.6,0.6){\circle{0.4}}
\put(0.0,0.5){\framebox(0.4,0.2){}}
\put(0.4,0.2){\circle{0.4}}
\put(0.2,0.0){\makebox(0.4,0.4){Jack}}
\end{picture} \\
\verb|> {row(<<x>>,<<y>>,<<z>>)}| \\
\begin{picture}(1.4,0.4)
\put(0.2,0.2){\circle{0.4}}
\put(0.5,0.1){\framebox(0.4,0.2){}}
\put(1.2,0.2){\circle{0.4}}
\put(1.0,0.0){\makebox(0.4,0.4){Jack}}
\end{picture} \\
\verb|> p = {column (row(<<x>>,<<y>>,<<z>>), row(<<z>>,<<y>>,<<x>>))}| \\
\begin{picture}(1.4,0.9)
\put(0.2,0.7){\circle{0.4}}
\put(0.5,0.6){\framebox(0.4,0.2){}}
\put(1.2,0.7){\circle{0.4}}
\put(1.0,0.5){\makebox(0.4,0.4){Jack}}
\put(1.2,0.2){\circle{0.4}}
\put(0.5,0.1){\framebox(0.4,0.2){}}
\put(0.2,0.2){\circle{0.4}}
\put(0.0,0.0){\makebox(0.4,0.4){Jack}}
\end{picture} \\
\verb|> raw x| \\
\verb|{circle 0.4}| \\
\verb|> raw p| \\
\verb|{column (row (circle 0.4,| \\
\verb|              rectangle (0.4,0.2),| \\
\verb|              (circle 0.4) labeled `Jack'),| \\
\verb|         row ((circle 0.4) labeled `Jack',| \\
\verb|              rectangle (0.4,0.2),| \\
\verb|              circle 0.4))}|
\end{indpar}

You can also change how an expression is displayed.

\begin{indpar}
\newlength{\ovalraise}
\setlength{\ovalraise}{-0.1in}
\addtolength{\ovalraise}{0.8ex}
\verb|> display (a person named X) as ((oval (0.4,0.2)) labelled X) <--| \\
\verb|> (a person named `Jack')| \\
\begin{picture}(0.4,0.2)
\put(0.2,0.1){\oval(0.4,0.2)}
\put(0.0,0.0){\makebox(0.4,0.2){Jack}}
\end{picture} \\
\verb|> ``(a person named `Jill') is wife of (a person named `Jack')''| \\
\verb|``|
\raisebox{\ovalraise}{\begin{picture}(0.4,0.2)
\put(0.2,0.1){\oval(0.4,0.2)}
\put(0.0,0.0){\makebox(0.4,0.2){Jill}}
\end{picture}}
{is the wife of}
\raisebox{\ovalraise}{\begin{picture}(0.4,0.2)
\put(0.2,0.1){\oval(0.4,0.2)}
\put(0.0,0.0){\makebox(0.4,0.2){Jack}}
\end{picture}}
\verb|''|
\end{indpar}

TBD: example of a simple game.


\section{Lexemes}

A PCASL program is a sequence of characters which is scanned from
left to right to produce a sequence of pre-lexemes.  The sequence
of pre-lexemes is then scanned from left to right to produce
a sequence of lexemes.

\subsection{Pre-Lexemes}

Pre-lexemes are defined as follows:

\begin{indpar}
\key{pre-lexeme}
	\begin{tabular}[t]{rl}
	::= & \key{pre-word} \\
	$|$ & \key{opening-mark} \\
	$|$ & \key{closing-mark} \\
	$|$ & \key{format-separator} \\
	$|$ & \key{white-space}
	\end{tabular}
	\\[1ex]
\key{pre-word} ::= {\em word-character} {\em word-character}$^\star$ \\[1ex]
\key{word-character} \begin{tabular}[t]{rl}
                       ::= & {\em letter} $|$ {\em digit} \\
		       $|$ &    \verb|+|%
		             $|$\verb|-|%
		             $|$\verb|*|%
		             $|$\verb|/|%
		             $|$\verb|\|%
		             $|$\verb|~|%
		             $|$\verb|@|%
		             $|$\verb|#|%
		             $|$\verb|$|%
		             $|$\verb|%|%
		             $|$\verb|^|%
		             $|$\verb|&|%
		             $|$\verb|=|%
		             $|$\verb/|/%
		             $|$\verb|<|%
		             $|$\verb|>|%
		             $|$\verb|_|%
		             $|$\verb|"|%
		             $|$\verb|`|%
		             $|$\verb|'|%
		             $|$\verb|!|%
		             $|$\verb|?|%
			     $|$\verb|;|%
			     $|$\verb|:|%
			     $|$\verb|,|%
		             $|$\verb|.|
			\end{tabular}\\[1ex]
\key{letter} ::= {\em lower-case-letter} $|$ {\em upper-case-letter} \\[1ex]
\key{lower-case-letter} ::=    \verb|a|%
			    $|$\verb|b|%
			    $|$\verb|c|%
			    $|$\verb|d|%
			    $|$\verb|e|%
			    $|$\verb|f|%
			    $|$\verb|g|%
			    $|$\verb|h|%
			    $|$\verb|i|%
			    $|$\verb|j|%
			    $|$\verb|k|%
			    $|$\verb|l|%
			    $|$\verb|m|%
			    $|$\verb|n|%
			    $|$\verb|o|%
			    $|$\verb|p|%
			    $|$\verb|q|%
			    $|$\verb|r|%
			    $|$\verb|s|%
			    $|$\verb|t|%
			    $|$\verb|u|%
			    $|$\verb|v|%
			    $|$\verb|w|%
			    $|$\verb|x|%
			    $|$\verb|y|%
			    $|$\verb|z|
			    \\[1ex]
\key{upper-case-letter} ::=    \verb|A|%
			    $|$\verb|B|%
			    $|$\verb|C|%
			    $|$\verb|D|%
			    $|$\verb|E|%
			    $|$\verb|F|%
			    $|$\verb|G|%
			    $|$\verb|H|%
			    $|$\verb|I|%
			    $|$\verb|J|%
			    $|$\verb|K|%
			    $|$\verb|L|%
			    $|$\verb|M|%
			    $|$\verb|N|%
			    $|$\verb|O|%
			    $|$\verb|p|%
			    $|$\verb|Q|%
			    $|$\verb|R|%
			    $|$\verb|S|%
			    $|$\verb|T|%
			    $|$\verb|U|%
			    $|$\verb|V|%
			    $|$\verb|W|%
			    $|$\verb|X|%
			    $|$\verb|Y|%
			    $|$\verb|Z|
			    \\[1ex]
\key{digit} ::=    \verb|0|%
		$|$\verb|1|%
		$|$\verb|2|%
		$|$\verb|3|%
		$|$\verb|4|%
		$|$\verb|5|%
		$|$\verb|6|%
		$|$\verb|7|%
		$|$\verb|8|%
		$|$\verb|9|
		\\[1ex]
\key{opening-mark} ::=     \verb|(|
	       	       $|$ \verb|[|
	       	       $|$ \verb|{|
	       	       $|$ {\em opening-quote}
	       	       $|$ {\em opening-angle}
	       	       \\[1ex]
\key{closing-mark} ::=     \verb|)|
	       	       $|$ \verb|]|
	       	       $|$ \verb|}|
	       	       $|$ {\em closing-quote}
	       	       $|$ {\em closing-angle}
	       	       \\[1ex]
\key{opening-quote} \begin{tabular}[t]{rl}
		     ::= & {\em opening-quote-character}
		           {\em opening-quote-character}$^\star$ \\
		     \end{tabular}
		     \\[1ex]
\key{opening-quote-character} ::= \verb|`| \\[1ex]
\key{closing-quote} \begin{tabular}[t]{rl}
		     ::= & {\em closing-quote-character}
		           {\em closing-quote-character}$^\star$ \\
		     \end{tabular}
		     \\[1ex]
\key{closing-quote-character} ::= \verb|'| \\[1ex]
\key{quote} ::= {\em opening-quote} $|$ {\em closing-quote} \\[1ex]
\key{opening-angle} \begin{tabular}[t]{rl}
		     ::= & {\em opening-angle-character}
		           {\em opening-angle-character} \\
		         & {\em opening-angle-character}$^\star$ \\
		     \end{tabular}
		     \\[1ex]
\key{opening-angle-character} ::= \verb|<| \\[1ex]
\key{closing-angle} \begin{tabular}[t]{rl}
		     ::= & {\em closing-angle-character}
		           {\em closing-angle-character} \\
		         & {\em closing-angle-character}$^\star$ \\
		     \end{tabular}
		     \\[1ex]
\key{closing-angle-character} ::= \verb|>| \\[1ex]
\key{angle-character} ::= \verb|<| $|$ \verb|>| \\[1ex]
\key{opening-character} ::=     \verb|(|
		            $|$ \verb|[|
		            $|$ \verb|{|
		            $|$ \verb|`|
		            $|$ \verb|<|
			    \\[1ex]
\key{closing-character} ::=     \verb|)|
		            $|$ \verb|]|
		            $|$ \verb|}|
		            $|$ \verb|'|
		            $|$ \verb|>|
			    \\[1ex]
\key{format-separator} ::= {\em format-separator-character}
			   {\em format-separator-character}$^\star$ \\[1ex]
\key{format-separator-character} ::=    \verb\|\
				        \\[1ex]
\key{white-space} ::= {\em white-space-character}
                     {\em white-space-character}$^\star$ \\[1ex]
\key{white-space-character} ::=
    \key{horizontal-space-character} $|$ \key{vertical-space-character} \\[1ex]
\key{horizontal-space-character} ::=
    \key{space} $|$ \key{horizontal-tab} $|$ \key{carriage-return} \\[1ex]
\key{vertical-space-character} ::=
    \key{line-feed} $|$ \key{vertical-tab} $|$ \key{form-feed}
\end{indpar}


The following sections give rules involving pre-lexemes.

\subsubsection{Matching and Pre-Lexical Context}
\label{MATCHING}

{\em Opening-marks} and {\em closing-marks} are both pre-lexemes
and also lexemes.  Rules for matching pre-lexemes in a pre-lexeme
sequence are the same as rules for matching lexemes in a lexeme sequence.
Here we will state the rules for lexemes, and leave it to the reader
to reformulate them for pre-lexemes.

{\bf Lexeme Matching Rule.}\index{Lexeme Matching Rule}
An {\em opening-mark} with $N$ characters $C$
must have a matching {\em closing-mark} with $N$ characters each the
mirror of $C$.  Each {\em closing-mark} must match exactly one
{\em opening-mark} and the {\em opening-mark} must precede the
{\em closing-mark}.

Two lexemes are said to be \mkey{matched}{lexemes} if and only if
they are matched opening and closing marks.

{\bf Matched Lexeme Nesting Rule.}\index{Matched Lexeme Nesting Rule}
If one lexeme in a pair $P_2$ of matched lexemes is in between the
lexemes of another pair $P_1$ of matched lexemes, then both lexemes
in $P_2$ must be in between the lexemes of $P_1$.  In this case
$P_2$ is said to be \mkey{nested}{lexemes} inside of $P_1$.

During the scan a character $C$ is said to be in the
\key{lexical context} of a pair $P$ of matched lexemes
if and only if $C$ is between the matched lexemes of $P$,
and $C$ is neither part of or between any other pair of matched
lexemes that is nested inside of $P$.

For a sequence of pre-lexemes, \mkey{matched}{pre-lexemes} pre-lexemes
and \key{pre-lexical context} are defined as for a sequence of lexemes.

\subsubsection{Character Disambiguation Rules}

Several characters in pre-lexemes are ambiguous in the
pre-lexeme syntax equations.  The following rules disambiguate these
characters.

{\bf Opening Quote Rule.}\index{Opening Quote Rule}
An \key{opening-quote-character} must be preceeded by a
{\em white-space-character},
an {\em opening-character}, or a {\em format-separator-character}.
Otherwise it is a {\em word-character}.

{\bf Closing Quote Rule.}\index{Closing Quote Rule}
A \key{closing-quote-character} must be part of a sequence of
{\em closing-quote-characters} that is of exactly the right length to be the
matching pre-lexeme for the last previous unmatched {\em opening-mark},
which must be an {\em opening-quote}.
Otherwise the potential {\em closing-quote-character}
is a {\em word-character}.

{\bf Format Separator Rule.}\index{Format Separator Rule}
A {\em format-separator-character} must be in the pre-lexical context of
a pair of matched {\em quotes}.  Otherwise it is a {\em word-character}.

{\bf Angle Rule.}\index{Angle Rule}
An {\em angle-character} must be either preceded by or followed by a copy
of itself.  Otherwise it is a {\em word-character}.

Quote Examples:

\begin{indpar}[0.1in]
\begin{tabular}{@{}l@{\hspace*{0.3in}}l}
			& Pre-Lexeme Sequence		\\
Input String		& with {\em spaces} represented by \verb|_|'s \\[1ex]
\verb|I said `Hello'.|	& \tt I~~\verb|_|~~said~~\verb|_|~~`~~Hello~~'~~.	\\
\verb|Re`op 'tis.  But!|
			& \tt Re`op~~\verb|_|~~'tis.%
			  ~~\verb|__|~~But! \\
\verb|`Like 'tis'|	& \tt `~~Like~~\verb|_|~~'~~tis'	\\
\verb|``Like 'tis''|	& \tt ``~~Like~~\verb|_|~~'tis~~''	\\
\verb|`Like me''|	& \tt `~~Like~~\verb|_|~~me''		\\
\verb|`` `Hello' is a word.''|
			& \tt ``~~\verb|_|~~`~~Hello~~'~~\verb|_|~~is%
			  ~~\verb|_|~~a~~\verb|_|~~word.~~'' \\
\end{tabular}
\end{indpar}

Other rules of PCASL (\ref{LEXEMES})
limit the semantic content
of {\em white-space}, so that there is no problem putting
space between the \verb|``| and \verb|`| in the last example.

Angle and Format Separator Examples:

\begin{indpar}[0.1in]
\begin{tabular}{@{}l@{\hspace*{0.6in}}l}
			& Pre-Lexeme Sequence		\\
Input String		& with {\em spaces} represented by \verb|_|'s \\[1ex]
\verb|x <= y |		& \tt x \verb|_| \verb|<=| \verb|_| y	\\
\verb|x <<= y |		& \tt x \verb|_| \verb|<<| = \verb|_| y	\\
\verb/x = y|z/		& \tt x \verb|_| = \verb|_| \verb/y|z/ \\
\verb/x = `y|z'/	& \tt x \verb|_| = \verb|_|
                              \verb|`| y \verb/|/ z \verb|'| \\
\end{tabular}
\end{indpar}

\subsubsection{White Space Conversion}

A \key{white-space} lexeme does not have exactly the same characters
that were input to create it, unlike other pre-lexemes.  The
sequence of {\em white-space-characters} input to create a
{\em white-space} lexeme is modified as follows to create the lexeme:

{\bf Line End Spaces Rule.}\index{Line End Spaces Rule}
All {\em horizontal-space} characters preceeding a {\em vertical-space}
character are deleted.  Thus spaces at line ends are ignored.

{\bf Carriage Return Rule.}\index{Carriage Return Rule}
Each {\em carriage-return} and all {\em horizontal-spaces} preceding
it are deleted.  Thus the lexeme has no {\em carriage-returns}.

{\bf Horizontal Tab Rule.}\index{Horizontal Tab Rule}
Each {\em horizontal-tab} is replace by {\em spaces} assuming that
horizontal tab stops are set every 8 columns.
Thus the lexeme has no {\em horizontal-tabs}.

Note that these rules do \underline{not} alter the printed appearance
of the {\em white-space} lexeme.

After these rules are applied, a {\em white-space} lexeme consists of
only of {\em vertical-space-characters} followed by {\em space} characters.
{\em White-space} lexemes are only pre-lexemes; they are deleted
when pre-lexemes are converted to lexemes.  The rules that
form the lexeme sequence ensure that all
{\em vertical-space} characters are equivalent
(\ref{INDENTATION-LEXEMES}).


\subsection{Lexemes}
\label{LEXEMES}

The sequence of pre-lexemes is converted to a sequence of lexemes
according to the following rules, which we will describe in the
order given:

\begin{indpar}[1in]
Numbers \\
Post Separators \\
Indentation Lexemes
\end{indpar}

The syntax equations defining a lexeme are:

\begin{indpar}
\key{lexeme} ::= {\em word} $|$ {\em separator}
		$|$ {\em opening-mark}
		$|$ {\em closing-mark} \\[1ex]
\key{separator} ::= {\em format-separator}
		$|$ {\em post-separator} \\[1ex]
\key{indentation-lexeme} ::= \verb|;|
			 $|$ \verb|{|
			 $|$ \verb|}|
\end{indpar}

{\em Post-separators} are single characters removed from the
ends of {\em pre-words}.  A {\em Word} is what is left of
a {\em pre-word} after any {\em post-separators}
are removed from its end.
{\em Words} and {\em post-separators} are defined
below in \ref{POST-SEPARATORS}.


The {\em indentation-lexemes} are lexemes implied by indentation, and
are not distinguishable from explicit lexemes, namely the post-separator
\verb|;|, the {\em opening-mark} \verb|{|, and the {\em closing-mark}
\verb|}|.  They are defined below in
\ref{INDENTATION-LEXEMES}.

{\em White-space} pre-lexemes are used only to define indentation and
create {\em indentation-lexemes}.
Then {\em white-space} pre-lexemes are
discarded: they are not {\em lexemes}.

{\em Format-separators}, {\em opening-marks}, and {\em closing-marks}
are both pre-lexemes and lexemes.

\subsubsection{Number Lexemes}
\label{NUMBER-LEXEMES}

The rule for spliting a {\em pre-word} into a {\em word}
and a {\em separator} makes reference to {\em words} that are
{\em numbers}, saying that splitting is preferred if the {\em word}
resulting from the split is a {\em number}.  Some of the syntax equations
defining {\em numbers} are as follows.

\begin{indpar}
\key{number} ::= {\em real-number} $|$ {\em unit-number}
				   $|$ {\em complex-number} \\[1ex]
\key{real-number} ::= {\em unsigned-real-number}
                  $|$ {\em sign} {\em unsigned-real-number}
		      \\[1ex]
\key{sign} ::= \verb|+| $|$ \verb|-| \\[1ex]
\key{unsigned-real-number} ::= {\em unexponented-number}
		$|$ {\em unexponented-number} {\em exponent} \\[1ex]
\key{unexponented-number} ::= {\em decimal-number}
			  $|$ {\em decimal-ratio}
			  $|$ {\em radixed-number} \\[1ex]
\key{decimal-number} \begin{tabular}[t]{rl}
                     ::= & {\em decimal-natural} \\
		     $|$ & {\em decimal-natural} \verb|.|
		           {\em decimal-natural} \\
		     $|$ & \verb|.| {\em decimal-natural}
		     \end{tabular} \\[1ex]
\key{decimal-natural} ::= {\em decimal-digits}
		     $|$ {\em decimal-natural} \verb|,| {\em decimal-digits}
		     \\[1ex]
\key{decimal-digits} ::= {\em digit} {\em digit}$^\star$ \\[1ex]
\key{decimal-ratio} ::= {\em decimal-natural} \verb|/|
			{\em decimal-natural} \\[1ex]
\key{exponent} ::= {\em exponent-indicator}
		   {\em exponent-sign-and-digits} \\[1ex]
\key{exponent-indicator} ::= \verb|e| $|$ \verb|E| $|$ \verb|^| \\[1ex]
\key{exponent-sign-and-digits} ::= {\em decimal-digits}
			    $|$ {\em sign} {\em decimal-digits}
\end{indpar}

Real Decimal Number Examples:

\begin{indpar}[0.1in]
\tt
\begin{tabular}{l@{~~~~~}l@{~~~~~}l@{~~~~~}l@{~~~~~}l}
123	& -123		& +123		& 1,234		& -1,234,567 \\
123.0	& -.123		& +0.0		& +.000		& 1,234.987,654 \\
123e0	& -123e+2	& +123e-321	& 1,234e9	& -0.123,456e-3 \\
123E0	& -123E+2	& +123E-321	& -0.123,456e-3	& -1,234.567890	\\
1/2	& -3/4		& +1,234/5	& 1,234/5,432	& -53/000 \\
1,2	& 1.86,54	& .123,45,6	& 1,2345678	& 1.2345678,92
\end{tabular}
\end{indpar}

In a {\em decimal-number} the decimal point
must be followed by a digit.  Commas must be surrounded by digits,
and should be
every 3 digits from the decimal point, or every three digits
from the end if there is no decimal point.  If there is any comma at all,
there must be commas
every 3 digits, except that commas may be used in the integer part 
without any being used in the faction part.
Incorrect numbers of digits between commas will result in an
error when the lexeme is converted to a number,
but is \underline{not} an error of lexeme formation.  The last line of
examples above are therefore legal lexemes that will give errors when
converted to numbers.

Similarly there will be an error converting a {\em decimal-ratio} to a
number if the denominator equals zero, but the ratio will still be a legal
lexeme.  \verb|-53/000| is an example.

\ikey{Radixed-numbers}{radixed-number} permit binary, octal, or hexadecimal
radices to the used instead of decimal.  In fact, other number representation
schemes are permitted.

\begin{indpar}
\key{radixed-number}::= {\em radix-indicator}
		        \verb|`| {\em radixed-number-mark}
		        {\em radix-number-mark}$^\star$ \verb|'|
		        \\[1ex]
\key{radix-indicator} ::= {\em letter} {\em letter}$^\star$ \\[1ex]
\key{radixed-number-mark} ::= {\em digit} $|$ {\em letter}
                      $|$ \verb|.| $|$ \verb|,| $|$ {\em sign}
\end{indpar}

Radixed Number Examples:

\begin{indpar}[0.1in]
\tt
\begin{tabular}{l@{~~~~~}l@{~~~~~}l@{~~~~~}l}

B'10110100'	& O'77534201'	& D'19758'	& X'FE8A932B' \\
B'101101'e+2	& O'0.7753'e-5	& D'197.58'	& X'0.FE8A932B' \\
B'10,1101'	& O'12,3456'e-5	& D'0.123,5'	& X'FE8A,932B.7CCD,83' \\
\end{tabular}
\end{indpar}


The following {\em radix-indicators} are standard.

\begin{center}
\begin{tabular}{l@{~~~~~}l@{~~~~~}l@{~~~~~}l}
Radix	& Radix		 &			& Allowed Digits \\
Name	& Indicators     & Allowed Digits	& Between Commas \\[1ex]
binary	& \tt b~~~B	 & \tt 0 1		& 4 or 8 \\
octal	& \tt o~~~O	 & \tt 0 1 2 3 4 5 6 7	& 3 \\
decimal	& \tt d~~~D	 & \tt 0 1 2 3 4 5 6 7 8 9
						& 3 \\
hexadecimal
	& \tt x~~~X	 & \tt 0 1 2 3 4 5 6 7 8 9
						& 4 or 8 \\
	&		 & \tt a b c d e f A B C D E F
\end{tabular}
\end{center}

{\em Radixed-numbers} can be legal lexemes and still be unconvertable to
numbers because their {\em radix-indicators} are undefined, they
have digits not defined for the given {\em radix-indicator}, they
have too many decimal points, and so forth.  These errors are detected
when the lexemes are converted to numbers.  On the other hand, it
is possible to define non-standard converters for converting
{\em radixed-number} lexemes to numbers, and thereby increase the
space of number representations.


\ikey{Unit-numbers}{unit-number} are just {\em real-numbers} with a
{\em unit-indicator} prefixed or postfixed.

\begin{indpar}
\key{unit-number} ::= {\em pre-unit-indicator} {\em real-number}
		  $|$ {\em real-number} {\em post-unit-indicator} \\[1ex]
\key{pre-unit-indicator} ::= \verb|$| $|$ {\tt \pounds} \\[1ex]
\key{post-unit-indicator} ::= \verb|'| $|$ \verb|"| $|$ $^\circ$ \\[1ex]
\key{unit-indicator} ::= {\em pre-unit-indicator}
		     $|$ {\em post-unit-indicator}
\end{indpar}

However, unit numbers are not lexemes.

{\bf Unit Number Rule.}\index{Unit Number Rule}
If a {\em unit-number} is to be output as a {\em word} lexeme, then instead
the {\em unit-number} is split into two {\em word} lexemes, one of which
is the {\em real-number} part and the other of which is a 1-character
{\em word} consisting of the {\em unit-indicator}.

Unit Number Examples:

\begin{indpar}[0.1in]
\begin{tabular}{@{}l@{\hspace*{0.3in}}l}
Unit Number		& Lexeme Sequence	\\[1ex]
\tt \$5.71		& \tt \$~~5.71 \\
\tt \pounds -5.71	& \tt \pounds ~~-5.71 \\
\tt 15'			& \tt 15~~' \\
\tt -2.543e3"		& \tt -2.543e3~~" \\
\tt 72$^\circ$		& \tt 72~~$^\circ$ \\
\tt X'BE63'e-2$^\circ$	& \tt X'BE63'e-2~~$^\circ$
\end{tabular}
\end{indpar}

An {\em imaginary-number} is just a {\em real-number} with an
{\em imaginary-indicator}, e.g.~\verb|i|, post-fixed.  A
{\em complex-number} is just an {\em imaginary-number}
or a {\em real-number} followed by
a {\em sign} followed by an {\em imaginary-number}.

\begin{indpar}
\key{complex-number} ::= {\em imaginary-number}
		$|$ {\em real-number} {\em signed-imaginary-number} \\[1ex]
\key{imaginary-number} ::= {\em unsigned-imaginary-number}
		$|$ {\em signed-imaginary-number} \\[1ex]
\key{signed-imaginary-number} ::=
		{\em sign} {\em unsigned-imaginary-number} \\[1ex]
\key{unsigned-imaginary-number} ::=
		{\em unsigned-real-number} {\em imaginary-indicator} \\[1ex]
\key{imaginary-indicator} ::=     \verb|I|
			      $|$ \verb|i|
			      $|$ \verb|J|
			      $|$ \verb|j|
\end{indpar}

Complex Number Examples:

\begin{indpar}[0.1in]
\tt
\begin{tabular}{l@{~~~~~}l@{~~~~~}l}

3i		& +3j		& -X'FE90.34D2'I		\\
2+3i		& -3+3.345e10j	& 35-X'FE90.34D2'J		\\
\end{tabular}
\end{indpar}

\subsubsection{Post Separators}
\label{POST-SEPARATORS}

Informally, a post-separator is a 1-character separator that immediately
follows a word and could be part of that word.  Examples are the comma, period,
and the exclamation point.  There are two kinds of post separators:
weak and strong.  The Post Separator Rule
given below tells when a {\em pre-word} ending
in a {\em post-separator-character}
must be split into smaller {\em pre-word} and a 1-character
{\em separator}.  This rule makes reference to {\em words} that are
{\em numbers}, saying that splitting is preferred when the
{\em post-separator-character} is weak if the {\em word}
resulting from the split is a {\em number}.

The syntax equations required are:

\begin{indpar}
\key{separator} ::= {\em format-separator}
		$|$ {\em post-separator} \\[1ex]
\key{post-separator} ::= {\em post-separator-character} \\[1ex]
\key{post-separator-character} \begin{tabular}[t]{rl}
                     ::= & {\em strong-post-separator-character} \\
		     $|$ & {\em weak-post-separator-character}
		     \end{tabular} \\[1ex]
\key{strong-post-separator-character} ::=     \verb|,|
			                $|$ \verb|;|
					\\[1ex]
\key{weak-post-separator-character} ::=     \verb|!|
				        $|$ \verb|?|
			                $|$ \verb|:|
			                $|$ \verb|.|
					\\[1ex]
\key{pre-word} ::= {\em word}
		$|$ {\em pre-word} {\em post-separator-character}
\end{indpar}

{\bf Post Separator Rule.}\index{Post Separator Rule}
A {\em pre-word} of 2 or more characters
that ends with a {\em post-separator-character}
is split into a smaller {\em pre-word} and a {\em post-separator}
if (1) the {\em post-separator-character} is strong, or if
(2) the smaller {\em pre-word} is a {\em number}, or if
(3) the smaller {\em pre-word} does 
\underline{not} contain a copy of the {\em post-separator-character}.
If the {\em pre-word} is not split, it becomes a {\em word} lexeme.

The following rule handles the case of 1-character {\em pre-words}.

{\bf Isolated Post Separator Rule.}\index{Isolated Post Separator Rule}
A {\em pre-word} that consists of a single {\em post-separator-character}
is a {\em post-separator} lexeme.


Examples:

\begin{indpar}[0.1in]
\begin{tabular}{@{}l@{\hspace*{0.3in}}l@{~~~}l@{\hspace*{0.6in}}l}
Pre-Word		& \multicolumn{2}{@{}l@{}}{Lexeme Sequence}
							& Splits?	\\[1ex]
\verb|hello.|		& \tt hello 		& \tt .	& yes		\\
\verb|X,|		& \tt X 		& \tt ,	& yes		\\
\verb|h.e.l.l.o.|	& \tt h.e.l.l.o.	&	& no		\\
\verb|e.g.|		& \tt e.g.		&	& no		\\
\verb|5.0.|		& \tt 5.0		& \tt .	& yes		\\
\verb|1,234.5,|		& \tt 1,234.5		& \tt ,	& yes		\\
\verb|1,234.5,,|	& \tt 1,234.5		& \tt ,~~,
							& yes, twice	\\
\verb|1,234.5.,|	& \tt 1,234.5		& \tt .~~,
							& yes, twice	\\
\verb|help!|		& \tt help		& \tt !	& yes		\\
\verb|!help!|		& \tt !help!		&	& no		\\
\verb|help.!|		& \tt help		& \tt .~~!
							& yes, twice	\\
\verb|.help.!|		& \tt .help.		& \tt !
							& yes, once	\\
\verb|!.help.!|		& \tt !.help.!		&	& no		\\
\end{tabular}
\end{indpar}

\subsubsection{Indentation Lexemes}
\label{INDENTATION-LEXEMES}

{\em Indentation-lexemes} are implied by indentation.  The
\mkey{indentation}{of line} of a line is the
the number of {\em space} characters in the {\em white-space}
pre-lexeme just before the first non-{\em white-space} pre-lexeme
of the line.  Note that lines cannot be empty; empty lines are
merged into {\em white-space} pre-lexemes.

At any given point in the scan of pre-lexemes, there is a
stack of indentation records, called the \key{indentation stack}.
An \key{indentation record} is a number of
columns, a pre-lexical context, and a flag.
The number of columns is called the \key{indentation}.
The flag is called the \key{implicit bracket flag}, and indicates whether
or not an implied \verb|{| lexeme was inserted at the same time the
indentation record was pushed onto the indentation stack.

Initially the indentation stack contains a single indentation record with
0 indentation, the outermost pre-lexical context,
and an off implicit bracket flag.
The stack cannot become empty; any operation that would
pop the last indentation off the stack announces an error and leaves the
stack alone.  Thus the bottommost indentation on the stack is always
the same.

The indentation in the indentation record at the top of the indentation
stack is called the \key{current indentation}, and the pre-lexical
context in that record is called the \key{current pre-lexical context}.

{\bf Semi-Colon Rule.}\index{Semi-Colon Rule}
If the first non-{\em white-space} pre-lexeme of a line is neither
\verb|{| nor \verb|}|, if that pre-lexeme is in
the current pre-lexical context, and if the indentation of the line
is the current indentation, and if the last lexeme output was not
a \verb|;| {\em separator} lexeme or a \verb|{| {\em opening-mark}
lexeme (including an implied {\em opening-mark} as in the
Implicit-Bracket Rule below), then a \verb|;| implied {\em separator}
lexeme is output
before any lexemes generated by the line are output.

{\bf Explicit-Bracket Rule.}\index{Explicit-Bracket Rule}
If the last pre-lexeme of a line is \verb|{|, then an indentation record
is pushed into the indentation stack just after the \verb|{| lexeme
is output.  The indentation in the record is the indentation of the next
line, the pre-lexical context is that in effect just after the \verb|{|,
and the implicit bracket flag is off.
The pushed indentation record is popped just after its pre-lexical context
ends; that is, just after reading the \verb|}| pre-lexeme that matches the
\verb|{| pre-lexeme that pushed the indentation record.

{\bf Implicit-Bracket Rule.}\index{Implicit-Bracket Rule}
If the last lexeme output for a line would be a post-separator \verb|:|,
then a \verb|{| implied {\em opening-mark} lexeme
is output instead of the \verb|:|, and an indentation
record is pushed into the indentation stack.  The indentation of the
record is the indentation of the next line, the implicit bracket flag
of the record is on, and the
pre-lexical context of the record is that of the \verb|:|.
The pushed record is popped (1) just before the first line such that
the line beginning pre-lexeme is in the record's pre-lexical context
and the line's indentation is less than the record's indentation,
or (2) at the end of the input pre-lexeme stream.
When the record is popped, a \verb|}| implied {\em closing-mark}
lexeme is output.

In order to avoid subtle errors created by indentation, there
is a {\tt minimum-indentation} parameter and the following rule.

{\bf Minimum-Indentation Rule.}\index{Minimum-Indentation Rule}
The indentation of any line must equal the current indentation
or differ from it by at least the value of the
\ttkey{minimum-indentation} parameter.  The {\tt minimum-indentation}
parameter defaults to {\tt 4}.


Indentation Lexeme Examples:

\begin{indpar}[0.1in]
\tt \ttbrackets
\begin{tabular}{@{}l@{~~~~~~~~~~}l}
{\rm Input String}		& {\rm Output Lexemes} \\[1ex]
hi \{ x; y z; w \}		& \tt hi \{ x ; y z ; w \} \\[1ex]
hi \{				& hi \{ \\
~~~~x				& x \\
~~~~y z				& ; y z \\
~~~~w \}			& ; w \} \\[1ex]
hi				& hi \\
\{				& \{ \\
~~~~x				& x \\
~~~~y z				& ; y z \\
~~~~w				& ; w \\
\}				& \} \\[1ex]
hi:				& hi \{ \\
~~~~x				& x \\
~~~~y z				& ; y z \\
~~~~w				& ; w \\
				& \} \\[1ex]
hi \{				& hi \{ \\
~~~~x				& x \\
~~~~y `this			& ; y ` this \\
is another pre-lexical		& is another pre-lexical \\
context.			& context . \\
' foo bar			& ' foo bar \\
~~~~w \}			& ; w \} \\[1ex]
hi \{				& hi \{ \\
~~~~x				& x \\
~~~~y \{			& ; y \{ \\
ho				& ho \\
hum \} z			& ; hum \} z \\
~~~~w \}			& ; w \}
\end{tabular}
\end{indpar}


\section{Expressions}

An expression is a sequence of words, separators, and subexpressions.
A subexpression is a pair of matched lexemes and all the lexemes in
between.

Expressions and subexpressions can contain operators.  When they do,
matched implied parentheses are inserted into the expressions or subexpressions
according to rules of operator precedence and associativity, and these
implied parentheses create new subexpressions.

Expressions and subexpressions that do not contain operators may contain
argument lists and qualifying phrases.  The order in which qualifying
phrases appear does not matter, and sometimes the order of arguments
in an argument list does not matter.

\subsection{Subexpressions}
\label{SUBEXPRESSIONS}

Expressions and subexpressions are defined by the following syntax equations.

\begin{indpar}
\key{expression} ::= {\em expression-item}$^\star$ \\[1ex]
\key{expression-item} ::= {\em word} $|$ {\em separator}
				     $|$ {\em subexpression} \\[1ex]
\key{subexpression} ::= {\em opening-mark} {\em expression}
			{\em closing-mark}
\end{indpar}

{\bf Subexpression Rule.}\index{Subexpression Rule}
The {\em opening-mark} lexeme that begins a subexpression
must match (\ref{MATCHING}) the {\em closing-mark} lexeme that
ends a subexpression.

Expression structure is affected by two special marks:
the reorder mark (\verb|<=>|) and the qualifier mark (\verb|@@@|).
Expressions will be restructured if they contain operators (e.g.,
\verb|+|,
\verb|-|,
\verb|*|,
\verb|.|) or
qualifiers (e.g.,
\verb|with|,
\verb|has|,
\verb|ascending|).

Note that there are several different types of matching lexemes
that are used to bracket subexpressions.  The following informal guide may
help keep them separate:

\begin{center}
\begin{tabular}{llll}
	   & Turn	& Is Subexpression	& Subexpression \\
Brackets   & Evaluation	& Restructured?		& Can Contain \\[1ex]

\verb|[]|  & off	& no			& \verb|<=>|, \verb|@@@| \\
\verb|`'|  & off	& yes			& \verb/|/ \\
\verb|()|  & -		& sometimes		& \verb|<=>|, \verb|@@@|,
						  operators, qualifiers \\
\verb|{}|  & off	& sometimes		& \verb|<=>|, \verb|@@@|,
						  operators, qualifiers \\
\verb|<<>>|& on		& sometimes		& \verb|<=>|, \verb|@@@|,
						  operators, qualifiers \\
\end{tabular}
\end{center}

Operators and qualifiers, when present in an expression, always
restructure the expression.  For example, \verb|x + y - 5 * z| is
restructured as \verb|[+- x + y - [* 5 z]]|, and \verb|sort x| \verb|ascending|
is restructured as \verb|[sort x @@@ ascending]|.

In expressions that cannot contain operators
or qualifiers, words and separators that would be recognized as operators
or qualifiers elsewhere are not recognized as such.  Thus in
\verb|[word +]| the \verb|+| is never recognized as an operator.

A \verb|`'| quoted expression is typically restructured into a
computational representation of a part of a document.  For example,
\verb|`I am!'| is restructured to become \verb|[sentence I am !]|.

A \verb|()|, \verb|{}|, or \verb|<<>>| bracketted
expression that does not contain operators
is restructured if its first item is a subexpression.
For example, \verb|((integral x) from 0)| is restructured as
\verb|(-EMPTY- (integral x) from 0)|.

TBD evaluation on/off.

\subsection{Raw Expressions}

A raw expression is an expression that contains no operators or
qualifiers that induce restructuring.  Raw expressions also contain
no 

\subsection{Parsing}
\label{PARSING}

Before an expression can be evaluated, it must be
\ikey{parsed}{parsing!expressions}.  The output of parsing is the
input expression with implied parentheses added.
This is called a \key{parsed expression}, and is input to
expression translation (\ref{EXPRESSION-TRANSLATION}.

The first step in parsing is to transform the expression into a sequence of
expression items as described in \ref{SUBEXPRESSIONS}.  This is
called \key{subexpression parsing}.

The second step in parsing is called \key{operator parsing}.
Operator parsing finds all the
expression items that are operators, picks from these the operators
of lowest precedence, and inserts implied parentheses around the arguments
of these operators, making new subexpressions.  The exact way in which
lowest precedence operators are selected and implied parantheses are
inserted depends upon operator definitions in the lexical context
(\ref{OPERATOR-DEFINITIONS}).

The third step in parsing is to parse each subexpression.  Thus parsing
is recursive.

In specific circumstances, subexpressions of an expression $E$
can be operator definitions (\ref{OPERATOR-DEFINITIONS})
that are added to the lexical context (\ref{LEXICAL-CONTEXT}) used to parse
subsequent subexpressions of $E$.


\subsubsection{Operator Definitions}
\label{OPERATOR-DEFINITIONS}

A lexical context (\ref{LEXICAL-CONTEXT})
consists of a set of \skey{operator definition}s.
An operator definition specifies for each operator the following:

\begin{indpar}[1in]
Lexemes \\
Fixity \\
Precedence \\
Associativity
\end{indpar}

{\bf Lexemes.}\ttmindex{lexemes}{of operator}
An operator definition has a sequence of lexemes.  The operator
inside a subexpression is just this sequence of lexemes, except for
{\tt matchfix} operators, which have two sequences of lexemes, one
of which must begin the subexpression and one of which must end the
subexpression.

The two sequences of lexemes for a {\tt matchfix}
operator are represented by a single sequence of lexemes that contains
the subexpression beginning lexemes followed by a `\verb/.../' lexeme
followed by the subexpression ending lexemes.   The beginning sequence
of lexemes must include the {\em opening-mark} that begins a subexpression
and the closing sequence of lexemes must include the {\em closing-mark}
that ends the subexpression.  An example sequence of lexemes for a
{\tt matchfix} operator is `\verb/[ | ... | ]/' that permits subexpressions
like `\verb/[| x - 5 |]/'.

Two different operators may have the same sequence of lexemes.  For example,
`\verb|-|' is the lexeme sequence of a {\tt prefix} operator and also of
a distinct {\tt infix} operator.


{\bf Fixity.}\ttmindex{fixity}{of operator}
An operator has one of the following fixities:

\begin{indpar}
\begin{tabular}{@{}p{1in}@{~~~}p{4in}@{}}
\ttkey{infix}		& E.g., \verb|+| in \verb|x + 5|.\\
\ttkey{prefix}		& E.g., \verb|-| in \verb|- 5|.\\
\ttkey{postfix}		& E.g., \verb|!| in \verb|x!|.\\
\ttkey{matchfix}	& E.g., \verb/[| |]/ in \verb/[| x - 5 |]/.
\end{tabular}
\end{indpar}

{\bf Precedence.}\ttmindex{precedence}{of operator}
The precedence of an operator is an integer.  Precedence is used in
selecting which infix operators in an expression will be used to form
implicitly parenthized subexpressions.  Only infix operators have
precedence.

If no matchfix operators apply to an expression, but there
are infix operators in the expression, the lowest
precedence $P$ of any infix operator in the expression is determined, and
only infix operators of precedence $P$ are considered when inserting implied
parentheses into the expression.  However, after implied parentheses
are inserted, higher precedence infix operators, prefix operators, and
postfix operators will be recognized when
the resulting subexpressions are parsed recursively.

{\bf Associativity.}\ttmindex{associativity}{of operator}
A infix operator may be \ttkey{left} or \ttkey{right} associative, or
\ttkey{non-associative}.

If more than one infix operator with lowest precedence appears in an expression,
all the operators that appear must have the same associativity.

If all operators are left associative, only the rightmost operator is used to
insert implied parentheses, so it is as if operators to the left had
higher precedence than those to the right.

If all operators are right associative, only the leftmost operator is used to
insert implied parentheses, so it is as if operators to the right had
higher precedence than those to the left.

If all operators are non-associative, all are recognized, and 
implicitly parenthesized subexpressions will be created between the
operators as well as possibly at the beginning and end of the whole expression.


\subsubsection{Implicit Parenthesis Insertion}
\label{IMPLICIT-PARENTHESIS-INSERTION}

If an expression begins and ends with a matchfix operator, that operator
will be used to insert implied parentheses.  Otherwise, if there are
any infix operators in the expression, these will be used to insert
implied parentheses.  Otherwise if the expression begins with a prefix
operator or ends with a postfix operator, that operator will be used
to insert implied parentheses.

An expression is in error if it begins and ends with more than one
matchfix operator.
When a matchfix operator is used to insert implicit parentheses
into an expression, the part of the expression that is not part of the
operator is the subexpression that is implicitly parenthesized.
This subexpression may be empty.

When infix operators are used to insert implicit parentheses
in an expression, the parts of the expression between operators and
the ends of the expression are the subexpressions that are implicitly
parenthesized.  These subexpressions can be empty.

An expression is in error if it has not matchfix or infix operators,
and it both begins with a prefix operator and ends with a postfix operator.
When a prefix or postfix operator is used to insert implied parentheses
into an expression, the part of the expression that is not part of the
operator is the subexpression that is implicitly parenthesized.
This subexpression may be empty.

\subsubsection{Lexical Context}
\label{LEXICAL-CONTEXT}

\subsection{Expression Translation}
\label{EXPRESSION-TRANSLATION}


\section{Expression Inference}

Expressions can be inferred to be true by inference and reduction rules.
Such \key{expression inference} is more basic than expression
evaluation, because to evaluate an expression you must first
infer it.  Inference rules can have associated blocks of code,
and the inference of an expression by a rule associates the rule's
block of code with the expression.  Evaluating that block of code
then evaluates the expression.  However, sometimes expressions are
inferred without being evaluated.

Inference and reduction rules are collected into sets of rules called
contexts.  An expression is inferred in some context.  Usually the
context is that of the code in which the expression appears, but
sometimes the context is that of the caller of that code (TBD).

To infer an expression, the expression is first reduced, and then
inferred.  Reduction and inference are intermixed; to reduce an
expression, one applied first a reduction rule, and gets are resulting
set of goal expressions that must be inferred for the reduction to succeed.
These expressions are in turned first reduced and then inferred.

Expression inference is a search process in which inferences
are found for a non-empty \key{goal set} of \skey{goal-expression}s.
An \key{inference} is an alternating sequence of expression reductions
and inference steps.
 
Expression reduction is a process that creates a unique result and
has no side effects.  An inference step takes as input a reduced
goal-expression and an inference rule, and replaced the goal-expession
in the goal set by other expressions that are in the inference rule.

An unreduced goal expression is said to be the parent of the unreduced
expressions that replace it in the goal set, and the parent relation
is labelled by the inference rule used to make the replacement.
An inference is associated with a forest (set of trees) whose nodes
are labelled with unreduced goal expressions and whose arcs are just the
parenting arcs which are labelled with the inference rule used to
replace the parent by its children.  Two inferences are said to be
distinct if and only if the inferences have distinct forests.

An expression inference is a search for all distinct inferences of
a goal set whose only member is the expression to be inferred.


Reduction and inference rules make use of unification and unification
variables (\ref{UNIFICATION}).
Each inference generates a set of values for the unification variables in the
original goal set.  Inference may create new unification variables that
appear in these values.

As inference rules (\ref{INFERENCE-RULES})
are simpler than reduction rules (\ref{REDUCTION-RULES}),
inference rules are explained first.

\subsection{Unification}
\label{UNIFICATION}

Expressions are externally represented as sequences of lexemes and
subexpressions, but internally they are represented as directed graphs whose
arcs are labelled by lexemes from the expression, and
whose nodes are unlabelled.  For example, the expression

\begin{center}
\verb|sort x ascending with key weight with comparitor <|
\end{center}

represents the tree

\[
    \verb|sort| \left[
	\begin{array}{l}
        \verb|1| \left[ \verb|x| \right. \\
        \verb|2| \left[ \verb|ascending| \right. \\
        \verb|3| \left[ \verb|with| \left[
	    \begin{array}{l}
	    \verb|1| \left[ \verb|key| \right. \\
	    \verb|2| \left[ \verb|weight| \right. \\
           \end{array} \right. \right. \\
        \verb|4| \left[ \verb|with| \left[
	    \begin{array}{l}
	    \verb|1| \left[ \verb|comparitor| \right. \\
	    \verb|2| \left[ \verb|<| \right. \\
           \end{array} \right. \right. \\
       \end{array} \right.
\]

while

\begin{center}
\verb|x = 7 * y + 5|
\end{center}

represents the tree

\[
    \verb|=| \left[
        \begin{array}{l}
	\verb|1| \left[ \verb|x| \right. \\
        \verb|2| \left[ \verb|+| \left[
	    \begin{array}{l}
	    \verb|1| \left[ \verb|*| \left[
	        \begin{array}{l}
		\verb|1| \left[ \verb|7| \right. \\
		\verb|2| \left[ \verb|y| \right. \\
		\end{array} \right. \right. \\
	    \verb|2| \left[ \verb|5| \right. \\
	    \end{array} \right. \right. \\
	\end{array} \right.
\]

and

\begin{center}
\verb|0 < x <= y <= 100|
\end{center}

represents the tree

\[
    \verb|<| \left[
        \begin{array}{l}
	\verb|1| \left[ \verb|0| \right. \\
        \verb|-REST-| \left[ \verb|<=| \left[
	    \begin{array}{l}
	    \verb|1| \left[ \verb|x| \right. \\
	    \verb|-REST-| \left[ \verb|<=| \left[
		\begin{array}{l}
		\verb|1| \left[ \verb|y| \right. \\
		\verb|2| \left[ \verb|100| \right. \\
		\end{array} \right. \right. \\
	    \end{array} \right. \right. \\
	\end{array} \right.
\]

\subsection{Inference Rules}
\label{INFERENCE-RULES}

An \key{inference rule} has the form:

\begin{center}
\key{consequent-expression} \verb|<--|
    \key{condition-expression} \{ \verb|,| {\em condition-expression} \}
\end{center}

An \key{inference step} takes as input one of the reduced goal-expressions
in the goal set and one inference rule,
such that the reduced goal-expression unifies with the
consequent-expression of the inference rule.  The unification variables in the
goal-set and inference-rule are replaced by their values computed
by this unification.  The goal-expression is removed the goal set, and
all the condition-expressions of the inference rule are added to the goal
set.

\subsection{Reduction Rules}
\label{REDUCTION-RULES}

A \key{reduction rule} has the form:

\begin{center}
\key{result-expression} \verb|<==|
\key{consequent-expression} \verb|<--|
    \key{condition-expression} \{ \verb|,| {\em condition-expression} \}
\end{center}

A reduction rule contains within it the equivalent of an inference rule,
which is obtained by removing the result-expression and following \verb|<==|
from the reduction rule.

A subexpression is \key{reduced} by finding for it inferences in which
the first rule applied to the original expression is a reduction rule.
If the result-expressions of all such inferences found unify, their
unification replaces the expression being reduced.  If no inferences
are found, the expression is not replaced.  It is an error
if several inferences are found but their result-expressions fail to unify.

An expression is \key{reduced} by reducing all its subexpressions, smallest
first, until lastly the whole expression is reduced as a subexpression of
itself.

\section{Design Notes}

These are some detailed design rules to be incorporated in the language
definition later.

\begin{list}{}{}

\item
{\bf Quotes}.  \verb|`'| are word, phrase, sentence, paragraph quotes.
\verb|[]| are math expression quotes.   Quotes are in left-right pairs
and can be nested.

\item
{\bf Multiple Quotes}.  Quotes can be multiplied $N$ times: e.g.,
\verb|[[...]]|, \verb|[[[...]]]|, etc.  It is possible to begin a quoted
phrase with a quoted phrase by following the initial $N$-left-quote by
space.  E.g., \verb|`` `Hello' 'tis a good word.''|.

\item
{\bf Algebraic Expressions}.
An expression may or may not be algebraic.  Algebraic expressions have
operators that determine structure.  Atoms in these are sequences of
words, numbers, and parenthesized or bracketted subexpressions.

\item
{\bf N-tuples and Flatening}.
The comma operator forms N-tuples, e.g., \verb|(x,y,z)| is a 3-tuple.

Tuples flatten.  It is not possible for a tuple to be a component of
a tuple: instead the tuples are flattened.  E.g., \verb|(x,(y,z),w)|
is the same value as \verb|(x,y,z,w)|.  There is no such thing as a
1-tuple, but any non-tuple behaves like a 1-tuple.

\item
{\bf Blank Algebraic Operators}.
The blank, or missing operator, denotes \verb|*| when it precedes a word,
as in \verb|5x| being equivalent to \verb|5*x|.  When it is between a
preceding integer and a following ratio, it adds the ratio to the integer,
as in \verb|41 1/3|.

\end{list}



\bibliographystyle{plain}
\bibliography{pcasl}

\printindex

\end{document}

