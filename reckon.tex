% Personal Calculation and Simulation Langauge (PCASL)
%
% File:         pcasl.tex
% Author:       Bob Walton (walton@deas.harvard.edu)
% Date:		See \date below.
  
\documentclass[12pt]{article}

\usepackage{makeidx}

\makeindex

\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}
\raggedbottom

\setlength{\unitlength}{1in}

\pagestyle{headings}
\setlength{\parindent}{0.0in}
\setlength{\parskip}{1ex}

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}
\newcommand{\subsubsubsection}[1]{\paragraph[#1]{#1.}}
\newcommand{\subsubsubsubsection}[1]{\subparagraph[#1]{#1.}}

% Begin \tableofcontents surgery.

\newcount\ATCATCODE
\ATCATCODE=\catcode`@
\catcode `@=11	% @ is now a letter

\renewcommand{\contentsname}{}
\renewcommand\l@section{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\l@table{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\tableofcontents{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}}%
    \item\@starttoc{toc}%
    \end{list}}
\renewcommand\listoftables{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}%
	      }%
    \item\@starttoc{lot}%
    \end{list}}

\catcode `@=\ATCATCODE	% @ is now restored

% End \tableofcontents surgery.

\newcommand{\CN}[2]%	Change Notice.
    {\hspace*{0in}\marginpar{\sloppy \raggedright \it \footnotesize
     $^{\mbox{#1}}$#2}}
    % Change notice.

\newcommand{\key}[1]{{\em #1}\index{#1}}
\newcommand{\mkey}[2]{{\em #1}\index{#1!#2}}
\newcommand{\skey}[2]{{\em #1#2}\index{#1}}
\newcommand{\ikey}[2]{{\em #1}\index{#2}}
\newcommand{\ttkey}[1]{{\tt #1}\index{#1@{\tt #1}}}
\newcommand{\ttmkey}[2]{{\tt #1}\index{#1@{\tt #1}!#2}}
\newcommand{\ttfkey}[2]{{\tt #1}\index{#1@{\tt #1}!for #2@for {\tt #2}}}
\newcommand{\ttakey}[2]{{\tt #1}\index{#2@{\tt #1}}}
\newcommand{\ttamkey}[3]{{\tt #1}\index{#2@{\tt #1}!#3}}
\newcommand{\ttindex}[1]{\index{#1@{\tt #1}}}
\newcommand{\ttmindex}[2]{\index{#1@{\tt #1}!#2}}
\newcommand{\emkey}[1]{{\em #1}\index{#1@{\em #1}}}
\newcommand{\emindex}[1]{\index{#1@{\em #1}}}

\newcommand{\EOL}{\penalty \exhyphenpenalty}

\newsavebox{\leftbracket}
\begin{lrbox}{\leftbracket}
\verb|{|
\end{lrbox}

\newsavebox{\rightbracket}
\begin{lrbox}{\rightbracket}
\verb|}|
\end{lrbox}

\newcommand{\ttbrackets}{
    \renewcommand{\{}{\usebox{\leftbracket}}
    \renewcommand{\}}{\usebox{\rightbracket}}}

\newlength{\figurewidth}
\setlength{\figurewidth}{\textwidth}
\addtolength{\figurewidth}{-0.40in}

\newsavebox{\figurebox}

\newenvironment{boxedfigure}[1][!btp]%
	{\begin{figure*}[#1]
	 \begin{lrbox}{\figurebox}
	 \begin{minipage}{\figurewidth}

	 \vspace*{1ex}}%
	{
	 \vspace*{1ex}

	 \end{minipage}
	 \end{lrbox}
	 \begin{center}
	 \fbox{\hspace*{0.1in}\usebox{\figurebox}\hspace*{0.1in}}
	 \end{center}
	 \end{figure*}}

\newenvironment{indpar}[1][0.3in]%
	{\begin{list}{}%
		     {\setlength{\itemsep}{0in}%
		      \setlength{\topsep}{0in}%
		      \setlength{\parsep}{1ex}%
		      \setlength{\labelwidth}{#1}%
		      \setlength{\leftmargin}{#1}%
		      \addtolength{\leftmargin}{\labelsep}}%
	 \item}%
	{\end{list}}

\begin{document}
        
\title{Personal\\Calculation and Simulation\\Language\\[2ex]PCASL\\[2ex]
       (Draft 1a)}

\author{Robert L. Walton\thanks{This document was partly inspired
by teaching courses at Suffolk University.}}

\date{November 26, 2003}
 
\maketitle

\tableofcontents 

\newpage

\section{Introduction}

This document describes PCASL, the Personal Calculation and Simulation
Language, that is informally referred to as P-Castle, Personal Castle, or just
Castle.

PCASL is designed for naive programmers: that is, for people who may never
be able to program computers well.  It is a simple language that has
powerful data types which make it easier to write small programs
that do a variety of tasks that a person might want to do.  Generally
the tasks fall into the categories of calculating things (taxes,
probabilities, statistics) or simulating things
(computer games, construction designs, mathematics demonstrations).
Included are:

\begin{center}
\begin{tabular}{l}
Calculations that might be done with a spreadsheet. \\
Drawing pictures. \\
Simulating popular board games and creating new ones. \\
Creating simple computer games, including dialog games. \\
Computing and analysing documents. \\
Doing elementary algebra and calculus problems. \\
Calculating basic probabilities and statistics. \\
Simulating two and three dimensional objects. \\
Simulating simple electrical, mechanical, chemical, and biological systems.\\
Solving problems in elementary logic. \\
\end{tabular}
\end{center}

There are many computer languages that have some powerful data type that adapts
them for a specific kind of computation.  PCASL tries to combine these.
Some previous computer languages that have influenced PCASL, and
the data types they particularly support, are:

\begin{center}
\begin{tabular}{l@{\hspace{0.5in}}l}
Various Spreadsheets		& Spreadsheets \\
Various Data Base Languages	& Data Bases \\
Matlab				& Matrices \\
Mathematica			& Expressions \\
TCL				& Character Strings and Lists \\
Lisp				& Words and Phrases \\
Prolog				& Logical Expressions \\
\end{tabular}
\end{center}

PCASL is \underline{not} designed to be a computer-efficient language.
It is designed to be person-efficient, and to do small calculations
rapidly enough with inexpensive modern computers.

\section{Remarks}

PCASL was created as an answer to the question: what programming language
should you teach beginning programming students who do not have the talent
or inclination to become good programmers?  The inital answer, that it does
not matter provided you implement some powerful types of data in the
language you choose, has a flaw.  The flaw is that without the right powerful
data types, the language will be useless to the students after the course
is over.  So what is needed is a programming language that will be useful
to students after a first course in programming, and the essence of
such a language is the integration within it of many powerful and useful
data types.

The current version of PCASL is not stable, because it has not been
implemented, and because, unlike most programming languages, PCASL
has lots of subtle interactions between its various features.  The
hope is that with implementation and experimentation, a stable sensible
version of PCASL integrating all its data types can be achieved.

\section{Data}

PCASL has two major kinds of data: expressions and blocks.  Numbers are
the simplest expressions.  More complex expressions are math
expressions or document expressions.  Blocks are sets of variables
each of which can have a value, which is an expression, and also
a definition, which is another expression that is used to compute the
value when the value is needed.  The definitions of a block, taken all
together, are called the `code' of the block.

You can use PCASL as a calculator by typing into it expressions to
be evaluated and assignments of values and definitions to variables.
Some examples involving numbers are:

\begin{indpar}\begin{verbatim}
> 9
9
> 9 + 8
17
> x = 9
9
> y = 9 + 8
17
> x + y
26
\end{verbatim}\end{indpar}

Here the `\verb|> |' at the beginning of some lines is the PCASL \key{prompt}
that tells you its OK to input an expression to be evaluated.

At somewhat the opposite extreme from numbers are words, phrases, sentences,
and paragraphs.  You can calculate with these `\skey{document expression}s'.

\begin{indpar}
\verb|> g = `hello'| \\
\verb|`|hello\verb|'| \\
\verb|> `<<g>> there'| \\
\verb|`|hello there\verb|'| \\
\verb|> z = ``I thought he said `<<g>>'.''| \\
\verb|``|I thought he said `hello'.\verb|''| \\
\verb/> notice = ``|This document is meant to be read./ \\
\verb/+            |Reading this document is good, but.../ \\
\verb/+            |<<z>>.''/ \\
\verb|``|This document is meant to be read. \\
\verb|  |Reading this document is good, but\ldots \\
\verb|  |I thought he said `hello'.\verb|''| \\
\verb|> `When you add <<x>> and <<y>> you get <<x+y>>.'| \\
\verb|`|When you add 9 and 17 you get 26.\verb|'|
\end{indpar}

Modern math computes with expressions, and not just numbers.
You can compute with \skey{math expression}s in PCASL.

\begin{indpar}
\verb|> f = {10x^2 - 3.67x - 0.04}| \\
\verb|{|$10x^2-3.67x-0.04$\verb|}| \\
\verb|> h = (- 0.96 + 0.67x) in x| \\
\verb|{|$-0.96+0.67x$\verb|}| \\
\verb|> (f + h) in x| \\
\verb|{|$10x^2-3x-1$\verb|}| \\
\verb|> solve (f + h = 0) for x| \\
\verb|{|$x = (-0.2, 0.5)$\verb|}| \\
\verb|> (f + h) at (x = (3, 4, 5))| \\
\verb|(78.95, 145.28, 231.61)| \\
\verb|> g = {integral (x^2 dx)}| \\
\verb|{|$\int x^2 dx$\verb|}| \\
\verb|> simplify g| \\
\verb|{|$\frac{1}{3} x^3$\verb|}| \\
\verb|> v = g from (x=1) to (x=5)| \\
\verb|41 1/3| \\
\verb|> out = `The value of {<<g>> from (x=1) to (x=5)} is <<v>>.'| \\
\verb|`|The value of $\int_{x=1}^{x=5} x^2 dx$ is $41\frac{1}{3}$.\verb|'| \\
\verb|> raw out| \\
\verb|[sentence the value of {(integral (x^2*dx)) from (x=1) to (x=5)}| \\
\verb|          is 124/3]|
\end{indpar}

Another kind of datum you can compute with in PCASL is
the \key{block}:

\begin{indpar}
\verb|> a person {| \\
\verb|+     name = `Jack'| \\
\verb|+     weight = 123 lb| \\
\verb|+     height = 5'9"| \\
\verb|+     age = 23 yr 2 mo }| \\
\begin{tabular}{|r|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000000 & Jack & \tt 123 lb & \tt 5'9" & \tt 23 yr 2 mo \\
\hline
\end{tabular} \\
\verb|> a person {| \\
\verb|+     name = `Jill'| \\
\verb|+     weight = 110 lb| \\
\verb|+     height = 5'7"| \\
\verb|+     age = 21 yr 8 mo }| \\
\begin{tabular}{|r|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000001 & Jill & \tt 110 lb & \tt 5'7" & \tt 21 yr 8 mo \\
\hline
\end{tabular} \\
\verb|> all persons| \\
\begin{tabular}{|r|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000000 & Jack & \tt 123 lb & \tt 5'9" & \tt 23 yr 2 mo \\
\tt @1000001 & Jill & \tt 110 lb & \tt 5'7" & \tt 21 yr 8 mo \\
\hline
\end{tabular} \\
\verb|> the person Jack| \\
\begin{tabular}{|r|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000000 & Jack & \tt 123 lb & \tt 5'9" & \tt 23 yr 2 mo \\
\hline
\end{tabular} \\
\verb|> the person named Jack's height| \\
\verb|5'9"| \\
\verb|> the weight of the person named Jack| \\
\verb|123 lb| \\
\verb|> @1000001| \\
\begin{tabular}{|r|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000001 & Jill & \tt 110 lb & \tt 5'7" & \tt 21 yr 8 mo \\
\hline
\end{tabular} \\
\verb|> the weight of @1000001| \\
\verb|110 lb|
\end{indpar}

It is possible to add code to a type such as `{\tt person}':

\begin{indpar}
\verb|> a person <-- {| \\
\verb|+     body-mass-index = 703.06958 * weight in lbs| \\
\verb|+                     / (height in inches)^2 }| \\
\verb|> all persons| \\
\begin{tabular}{|r|l|r|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} &
\multicolumn{1}{|c|}{\bf \shortstack{body-mass-\\index}} \\
\hline
\tt @1000000 & Jack & \tt 123 lb & \tt 5'9" & \tt 23 yr 2 mo & \tt 18.163738 \\
\tt @1000001 & Jill & \tt 110 lb & \tt 5'7" & \tt 21 yr 8 mo & \tt 17.228258 \\
\hline
\end{tabular}
\end{indpar}

One can use definitions to define expressions that compute values:

\begin{indpar}
\verb|> sum from X through Y <-- integer X, integer Y {| \\
\verb|+     `Sum of integers from X through Y.'| \\
\verb|+     if ( X > Y ):| \\
\verb|+         value = 0| \\
\verb|+     else:| \\
\verb|+         value = X + sum (X+1) through Y }| \\
\verb|> sum from 5 through 10| \\
\verb|45| \\
\verb|> all (sums from X through Y)| \\
\begin{tabular}{|r|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf X} &
\multicolumn{1}{|c}{\bf Y} &
\multicolumn{1}{|c|}{\bf value} \\
\hline
\tt @1000002 & \tt 5	& \tt	10	& \tt 45 \\
\tt @1000003 & \tt 6	& \tt	10	& \tt 40 \\
\tt @1000004 & \tt 7	& \tt	10	& \tt 34 \\
\tt @1000005 & \tt 8	& \tt	10	& \tt 27 \\
\tt @1000006 & \tt 9	& \tt	10	& \tt 19 \\
\tt @1000007 & \tt 10	& \tt	10	& \tt 10 \\
\tt @1000008 & \tt 11	& \tt	10	& \tt 0 \\
\hline
\end{tabular} \\
\verb|> sum from 1 through 2| \\
\verb|3| \\
\verb|> all (sums from X through Y)| \\
\begin{tabular}{|r|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf X} &
\multicolumn{1}{|c}{\bf Y} &
\multicolumn{1}{|c|}{\bf value} \\
\hline
\tt @1000002 & \tt 5	& \tt	10	& \tt 45 \\
\tt @1000003 & \tt 6	& \tt	10	& \tt 40 \\
\tt @1000004 & \tt 7	& \tt	10	& \tt 34 \\
\tt @1000005 & \tt 8	& \tt	10	& \tt 27 \\
\tt @1000006 & \tt 9	& \tt	10	& \tt 19 \\
\tt @1000007 & \tt 10	& \tt	10	& \tt 10 \\
\tt @1000008 & \tt 11	& \tt	10	& \tt 0 \\
\tt @1000009 & \tt 1	& \tt	2	& \tt 3 \\
\tt @1000010 & \tt 2	& \tt	2	& \tt 2 \\
\tt @1000011 & \tt 3	& \tt	2	& \tt 0 \\
\hline
\end{tabular}
\end{indpar}

Executions can be examined in detail because
when an expression is computed, the block that computes it is remembered
for some time.  However, as memory is finite, eventually these
computations are forgotten as they can always be regenerated if
needed.

The sum above was computed by recursion: to compute the sum of 5 through 10
one computes the sum of 6 through 10.  One can also compute sums by
iteration.

\begin{indpar}
\verb|> sum from X through Y <-- integer X, integer Y {| \\
\verb|+     `Sum of integers from X through Y.'| \\
\verb|+     first sum = 0| \\
\verb|+     if ( X <= Y ):| \\
\verb|+         next sum = sum + X| \\
\verb|+         next X = X + 1| \\
\verb|+     else:| \\
\verb|+         value = sum }| \\
\verb|> sum from 5 through 10| \\
\verb|45| \\
\verb|> all (sums from 5 through 10)| \\
\begin{tabular}{|r|r|r|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf previous} &
\multicolumn{1}{|c}{\bf X} &
\multicolumn{1}{|c}{\bf Y} &
\multicolumn{1}{|c}{\bf sum} &
\multicolumn{1}{|c|}{\bf value} \\
\hline
\tt @1000012 &              & \tt 5	& \tt 10   & \tt 0	& \\
\tt @1000013 & \tt @1000012 & \tt 6	& \tt 10   & \tt 5	& \\
\tt @1000014 & \tt @1000013 & \tt 7	& \tt 10   & \tt 11	& \\
\tt @1000015 & \tt @1000014 & \tt 8	& \tt 10   & \tt 18	& \\
\tt @1000016 & \tt @1000015 & \tt 9	& \tt 10   & \tt 26	& \\
\tt @1000017 & \tt @1000016 & \tt 10	& \tt 10   & \tt 35	& \\
\tt @1000018 & \tt @1000017 & \tt 11	& \tt 10   & \tt 45	& \tt 45 \\
\hline
\end{tabular}
\end{indpar}

One can also iterate over data.

\begin{indpar}
\verb|> average weight of X <-- tuple X of persons {| \\
\verb|+     first count = 0| \\
\verb|+     first sum = 0| \\
\verb|+     if X = ():| \\
\verb|+         if count = 0:| \\
\verb|+             value = error `Cannot average 0 things.'| \\
\verb|+         else:| \\
\verb|+             value = sum / count| \\
\verb|+     else:| \\
\verb|+         next count = count + 1| \\
\verb|+         next sum = sum + the weight of (first X)| \\
\verb|+         next X = rest X }| \\
\verb|> average weight of (all persons)| \\
\verb|116.5 lbs|
\end{indpar}

In case you wonder how some of the above works, here are some hints.

PCASL tends to ignore word endings: thus `{\tt person}' and
`{\tt persons}' are to PCASL the same word.
PCASL can even be told that `{\tt person}'
and `{\tt people}' are the same word.
`{\tt Jack's}', on the other hand, is treated an abbreviation
of two separate words `{\tt Jack 's}', where `{\tt 's}' is
a separate word by itself.

Expressions are just strings of words and subexpressions.  Subexpressions
must be parenthesized unless they consist of a single word, or unless
they are delimited by operators.

Lists of values can be stored in tuples, which are computed by comma
separted lists in parentheses.  Thus

\begin{indpar}
\verb|> (the person named Jill, the person named Jack)| \\
\begin{tabular}{|r|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000001 & Jill & \tt 110 lb & \tt 5'7" & \tt 21 yr 8 mo \\
\tt @1000000 & Jack & \tt 123 lb & \tt 5'9" & \tt 23 yr 2 mo \\
\hline
\end{tabular} \\
\verb|> (the person named Jack, the person named Jill)| \\
\begin{tabular}{|r|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000000 & Jack & \tt 123 lb & \tt 5'9" & \tt 23 yr 2 mo \\
\tt @1000001 & Jill & \tt 110 lb & \tt 5'7" & \tt 21 yr 8 mo \\
\hline
\end{tabular} \\
\verb|> raw (all persons)| \\
\verb|(the person named Jack, the person named Jill)|
\end{indpar}

The `{\tt raw}' form of a value is a form that prints as you could
input it in a way that reveals its internal structure.  Thus
`{\tt all persons}' denotes the tuple of all persons.

`{\tt the person named Jack}' is a printed representation of the
internal name of a block.  Such printed representations are chosen
automatically from the set of all possible representations, which
in this case include `{\tt the person weighing 123}' and
`{\tt the person named Jack weighing 123}'.

A single non-tuple value is equivalent to a tuple with one element.
Tuples cannot have other tuples as elements; instead attempts to
compute such tuples are \key{flattened}:

\begin{indpar}
\verb|> x = (1,(2,3),4)| \\
\verb|(1,2,3,4)| \\
\verb|> first x| \\
\verb|1| \\
\verb|> rest x| \\
\verb|(2,3,4)| \\
\verb|> rest (rest x)| \\
\verb|(3,4)| \\
\verb|> rest (rest (rest x))| \\
\verb|3| \\
\verb|> rest 9| \\
\verb|()|
\end{indpar}

PCASL has many different kinds of quotes or brackets.  Some of these,
\verb|{...}|, \verb|`...'|, and \verb|[...]|, turn evalution off,
while \verb|<<...>>| turns evaluation on.  Some,
\verb|`...'| and \verb|[...]|, turn recognition of operators (e.g., \verb|+|
and \verb|=|) off, while others,
\verb|{...}| and \verb|<<...>>|, turn recognition of operators on.
\verb|`...'| (and \verb|``...''|, \verb|```...'''|, etc.), also do other
things, like insert implicit operations (e.g., \verb|sentence|).

PCASL stores information as expressions.  For example:

\begin{indpar}
\verb|> (a person named `Jack') is husband of (a person named `Jill') <--| \\
\verb|> Y is wife of X <-- X is husband of Y| \\
\verb|> (a person named `Jill') is wife of (a person named `Jack') ?| \\
\verb|true| \\
\verb|> (a person named `Jack') is wife of (a person named `Jill') ?| \\
\verb|false| \\
\verb|> (a person named X) is wife of (a person named `Jack') ?| \\
\verb|X = `|Jill\verb|'| \\
\verb|> X is wife of (a person named `Jack') ?| \\
\verb|X = (a person named `Jill')| \\
\verb|> @1000001 is wife of (a person named `Jack') ?| \\
\verb|true| \\
\verb|> @1000001 = (a person named `Jill') ?| \\
\verb|true| \\
\verb|> @1000001 = (a person named `Jack') ?| \\
\verb|false|
\end{indpar}

PCASL also supports pictorial data
that are computed like expressions.

\begin{indpar}
\verb|> x = {circle 0.4}| \\
\begin{picture}(0.4,0.4)
\put(0.2,0.2){\circle{0.4}}
\end{picture} \\
\verb|> y = {rectangle (0.4,0.2)}| \\
\begin{picture}(0.4,0.2)
\put(0,0){\framebox(0.4,0.2){}}
\end{picture} \\
\verb|> z = {(circle 0.4) labeled `Jack'}| \\
\begin{picture}(0.4,0.4)
\put(0.2,0.2){\circle{0.4}}
\put(0.0,0.0){\makebox(0.4,0.4){Jack}}
\end{picture} \\
\verb|> {(<<x>> right of <<y>>) above <<z>>}| \\
\begin{picture}(0.8,0.8)
\put(0.6,0.6){\circle{0.4}}
\put(0.0,0.5){\framebox(0.4,0.2){}}
\put(0.4,0.2){\circle{0.4}}
\put(0.2,0.0){\makebox(0.4,0.4){Jack}}
\end{picture} \\
\verb|> {row(<<x>>,<<y>>,<<z>>)}| \\
\begin{picture}(1.4,0.4)
\put(0.2,0.2){\circle{0.4}}
\put(0.5,0.1){\framebox(0.4,0.2){}}
\put(1.2,0.2){\circle{0.4}}
\put(1.0,0.0){\makebox(0.4,0.4){Jack}}
\end{picture} \\
\verb|> p = {column (row(<<x>>,<<y>>,<<z>>), row(<<z>>,<<y>>,<<x>>))}| \\
\begin{picture}(1.4,0.9)
\put(0.2,0.7){\circle{0.4}}
\put(0.5,0.6){\framebox(0.4,0.2){}}
\put(1.2,0.7){\circle{0.4}}
\put(1.0,0.5){\makebox(0.4,0.4){Jack}}
\put(1.2,0.2){\circle{0.4}}
\put(0.5,0.1){\framebox(0.4,0.2){}}
\put(0.2,0.2){\circle{0.4}}
\put(0.0,0.0){\makebox(0.4,0.4){Jack}}
\end{picture} \\
\verb|> raw x| \\
\verb|{circle 0.4}| \\
\verb|> raw p| \\
\verb|{column (row (circle 0.4,| \\
\verb|              rectangle (0.4,0.2),| \\
\verb|              (circle 0.4) labeled `Jack'),| \\
\verb|         row ((circle 0.4) labeled `Jack',| \\
\verb|              rectangle (0.4,0.2),| \\
\verb|              circle 0.4))}|
\end{indpar}

You can also change how an expression is displayed.

\begin{indpar}
\newlength{\ovalraise}
\setlength{\ovalraise}{-0.1in}
\addtolength{\ovalraise}{0.8ex}
\verb|> display (a person named X) as ((oval (0.4,0.2)) labelled X) <--| \\
\verb|> (a person named `Jack')| \\
\begin{picture}(0.4,0.2)
\put(0.2,0.1){\oval(0.4,0.2)}
\put(0.0,0.0){\makebox(0.4,0.2){Jack}}
\end{picture} \\
\verb|> ``(a person named `Jill') is wife of (a person named `Jack')''| \\
\verb|``|
\raisebox{\ovalraise}{\begin{picture}(0.4,0.2)
\put(0.2,0.1){\oval(0.4,0.2)}
\put(0.0,0.0){\makebox(0.4,0.2){Jill}}
\end{picture}}
{is the wife of}
\raisebox{\ovalraise}{\begin{picture}(0.4,0.2)
\put(0.2,0.1){\oval(0.4,0.2)}
\put(0.0,0.0){\makebox(0.4,0.2){Jack}}
\end{picture}}
\verb|''|
\end{indpar}

TBD: example of a simple game.


\section{Lexemes}

A PCASL program is a sequence of characters which is scanned from
left to right to produce a sequence of pre-lexemes.  The sequence
of pre-lexemes is then scanned from left to right to produce
a sequence of lexemes.

\subsection{Pre-Lexemes}

Pre-lexemes are defined as follows:

\begin{indpar}
\key{pre-lexeme}
	\begin{tabular}[t]{rl}
	::= & \key{pre-word} \\
	$|$ & \key{opening-mark} \\
	$|$ & \key{closing-mark} \\
	$|$ & \key{format-separator} \\
	$|$ & \key{white-space}
	\end{tabular}
	\\[1ex]
\key{pre-word} ::= {\em word-character} {\em word-character}$^\star$ \\[1ex]
\key{word-character} \begin{tabular}[t]{rl}
                       ::= & {\em letter} $|$ {\em digit} \\
		       $|$ &    \verb|+|%
		             $|$\verb|-|%
		             $|$\verb|*|%
		             $|$\verb|/|%
		             $|$\verb|\|%
		             $|$\verb|~|%
		             $|$\verb|@|%
		             $|$\verb|#|%
		             $|$\verb|$|%
		             $|$\verb|%|%
		             $|$\verb|^|%
		             $|$\verb|&|%
		             $|$\verb|=|%
		             $|$\verb/|/%
		             $|$\verb|<|%
		             $|$\verb|>|%
		             $|$\verb|_|%
		             $|$\verb|"|%
		             $|$\verb|`|%
		             $|$\verb|'|%
		             $|$\verb|!|%
		             $|$\verb|?|%
			     $|$\verb|;|%
			     $|$\verb|:|%
			     $|$\verb|,|%
		             $|$\verb|.|
			\end{tabular}\\[1ex]
\key{letter} ::= {\em lower-case-letter} $|$ {\em upper-case-letter} \\[1ex]
\key{lower-case-letter} ::=    \verb|a|%
			    $|$\verb|b|%
			    $|$\verb|c|%
			    $|$\verb|d|%
			    $|$\verb|e|%
			    $|$\verb|f|%
			    $|$\verb|g|%
			    $|$\verb|h|%
			    $|$\verb|i|%
			    $|$\verb|j|%
			    $|$\verb|k|%
			    $|$\verb|l|%
			    $|$\verb|m|%
			    $|$\verb|n|%
			    $|$\verb|o|%
			    $|$\verb|p|%
			    $|$\verb|q|%
			    $|$\verb|r|%
			    $|$\verb|s|%
			    $|$\verb|t|%
			    $|$\verb|u|%
			    $|$\verb|v|%
			    $|$\verb|w|%
			    $|$\verb|x|%
			    $|$\verb|y|%
			    $|$\verb|z|
			    \\[1ex]
\key{upper-case-letter} ::=    \verb|A|%
			    $|$\verb|B|%
			    $|$\verb|C|%
			    $|$\verb|D|%
			    $|$\verb|E|%
			    $|$\verb|F|%
			    $|$\verb|G|%
			    $|$\verb|H|%
			    $|$\verb|I|%
			    $|$\verb|J|%
			    $|$\verb|K|%
			    $|$\verb|L|%
			    $|$\verb|M|%
			    $|$\verb|N|%
			    $|$\verb|O|%
			    $|$\verb|p|%
			    $|$\verb|Q|%
			    $|$\verb|R|%
			    $|$\verb|S|%
			    $|$\verb|T|%
			    $|$\verb|U|%
			    $|$\verb|V|%
			    $|$\verb|W|%
			    $|$\verb|X|%
			    $|$\verb|Y|%
			    $|$\verb|Z|
			    \\[1ex]
\key{digit} ::=    \verb|0|%
		$|$\verb|1|%
		$|$\verb|2|%
		$|$\verb|3|%
		$|$\verb|4|%
		$|$\verb|5|%
		$|$\verb|6|%
		$|$\verb|7|%
		$|$\verb|8|%
		$|$\verb|9|
		\\[1ex]
\key{opening-mark} ::=     \verb|(|
	       	       $|$ \verb|[|
	       	       $|$ \verb|{|
	       	       $|$ {\em opening-quote}
	       	       $|$ {\em opening-angle}
	       	       \\[1ex]
\key{closing-mark} ::=     \verb|)|
	       	       $|$ \verb|]|
	       	       $|$ \verb|}|
	       	       $|$ {\em closing-quote}
	       	       $|$ {\em closing-angle}
	       	       \\[1ex]
\key{opening-quote} \begin{tabular}[t]{rl}
		     ::= & {\em opening-quote-character}
		           {\em opening-quote-character}$^\star$ \\
		     \end{tabular}
		     \\[1ex]
\key{opening-quote-character} ::= \verb|`| \\[1ex]
\key{closing-quote} \begin{tabular}[t]{rl}
		     ::= & {\em closing-quote-character}
		           {\em closing-quote-character}$^\star$ \\
		     \end{tabular}
		     \\[1ex]
\key{closing-quote-character} ::= \verb|'| \\[1ex]
\key{quote} ::= {\em opening-quote} $|$ {\em closing-quote} \\[1ex]
\key{opening-angle} \begin{tabular}[t]{rl}
		     ::= & {\em opening-angle-character}
		           {\em opening-angle-character} \\
		         & {\em opening-angle-character}$^\star$ \\
		     \end{tabular}
		     \\[1ex]
\key{opening-angle-character} ::= \verb|<| \\[1ex]
\key{closing-angle} \begin{tabular}[t]{rl}
		     ::= & {\em closing-angle-character}
		           {\em closing-angle-character} \\
		         & {\em closing-angle-character}$^\star$ \\
		     \end{tabular}
		     \\[1ex]
\key{closing-angle-character} ::= \verb|>| \\[1ex]
\key{angle-character} ::= \verb|<| $|$ \verb|>| \\[1ex]
\key{opening-character} ::=     \verb|(|
		            $|$ \verb|[|
		            $|$ \verb|{|
		            $|$ \verb|`|
		            $|$ \verb|<|
			    \\[1ex]
\key{closing-character} ::=     \verb|)|
		            $|$ \verb|]|
		            $|$ \verb|}|
		            $|$ \verb|'|
		            $|$ \verb|>|
			    \\[1ex]
\key{format-separator} ::= {\em format-separator-character}
			   {\em format-separator-character}$^\star$ \\[1ex]
\key{format-separator-character} ::=    \verb\|\
				        \\[1ex]
\key{white-space} ::= {\em white-space-character}
                     {\em white-space-character}$^\star$ \\[1ex]
\key{white-space-character} ::=
    \key{horizontal-space-character} $|$ \key{vertical-space-character} \\[1ex]
\key{horizontal-space-character} ::=
    \key{space} $|$ \key{horizontal-tab} $|$ \key{carriage-return} \\[1ex]
\key{vertical-space-character} ::=
    \key{line-feed} $|$ \key{vertical-tab} $|$ \key{form-feed}
\end{indpar}


The following sections give rules involving pre-lexemes.

\subsubsection{Matching and Pre-Lexical Context}
\label{MATCHING}

{\em Opening-marks} and {\em closing-marks} are both pre-lexemes
and also lexemes.  Rules for matching pre-lexemes in a pre-lexeme
sequence are the same as rules for matching lexemes in a lexeme sequence.
Here we will state the rules for lexemes, and leave it to the reader
to reformulate them for pre-lexemes.

{\bf Lexeme Matching Rule.}\index{Lexeme Matching Rule}
An {\em opening-mark} with $N$ characters $C$
must have a matching {\em closing-mark} with $N$ characters each the
mirror of $C$.  Each {\em closing-mark} must match exactly one
{\em opening-mark} and the {\em opening-mark} must precede the
{\em closing-mark}.

Two lexemes are said to be \mkey{matched}{lexemes} if and only if
they are matched opening and closing marks.

{\bf Matched Lexeme Nesting Rule.}\index{Matched Lexeme Nesting Rule}
If one lexeme in a pair $P_2$ of matched lexemes is in between the
lexemes of another pair $P_1$ of matched lexemes, then both lexemes
in $P_2$ must be in between the lexemes of $P_1$.  In this case
$P_2$ is said to be \mkey{nested}{lexemes} inside of $P_1$.

During the scan a character $C$ is said to be in the
\key{lexical context} of a pair $P$ of matched lexemes
if and only if $C$ is between the matched lexemes of $P$,
and $C$ is neither part of or between any other pair of matched
lexemes that is nested inside of $P$.

For a sequence of pre-lexemes, \mkey{matched}{pre-lexemes} pre-lexemes
and \key{pre-lexical context} are defined as for a sequence of lexemes.

\subsubsection{Character Disambiguation Rules}

Several characters in pre-lexemes are ambiguous in the
pre-lexeme syntax equations.  The following rules disambiguate these
characters.

{\bf Opening Quote Rule.}\index{Opening Quote Rule}
An \key{opening-quote-character} must be preceeded by a
{\em white-space-character},
an {\em opening-character}, or a {\em format-separator-character}.
Otherwise it is a {\em word-character}.

{\bf Closing Quote Rule.}\index{Closing Quote Rule}
A \key{closing-quote-character} must be part of a sequence of
{\em closing-quote-characters} that is of exactly the right length to be the
matching pre-lexeme for the last previous unmatched {\em opening-mark},
which must be an {\em opening-quote}.
Otherwise the potential {\em closing-quote-character}
is a {\em word-character}.

{\bf Format Separator Rule.}\index{Format Separator Rule}
A {\em format-separator-character} must be in the pre-lexical context of
a pair of matched {\em quotes}.  Otherwise it is a {\em word-character}.

{\bf Angle Rule.}\index{Angle Rule}
An {\em angle-character} must be either preceded by or followed by a copy
of itself.  Otherwise it is a {\em word-character}.

Quote Examples:

\begin{indpar}[0.1in]
\begin{tabular}{@{}l@{\hspace*{0.3in}}l}
			& Pre-Lexeme Sequence		\\
Input String		& with {\em spaces} represented by \verb|_|'s \\[1ex]
\verb|I said `Hello'.|	& \tt I~~\verb|_|~~said~~\verb|_|~~`~~Hello~~'~~.	\\
\verb|Re`op 'tis.  But!|
			& \tt Re`op~~\verb|_|~~'tis.%
			  ~~\verb|__|~~But! \\
\verb|`Like 'tis'|	& \tt `~~Like~~\verb|_|~~'~~tis'	\\
\verb|``Like 'tis''|	& \tt ``~~Like~~\verb|_|~~'tis~~''	\\
\verb|`Like me''|	& \tt `~~Like~~\verb|_|~~me''		\\
\verb|`` `Hello' is a word.''|
			& \tt ``~~\verb|_|~~`~~Hello~~'~~\verb|_|~~is%
			  ~~\verb|_|~~a~~\verb|_|~~word.~~'' \\
\end{tabular}
\end{indpar}

Other rules of PCASL (\ref{LEXEMES})
limit the semantic content
of {\em white-space}, so that there is no problem putting
space between the \verb|``| and \verb|`| in the last example.

Angle and Format Separator Examples:

\begin{indpar}[0.1in]
\begin{tabular}{@{}l@{\hspace*{0.6in}}l}
			& Pre-Lexeme Sequence		\\
Input String		& with {\em spaces} represented by \verb|_|'s \\[1ex]
\verb|x <= y |		& \tt x \verb|_| \verb|<=| \verb|_| y	\\
\verb|x <<= y |		& \tt x \verb|_| \verb|<<| = \verb|_| y	\\
\verb/x = y|z/		& \tt x \verb|_| = \verb|_| \verb/y|z/ \\
\verb/x = `y|z'/	& \tt x \verb|_| = \verb|_|
                              \verb|`| y \verb/|/ z \verb|'| \\
\end{tabular}
\end{indpar}

\subsubsection{White Space Conversion}

A \key{white-space} lexeme does not have exactly the same characters
that were input to create it, unlike other pre-lexemes.  The
sequence of {\em white-space-characters} input to create a
{\em white-space} lexeme is modified as follows to create the lexeme:

{\bf Line End Spaces Rule.}\index{Line End Spaces Rule}
All {\em horizontal-space} characters preceeding a {\em vertical-space}
character are deleted.  Thus spaces at line ends are ignored.

{\bf Carriage Return Rule.}\index{Carriage Return Rule}
Each {\em carriage-return} and all {\em horizontal-spaces} preceding
it are deleted.  Thus the lexeme has no {\em carriage-returns}.

{\bf Horizontal Tab Rule.}\index{Horizontal Tab Rule}
Each {\em horizontal-tab} is replace by {\em spaces} assuming that
horizontal tab stops are set every 8 columns.
Thus the lexeme has no {\em horizontal-tabs}.

Note that these rules do \underline{not} alter the printed appearance
of the {\em white-space} lexeme.

After these rules are applied, a {\em white-space} lexeme consists of
only of {\em vertical-space-characters} followed by {\em space} characters.
{\em White-space} lexemes are only pre-lexemes; they are deleted
when pre-lexemes are converted to lexemes.  The rules that
form the lexeme sequence ensure that all
{\em vertical-space} characters are equivalent
(\ref{INDENTATION-LEXEMES}).


\subsection{Lexemes}
\label{LEXEMES}

The sequence of pre-lexemes is converted to a sequence of lexemes
according to the following rules, which we will describe in the
order given:

\begin{indpar}[1in]
Numbers \\
Post Separators \\
Indentation Lexemes
\end{indpar}

The syntax equations defining a lexeme are:

\begin{indpar}
\key{lexeme} ::= {\em word} $|$ {\em separator}
		$|$ {\em opening-mark}
		$|$ {\em closing-mark} \\[1ex]
\key{separator} ::= {\em format-separator}
		$|$ {\em post-separator} \\[1ex]
\key{indentation-lexeme} ::= \verb|;|
			 $|$ \verb|{|
			 $|$ \verb|}|
\end{indpar}

{\em Post-separators} are single characters removed from the
ends of {\em pre-words}.  A {\em Word} is what is left of
a {\em pre-word} after any {\em post-separators}
are removed from its end.
{\em Words} and {\em post-separators} are defined
below in \ref{POST-SEPARATORS}.


The {\em indentation-lexemes} are lexemes implied by indentation, and
are not distinguishable from explicit lexemes, namely the post-separator
\verb|;|, the {\em opening-mark} \verb|{|, and the {\em closing-mark}
\verb|}|.  They are defined below in
\ref{INDENTATION-LEXEMES}.

{\em White-space} pre-lexemes are used only to define indentation and
create {\em indentation-lexemes}.
Then {\em white-space} pre-lexemes are
discarded: they are not {\em lexemes}.

[TBD: what about use of whitespace in text.]

{\em Format-separators}, {\em opening-marks}, and {\em closing-marks}
are both pre-lexemes and lexemes.

\subsubsection{Number Lexemes}
\label{NUMBER-LEXEMES}

The rule for spliting a {\em pre-word} into a {\em word}
and a {\em separator} makes reference to {\em words} that are
{\em numbers}, saying that splitting is preferred if the {\em word}
resulting from the split is a {\em number}.  Some of the syntax equations
defining {\em numbers} are as follows.

\begin{indpar}
\key{number} ::= {\em real-number} $|$ {\em unit-number}
				   $|$ {\em complex-number} \\[1ex]
\key{real-number} ::= {\em unsigned-real-number}
                  $|$ {\em sign} {\em unsigned-real-number}
		      \\[1ex]
\key{sign} ::= \verb|+| $|$ \verb|-| \\[1ex]
\key{unsigned-real-number} ::= {\em unexponented-number}
		$|$ {\em unexponented-number} {\em exponent} \\[1ex]
\key{unexponented-number} ::= {\em decimal-number}
			  $|$ {\em decimal-ratio}
			  $|$ {\em radixed-number} \\[1ex]
\key{decimal-number} \begin{tabular}[t]{rl}
                     ::= & {\em decimal-natural} \\
		     $|$ & {\em decimal-natural} \verb|.|
		           {\em decimal-natural} \\
		     $|$ & \verb|.| {\em decimal-natural}
		     \end{tabular} \\[1ex]
\key{decimal-natural} ::= {\em decimal-digits}
		     $|$ {\em decimal-natural} \verb|,| {\em decimal-digits}
		     \\[1ex]
\key{decimal-digits} ::= {\em digit} {\em digit}$^\star$ \\[1ex]
\key{decimal-ratio} ::= {\em decimal-natural} \verb|/|
			{\em decimal-natural} \\[1ex]
\key{exponent} ::= {\em exponent-indicator}
		   {\em exponent-sign-and-digits} \\[1ex]
\key{exponent-indicator} ::= \verb|e| $|$ \verb|E| $|$ \verb|^| \\[1ex]
\key{exponent-sign-and-digits} ::= {\em decimal-digits}
			    $|$ {\em sign} {\em decimal-digits}
\end{indpar}

Real Decimal Number Examples:

\begin{indpar}[0.1in]
\tt
\begin{tabular}{l@{~~~~~}l@{~~~~~}l@{~~~~~}l@{~~~~~}l}
123	& -123		& +123		& 1,234		& -1,234,567 \\
123.0	& -.123		& +0.0		& +.000		& 1,234.987,654 \\
123e0	& -123e+2	& +123e-321	& 1,234e9	& -0.123,456e-3 \\
123E0	& -123E+2	& +123E-321	& -0.123,456e-3	& -1,234.567890	\\
1/2	& -3/4		& +1,234/5	& 1,234/5,432	& -53/000 \\
1,2	& 1.86,54	& .123,45,6	& 1,2345678	& 1.2345678,92
\end{tabular}
\end{indpar}

In a {\em decimal-number} the decimal point
must be followed by a digit.  Commas must be surrounded by digits,
and should be
every 3 digits from the decimal point, or every three digits
from the end if there is no decimal point.  If there is any comma at all,
there must be commas
every 3 digits, except that commas may be used in the integer part 
without any being used in the faction part.
Incorrect numbers of digits between commas will result in an
error when the lexeme is converted to a number,
but is \underline{not} an error of lexeme formation.  The last line of
examples above are therefore legal lexemes that will give errors when
converted to numbers.

Similarly there will be an error converting a {\em decimal-ratio} to a
number if the denominator equals zero, but the ratio will still be a legal
lexeme.  \verb|-53/000| is an example.

\ikey{Radixed-numbers}{radixed-number} permit binary, octal, or hexadecimal
radices to the used instead of decimal.  In fact, other number representation
schemes are permitted.

\begin{indpar}
\key{radixed-number}::= {\em radix-indicator}
		        \verb|`| {\em radixed-number-mark}
		        {\em radix-number-mark}$^\star$ \verb|'|
		        \\[1ex]
\key{radix-indicator} ::= {\em letter} {\em letter}$^\star$ \\[1ex]
\key{radixed-number-mark} ::= {\em digit} $|$ {\em letter}
                      $|$ \verb|.| $|$ \verb|,| $|$ {\em sign}
\end{indpar}

Radixed Number Examples:

\begin{indpar}[0.1in]
\tt
\begin{tabular}{l@{~~~~~}l@{~~~~~}l@{~~~~~}l}

B'10110100'	& O'77534201'	& D'19758'	& X'FE8A932B' \\
B'101101'e+2	& O'0.7753'e-5	& D'197.58'	& X'0.FE8A932B' \\
B'10,1101'	& O'12,3456'e-5	& D'0.123,5'	& X'FE8A,932B.7CCD,83' \\
\end{tabular}
\end{indpar}


The following {\em radix-indicators} are standard.

\begin{center}
\begin{tabular}{l@{~~~~~}l@{~~~~~}l@{~~~~~}l}
Radix	& Radix		 &			& Allowed Digits \\
Name	& Indicators     & Allowed Digits	& Between Commas \\[1ex]
binary	& \tt b~~~B	 & \tt 0 1		& 4 or 8 \\
octal	& \tt o~~~O	 & \tt 0 1 2 3 4 5 6 7	& 3 \\
decimal	& \tt d~~~D	 & \tt 0 1 2 3 4 5 6 7 8 9
						& 3 \\
hexadecimal
	& \tt x~~~X	 & \tt 0 1 2 3 4 5 6 7 8 9
						& 4 or 8 \\
	&		 & \tt a b c d e f A B C D E F
\end{tabular}
\end{center}

{\em Radixed-numbers} can be legal lexemes and still be unconvertable to
numbers because their {\em radix-indicators} are undefined, they
have digits not defined for the given {\em radix-indicator}, they
have too many decimal points, and so forth.  These errors are detected
when the lexemes are converted to numbers.  On the other hand, it
is possible to define non-standard converters for converting
{\em radixed-number} lexemes to numbers, and thereby increase the
space of number representations.


\ikey{Unit-numbers}{unit-number} are just {\em real-numbers} with a
{\em unit-indicator} prefixed or postfixed.

\begin{indpar}
\key{unit-number} ::= {\em pre-unit-indicator} {\em real-number}
		  $|$ {\em real-number} {\em post-unit-indicator} \\[1ex]
\key{pre-unit-indicator} ::= \verb|$| $|$ {\tt \pounds} \\[1ex]
\key{post-unit-indicator} ::= \verb|'| $|$ \verb|"| $|$ $^\circ$ \\[1ex]
\key{unit-indicator} ::= {\em pre-unit-indicator}
		     $|$ {\em post-unit-indicator}
\end{indpar}

However, unit numbers are not lexemes.

{\bf Unit Number Rule.}\index{Unit Number Rule}
If a {\em unit-number} is to be output as a {\em word} lexeme, then instead
the {\em unit-number} is split into two {\em word} lexemes, one of which
is the {\em real-number} part and the other of which is a 1-character
{\em word} consisting of the {\em unit-indicator}.

Unit Number Examples:

\begin{indpar}[0.1in]
\begin{tabular}{@{}l@{\hspace*{0.3in}}l}
Unit Number		& Lexeme Sequence	\\[1ex]
\tt \$5.71		& \tt \$~~5.71 \\
\tt \pounds -5.71	& \tt \pounds ~~-5.71 \\
\tt 15'			& \tt 15~~' \\
\tt -2.543e3"		& \tt -2.543e3~~" \\
\tt 72$^\circ$		& \tt 72~~$^\circ$ \\
\tt X'BE63'e-2$^\circ$	& \tt X'BE63'e-2~~$^\circ$
\end{tabular}
\end{indpar}

An {\em imaginary-number} is just a {\em real-number} with an
{\em imaginary-indicator}, e.g.~\verb|i|, post-fixed.  A
{\em complex-number} is just an {\em imaginary-number}
or a {\em real-number} followed by
a {\em sign} followed by an {\em imaginary-number}.

\begin{indpar}
\key{complex-number} ::= {\em imaginary-number}
		$|$ {\em real-number} {\em signed-imaginary-number} \\[1ex]
\key{imaginary-number} ::= {\em unsigned-imaginary-number}
		$|$ {\em signed-imaginary-number} \\[1ex]
\key{signed-imaginary-number} ::=
		{\em sign} {\em unsigned-imaginary-number} \\[1ex]
\key{unsigned-imaginary-number} ::=
		{\em unsigned-real-number} {\em imaginary-indicator} \\[1ex]
\key{imaginary-indicator} ::=     \verb|I|
			      $|$ \verb|i|
			      $|$ \verb|J|
			      $|$ \verb|j|
\end{indpar}

Complex Number Examples:

\begin{indpar}[0.1in]
\tt
\begin{tabular}{l@{~~~~~}l@{~~~~~}l}

3i		& +3j		& -X'FE90.34D2'I		\\
2+3i		& -3+3.345e10j	& 35-X'FE90.34D2'J		\\
\end{tabular}
\end{indpar}

\subsubsection{Post Separators}
\label{POST-SEPARATORS}

Informally, a post-separator is a 1-character separator that immediately
follows a word and could be part of that word.  Examples are the comma, period,
and the exclamation point.  There are two kinds of post separators:
weak and strong.  The Post Separator Rule
given below tells when a {\em pre-word} ending
in a {\em post-separator-character}
must be split into smaller {\em pre-word} and a 1-character
{\em separator}.  This rule makes reference to {\em words} that are
{\em numbers}, saying that splitting is preferred when the
{\em post-separator-character} is weak if the {\em word}
resulting from the split is a {\em number}.

The syntax equations required are:

\begin{indpar}
\key{separator} ::= {\em format-separator}
		$|$ {\em post-separator} \\[1ex]
\key{post-separator} ::= {\em post-separator-character} \\[1ex]
\key{post-separator-character} \begin{tabular}[t]{rl}
                     ::= & {\em strong-post-separator-character} \\
		     $|$ & {\em weak-post-separator-character}
		     \end{tabular} \\[1ex]
\key{strong-post-separator-character} ::=     \verb|,|
			                $|$ \verb|;|
					\\[1ex]
\key{weak-post-separator-character} ::=     \verb|!|
				        $|$ \verb|?|
			                $|$ \verb|:|
			                $|$ \verb|.|
					\\[1ex]
\key{pre-word} ::= {\em word}
		$|$ {\em pre-word} {\em post-separator-character}
\end{indpar}

{\bf Post Separator Rule.}\index{Post Separator Rule}
A {\em pre-word} of 2 or more characters
that ends with a {\em post-separator-character}
is split into a smaller {\em pre-word} and a {\em post-separator}
if (1) the {\em post-separator-character} is strong, or if
(2) the smaller {\em pre-word} is a {\em number}, or if
(3) the smaller {\em pre-word} does 
\underline{not} contain a copy of the {\em post-separator-character}.
If the {\em pre-word} is not split, it becomes a {\em word} lexeme.

The following rule handles the case of 1-character {\em pre-words}.

{\bf Isolated Post Separator Rule.}\index{Isolated Post Separator Rule}
A {\em pre-word} that consists of a single {\em post-separator-character}
is a {\em post-separator} lexeme.


Examples:

\begin{indpar}[0.1in]
\begin{tabular}{@{}l@{\hspace*{0.3in}}l@{~~~}l@{\hspace*{0.6in}}l}
Pre-Word		& \multicolumn{2}{@{}l@{}}{Lexeme Sequence}
							& Splits?	\\[1ex]
\verb|hello.|		& \tt hello 		& \tt .	& yes		\\
\verb|X,|		& \tt X 		& \tt ,	& yes		\\
\verb|h.e.l.l.o.|	& \tt h.e.l.l.o.	&	& no		\\
\verb|e.g.|		& \tt e.g.		&	& no		\\
\verb|5.0.|		& \tt 5.0		& \tt .	& yes		\\
\verb|1,234.5,|		& \tt 1,234.5		& \tt ,	& yes		\\
\verb|1,234.5,,|	& \tt 1,234.5		& \tt ,~~,
							& yes, twice	\\
\verb|1,234.5.,|	& \tt 1,234.5		& \tt .~~,
							& yes, twice	\\
\verb|help!|		& \tt help		& \tt !	& yes		\\
\verb|!help!|		& \tt !help!		&	& no		\\
\verb|help.!|		& \tt help		& \tt .~~!
							& yes, twice	\\
\verb|.help.!|		& \tt .help.		& \tt !
							& yes, once	\\
\verb|!.help.!|		& \tt !.help.!		&	& no		\\
\end{tabular}
\end{indpar}

\subsubsection{Indentation Lexemes}
\label{INDENTATION-LEXEMES}

{\em Indentation-lexemes} are implied by indentation.  The
\mkey{indentation}{of line} of a line is the
the number of {\em space} characters in the {\em white-space}
pre-lexeme just before the first non-{\em white-space} pre-lexeme
of the line.  Note that lines cannot be empty; empty lines are
merged into {\em white-space} pre-lexemes.

At any given point in the scan of pre-lexemes, there is a
stack of indentation records, called the \key{indentation stack}.
An \key{indentation record} is a number of
columns, a pre-lexical context, and a flag.
The number of columns is called the \key{indentation}.
The flag is called the \key{implicit bracket flag}, and indicates whether
or not an implied \verb|{| lexeme was inserted at the same time the
indentation record was pushed onto the indentation stack.

Initially the indentation stack contains a single indentation record with
0 indentation, the outermost pre-lexical context,
and an off implicit bracket flag.
The stack cannot become empty; any operation that would
pop the last indentation off the stack announces an error and leaves the
stack alone.  Thus the bottommost indentation on the stack is always
the same.

The indentation in the indentation record at the top of the indentation
stack is called the \key{current indentation}, and the pre-lexical
context in that record is called the \key{current pre-lexical context}.

{\bf Semi-Colon Rule.}\index{Semi-Colon Rule}
If the first non-{\em white-space} pre-lexeme of a line is neither
\verb|{| nor \verb|}|, if that pre-lexeme is in
the current pre-lexical context, and if the indentation of the line
is the current indentation, and if the last lexeme output was not
a \verb|;| {\em separator} lexeme or a \verb|{| {\em opening-mark}
lexeme (including an implied {\em opening-mark} as in the
Implicit-Bracket Rule below), then a \verb|;| implied {\em separator}
lexeme is output
before any lexemes generated by the line are output.

{\bf Explicit-Bracket Rule.}\index{Explicit-Bracket Rule}
If the last pre-lexeme of a line is \verb|{|, then an indentation record
is pushed into the indentation stack just after the \verb|{| lexeme
is output.  The indentation in the record is the indentation of the next
line, the pre-lexical context is that in effect just after the \verb|{|,
and the implicit bracket flag is off.
The pushed indentation record is popped just after its pre-lexical context
ends; that is, just after reading the \verb|}| pre-lexeme that matches the
\verb|{| pre-lexeme that pushed the indentation record.

{\bf Implicit-Bracket Rule.}\index{Implicit-Bracket Rule}
If the last lexeme output for a line would be a post-separator \verb|:|,
then a \verb|{| implied {\em opening-mark} lexeme
is output instead of the \verb|:|, and an indentation
record is pushed into the indentation stack.  The indentation of the
record is the indentation of the next line, the implicit bracket flag
of the record is on, and the
pre-lexical context of the record is that of the \verb|:|.
The pushed record is popped (1) just before the first line such that
the line beginning pre-lexeme is in the record's pre-lexical context
and the line's indentation is less than the record's indentation,
or (2) at the end of the input pre-lexeme stream.
When the record is popped, a \verb|}| implied {\em closing-mark}
lexeme is output.

In order to avoid subtle errors created by indentation, there
is a {\tt minimum-indentation} parameter and the following rule.

{\bf Minimum-Indentation Rule.}\index{Minimum-Indentation Rule}
The indentation of any line must equal the current indentation
or differ from it by at least the value of the
\ttkey{minimum-indentation} parameter.  The {\tt minimum-indentation}
parameter defaults to {\tt 4}.


Indentation Lexeme Examples:

\begin{indpar}[0.1in]
\tt \ttbrackets
\begin{tabular}{@{}l@{~~~~~~~~~~}l}
{\rm Input String}		& {\rm Output Lexemes} \\[1ex]
hi \{ x; y z; w \}		& \tt hi \{ x ; y z ; w \} \\[1ex]
hi \{				& hi \{ \\
~~~~x				& x \\
~~~~y z				& ; y z \\
~~~~w \}			& ; w \} \\[1ex]
hi				& hi \\
\{				& \{ \\
~~~~x				& x \\
~~~~y z				& ; y z \\
~~~~w				& ; w \\
\}				& \} \\[1ex]
hi:				& hi \{ \\
~~~~x				& x \\
~~~~y z				& ; y z \\
~~~~w				& ; w \\
				& \} \\[1ex]
hi \{				& hi \{ \\
~~~~x				& x \\
~~~~y `this			& ; y ` this \\
is another pre-lexical		& is another pre-lexical \\
context.			& context . \\
' foo bar			& ' foo bar \\
~~~~w \}			& ; w \} \\[1ex]
hi \{				& hi \{ \\
~~~~x				& x \\
~~~~y \{			& ; y \{ \\
ho				& ho \\
hum \} z			& ; hum \} z \\
~~~~w \}			& ; w \}
\end{tabular}
\end{indpar}


\section{Expressions}

An expression is a sequence of words, separators, and subexpressions.
A subexpression is a pair of matched lexemes and all the lexemes in
between.

Expressions and subexpressions can contain operators.  When they do,
matched implied parentheses are inserted into the expressions or subexpressions
according to rules of operator precedence and associativity, and these
implied parentheses create new subexpressions.

Expressions and subexpressions that do not contain operators may contain
argument lists and qualifying phrases.  The order in which qualifying
phrases appear does not matter, and sometimes the order of arguments
in an argument list does not matter.

Expressions containing operators are restructured, both by inserting
implied parentheses and in other ways.  Subexpressions surrounded by
particular matching lexemes, such as \verb|`'|, are restructured.

The process of restructuring expressions is called \key{parsing}.
Parsing takes an expression as input, and produces as output a raw
expression that contains nothing that will trigger further restructuring.

\subsection{Subexpressions}
\label{SUBEXPRESSIONS}

The first step in parsing is to identify \skey{subexpression}s within
an expression, without restructuring the expression, by applying
the following syntax equations.

\begin{indpar}
\key{expression} ::= {\em expression-item}$^\star$ \\[1ex]
\key{expression-item} ::= {\em word} $|$ {\em separator}
				     $|$ {\em subexpression} \\[1ex]
\key{subexpression} ::= {\em opening-mark} {\em expression}
			{\em closing-mark}
\end{indpar}

{\bf Subexpression Rule.}\index{Subexpression Rule}
The {\em opening-mark} lexeme that begins a subexpression
must match (\ref{MATCHING}) the {\em closing-mark} lexeme that
ends a subexpression.

\subsection{Expression Structure}
\label{EXPRESSION-STRUCTURE}

Expression structure is affected by three special marks.
The \key{reorder mark} (\ttkey{<:>}) separates arguments that can be
reordered, as in the expression `\verb|element LIST <:> INDEX|', and is used in
expression definitions.
The \key{remainder mark} (\ttkey{::>}) preceeds a final argument in an
expression definition that represents the list of remainding arguments in a use
of the definition, as in the expression `\verb|max ::> ARGS|'
where \verb|ARGS| represents
the list of all the arguments given to \verb|max|.
The \key{qualifier mark} (\ttkey{@@@}) signals that the following
expression item is a qualifier, as in the expression
`\verb|sort x @@@ ascending|',
and is implied by qualifiers (e.g. \verb|with|, \verb|has|,
\verb|ascending|) in an expression.

Expressions are restructured if they contain operators (e.g.,
\verb|+|,
\verb|-|,
\verb|*|,
\verb|/|),
qualifiers (e.g.,
\verb|with|,
\verb|has|,
\verb|ascending|),
or certain matching lexemes.  A \key{raw expression}
(\ref{RAW-EXPRESSIONS})
is a particular kind of expression that will not be
restructured.  The only special marks that may be in a raw expression
are the reorder mark (\verb|<:>|), the remainder mark (\verb|::>|),
and the qualifier mark (\verb|@@@|).
Translating
an expression into a raw expression is called \key{parsing}.

Matching lexemes may affect parsing.
An informal summary of some of these is:

\begin{center}
\begin{tabular}{lll}
Brackets   & Turns Off			& Turns On \\[1ex]

\verb|[]|  & operators, qualifiers, \verb/|/, text
					& \verb|<:>|, \verb|::>|, \verb|@@@| \\
\verb|[< >]|  & \verb/|/, text		& operators, qualifiers,
					  \verb|<:>|, \verb|::>|, \verb|@@@| \\
\verb|()|  & nothing			& nothing \\
\verb|{}|  & eval, \verb/|/, text	& operators, qualifiers,
					  \verb|<:>|, \verb|::>|, \verb|@@@| \\
\verb|<<>>|  & \verb/|/, text		& eval, operators, qualifiers,
					  \verb|<:>|, \verb|::>|, \verb|@@@| \\
\verb|`'|  & eval, operators, qualifiers,
					& \verb/|/, text \\
	   & \verb|<:>|, \verb|::>|, \verb|@@@|
\end{tabular}
\end{center}

Other matching lexemes may be made to affect parsing by introducing
operator definitions (\ref{OPERATOR-DEFINITIONS}).

Parsing is controlled by the \key{parsing context}, which consists
of a \key{parsing parser stack} and a \key{parsing definition stack}.

There are three standard \ikey{parsers}{parser!standard}:
the \key{marks parser} \ttkey{-MARKS-PARSER-},
where only the reorder mark (\verb|<:>|),
remainder mark (\verb|::>|), and the qualifier mark (\verb|@@@|) are recognized,
the \key{operators parser} \ttkey{-OPERATORS-PARSER-},
where these marks
are recognized along with operators and qualifiers,
and the \key{text parser} \ttkey{-TEXT-PARSER-},
where only the format-separator (\verb/|/)
is recognized.
An opening mark may change the parser by
pushing a new parser into the parsing
parser stack whose top member is the effective parser for subexpressions.
The corresponding closing mark will pop the parsing parser
stack.

From the parsing point of view there are several types of
expression restructuring that can occur.  One, text restructuring,
is done by the text parser, which is invoked by
\verb|`'| quotes, and does things like turn
\verb|`I am!'| into \verb|[sentence I am !]|.  A second kind of
restructuring, which is done by all standard parsers,
enforces the rule that the first item of an expression with no
operators cannot be a subexpression or qualifier,
by inserting the word \verb|-EMPTY-| at the
beginning of the expression if necessary, as when
\verb|((integral x) from 0)| is restructured as
\verb|(-EMPTY- (integral x) from 0)|.  Lastly, operators (\ref{OPERATORS}),
as recognized by the operators parser,
can cause major restructuring of an expression,
as when \verb|x + y - 5 * z| is restructured as \verb|[- [+ x y] [* 5 z]]|,
and qualifiers, also recognized by the operators parser,
can cause qualifier marks (\verb|@@@|) to be inserted, as when
\verb|sort x| \verb|ascending|
is restructured as
\verb|[sort x @@@ ascending]|.

In expressions that cannot contain operators
or qualifiers, words and separators that would be recognized as operators
or qualifiers elsewhere are not recognized as such.  Thus in
\verb|[word +]| the \verb|+| is not recognized as an operator, and
in \verb|[item ascending]| \verb|ascending| is not recognized as
a qualifier.

Some matching lexemes above affect evaluation (eval).
Evaluation differs from parsing context in that it is managed by a
counter and not a stack; if evaluation is
turned off twice, it must be turned on twice to be in effect.
Thus in a context in which evaluation is on, the \verb|X| in
\verb|{ <<X>> = 5 }| and \verb|{ y = `<< <<X>> >>' }| will be evaluated
but the \verb|X| in \verb|{ y = `<<X>>' }| will not be.  There is
an \key{evaluation counter} value that is
incremented (decremented) by an opening mark
that turns evaluation on (off), and decremented (incremented) by the
corresponding closing mark.  This counter sticks at +1: matching
lexemes that would increment the counter have no affect if the counter
is at +1.

Evaluation is also not part of parsing; the evaluation counter is
used during expression evaluation, which occurs after expression parsing.
Parsing does insert the wrappers (\ref{OPERATOR-WRAPPER})
\ttkey{-EVAL-ON-} and \ttkey{-EVAL-OFF-} around expressions to inform
the evaluator when to increment or decrement the evaluation counter.

\subsection{Raw Expressions}
\label{RAW-EXPRESSIONS}

A raw expression is an expression that contains no operators,
qualifiers, or text parsing contexts that induce restructuring.
Also, all raw expressions must begin with a word or separator.
Raw expressions can be directly represented using the \verb|[]|
matching lexemes and the \verb|<:>| reorder, \verb|::>| remainder, and 
\verb|@@@| qualifier marks.

When an expression is parsed, the output is a raw expression.
The following are examples, all of which are assumed to
appear in the context of \verb|{}| matching lexemes (so
operators and qualifiers are turned on and text parsing is turned off):

\begin{center}
\begin{tabular}{ll}
Input Expression	& Raw Expression Equivalent \\[1ex]
\verb|3*x*x + 5|	& \verb|[+ [* [* 3 x] x] 5]| \\
\verb|x = y = 10|	& \verb|[= x [= y 10]]| \\
\verb|0 < x <= 5 |	& \verb|[-COMPARE- 0 < x <= 5]| \\
\verb|x = `Hello <<y>>.' |
			& \begin{tabular}[t]{@{}l}
	    \verb|[= x [-EVAL-OFF-| \\
	    \verb|      [sentence Hello| \\
	    \verb|                [-EVAL-ON- y]| \\
	    \verb|                .]]]| \\
	    \end{tabular}
\end{tabular}
\end{center}

The syntax of raw expressions is defined as follows:

\begin{indpar}
\key{raw-expression} ::= {\em word} $|$ {\em separator}
				     $|$ {\em raw-subexpression} \\[1ex]
\key{raw-subexpression} ::=
	\begin{tabular}[t]{@{}ll}
	\verb|[| & {\em raw-expression-head} \\
		 & {\em raw-argument-list} \\
		 & {\em raw-qualifier-phrase}$^\star$ \verb|]| \\
	\end{tabular} \\[1ex]
\key{raw-expression-head} ::= {\em word} $|$ {\em separator} \\[1ex]
\key{raw-argument-list} ::=
	    {\em raw-base-argument-list}
	    {\em raw-argument-remainder-option} \\[1ex]
\key{raw-base-argument-list}
        \begin{tabular}[t]{@{}rl}
	::= & {\em empty} \\
	$|$ & {\em raw-argument}
	    \{ {\em reorder-mark-option} {\em raw-argument} \}$^\star$
	\end{tabular} \\[1ex]
\key{reorder-mark-option} ::= {\em empty} $|$ \verb|<:>| \\[1ex]
\key{reorder-argument-remainder-option} ::=
	{\em empty} $|$ \verb|::>| {\em raw-argument} \\[1ex]
\key{raw-argument} ::= {\em raw-expression} \\[1ex]
\key{raw-qualifier-phrase} ::=
	\verb|@@@| {\em raw-qualifier-head} {\em raw-argument-list} \\[1ex]
\key{raw-qualifier-head} ::= {\em word} $|$ {\em separator}
\end{indpar}

The order of {\em raw-qualifier-phrases}
in a {\em raw-expression} does not matter.
The order of arguments separated by {\em reorder-marks} (\verb|<:>|) does
not matter.  Both {\em reorder-marks} (\verb|<:>|) and {\em remainder-marks}
(\verb|::>|) can only occur in the head of an expression definition
(\ref{TBD}).

\subsection{Operators}
\label{OPERATORS}

Operators restructure expressions in which they occur.  Operators
are defined by operator definitions that can be added to the current
operator context by some operators.

\subsubsection{Operator Definitions}
\label{OPERATOR-DEFINITIONS}

The parsing definitions stack
contains \skey{operator definition}s and qualifier definitions.
An operator definition specifies for each operator the following:

\begin{indpar}[1in]
Fixity \\
Name \\
Precedence \\
Associativity \\
Parser \\
Control Flags \\
Wrapper \\
Subdefinitions
\end{indpar}


\subsubsubsection{Operator Fixity}\ttmindex{fixity}{of operator}
\label{OPERATOR-FIXITY}
An operator has one of the following fixities:

\begin{indpar}
\begin{tabular}{@{}p{1in}@{~~~}p{4in}@{}}
\ttkey{infix}		& E.g., \verb|+| in \verb|x + 5|.\\
\ttkey{prefix}		& E.g., \verb|-| in \verb|- 5|.\\
\ttkey{postfix}		& E.g., \verb|!| in \verb|x!|.\\
\ttkey{matchfix}	& E.g., \verb/[| |]/ in \verb/[| x - 5 |]/.
\end{tabular}
\end{indpar}

An infix operator is placed between its two operands;
a prefix operator is placed before its one operand;
a postfix operator is placed after its one operand;
and a matchfix operator surrounds its one operand.
Operands of prefix, infix, and postfix
operators may not be empty; but the operand of a matchfix operator
may be empty.
An infix operator may not begin or end an expression;
a prefix operator must begin an expression;
a postfix operator must end an expression;
and a matchfix operator has two parts: an opening operator
that must begin an expression and a closing operator that must end
the same expression.

\subsubsubsection{Operator Name}\ttmindex{name}{of operator}
\label{OPERATOR-NAME}
An operator definition has a sequence of lexemes that is the
{\em name} of the operator.  The operator
inside a subexpression is just this sequence of lexemes, except for
matchfix operators, which have two sequences of lexemes, an
\key{opening operator name} that must begin the subexpression and
a \key{closing operator name} that must end the subexpression.

By abuse of language, the term `\key{operator}' is often used
as a synonym for `operator name'.  Similarly `\key{opening operator}'
is used as a synonym for `opening operator name' and `\key{closing operator}'
is used as a synonym for `closing operator name'.

The opening and closing names of a matchfix
operator are bundled into a single operator name that is
sequence of lexemes consisting of
the opening operator name followed by a `\verb/.../' lexeme
followed by the closing operator name.
For example, the
matchfix operator named `\verb/[ | ... | ]/' permits subexpressions
like `\verb/[| x - 5 |]/'.  Here the opening operator name
is `\verb/[|/' and the closing operator name is `\verb/|]/'.

Opening and closing marks cannot be part of an operator name
unless the operator is a matchfix operator.
If opening and closing marks are part of a matchfix operator
name, they must begin and end the name, and they must not be
parentheses \verb|()|.

When a subexpression is tested
for matchfix operators, any opening and closing marks that begin and
end the subexpression are included in the subexpression, unless they are
parentheses \verb|()|, which are always removed (recursively) when they
begin and end a subexpression, and are thus invisible.  Thus
the matchfix operator `\verb/| ... |/' could be invoked by
the expression `\verb/x + (| y |)/'.  Operator names are not permitted
to include parentheses \verb|()|, so names such as `\verb/|( ... )|/'
are erroneous.
Generally, including extra pairs of parentheses
\verb|()| has no affect on expression parsing or expression meaning,
though the explicit parentheses in `\verb/[(|x|)]/' will prevent 
a matchfix operator named `\verb/[| ... |]/' from being recognized.

\subsubsubsection{Operator Precedence}\ttmindex{precedence}{of operator}
\label{OPERATOR-PRECEDENCE}
The precedence of an operator is an integer.  Precedence is used in
selecting which infix operators in an expression to consider
(\ref{OPERATOR-SELECTION}).
Only infix operators have precedence.

\subsubsubsection{Operator Associativity}\ttmindex{associativity}{of operator}
\label{OPERATOR-ASSOCIATIVITY}
An infix operator has an {\em associativity} that is
a sequence of lexemes.
Three associativities, {\tt left}, {\tt right}, and
{\tt none}, have special meaning.  If an infix operator has some
other associativity, it is said to have \key{named associativity}.
Only infix operators have associativity.

If more than one infix operator is selected in an expression by the operator
selection algorithm\EOL (\ref{OPERATOR-SELECTION}),
all the infix operators that are selected
must have the identical operator definitions except for operator names,
and the associativity in these definitions
must not be {\tt none}\ttmindex{none}{associativity}.

If all operators are {\tt left} associative%
\index{left associative@{\tt left} associative},
all the infix operators but the rightmost are deselected,
so it is as if operators to the left had
higher precedence than those to the right.

If all operators are {\tt right} associative%
\index{right associative@{\tt right} associative},
all the infix operators but the leftmost are deselected,
so it is as if operators to the right had
higher precedence than those to the left.

If all operators are of \key{named associativity}, all remain selected, and 
implicitly parenthesized subexpressions will be created between the
operators as well as between the beginning of the expression and the
first operator and between the last operator and the end of the expression.
Then the associativity, as a lexeme sequence, is prepended to the expression.
Thus if the infix operators \verb|<| and \verb|<=| have associativity
\verb|-COMPARE-|, the expression \verb|0 < x - 3 <= 5| will
be rewritten as \verb|[-COMPARE- 0 < (x - 3) <= 5]|.

\subsubsubsection{Operator Parser}\ttmindex{parser}{of operator}
\label{OPERATOR-PARSER}

A parser is the name of the function that is called with a expression
as its single argument in order to parse the expression.

The parser used for subexpressions of an expression is the parser
at the top of the \key{parsing parser stack}.

The \verb|parser| of an operator definition is an optional word that
names a parser.  If present, the word is pushed into the parsing parser
stack before subexpressions are parsed, and then the parsing parser stack
is popped after subexpressions have been parsed.

The following are standard parsers:

\begin{indpar}

The \key{operators parser} \ttkey{-OPERATORS-PARSER-}.
Operators, qualifiers, and the
\verb|<:>| reorder, \verb|::>| remainder, and
\verb|@@@| qualifier marks are recognized.  The special constructs
of text parsing, e.g., the \verb/|/ format separator,
are \underline{not} recognized.

The \key{marks parser} \ttkey{-MARKS-PARSER-}.
The \verb|<:>| reorder, \verb|::>| remainder, and
\verb|@@@| qualifier marks are recognized.  Operators, qualifiers,
and the special constructs
of text parsing, e.g., the \verb/|/ format separator,
are \underline{not} recognized.

The \key{text parser} \ttkey{-TEXT-PARSER-}.
The special constructs of text parsing (\ref{TEXT-PARSING}) are
recognized.  Operators, qualifiers, and
the \verb|<:>| reorder, \verb|::>| remainder, and
\verb|@@@| qualifier marks are \underline{not} recognized.

\end{indpar}

\subsubsubsection{Operator Control Flags}\ttmindex{control flag}{of operator}
\label{OPERATOR-CONTROL-FLAGS}
Operators can be associated with \skey{operator control flag}s that
affect parsing of subexpressions of the operator.

\begin{indpar}

{\bf definitions}\index{definitions flag@{\tt definitions} flag}\\
This flag may only be given for a right associative infix operator.
It causes the
left operand of the operator to be inspected to see if it is an
operator or qualifier definition.  If no, nothing special is done.
If yes, the expression containing
the infix operator is replaced by just its right operand, the definition
in the left operand
is pushed onto the parsing definitions stack, the right operand is
parsed, and then the definition is popped off the parsing definitions stack.

\end{indpar}

\subsubsubsection{Operator Wrapper}\ttmindex{wrapper}{of operator}
\label{OPERATOR-WRAPPER}

An operator wrapper is a raw expression containing the lexeme `\verb|...|'.
If operator selection for an expression selects a single operator with a
wrapper, the expression is restructured to be a copy of the wrapper
with its `\verb|...|' lexeme replaced by the parse of the expression
being restructured.

For example, if the matchfix operator `\verb|<< ... >>|' has the
wrapper `\verb|-EVAL-ON- ...|', then the expression `\verb|<<x>>|'
will be restructured to be `\verb|-EVAL-ON- x|'.

\subsubsubsection{Operator Subdefinitions}\ttmindex{definition}{of operator}
\label{OPERATOR-SUBDEFINITIONS}

An operator definition can contain a list of definitions
that are pushed into the parsing definition stack before the subexpressions
of the operator are parsed, and are popped from the stack after the
subexpressions are parsed.  To avoid name confusion, these definitions
are called \skey{subdefinition}s.

Note that subdefinitions can include operator definitions, operator
undefinitions, qualifier definitions, and qualifier undefinitions.

\subsubsection{Operator Selection}
\label{OPERATOR-SELECTION}

To check an expression for operators, an operator selection algorithm is
run.  This algorithm selects operators whose name appears in the expression,
and then applies rules to deselect some selected operators.  If at the end
of the algorithm there is exactly one operator selected, the definition
of that operator is used to restructure the expression.  If there is more
than one operator selected, it is a parse error unless the definitions of
all selected operators are identical except for operator names.

The operator selection algorithm uses the current parsing definition stack
to determine which operators are defined.  The most important parts of each
definition are the operator name and operator fixity.

In the algorithm the concepts of prefix sequence and postfix sequence
are used.  A \key{prefix sequence} is a sequence of defined prefix operator
names.  A \key{postfix sequence} is a sequence of defined postfix operator
names.

In the \key{operator selection algorithm}, which is defined as follows,
the steps are executed in the order given, and
each step is repeated until it does nothing.

\begin{enumerate}

\item
Select any defined matchfix operator whose opening name
begins the expression and whose closing name ends the expression.

\item
If two matchfix operators are selected, the opening operator name
of the first is longer than the opening operator name of the second,
and the closing operator name
of the first is longer than the closing operator name of the second,
then the second operator is deselected.

Thus if `\verb/[| ... |]/' and `\verb/[ ... ]/' are two selected
matchfix operators, the second will be deselected.

\item
If more than one matchfix operator is still selected, the parse is in error.

\item
If a matchfix operator is selected, and the expression begins with
a prefix sequence that is not shorter than the opening name of the
matchfix operator, the parse is in error.
Similarly if a matchfix operator is selected, and the expression ends with
a postfix sequence that is not shorter than the closing name of the
matchfix operator, the parse is in error.

Thus if `\verb|- < ... > -|' is a defined matchfix operator and
`\verb|-|' is a defined prefix operator, but there is no defined
prefix operator whose name begins with the lexeme `\verb|<|',
parses of expressions containing the matchfix operator
will \underline{not} be in error.
But if there is another defined prefix operator named `\verb|<|',
parses of these expressions will be in error.

\item
If a matchfix operator is selected, the algorithm terminates successfully
at this point, without selecting any other operators.
The part of the expression between the opening operator name and closing
operator name is the sole operand of the matchfix operator.  This operand
is implicitly parenthesized, and may be empty.

\item
Select all defined infix operators that occur in the expression.

\item
Deselect any selected infix operator that overlaps or abuts
a prefix sequence that begins the expression.
Deselect any selected infix operator that overlaps or abuts
a postfix sequence that ends the expression.

Note that the empty sequence is both a prefix and a postfix sequence,
so infix operators that begin or end the expression are deselected.
For example, in the expression `\verb|+ x * y|' the prefix operator
`\verb|+|' is
deselected, and in the expression `\verb|+ + + x * y|' all the `\verb|+|'s are
deselected.

\item
On the set of selected infix operators define the \key{infix conflict relation}
to be the smallest equivalence relation such that two selected infix operators
conflict if they overlap or abut.

\item
Deselect any infix operator if it is not followed by a prefix sequence that
contains all other infix operators that conflict with the infix operator.
Deselect any infix operator if it is not preceded by a postfix sequence that
contains all other infix operators that conflict with the infix operator.
In checking for conflicting operators, check any infix operator selected
at the end of the previous step, whether or not it has been deselected
in this step.

Since the empty sequence is a prefix and postfix sequence, any infix operator
that does not conflict with any other infix operator will still be selected
at the end of this step.

The parse is in error if there is an equivalence class of
conflicting operators all
of whose members are deselected by this step.

\item
The parse is in error if two conflicting infix operators are still selected at
this point.

\item
If two infix operators are selected, and the first has strictly lower
precedence than the second, deselect the second.

\item
If several infix operators are still selected at this point, all these
operators must have the same associativity, which must not be `\verb|none|'.
Otherwise the parse is in error.

\item
If several infix operators are selected at this point and their common
associativity is `\verb|left|', all but the rightmost infix operator
are deselected.
Similarly if several infix operators are selected at this point and their common
associativity is `\verb|right|', all but the leftmost infix operator
are deselected.

\item
If several infix operators are still selected at this point, all these
operators must have the same definitions except for operator names.
Otherwise the parse is in error.

\item
If any infix operators are still selected at this point, the algorithm
terminates successfully.
The parts of the expression between the operators, before the first
operator, and after the last operator are the operands, and are
implicitly parenthesized.  No operand is empty.
If the common associativity of the infix operators is not
`\verb|left|',
`\verb|right|', or
`\verb|none|', this associativity as a lexeme sequence is prepended to the
expression, before the first operator.

\item
Select all prefix operators that begin the expression, and all postfix
operators that end the expression.

\item
If two prefix operators are selected, and one is longer than the other,
deselect the shorter.
Similarly, if two postfix operators are selected,
and one is longer than the other,
deselect the shorter.

\item
If more than one operator is selected at this point, the parse is in error.

\item
If one operator is selected at this point, and the operator name
is the entire expression, deselect the operator.  Thus
in the expression `\verb|x = (+)|', `\verb|+|' will be deselected
when the subexpression `\verb|(+)|' is parsed.

\item
The algorithm terminates successfully
at this point with zero operators selected,
or with one prefix or postfix operator selected.
If there is one selected operator, the part of the expression
that is not the operator name is the sole operand, and is implicitly
parenthesized.  Note this operand cannot be empty.

\end{enumerate}


The rules just given produce a result that is often the same as the
more common context free grammar rules for parsing expressions.  However,
there is a difference: in PCASL an operator can change the parsing context
used to parse its operand subexpressions.  See the sections on
operator parsers (\ref{OPERATOR-PARSER}),
operator control flags (\ref{OPERATOR-CONTROL-FLAGS}),
and operator subdefinitions (\ref{OPERATOR-SUBDEFINITIONS})
above.

\subsubsection{Selection Post-Processing}
\label{SELECTION-POST-PROCESSING}


\section{Expression Inference}

Expressions can be inferred to be true by inference and reduction rules.
Such \key{expression inference} is more basic than expression
evaluation, because to evaluate an expression you must first
infer it.  Inference rules can have associated blocks of code,
and the inference of an expression by a rule associates the rule's
block of code with the expression.  Evaluating that block of code
then evaluates the expression.  However, sometimes expressions are
inferred without being evaluated.

Inference and reduction rules are collected into sets of rules called
contexts.  An expression is inferred in some context.  Usually the
context is that of the code in which the expression appears, but
sometimes the context is that of the caller of that code (TBD).

To infer an expression, the expression is first reduced, and then
inferred.  Reduction and inference are intermixed; to reduce an
expression, one applied first a reduction rule, and gets are resulting
set of goal expressions that must be inferred for the reduction to succeed.
These expressions are in turned first reduced and then inferred.

Expression inference is a search process in which inferences
are found for a non-empty \key{goal set} of \skey{goal-expression}s.
An \key{inference} is an alternating sequence of expression reductions
and inference steps.
 
Expression reduction is a process that creates a unique result and
has no side effects.  An inference step takes as input a reduced
goal-expression and an inference rule, and replaced the goal-expression
in the goal set by other expressions that are in the inference rule.

An unreduced goal expression is said to be the parent of the unreduced
expressions that replace it in the goal set, and the parent relation
is labelled by the inference rule used to make the replacement.
An inference is associated with a forest (set of trees) whose nodes
are labelled with unreduced goal expressions and whose arcs are just the
parenting arcs which are labelled with the inference rule used to
replace the parent by its children.  Two inferences are said to be
distinct if and only if the inferences have distinct forests.

An expression inference is a search for all distinct inferences of
a goal set whose only member is the expression to be inferred.


Reduction and inference rules make use of unification and unification
variables (\ref{UNIFICATION}).
Each inference generates a set of values for the unification variables in the
original goal set.  Inference may create new unification variables that
appear in these values.

As inference rules (\ref{INFERENCE-RULES})
are simpler than reduction rules (\ref{REDUCTION-RULES}),
inference rules are explained first.

\subsection{Unification}
\label{UNIFICATION}

Expressions are externally represented as sequences of lexemes and
subexpressions, but internally they are represented as directed graphs whose
arcs are labelled by lexemes from the expression, and
whose nodes are unlabelled.  For example, the expression

\begin{center}
\verb|sort x ascending with key weight with comparitor <|
\end{center}

represents the tree

\[
    \verb|sort| \left[
	\begin{array}{l}
        \verb|1| \left[ \verb|x| \right. \\
        \verb|2| \left[ \verb|ascending| \right. \\
        \verb|3| \left[ \verb|with| \left[
	    \begin{array}{l}
	    \verb|1| \left[ \verb|key| \right. \\
	    \verb|2| \left[ \verb|weight| \right. \\
           \end{array} \right. \right. \\
        \verb|4| \left[ \verb|with| \left[
	    \begin{array}{l}
	    \verb|1| \left[ \verb|comparitor| \right. \\
	    \verb|2| \left[ \verb|<| \right. \\
           \end{array} \right. \right. \\
       \end{array} \right.
\]

while

\begin{center}
\verb|x = 7 * y + 5|
\end{center}

represents the tree

\[
    \verb|=| \left[
        \begin{array}{l}
	\verb|1| \left[ \verb|x| \right. \\
        \verb|2| \left[ \verb|+| \left[
	    \begin{array}{l}
	    \verb|1| \left[ \verb|*| \left[
	        \begin{array}{l}
		\verb|1| \left[ \verb|7| \right. \\
		\verb|2| \left[ \verb|y| \right. \\
		\end{array} \right. \right. \\
	    \verb|2| \left[ \verb|5| \right. \\
	    \end{array} \right. \right. \\
	\end{array} \right.
\]

and

\begin{center}
\verb|0 < x <= y <= 100|
\end{center}

represents the tree

\[
    \verb|<| \left[
        \begin{array}{l}
	\verb|1| \left[ \verb|0| \right. \\
        \verb|-REST-| \left[ \verb|<=| \left[
	    \begin{array}{l}
	    \verb|1| \left[ \verb|x| \right. \\
	    \verb|-REST-| \left[ \verb|<=| \left[
		\begin{array}{l}
		\verb|1| \left[ \verb|y| \right. \\
		\verb|2| \left[ \verb|100| \right. \\
		\end{array} \right. \right. \\
	    \end{array} \right. \right. \\
	\end{array} \right.
\]

\subsection{Inference Rules}
\label{INFERENCE-RULES}

An \key{inference rule} has the form:

\begin{center}
\key{consequent-expression} \verb|<--|
    \key{condition-expression} \{ \verb|,| {\em condition-expression} \}
\end{center}

An \key{inference step} takes as input one of the reduced goal-expressions
in the goal set and one inference rule,
such that the reduced goal-expression unifies with the
consequent-expression of the inference rule.  The unification variables in the
goal-set and inference-rule are replaced by their values computed
by this unification.  The goal-expression is removed the goal set, and
all the condition-expressions of the inference rule are added to the goal
set.

\subsection{Reduction Rules}
\label{REDUCTION-RULES}

A \key{reduction rule} has the form:

\begin{center}
\key{result-expression} \verb|<==|
\key{consequent-expression} \verb|<--|
    \key{condition-expression} \{ \verb|,| {\em condition-expression} \}
\end{center}

A reduction rule contains within it the equivalent of an inference rule,
which is obtained by removing the result-expression and following \verb|<==|
from the reduction rule.

A subexpression is \key{reduced} by finding for it inferences in which
the first rule applied to the original expression is a reduction rule.
If the result-expressions of all such inferences found unify, their
unification replaces the expression being reduced.  If no inferences
are found, the expression is not replaced.  It is an error
if several inferences are found but their result-expressions fail to unify.

An expression is \key{reduced} by reducing all its subexpressions, smallest
first, until lastly the whole expression is reduced as a subexpression of
itself.

\section{Design Notes}

These are some detailed design rules to be incorporated in the language
definition later.

\begin{list}{}{}

\item
{\bf Quotes}.  \verb|`'| are word, phrase, sentence, paragraph quotes.
\verb|[]| are math expression quotes.   Quotes are in left-right pairs
and can be nested.

\item
{\bf Multiple Quotes}.  Quotes can be multiplied $N$ times: e.g.,
\verb|[[...]]|, \verb|[[[...]]]|, etc.  It is possible to begin a quoted
phrase with a quoted phrase by following the initial $N$-left-quote by
space.  E.g., \verb|`` `Hello' 'tis a good word.''|.

\item
{\bf Algebraic Expressions}.
An expression may or may not be algebraic.  Algebraic expressions have
operators that determine structure.  Atoms in these are sequences of
words, numbers, and parenthesized or bracketted subexpressions.

\item
{\bf N-tuples and Flatening}.
The comma operator forms N-tuples, e.g., \verb|(x,y,z)| is a 3-tuple.

Tuples flatten.  It is not possible for a tuple to be a component of
a tuple: instead the tuples are flattened.  E.g., \verb|(x,(y,z),w)|
is the same value as \verb|(x,y,z,w)|.  There is no such thing as a
1-tuple, but any non-tuple behaves like a 1-tuple.

\item
{\bf Blank Algebraic Operators}.
The blank, or missing operator, denotes \verb|*| when it precedes a word,
as in \verb|5x| being equivalent to \verb|5*x|.  When it is between a
preceding integer and a following ratio, it adds the ratio to the integer,
as in \verb|41 1/3|.

\end{list}



\bibliographystyle{plain}
\bibliography{pcasl}

\printindex

\end{document}

