%  Calculation and Simulation Total Language Environment (CASTLE)
%
% File:         castle.tex
% Author:       Bob Walton (walton@deas.harvard.edu)
% Date:		See \date below.
  
\documentclass[12pt]{article}

\usepackage{makeidx}
\usepackage{pictex}

\makeindex

\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}
\raggedbottom

\setlength{\unitlength}{1in}

\pagestyle{headings}
\setlength{\parindent}{0.0in}
\setlength{\parskip}{1ex}

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}
\newcommand{\subsubsubsection}[1]{\paragraph[#1]{#1.}}
\newcommand{\subsubsubsubsection}[1]{\subparagraph[#1]{#1.}}

% Begin \tableofcontents surgery.

\newcount\AtCatcode
\AtCatcode=\catcode`@
\catcode `@=11	% @ is now a letter

\renewcommand{\contentsname}{}
\renewcommand\l@section{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\l@table{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\tableofcontents{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}}%
    \item\@starttoc{toc}%
    \end{list}}
\renewcommand\listoftables{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}%
	      }%
    \item\@starttoc{lot}%
    \end{list}}

\catcode `@=\AtCatcode	% @ is now restored

% End \tableofcontents surgery.

\newcommand{\CN}[2]%	Change Notice.
    {\hspace*{0in}\marginpar{\sloppy \raggedright \it \footnotesize
     $^{\mbox{#1}}$#2}}
    % Change notice.

\newcommand{\key}[1]{{\bf \em #1}\index{#1}}
\newcommand{\mkey}[2]{{\bf \em #1}\index{#1!#2}}
\newcommand{\skey}[2]{{\bf \em #1#2}\index{#1}}
\newcommand{\ikey}[2]{{\bf \em #1}\index{#2}}
\newcommand{\ttkey}[1]{{\tt \bf #1}\index{#1@{\tt #1}}}
% < and > do not work for \tt \bf, hence:
\newcommand{\ttnbkey}[1]{{\tt #1}\index{#1@{\tt #1}}}
\newcommand{\ttmnbkey}[2]{{\tt #1}\index{#1@{\tt #1}!#2}}
\newcommand{\ttbkey}[1]{{\tt \bf [#1]}\index{#1@{\tt [#1]}}}
\newcommand{\ttnbbkey}[1]{{\tt [#1]}\index{#1@{\tt [#1]}}}
\newcommand{\ttmkey}[2]{{\tt \bf #1}\index{#1@{\tt #1}!#2}}
\newcommand{\ttfkey}[2]{{\tt \bf #1}\index{#1@{\tt #1}!for #2@for {\tt #2}}}
\newcommand{\ttnbflagkey}[1]{{\tt #1} {\bf flag}\index{#1 flag@{\tt #1}-flag}}
\newcommand{\ttakey}[2]{{\tt \bf #1}\index{#2@{\tt #1}}}
\newcommand{\ttamkey}[3]{{\tt \bf #1}\index{#2@{\tt #1}!#3}}
\newcommand{\ttindex}[1]{\index{#1@{\tt #1}}}
\newcommand{\ttmindex}[2]{\index{#1@{\tt #1}!#2}}
\newcommand{\emkey}[1]{{\bf \em #1}\index{#1@{\em #1}}}
\newcommand{\emindex}[1]{\index{#1@{\em #1}}}

\newcommand{\opt}{$^!$}

\newcommand{\secref}[1]{\ref{#1}$\,^{p\,\pageref{#1}}$}
\newcommand{\stepref}[1]{\ref{#1}\,$^{p\,\pageref{#1}}$}
\newcommand{\appref}[1]{\ref{#1}$\,^{p\,\pageref{#1}}$}
\newcommand{\figref}[1]{\ref{#1}$\,^{p\,\pageref{#1}}$}
\newcommand{\pagref}[1]{p\pageref{#1}}

\newcommand{\EOL}{\penalty \exhyphenpenalty}

\newcount\TildeCatcode
\TildeCatcode=\catcode`\~
\catcode`~=12
\newcommand{\Tilde}{~}
\catcode`~=\TildeCatcode

\newcount\CircumflexCatcode
\CircumflexCatcode=\catcode`\^
\catcode`^=12
\newcommand{\Circumflex}{^}
\catcode`^=\CircumflexCatcode

\newcount\BraCatcode
\BraCatcode=\catcode`\<
\catcode`<=12
\newcommand{\Bra}{<}
\catcode`<=\BraCatcode

\newcount\KetCatcode
\KetCatcode=\catcode`\>
\catcode`>=12
\newcommand{\Ket}{>}
\catcode`>=\KetCatcode

\newcount\CurlyBraCatcode
\newcount\CurlyKetCatcode
\newcount\SquareBraCatcode
\newcount\SquareKetCatcode
\CurlyBraCatcode=\catcode`{
\CurlyKetCatcode=\catcode`}
\SquareBraCatcode=\catcode`[
\SquareKetCatcode=\catcode`]

\catcode`{=\SquareBraCatcode
\catcode`}=\SquareKetCatcode
\catcode`[=\CurlyBraCatcode
\catcode`]=\CurlyKetCatcode

\newcommand[\CurlyBra][{]
\newcommand[\CurlyKet][}]

\catcode`{=\CurlyBraCatcode
\catcode`}=\CurlyKetCatcode
\catcode`[=\SquareBraCatcode
\catcode`]=\SquareKetCatcode

\newcommand{\ttbrackets}{%
    \renewcommand{\{}{\CurlyBra}%
    \renewcommand{\}}{\CurlyKet}}

\newsavebox{\TILDEBOX}
\begin{lrbox}{\TILDEBOX}
\verb|~|
\end{lrbox}
\newcommand{\TILDE}{\usebox{\TILDEBOX}}

\newsavebox{\BACKSLASHBOX}
\begin{lrbox}{\BACKSLASHBOX}
\verb|\|
\end{lrbox}
\newcommand{\BACKSLASH}{\usebox{\BACKSLASHBOX}}

\newsavebox{\LEFTBRACKETBOX}
\begin{lrbox}{\LEFTBRACKETBOX}
\verb|{|
\end{lrbox}
\newcommand{\LEFTBRACKET}{\usebox{\LEFTBRACKETBOX}}

\newsavebox{\RIGHTBRACKETBOX}
\begin{lrbox}{\RIGHTBRACKETBOX}
\verb|}|
\end{lrbox}
\newcommand{\RIGHTBRACKET}{\usebox{\RIGHTBRACKETBOX}}

\newsavebox{\UNDERLINEBOX}
\begin{lrbox}{\UNDERLINEBOX}
\verb|_|
\end{lrbox}
\newcommand{\UNDERLINE}{\usebox{\UNDERLINEBOX}}

\newsavebox{\CIRCUMFLEXBOX}
\begin{lrbox}{\CIRCUMFLEXBOX}
\verb|^|
\end{lrbox}
\newcommand{\CIRCUMFLEX}{\usebox{\CIRCUMFLEXBOX}}

\newsavebox{\BARBOX}
\begin{lrbox}{\BARBOX}
\verb/|/
\end{lrbox}
\newcommand{\BAR}{\usebox{\BARBOX}}

\newsavebox{\LESSTHANBOX}
\begin{lrbox}{\LESSTHANBOX}
\verb/</
\end{lrbox}
\newcommand{\LESSTHAN}{\usebox{\LESSTHANBOX}}

\newsavebox{\GREATERTHANBOX}
\begin{lrbox}{\GREATERTHANBOX}
\verb/>/
\end{lrbox}
\newcommand{\GREATERTHAN}{\usebox{\GREATERTHANBOX}}

\newlength{\figurewidth}
\setlength{\figurewidth}{\textwidth}
\addtolength{\figurewidth}{-0.40in}

\newsavebox{\figurebox}

\newenvironment{boxedfigure}[1][!btp]%
	{\begin{figure*}[#1]
	 \begin{lrbox}{\figurebox}
	 \begin{minipage}{\figurewidth}

	 \vspace*{1ex}}%
	{
	 \vspace*{1ex}

	 \end{minipage}
	 \end{lrbox}
	 \begin{center}
	 \fbox{\hspace*{0.1in}\usebox{\figurebox}\hspace*{0.1in}}
	 \end{center}
	 \end{figure*}}

\newenvironment{indpar}[1][0.3in]%
	{\begin{list}{}%
		     {\setlength{\itemsep}{0in}%
		      \setlength{\topsep}{0in}%
		      \setlength{\parsep}{1ex}%
		      \setlength{\labelwidth}{#1}%
		      \setlength{\leftmargin}{#1}%
		      \addtolength{\leftmargin}{\labelsep}}%
	 \item}%
	{\end{list}}

\newenvironment{labpar}[2][0.3in]%
	{\begin{list}{}%
		     {\setlength{\itemsep}{0in}%
		      \setlength{\topsep}{0in}%
		      \setlength{\parsep}{1ex}%
		      \setlength{\labelwidth}{#1}%
		      \setlength{\leftmargin}{#1}%
		      \addtolength{\leftmargin}{\labelsep}}%
	 \item[#2]}%
	{\end{list}}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{lemma}[theorem]{Lemma}

\begin{document}
        
\title{Calculation and Simulation\\
       Total Language Environment\\[2ex]
       CASTLE\\[2ex]
       (Draft 1a)}

\author{Robert L. Walton\thanks{Copyright 2008 Robert L. Walton.
Permission to copy this document verbatim is granted by the author
to the public.  This document was partly inspired
by teaching courses at Suffolk University, and by the work of Thomas
Cheatham and Stuart Shieber.}}

\date{February 21, 2008}
 
\maketitle

\newpage
\begin{center}
\large \bf Table of Contents
\end{center}

\bigskip

\tableofcontents 

\newpage

\section{Introduction}

This document describes the programming language CASTLE.  CASTLE,
for what its worth, stands for `Calculation and Simulation Total Language
Environment', which hints at its purpose.

CASTLE is designed for naive programmers: that is, for people who may never
be able to program computers well.  It is a fairly simple language with
powerful data types that make it easier to write small programs
that do a variety of tasks a person might want to do.  Generally
the tasks fall into the categories of calculating things (taxes,
probabilities, statistics) or simulating things
(computer games, construction designs, mathematics demonstrations).
Included are:

\begin{center}
\begin{tabular}{l}
Calculations that might be done with a spreadsheet. \\
Drawing pictures. \\
Simulating popular board games and creating new ones. \\
Creating simple computer games, including dialog games. \\
Computing and analyzing documents. \\
Doing elementary algebra and calculus problems. \\
Doing matrix calculations. \\ 
Calculating basic probabilities and statistics. \\
Simulating two and three dimensional objects. \\
Simulating simple electrical, mechanical, chemical, and biological systems.\\
Solving problems in elementary logic. \\
\end{tabular}
\end{center}

There are many computer languages that have some powerful data type that adapts
them for a specific kind of computation.  CASTLE tries to combine these.
Some previous computer languages that have influenced CASTLE, and
the data types they particularly support, are:

\begin{center}
\begin{tabular}{l@{\hspace{0.5in}}l}
Various Spreadsheets		& Spreadsheets \\
Various Data Base Languages	& Data Bases \\
Various Script Languages	& Documents \\
MATLAB				& Matrices \\
Mathematica			& Expressions \\
TCL				& Character Strings and Lists \\
Lisp				& Words and Phrases \\
PROLOG				& Logical Expressions \\
\end{tabular}
\end{center}

CASTLE is \underline{not} designed to be a computer-efficient language.
It is designed to be person-efficient, and to do small calculations
rapidly enough with inexpensive modern computers.

\section{Remarks}

CASTLE was created as an answer to the question: what programming language
should you teach beginning programming students who do not have the talent
or inclination to become good programmers?  The initial answer, that it does
not matter provided you implement some powerful types of data in the
language you choose, has a flaw.  The flaw is that without the right powerful
data types, the language will be useless to the students after the course
is over.  So what is needed is a programming language that will be useful
to students after a first course in programming, and the essence of
such a language is the integration within it of many powerful and useful
data types.

The basic principles of the CASTLE design were developed
by the author while teaching the intended customers of
CASTLE.\footnote{Specifically, while teaching CS121 at Suffolk University
using the C programming language.}
The language should have as few parts as possible, to cut down
on the amount of detail that must be remembered to use the language, but
conversely, there is no limit to the conceptual complexity of any well-used
part.\footnote{There was no problem teaching recursion, but it was better
not to each many different looping constructs.}
The language should have powerful data types, well integrated into
the syntax of the language.  As much as possible, statement executions
in the language should have visible effect.

The current version of CASTLE is not stable, because it has not been
implemented, and because, unlike most programming languages, CASTLE
has lots of subtle important interactions between its various features.  The
hope is that after implementation and experimentation a stable sensible
version of CASTLE, integrating all its data types, can be achieved.

\section{Overview}

CASTLE has two major kinds of data: expressions and blocks.  Numbers are
the simplest expressions.  More complex expressions are math
expressions or document expressions.  A block is a set of variables
and an piece of code.  Each variable can have a value, which is an expression.
The code contains expressions that can be evaluated under appropriate
circumstances to produce values for variables.

In CASTLE an `object' is a block that has an associated `type'.  For
example, there may be an object `george' with type `person'.  All blocks
of the same type have the same code, and many of the same variables,
but typically have different variable values.

You can use CASTLE as a calculator by typing into it expressions to
be evaluated, assignments of values to variables, and definitions
of functions and predicates.  Some examples involving numbers are:

\begin{indpar}\begin{verbatim}
> 9
9
> 9 + 8
17
> x = 9
9
> y = 9 + 8
17
> x + y
26
\end{verbatim}\end{indpar}

Here the `\verb|> |' at the beginning of some lines is the CASTLE \key{prompt}
that tells you its OK to input an expression to be evaluated.
Except for this prompt, lines beginning with `\verb|> |' are input lines to
a CASTLE interpreter, and other lines are output lines.

At somewhat the opposite extreme from numbers are words, phrases, sentences,
and paragraphs.  You can calculate with these `\skey{document expression}s'.

\begin{indpar}
\verb|> g = `hello'| \\
\verb|`|hello\verb|'| \\
\verb|> `[g] there'| \\
\verb|`|hello there\verb|'| \\
\verb|> z = `I thought he said `[[g]]'.'| \\
\verb|`|I thought he said `hello'.\verb|'| \\
\verb/> notice = `|This document is meant to be read./ \\
\verb/+           |Reading this document is good, but.../ \\
\verb/+           |[z].'/ \\
\verb|`|This document is meant to be read. \\
\verb| |Reading this document is good, but\ldots \\
\verb| |I thought he said `hello'.\verb|'| \\
\verb|> `When you add [x] and [y] you get [x+y].'| \\
\verb|`|When you add 9 and 17 you get 26.\verb|'|
\end{indpar}

Modern math computes with expressions, and not just numbers.
You can compute with \skey{math expression}s in CASTLE.

\begin{indpar}
\verb|> f = {10x^2 - 3.67x - 0.04}| \\
\verb|{|$10x^2-3.67x-0.04$\verb|}| \\
\verb|> h = (- 0.96 + 0.67x) in x| \\
\verb|{|$-0.96+0.67x$\verb|}| \\
\verb|> (f + h) in x| \\
\verb|{|$10x^2-3x-1$\verb|}| \\
\verb|> solve (f + h = 0) for x| \\
\verb|{|$x = (-0.2, 0.5)$\verb|}| \\
\verb|> (f + h) at (x = (3, 4, 5))| \\
\verb|(78.95, 145.28, 231.61)| \\
\verb|> g = {integral (x ^ 2 dx)}| \\
\verb|{|$\int x^2 dx$\verb|}| \\
\verb|> simplify g| \\
\verb|{|$\frac{1}{3} x^3$\verb|}| \\
\verb|> v = g from (x = 1) to (x = 5)| \\
\verb|41 1/3| \\
\verb|> out = `The value of {[[g]] from (x = 1) to (x = 5)} is [v].'| \\
\verb|`|The value of $\int_{x = 1}^{x = 5} x^2 dx$ is $41\frac{1}{3}$.\verb|'|
\end{indpar}

Another kind of datum you can compute with in CASTLE is
the block.  A \key{block} contains a set of variables, each of which
can have a value which is an expression.  A block can also
have code, which contains expressions that are evaluated under appropriate
circumstances to produce values for the block's variables.

In CASTLE an \key{object} is a block that has an associated \key{type}.  For
example, there may be an object named `Jack' with type `person'.  All objects
of the same type have the same code, and many of the same variables,
but typically have different variable values.  For example:

\begin{indpar}
\verb|> a person:| \\
\verb|+     name = `Jack'| \\
\verb|+     weight = 123 lb| \\
\verb|+     height = 5 ft 9 in| \\
\verb|+     age = 23 yr 2 mo| \\
\begin{tabular}{|r|l|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf type} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000000 & person & Jack & \tt 123 lb & \tt 5 ft 9 in & \tt 23 yr 2 mo \\
\hline
\end{tabular} \\[0.5ex]
\verb|> a person:| \\
\verb|+     name = `Jill'| \\
\verb|+     weight = 110 lb| \\
\verb|+     height = 5 ft 7 in| \\
\verb|+     age = 21 yr 8 mo| \\
\begin{tabular}{|r|l|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf type} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000001 & person & Jill & \tt 110 lb & \tt 5 ft 7 in & \tt 21 yr 8 mo \\
\hline
\end{tabular} \\[0.5ex]
\verb|> all persons| \\
\begin{tabular}{|r|l|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf type} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000000 & person & Jack & \tt 123 lb & \tt 5 ft 9 in & \tt 23 yr 2 mo \\
\tt @1000001 & person & Jill & \tt 110 lb & \tt 5 ft 7 in & \tt 21 yr 8 mo \\
\hline
\end{tabular} \\[0.5ex]
\verb|> the person Jack| \\
\begin{tabular}{|r|l|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf type} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000000 & person & Jack & \tt 123 lb & \tt 5 ft 9 in & \tt 23 yr 2 mo \\
\hline
\end{tabular} \\[0.5ex]
\verb|> the person named Jack's height| \\
\verb|5 ft 9 in| \\
\verb|> the weight of the person named Jack| \\
\verb|123 lb| \\
\verb|> @1000001| \\
\begin{tabular}{|r|l|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf type} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000001 & person & Jill & \tt 110 lb & \tt 5 ft 7 in & \tt 21 yr 8 mo \\
\hline
\end{tabular} \\[0.5ex]
\verb|> the weight of @1000001| \\
\verb|110 lb|
\end{indpar}

It is possible to add code to a type such as `{\tt person}'.  This has
the affect of adding the code to all blocks that are objects of that type.
For example:

\begin{indpar}
\verb|> for every person:| \\
\verb|+     body-mass-index = 703.06958 * weight in lbs| \\
\verb|+                     / (height in inches)^2| \\
\verb|> all persons| \\
\begin{tabular}{|r|l|l|r|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf type} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} &
\multicolumn{1}{|c|}{\bf \shortstack{body-mass-\\index}} \\
\hline
\tt @1000000 & person & Jack
	     & \tt 123 lb & \tt 5 ft 9 in & \tt 23 yr 2 mo & \tt 18.163738 \\
\tt @1000001 & person & Jill
	     & \tt 110 lb & \tt 5 ft 7 in & \tt 21 yr 8 mo & \tt 17.228258 \\
\hline
\end{tabular}
\end{indpar}

One can use definitions to define expressions that compute values:

\begin{indpar}
\verb|> sum from X through Y <-- integer X, integer Y:| \\
\verb|+     `Sum of integers from X through Y.'| \\
\verb|+     if ( X > Y ):| \\
\verb|+         value = 0| \\
\verb|+     else:| \\
\verb|+         value = X + sum (X+1) through Y| \\
\verb|> sum from 5 through 10| \\
\verb|45| \\
\verb|> all (sums from X through Y)| \\
\begin{tabular}{|r|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf X} &
\multicolumn{1}{|c}{\bf Y} &
\multicolumn{1}{|c|}{\bf value} \\
\hline
\tt @1000002 & \tt 5	& \tt	10	& \tt 45 \\
\tt @1000003 & \tt 6	& \tt	10	& \tt 40 \\
\tt @1000004 & \tt 7	& \tt	10	& \tt 34 \\
\tt @1000005 & \tt 8	& \tt	10	& \tt 27 \\
\tt @1000006 & \tt 9	& \tt	10	& \tt 19 \\
\tt @1000007 & \tt 10	& \tt	10	& \tt 10 \\
\tt @1000008 & \tt 11	& \tt	10	& \tt 0 \\
\hline
\end{tabular} \\[0.5ex]
\verb|> sum from 1 through 2| \\
\verb|3| \\
\verb|> all (sums from X through Y)| \\
\begin{tabular}{|r|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf X} &
\multicolumn{1}{|c}{\bf Y} &
\multicolumn{1}{|c|}{\bf value} \\
\hline
\tt @1000002 & \tt 5	& \tt	10	& \tt 45 \\
\tt @1000003 & \tt 6	& \tt	10	& \tt 40 \\
\tt @1000004 & \tt 7	& \tt	10	& \tt 34 \\
\tt @1000005 & \tt 8	& \tt	10	& \tt 27 \\
\tt @1000006 & \tt 9	& \tt	10	& \tt 19 \\
\tt @1000007 & \tt 10	& \tt	10	& \tt 10 \\
\tt @1000008 & \tt 11	& \tt	10	& \tt 0 \\
\tt @1000009 & \tt 1	& \tt	2	& \tt 3 \\
\tt @1000010 & \tt 2	& \tt	2	& \tt 2 \\
\tt @1000011 & \tt 3	& \tt	2	& \tt 0 \\
\hline
\end{tabular}
\end{indpar}

Executions can be examined in detail, because
when an expression is computed, the block that computes it is remembered
for some time.  However, as memory is finite, eventually these
computations are forgotten as they can always be regenerated if
needed.

The sum above was computed by recursion: to compute the sum of 5 through 10
one adds 5 to the sum of 6 through 10.  One can also compute sums by
iteration.

\begin{indpar}
\verb|> sum from X through Y <-- integer X, integer Y:| \\
\verb|+     `Sum of integers from X through Y.'| \\
\verb|+     first sum = 0| \\
\verb|+     if ( X <= Y ):| \\
\verb|+         next sum = sum + X| \\
\verb|+         next X = X + 1| \\
\verb|+     else:| \\
\verb|+         value = sum| \\
\verb|> sum from 5 through 10| \\
\verb|45| \\
\verb|> all (sums from X through Y)| \\
\begin{tabular}{|r|r|r|r|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf previous} &
\multicolumn{1}{|c}{\bf next} &
\multicolumn{1}{|c}{\bf X} &
\multicolumn{1}{|c}{\bf Y} &
\multicolumn{1}{|c}{\bf sum} &
\multicolumn{1}{|c|}{\bf value} \\
\hline
\tt @1000012 &              & \tt @1000013
	     & \tt 5	& \tt 10   & \tt 0	& \\
\tt @1000013 & \tt @1000012 & \tt @1000014
	     & \tt 6	& \tt 10   & \tt 5	& \\
\tt @1000014 & \tt @1000013 & \tt @1000015
	     & \tt 7	& \tt 10   & \tt 11	& \\
\tt @1000015 & \tt @1000014 & \tt @1000016
	     & \tt 8	& \tt 10   & \tt 18	& \\
\tt @1000016 & \tt @1000015 & \tt @1000017
	     & \tt 9	& \tt 10   & \tt 26	& \\
\tt @1000017 & \tt @1000016 & \tt @1000018
	     & \tt 10	& \tt 10   & \tt 35	& \\
\tt @1000018 & \tt @1000017 &
	     & \tt 11	& \tt 10   & \tt 45	& \tt 45 \\
\hline
\end{tabular}
\end{indpar}

One can also iterate over data.

\begin{indpar}
\verb|> average weight of X <-- list X of persons:| \\
\verb|+     first count = 0| \\
\verb|+     first sum = 0| \\
\verb|+     if X = ():| \\
\verb|+         if count = 0:| \\
\verb|+             value = error `Cannot average 0 things.'| \\
\verb|+         else:| \\
\verb|+             value = sum / count| \\
\verb|+     else:| \\
\verb|+         next count = count + 1| \\
\verb|+         next sum = sum + the weight of (first X)| \\
\verb|+         next X = rest X| \\
\verb|> average weight of (all persons)| \\
\verb|116.5 lbs|
\end{indpar}

In case you wonder how some of the above works, here are some hints.

CASTLE tends to ignore word endings: thus `{\tt person}' and
`{\tt persons}' are to CASTLE the same word.
CASTLE can even be told that `{\tt person}'
and `{\tt people}' are the same word.
`{\tt Jack's}', on the other hand, is treated an abbreviation
of two separate words `{\tt Jack}' and `{\tt 's}', where `{\tt 's}' is
a separate word by itself.

Expressions are just strings of words and subexpressions.  Subexpressions
must be parenthesized unless they consist of a single word, or unless
they are delimited by operators.

Lists of values can be stored in \skey{list}s, which are computed by comma
separated lists in parentheses.  Thus

\begin{indpar}
\verb|> (the person named Jill, the person named Jack)| \\
\begin{tabular}{|r|l|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf type} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000001 & person & Jill & \tt 110 lb & \tt 5 ft 7 in & \tt 21 yr 8 mo \\
\tt @1000000 & person & Jack & \tt 123 lb & \tt 5 ft 9 in & \tt 23 yr 2 mo \\
\hline
\end{tabular} \\[0.5ex]
\verb|> (the person named Jack, the person named Jill)| \\
\begin{tabular}{|r|l|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf type} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000000 & person & Jack & \tt 123 lb & \tt 5 ft 9 in & \tt 23 yr 2 mo \\
\tt @1000001 & person & Jill & \tt 110 lb & \tt 5 ft 7 in & \tt 21 yr 8 mo \\
\hline
\end{tabular} \\[0.5ex]
\verb|> raw (all persons)| \\
\verb|(the person named Jack, the person named Jill)| \\
\verb|> really raw (all persons)| \\
\verb|(@1000000, @1000001)|
\end{indpar}

The `{\tt raw}' form of a value represents the value
as you could input it in a way that reveals its internal structure.  Thus
`{\tt all persons}' denotes the list of all persons, and it is the list
structure that is revealed, not the structure of the elements of the list.

`{\tt the person named Jack}' is a printed representation of the
internal name of an object.  Such printed representations are chosen
automatically from the set of all possible representations, which
in this case include `{\tt the person weighing 123 lbs}' and
`{\tt the person named Jack weighing 123 lbs}'.

The `{\tt really raw}' form of a value identifies objects by their IDs.

A single non-list value is equivalent to a list with one element.
Lists cannot have other lists as elements; instead attempts to
compute such lists are \key{flattened}:

\begin{indpar}
\verb|> x = (1,(2,3),4)| \\
\verb|(1,2,3,4)| \\
\verb|> first x| \\
\verb|1| \\
\verb|> rest x| \\
\verb|(2,3,4)| \\
\verb|> rest (rest x)| \\
\verb|(3,4)| \\
\verb|> rest (rest (rest x))| \\
\verb|4| \\
\verb|> rest 4| \\
\verb|()|
\end{indpar}

For this reason CASTLE lists are sometimes called `\skey{flat list}s'.

CASTLE has different kinds of quotes or brackets.  The brackets
\verb|{|\ldots\verb|}|, \verb|`|\ldots\verb|'|,
turn
evaluation off, while \verb|[|\ldots\verb|]| turns evaluation on.
The brackets \verb|`|\ldots\verb|'| turn
recognition of operators (e.g., \verb|+| and \verb|=|) off, and turn
recognition of phrase separators (e.g., `\verb|,|' and `\verb|;|') and
sentence terminators (e.g., `\verb|.|' and `\verb|?|') on, while
\verb|[|\ldots\verb|]| and \verb|{|\ldots\verb|}|
turn recognition of operators on, and turn recognition of phrase
separators and sentence terminators off.

CASTLE can store information as expressions.  For example:

\begin{indpar}
\verb|> (a person named `Jack') is husband of (a person named `Jill') <--| \\
\verb|> Y is wife of X <-- X is husband of Y|
\end{indpar}

Here `\verb|<--|' means `is asserted' or `is asserted if'.
All the assertions that have been made can be queried:

\begin{indpar}
\verb|> (a person named `Jill') is wife of (a person named `Jack') ?| \\
\verb|true| \\
\verb|> (a person named `Jack') is wife of (a person named `Jill') ?| \\
\verb|false| \\
\verb|> (a person named X) is wife of (a person named `Jack') ?| \\
\verb|X = `|Jill\verb|'| \\
\verb|> X is wife of (a person named `Jack') ?| \\
\verb|X = (a person named `Jill')| \\
\verb|> @1000001 is wife of (a person named `Jack') ?| \\
\verb|true| \\
\verb|> @1000001 = (a person named `Jill') ?| \\
\verb|true| \\
\verb|> @1000001 = (a person named `Jack') ?| \\
\verb|false|
\end{indpar}

CASTLE supports pictorial data
that are expressions displayed as pictures:

\begin{indpar}
\verb|> x = {circle 0.4}| \\
\begin{picture}(0.4,0.4)
\put(0.2,0.2){\circle{0.4}}
\end{picture} \\
\verb|> y = {rectangle (0.4,0.2)}| \\
\begin{picture}(0.4,0.2)
\put(0,0){\framebox(0.4,0.2){}}
\end{picture} \\
\verb|> z = {(circle 0.4) labeled `Jack'}| \\
\begin{picture}(0.4,0.4)
\put(0.2,0.2){\circle{0.4}}
\put(0.0,0.0){\makebox(0.4,0.4){Jack}}
\end{picture} \\
\verb|> {([x] right of [y]) above [z]}| \\
\begin{picture}(0.8,0.8)
\put(0.6,0.6){\circle{0.4}}
\put(0.0,0.5){\framebox(0.4,0.2){}}
\put(0.4,0.2){\circle{0.4}}
\put(0.2,0.0){\makebox(0.4,0.4){Jack}}
\end{picture} \\
\verb|> {row([x],[y],[z])}| \\
\begin{picture}(1.4,0.4)
\put(0.2,0.2){\circle{0.4}}
\put(0.5,0.1){\framebox(0.4,0.2){}}
\put(1.2,0.2){\circle{0.4}}
\put(1.0,0.0){\makebox(0.4,0.4){Jack}}
\end{picture} \\
\verb|> p = {column (row([x],[y],[z]), row([z],[y],[x]))}| \\
\begin{picture}(1.4,0.9)
\put(0.2,0.7){\circle{0.4}}
\put(0.5,0.6){\framebox(0.4,0.2){}}
\put(1.2,0.7){\circle{0.4}}
\put(1.0,0.5){\makebox(0.4,0.4){Jack}}
\put(1.2,0.2){\circle{0.4}}
\put(0.5,0.1){\framebox(0.4,0.2){}}
\put(0.2,0.2){\circle{0.4}}
\put(0.0,0.0){\makebox(0.4,0.4){Jack}}
\end{picture} \\
\verb|> raw x| \\
\verb|{circle 0.4}| \\
\verb|> raw p| \\
\verb|{column (row (circle 0.4,| \\
\verb|              rectangle (0.4,0.2),| \\
\verb|              (circle 0.4) labeled `Jack'),| \\
\verb|         row ((circle 0.4) labeled `Jack',| \\
\verb|              rectangle (0.4,0.2),| \\
\verb|              circle 0.4))}|
\end{indpar}

You can also change how an expression is displayed.

\begin{indpar}
\newlength{\ovalraise}
\setlength{\ovalraise}{-0.1in}
\addtolength{\ovalraise}{0.8ex}
\verb|> display ( P ) <-- person ( P ) has name ( X ):| \\
\verb|>     value = {oval (0.4,0.2) labeled [X]}| \\
\verb|> (a person named `Jack')| \\
\begin{picture}(0.4,0.2)
\put(0.2,0.1){\oval(0.4,0.2)}
\put(0.0,0.0){\makebox(0.4,0.2){Jack}}
\end{picture} \\
\verb|> `(a person named `Jill') is wife of (a person named `Jack')'| \\
\verb|`|
\raisebox{\ovalraise}{\begin{picture}(0.4,0.2)
\put(0.2,0.1){\oval(0.4,0.2)}
\put(0.0,0.0){\makebox(0.4,0.2){Jill}}
\end{picture}}
{is the wife of}
\raisebox{\ovalraise}{\begin{picture}(0.4,0.2)
\put(0.2,0.1){\oval(0.4,0.2)}
\put(0.0,0.0){\makebox(0.4,0.2){Jack}}
\end{picture}}
\verb|'|
\end{indpar}

Displays can be used to make demonstrations:

\begin{indpar}
\verb|> for every demo:| \\
\verb|>     on a demo with angle X:| \\
\verb|+         angle = X| \\
\verb|> x = a demo with angle 30 degrees| \\
\begin{tabular}{|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf type} &
\multicolumn{1}{|c|}{\bf angle} \\
\hline
\tt @1000043 & demo & 30 degrees \\
\hline
\end{tabular} \\[0.5ex]
\verb|> for every demo:| \\
\verb|+     on update THIS to X:|\\
\verb|+         next angle = X| \\
\verb|+     on increment THIS by X:| \\
\verb|+         next angle = angle + X| \\
\verb|> update x to 40 degrees| \\
\begin{tabular}{|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf type} &
\multicolumn{1}{|c|}{\bf angle} \\
\hline
\tt @1000044 & demo & 40 degrees \\
\hline
\end{tabular} \\[0.5ex]
\verb|> increment x by 5 degrees| \\
\begin{tabular}{|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf type} &
\multicolumn{1}{|c|}{\bf angle} \\
\hline
\tt @1000045 & demo & 45 degrees \\
\hline
\end{tabular} \\[0.5ex]
\verb|> display ( D ) <-- demo ( D ) with angle ( X ):| \\
\verb|+     c = {circle 1.0 dotted center (0.0,0.0)}| \\
\verb|+     x-axis = {arrow from (-0.75,0.0) to (0.75,0.0)}| \\
\verb|+     y-axis = {arrow from (0.0,-0.75) to (0.0,0.75)}| \\
\verb|+     line = {line from (0.0,0.0) to [(0.5*cos X, 0.5*sin X)]}| \\
\verb|+     arc = {arc-arrow from (0.7,0.0) to [(0.3*cos X, 0.3*sin X)]}| \\
\verb|+     theta = {Greek th}| \\
\verb|+     value = {column (| \\
\verb|+                overlap (| \\
\verb|+                  [c],| \\
\verb|+                  [x-axis] labeled `X Axis',| \\
\verb|+                  [y-axis] labeled `Y Axis',| \\
\verb|+                  [line],| \\
\verb|+                  [arc] labeled `[[theta]]' ),| \\
\verb|+                label `Depiction of Angle [[theta]]' ) }| \\
\verb|> x| \\
\begin{picture}(4.0,1.9)
\put(1.0,0.95){\qbezier[40](0.5,0.0)(0.46,0.46)(0.0,0.5)}
\put(1.0,0.95){\qbezier[40](0.0,0.5)(-0.46,0.46)(-0.5,0.0)}
\put(1.0,0.95){\qbezier[40](-0.5,0.0)(-0.46,-0.46)(0.0,-0.5)}
\put(1.0,0.95){\qbezier[40](0.0,-0.5)(0.46,-0.46)(0.5,0.0)}
\put(1.0,0.95){
    \qbezier[250](0.3,0.0)(0.3,0.124264)(0.212132,0.212132)
    \put(0.212132,0.212132){\vector(-1,1){0.00}}
    \put(0.31,0.1){$\theta$}}
\put(1.0,0.2){\vector(0,1){1.5}}
\put(0.0,1.7){\makebox(2.0,0.2){Y Axis}}
\put(0.25,0.95){\vector(1,0){1.5}}
\put(1.80,0.85){\makebox(2.0,0.2)[l]{X Axis}}
\put(1.0,0.95){\line(1,1){0.353553}}
\put(0.0,0.0){\makebox(2.0,0.2){Depiction of Angle $\theta$}}
\end{picture} \\
\verb|> show x label {Greek th}| \\
See $\theta$ \\
\verb|> update x to 40 degrees| \\
See $\theta$ \\
\verb|> increment x by -5 degrees| \\
See $\theta$
\end{indpar} 

In this example we first define a `constructor'
of the form `{\tt a demo with angle X}' to make new {\tt demo} objects,
and then we define two `methods', namely `{\tt update THIS to X}' and
`{\tt in\-cre\-ment THIS by X}', to change a {\tt demo} object.  Changing
a {\tt demo} object is like iterating a loop to make a new object.

Next we define how to display a {\tt demo} object.  Then we use the
`{\tt show x label {\ttbrackets \{Greek th\}}}' command
to cause the {\tt demo} object value of {\tt x}
to be displayed in a separate window labeled `$\theta$'.
Every time this {\tt demo} object
changes, the $\theta$ window is updated, and every time the object
is to be printed, `See $\theta$' is printed instead.


TBD: example of a simple game.

\begin{boxedfigure}

\begin{verbatim}
for every board:
    on a board of dimension S:
        `Make a board of size SxS.'
        size = S
        `Allowed vessels have lengths 2 (destroyer), 3 (cruiser),
         5 (battleship).  vessels(L) is number of length L.'
        array vessels of size 5 with initial element 0
        `maximum-vessels(L) is maximum number of vessels of
         length L.'
        array maximum-vessels of size 5 with initial element 0
        maximum-vessels(2) = 5
        maximum-vessels(3) = 2
        maximum-vessels(5) = 1
        `state(I,J) is `none', `miss', or `hit' iff shell has not
         struck square (I,J), struck square (I,J) but that square
         had no ship, or struck square (I,J) and hit a ship at
         that square.'
        array hit of size (S,S) with initial element `none'
        `vessel(I,J) is the vessel at (I,J)'
        array vessel of size (S,S) with initial element `none'
\end{verbatim}

\caption{Code for the Battleship Game, Part I}
\label{CODE-FOR-BATTLESHIP-1}
\end{boxedfigure}


\begin{boxedfigure}

\begin{verbatim}
direction vector of D:
    `given a direction N, NE, E, SE, S, SW, W, NW, return a vector
     with unit components in the given direction.'
    if D == `N':
        value = (1,0)
    else if D == `NE':
        value = (1,1)
    else if D == `E':
        value = (1,0)
    else if D == `SE':
        value = (1,-1)
    else if D == `S':
        value = (0,-1)
    else if D == `SW':
        value = (-1,-1)
    else if D == `W':
        value = (-1,0)
    else if D == `NW':
        value = (-1,1)
\end{verbatim}

\caption{Code for the Battleship Game, Part II}
\label{CODE-FOR-BATTLESHIP-2}
\end{boxedfigure}

\begin{boxedfigure}

\begin{verbatim}
for every vessel:
    on a vessel of length L with direction D from (I,J) on B:
        `make a vessel of length L positioned in direction D
         from origin (I,J) on boards B; directions are N,
         NE, E, SE, S, SW, W, NW'
        length = L
        direction = D
        origin = (I,J)
        vector = direction vector of D
        destination = L * vector + origin
        board = B
        conflict =:
            first p = origin
            first k = 0
            next k = k + 1
            next p = p + vector
            TBD
        if L < 2 or L > 5:
            value = error `bad length [L]'
        else if maximum-vessels(L) of B >= vessels(L) of B:
            value = error `two many vessels of length [L]
                           on board [B]'
        else:
            vessels(L) of B += 1
\end{verbatim}

\caption{Code for the Battleship Game, Part III}
\label{CODE-FOR-BATTLESHIP-3}
\end{boxedfigure}

The rest of this document is a reference manual for CASTLE.


\section{Lexemes}

Input text is a sequence of characters.  This is scanned from
left to right and top to bottom to produce a sequence of lexemes,
which include words, marks, separators, numbers, and quoted strings.

For example, the input
\begin{center}
\verb|x = 7ft 1 3/4in;|
\end{center}
contains in order the following lexemes:
\begin{center}
\begin{tabular}{ll}
\tt x	& word \\
\tt =	& mark \\
\tt 7	& number \\
\tt ft	& word \\
\tt 1	& number \\
\tt 3/4	& number \\
\tt in	& word \\
\tt ;	& separator \\
\end{tabular}
\end{center}

\ikey{Lexemes}{lexeme} are defined more specifically as follows:

\begin{indpar}
\key{lexeme}
	::= {\em symbol} $|$ {\em number}
	$|$ {\em separator}
	\\[1ex]
\key{symbol}
	::= {\em word}
	$|$ {\em mark}
	$|$ {\em quoted-string}
\label{SYMBOL-LEXEME}
	\\[1ex]
\key{word} ::= {\em word-character} {\em word-character}\,$^\star$ \\[1ex]
\key{mark} ::= {\em mark-character} {\em mark-character}\,$^\star$ \\[1ex]
\key{number-lexeme} ::= {\em number-character} {\em number-character}\,$^\star$
\label{NUMBER-LEXEME}
\\[1ex]
\key{quoted-string} ::=
    \verb|"| {\em character-representative}\,$^\star$ \verb|"| \\[1ex]
\key{separator} ::= {\em separator-character} \\[1ex]
\key{word-character} \begin{tabular}[t]{rl}
                     ::= & {\em letter} \\
		     $|$ & \verb|'| followed by a letter \\
		     \end{tabular}
		     \\[1ex]
\key{mark-character} \begin{tabular}[t]{rl}
		     ::= &      \verb|+|%
		             $|$\verb|-|%
		             $|$\verb|*|%
		             $|$\verb|/|%
		             $|$\verb|\|%
		             $|$\verb|~|%
		             $|$\verb|@|%
		             $|$\verb|#|%
		             $|$\verb|$|%
		             $|$\verb|%|%
		             $|$\verb|^|%
		             $|$\verb|&|%
		             $|$\verb|=|%
		             $|$\verb/|/%
		             $|$\verb|<|%
		             $|$\verb|>|%
		             $|$\verb|_|%
		             $|$\verb|!|%
		             $|$\verb|?|%
			     $|$\verb|:| \\
		     $|$ & \verb|.| not followed by a {\em digit} \\
		     $|$ & \verb|/| not surrounded by {\em digits} \\
			\end{tabular}\\[1ex]
\key{separator-character} \begin{tabular}[t]{rl}
		::= &   \verb|(|
	       	    $|$ \verb|)|
	       	    $|$ \verb|[|
	       	    $|$ \verb|]|
	       	    $|$ \verb|{|
	       	    $|$ \verb|}|
	       	    $|$ \verb|;|
	       	    $|$ \verb|`| \\
		$|$ & \verb|,| not surrounded by {\em digits} \\
		$|$ & \verb|'| not followed by a letter 
		    \end{tabular}\\[1ex]
\key{number-character} \begin{tabular}[t]{rl}
		::= &   {\em digit} \\
		$|$ & \verb|.| followed by by a {\em digit } \\
		$|$ & \verb|,| surrounded by {\em digits} \\
		$|$ & \verb|/| surrounded by {\em digits} \\
		    \end{tabular}\\[1ex]
\key{character-representative}
    ::= see Figure~\figref{CHARACTER-REPRESENTATIVES} \\[1ex]
\key{letter} ::= {\em lower-case-letter} $|$ {\em upper-case-letter} \\[1ex]
\key{lower-case-letter} ::=    \verb|a|%
			    $|$\verb|b|%
			    $|$\verb|c|%
			    $|$\verb|d|%
			    $|$\verb|e|%
			    $|$\verb|f|%
			    $|$\verb|g|%
			    $|$\verb|h|%
			    $|$\verb|i|%
			    $|$\verb|j|%
			    $|$\verb|k|%
			    $|$\verb|l|%
			    $|$\verb|m|%
			    $|$\verb|n|%
			    $|$\verb|o|%
			    $|$\verb|p|%
			    $|$\verb|q|%
			    $|$\verb|r|%
			    $|$\verb|s|%
			    $|$\verb|t|%
			    $|$\verb|u|%
			    $|$\verb|v|%
			    $|$\verb|w|%
			    $|$\verb|x|%
			    $|$\verb|y|%
			    $|$\verb|z|
			    \\[1ex]
\key{upper-case-letter} ::=    \verb|A|%
			    $|$\verb|B|%
			    $|$\verb|C|%
			    $|$\verb|D|%
			    $|$\verb|E|%
			    $|$\verb|F|%
			    $|$\verb|G|%
			    $|$\verb|H|%
			    $|$\verb|I|%
			    $|$\verb|J|%
			    $|$\verb|K|%
			    $|$\verb|L|%
			    $|$\verb|M|%
			    $|$\verb|N|%
			    $|$\verb|O|%
			    $|$\verb|p|%
			    $|$\verb|Q|%
			    $|$\verb|R|%
			    $|$\verb|S|%
			    $|$\verb|T|%
			    $|$\verb|U|%
			    $|$\verb|V|%
			    $|$\verb|W|%
			    $|$\verb|X|%
			    $|$\verb|Y|%
			    $|$\verb|Z|
			    \\[1ex]
\key{digit} ::=    \verb|0|%
		$|$\verb|1|%
		$|$\verb|2|%
		$|$\verb|3|%
		$|$\verb|4|%
		$|$\verb|5|%
		$|$\verb|6|%
		$|$\verb|7|%
		$|$\verb|8|%
		$|$\verb|9|
		\\[1ex]
\key{white-space} ::= {\em white-space-character}
                     {\em white-space-character}\,$^\star$ \\[1ex]
\key{white-space-character}
    \begin{tabular}[t]{rl}
    ::= & {\em horizontal-space-character} \\
    $|$ & {\em vertical-space-character}
    \end{tabular}
    \\[1ex]
\key{horizontal-space-character} ::=
    \key{space} $|$ \key{horizontal-tab} $|$ \key{carriage-return} \\[1ex]
\key{vertical-space-character} ::=
    \key{line-feed} $|$ \key{vertical-tab} $|$ \key{form-feed}
\end{indpar}

\begin{boxedfigure}

\begin{center}
\begin{tabular}{lp{4in}}
\verb|\n| & new line \\
\verb|\r| & carriage return \\
\verb|\t| & horizontal tab \\
\verb|\b| & backspace \\
\verb|\f| & form feed \\
\verb|\v| & vertical tab \\
\verb|\\| & \verb|\| \\
\verb|\"| & \verb|"| \\[1ex]
\verb|\x|$hh$ & character with ASCII code $hh$ as a 2 digit
		hexadecimal number \\[1ex]
\verb|\|$ooo$ & character with ASCII code $ooo$ as a
		3 digit octal number \\[1ex]
\verb|\|{\em white-space}\verb|\|
		& the backslash, white space, and second backslash
		  are deleted; this allows continuation across
		  line ends
\end{tabular}
\end{center}%
\index{n@{\tt \BACKSLASH n}}%
\index{r@{\tt \BACKSLASH r}}%
\index{t@{\tt \BACKSLASH t}}%
\index{b@{\tt \BACKSLASH b}}%
\index{f@{\tt \BACKSLASH f}}%
\index{v@{\tt \BACKSLASH v}}%
\index{\\2@{\BACKSLASH\BACKSLASH}}%
\index{""2@{\tt \BACKSLASH""}}%
\index{space character 2@{\BACKSLASH{\em space}}}%
\index{x@{\tt \BACKSLASH x}$hh$}%
\index{digit@{\BACKSLASH{\em digit}}}%
\index{whitespace@{\BACKSLASH{\em white-space}\BACKSLASH}}

Characters that represent themselves:

\begin{indpar}
non-control, non-whitespace characters other than \verb|\| and \verb|"| \\
the single space character \\
\verb|\| when not followed by \verb|"|, \verb|\|, a digit,
    a lower case letter, or white-space
\end{indpar}


\caption{Character Representatives}
\label{CHARACTER-REPRESENTATIVES}
\end{boxedfigure}

A \key{word} is a sequence of letters that may include
a \verb|'| if it is followed by a letter.  A \key{mark} is a
sequence of mark characters (e.g., \verb|+| and \verb|-|).
A \key{separator} is a \underline{single} separator character.
A \key{number-lexeme} is a sequence of digits, decimal points
which are always followed by a digit, commas that are
both preceded and followed by digits, and slashes that are
both preceded and followed by digits.
A quoted string is
a sequence of \skey{character representative}s surrounded by
the double quote character (\ttnbkey{"}), where most characters
are their own representatives (\verb|A|, \verb|B|, \verb|0|, \verb|1|,
etc.) but other characters are represented by a sequences of
characters that begin with a backslash (e.g., \verb|\n| represents
a new line character).

A \ttnbkey{'} is a word character if it is followed by a letter,
and a separator character otherwise.
A \verb|.| is a number character (decimal point) if it
is followed by a digit, and a mark character otherwise.
A \ttnbkey{,} is a number character if surrounded by digits, and
a separator character otherwise.
A \ttnbkey{/} is a number character if surrounded by digits, and
a mark character otherwise.

Lexemes may be separated by \key{white-space}, which
is a sequence of white-space characters (single space, horizontal tab, form
feed, etc.), but is not itself a lexeme.
In order to indicate spacing, each lexeme is
tagged with the column, line, and page number of its first character.
This can be used to determine the indentation and extent of the lexeme.

Words, marks, and quoted strings are called \skey{symbol}s,
to distinguish them from separators and numbers.
Unless specified otherwise, a unquoted symbol may be quoted without changing
its meaning; i.e., \verb|fie| and \verb|*| mean the same thing
as \verb|"fie"| and \verb|"*"|.  However, to be a symbol a separator
or number must be quoted (e.g., \verb|","| and \verb|"5.9"|),
and to protect a symbol from
a special interpretation by a parser the symbol must be quoted
(e.g., \verb|"+"| will not be recognized as an operator in a context
in which \verb|+| would be).

\section{Data}

A \key{datum} in MIN is either an atom, an object, or an arrow.

An \key{atom} is a symbol or a number.

An object is just a place in memory, and is like a dot on a blank page.
It can be the source or target of arrows, and it is different from
every other object and from every atom.  But it is nothing more.

However, as a place in memory, an object has a name.  Objects are assigned
\skey{raw object name}s
of the form `\ttmnbkey{@}{in raw object name}$N$' where $N$
is a natural number (non-negative integer).
Raw object names of this form are assigned only to objects
that must be named in an output stream (e.g., printed output).
The first object named in output stream is assigned the name
\verb|@1|, the second object named in output the name \verb|@2|,
and so forth.  The same object may be assigned different names in different
output streams.\footnote{A possible implementation is to give objects that
have been assigned names in an output stream a hidden system defined output
stream specific attribute (\pagref{ATTRIBUTE})
equal to the object's name integer.  Another implementation uses a
hash table per stream.}

There are two kinds of arrows: single and double.

A \key{single arrow} is an arrow from an object to either another object
or to an atom.  The arrow has a \key{label}, which is a sequence of zero or
more atoms.

A \key{double arrow} is a double headed arrow between two objects.
It has a separate label for each direction, with each label being a
sequence of zero or more atoms.  A double arrow is equivalent to a
\underline{related pair}
of single arrows going in opposite directions between the same two objects.
The difference between a double arrow and a pair of single arrows is that
it is possible to delete only one direction of a pair of single arrows, but 
when deleting a double arrow, both directions are deleted.

An \key{arrow label} is a sequence of zero or more atoms.
Two arrows leaving the same object may have the same label.  Thus
an object and an arrow label together name
a set of arrows sourced at the object.

\ikey{Arrow flags}{arrow flag} may be attached to arrow labels.
More precisely, a set of arrow flags is defined for each object
and each arrow label, and these flags apply to all arrows sourced at the
object that have the given label.
The standard flags are the \key{dot flag} (\ttmkey{.}{dot flag}),
and the \key{maybe flag} (\ttmkey{?}{maybe flag}).
Arrows with a dot flagged label are not to be output when their source
is output.
Targets of arrows with a maybe flagged label may be garbage collected
(made to disappear automatically, see \secref{GARBAGE-COLLECTION})
if they cannot be reached except by traversing arrows whose labels
have maybe flags.

We will give examples in the next section along with a basic way of
representing sets of objects in text.  In the rest of this document
arrows are called \skey{attribute}s,\label{ATTRIBUTE} arrow labels are called
\skey{attribute label}s, arrow flags are called \skey{attribute flag}s,
and arrow targets are called \skey{attribute value}s.
Also `\ikey{attribute L of object O}{attribute!of an object}'
denotes the set of all values (arrow targets) of attributes
of object O (arrows sourced at O) which have the attribute label
(arrow label) L.

A double arrow is called a \key{double attribute}.  When viewed from
an object at one end of the double arrow, the double arrow is an
attribute of that object, the label of the arrow directed away from that object
is the \mkey{attribute label}{of double attribute} of the double attribute,
and the label of the arrow directed toward the object is the
\mkey{reverse attribute label}{of double attribute} of the double attribute.


\subsection{Raw Representations}
\label{RAW-REPRESENTATIONS}

A set of objects can be written to a text file or read from a text file.
When this is done, a textual representation of the object set is used
in the file.  The simplest representation is the raw representation,
which we now describe.

The format of a \key{raw representation} is:

\begin{indpar}[0.5em]
\begin{tabular}{l}
\emkey{raw-representation}
\\\hspace*{0.5in}\begin{tabular}[t]{rl}
                 ::= & {\em empty} \\
		 $|$ & {\em raw-object-representation}
		       \{ \verb|;| {\em raw-object-representation} \}$^\star$
		 \end{tabular}
\end{tabular}

\begin{tabular}{l}
\emkey{raw-object-representation} ::=
\\\hspace*{0.5in}
    {\em object-header} {\em raw-single-attribute-value}$^\star$
    {\em raw-attribute-representations}
\end{tabular}

\begin{tabular}{l}
\emkey{object-header}
    \begin{tabular}[t]{@{}rl@{}}
    ::= & {\em object-name} \verb|=|
          \ttmindex{=}{in {\em object-header}} \\
    $|$ & {\em object-name} \verb|>|
          \ttmindex{>}{in {\em object-header}} \\
    $|$ & {\em object-name} \verb|>>|
          \ttmindex{>>}{in {\em object-header}} \\
    \end{tabular}
\end{tabular}

\begin{tabular}{l}
\emkey{object-name} ::=
	\ttmnbkey{@}{in {\em object-name}} {\em natural-number}
\end{tabular}

\begin{tabular}{l}
\emkey{natural-number} ::=
\\\hspace*{0.5in}
{\em number} lexeme (\pagref{NUMBER-LEXEME})
				 containing only digits and commas
\end{tabular}%

\begin{tabular}{l}
\emkey{raw-attribute-representations}
\\\hspace*{0.5in}
	\begin{tabular}[t]{rl}
        ::= & {\em empty} \\
	$|$ & \underline{\LEFTBRACKET}
	      {\em raw-attribute-representation-list}
	      \underline{\RIGHTBRACKET}
	\end{tabular}
\end{tabular}

\begin{tabular}{l}
\emkey{raw-attribute-representation-list}
\\\hspace*{0.5in}
	\begin{tabular}[t]{rl}
        ::= & {\em empty} \\
	$|$ & {\em raw-attribute-representation}
	      \{ \verb|;| {\em raw-attribute-representation} \}$^\star$
	\end{tabular}
\end{tabular}


\begin{tabular}{l}
\emkey{raw-attribute-representation}\label{RAW-ATTRIBUTE-REPRESENTATION}
    \begin{tabular}[t]{@{}rl@{}}
    ::= & {\em raw-single-attribute-representation} \\
    $|$ & {\em double-attribute-representation}
    \end{tabular}
\end{tabular}

\begin{tabular}{l}
\emkey{raw-single-attribute-representation} ::=
\\\hspace*{0.5in}
	{\em attribute-label} {\em attribute-label-flags-option} \verb|=|
	{\em raw-single-attribute-value}
\end{tabular}%
\index{value!attribute}

\begin{tabular}{l}
\emkey{attribute-label} ::= {\em label}
\end{tabular}%
\index{label!attribute}

\begin{tabular}{l}
\emkey{label} ::= {\em atom}$^\star$
\end{tabular}%
\index{label}

\begin{tabular}{l}
\emkey{attribute-label-flags-option} ::=
    {\em empty} $|$ [ {\em non-special-symbol} ]
\end{tabular}%
\index{flags!attribute label}%
\index{attribute label!flags}

\begin{tabular}{l}
\emkey{raw-single-attribute-value} ::= {\em atom} $|$ {\em object-name}
\end{tabular}

\begin{tabular}{l}
\emkey{atom} ::= {\em non-special-symbol} $|$ {\em real-number}
\end{tabular}

\begin{tabular}{l}
\emkey{real-number} ::= see \pagref{NUMBER}
\end{tabular}

\begin{tabular}{l}
\emkey{non-special-symbol} ::= see text
\end{tabular}

\begin{tabular}{l}
\emkey{double-attribute-representation} ::=
\\\hspace*{0.5in}
	{\em attribute-label} {\em attribute-label-flags-option}
	\verb|=|
\\\hspace*{0.5in}
	{\em double-attribute-value} {\em reverse-attribute-label}
	{\em attribute-label-flags-option}
\end{tabular}

\begin{tabular}{l}
\emkey{double-attribute-value} ::= {\em object-name}
\end{tabular}

\begin{tabular}{l}
\emkey{reverse-attribute-label} ::= {\em label}
\end{tabular}

\end{indpar}

This syntax uses \verb|{ }| brackets and \verb|;| separators, but
these can be replaced by indentation and the \verb|:| mark according
to rules given in \secref{INDENTATION-LEXEME-INSERTION}.  Roughly,
everything is indented appropriately so the \verb|{|, \verb|;|,
and \verb|}| separators are all at line ends, and then the \verb|{|'s
are replaced by \verb|:|'s and the \verb|;|'s and \verb|}|'s are
deleted.  A \verb|:| can be glued to a previous mark, i.e.,
\verb|= {| can be replaced by \verb|=:|.  For example,

\begin{indpar}\begin{verbatim}
@1 = { type = woman; name = Jill; husband = @2 wife };
@2 = { type = man; name = Jack }
\end{verbatim}\end{indpar}

becomes

\begin{indpar}\begin{verbatim}
@1 =:
    type = woman
    name = Jill
    husband = @2 wife
@2 =:
    type = man
    name = Jack
\end{verbatim}\end{indpar}

These are {\em raw-representations} of an object pair that can
be represented pictorially as:

\begin{center}
\begin{picture}(3.0,1.5)
\put(0,0){\framebox(3.0,1.5){}}
\put(0.3,1.00){\makebox(0.8,0.3){\tt @1}}
\put(0.7,1.15){\oval(0.8,0.3)}
\put(0.5,1.00){\vector(0,-1){0.5}}
\put(0.45,0.75){\makebox(0,0)[r]{\tt type}}
\put(0.5,0.4){\makebox(0,0){\tt woman}}
\put(0.9,1.00){\vector(0,-1){0.7}}
\put(0.95,0.55){\makebox(0,0)[l]{\tt name}}
\put(0.9,0.2){\makebox(0,0){\tt Jill}}
\put(1.9,1.00){\makebox(0.8,0.3){\tt @2}}
\put(2.3,1.15){\oval(0.8,0.3)}
\put(2.1,1.00){\vector(0,-1){0.5}}
\put(2.05,0.75){\makebox(0,0)[r]{\tt type}}
\put(2.1,0.4){\makebox(0,0){\tt man}}
\put(2.5,1.00){\vector(0,-1){0.7}}
\put(2.55,0.55){\makebox(0,0)[l]{\tt name}}
\put(2.5,0.2){\makebox(0,0){\tt Jack}}
\put(1.1,1.17){\vector(1,0){0.8}}
\put(1.9,1.13){\vector(-1,0){0.8}}
\put(1.5,1.15){\oval(0.07,0.12)}
\put(1.5,1.30){\makebox(0,0){\tt husband}}
\put(1.5,1.00){\makebox(0,0){\tt wife}}
\end{picture}
\end{center}

There are two single attributes of object \verb|@1| (arrows sourced
at \verb|@1|),
one attribute labeled {\tt type} whose value (target) is the atom {\tt woman},
and one attribute labeled {\tt name} whose value is the atom {\tt Jill}.
There are two similar single attributes from object \verb|@2|.
There is a double attribute (double arrow)
between the two objects which has the
label {\tt husband} when going from \verb|@1| to \verb|@2|
and the label {\tt wife} when going in the reverse direction.

Note that in this syntax
only \emkey{non-special-symbols} may be used as {\em atoms}
that are parts of labels or attribute values.  A \key{special symbol}
is something like \verb|=| or \verb|+| that is given a special
interpretation during parsing.  In order to use a special symbol
as an atom in an attribute label or value,
it must be quoted; e.g., \verb|"="| must be used instead
of \verb|=| in a label.  This prevents the symbol from being confused with
the \verb|=| that follows the label.  In general, quoting a word or mark in an
attribute label or value never hurts,
as if the word or mark is not special, its quoted and unquoted
versions have the same meaning; e.g., \verb|"type"| and \verb|type|
denote the same symbol.  Consequently,
it is a good idea to quote any mark that is
used in a label, and also to quote words that are used
as operators, such as \verb|"if"|, \verb|"then"|, and \verb|"else"|.

Note, however, that quoted numbers and unquoted numbers are distinct;
quoted numbers are symbols and numbers are not.  When numbers are
input, details such as the presence of commas are lost, so when
the numbers are output, they may or may not have commas.  Thus the number
\verb|1,000| may become \verb|1000| on output.  This is
not true of symbols, so it would not be true of the symbol \verb|"1,000"|,
which would be \verb|1,000| on output.

Similarly quoted separators and separators are distinct.  \verb|";"|
is a symbol and \verb|;| is a separator.

It is possible to place \skey{attribute flag}s on attribute labels
by putting flag characters in \verb|[ ]| brackets after a label.
The flag characters must be combined into a {\em non-special-symbol}.
The following is the same as the above example except that flags
have been added to some of the attributes:

\begin{center}
\begin{tabular}[b]{@{}l@{}}
\verb|@1 =:|\\
\verb|    type = woman|\\
\verb|    name["-"] = Jill|\\
\verb|    husband["*"] = @2 wife["*"]|\\
\verb|@2 =:|\\
\verb|    type = man|\\
\verb|    name["+"] = Jack|\\
\end{tabular}
~~~~~~~~~
\begin{picture}(3.0,1.5)
\put(0,0){\framebox(3.0,1.5){}}
\put(0.3,1.00){\makebox(0.8,0.3){\tt @1}}
\put(0.7,1.15){\oval(0.8,0.3)}
\put(0.5,1.00){\vector(0,-1){0.5}}
\put(0.45,0.75){\makebox(0,0)[r]{\tt type}}
\put(0.5,0.4){\makebox(0,0){\tt woman}}
\put(0.9,1.00){\vector(0,-1){0.7}}
\put(0.95,0.55){\makebox(0,0)[l]{{\tt name}$^{\mbox{\tt -}}$}}
\put(0.9,0.2){\makebox(0,0){\tt Jill}}
\put(1.9,1.00){\makebox(0.8,0.3){\tt @2}}
\put(2.3,1.15){\oval(0.8,0.3)}
\put(2.1,1.00){\vector(0,-1){0.5}}
\put(2.05,0.75){\makebox(0,0)[r]{\tt type}}
\put(2.1,0.4){\makebox(0,0){\tt man}}
\put(2.5,1.00){\vector(0,-1){0.7}}
\put(2.55,0.55){\makebox(0,0)[l]{{\tt name}$^{\mbox{\tt +}}$}}
\put(2.5,0.2){\makebox(0,0){\tt Jack}}
\put(1.1,1.17){\vector(1,0){0.8}}
\put(1.9,1.13){\vector(-1,0){0.8}}
\put(1.5,1.15){\oval(0.07,0.12)}
\put(1.5,1.30){\makebox(0,0){{\tt husband}$^{\mbox{\tt *}}$}}
\put(1.5,1.00){\makebox(0,0){{\tt wife}$^{\mbox{\tt *}}$}}
\end{picture}
\end{center}

In the picture the attribute flags have been added as superscripts on the
attribute labels, and in the text the flags have been added as characters
in quoted strings inside \verb|[ ]| brackets that
follow attribute labels.

Several attributes of the same object (arrows sourced at the object)
may have the same attribute
label.  An example of this, in which object \verb|@1| has two
attributes labeled \verb|child|, is:

\begin{center}
\begin{tabular}{l@{\hspace*{1in}}l}
\begin{tabular}[b]{@{}l@{}}
\verb|@1 =:|\\
\verb|    child = @2 parent|\\
\verb|    child = @3 parent|\\
\end{tabular}
&
\begin{picture}(3.0,1.5)
\put(0,0){\framebox(3.0,1.5){}}
\put(0.3,1.00){\makebox(2.4,0.3){\tt @1}}
\put(1.5,1.15){\oval(2.4,0.3)}
\put(0.65,1.00){\vector(0,-1){0.6}}
\put(0.60,0.80){\makebox(0,0)[r]{\tt child}}
\put(0.75,0.40){\vector(0,1){0.6}}
\put(0.80,0.55){\makebox(0,0)[l]{\tt parent}}
\put(2.25,1.00){\vector(0,-1){0.6}}
\put(2.20,0.80){\makebox(0,0)[r]{\tt child}}
\put(2.35,0.40){\vector(0,1){0.6}}
\put(2.40,0.55){\makebox(0,0)[l]{\tt parent}}
\put(0.3,0.10){\makebox(0.8,0.3){\tt @2}}
\put(0.7,0.25){\oval(0.8,0.3)}
\put(1.9,0.10){\makebox(0.8,0.3){\tt @3}}
\put(2.3,0.25){\oval(0.8,0.3)}
\end{picture}
\end{tabular}
\end{center}

We say that the value of the \verb|child| attribute of \verb|@1| is
the set to two elements, \verb|@2| and \verb|@3|.

The differences between \verb|=|, \verb|>|, and \verb|>>| in the
{\em object-header} relate
to what is done when an object or attribute label previously exists.
Note that with the indentation convention, these become differences
between \verb|=:|, \verb|>:|, and \verb|>>:|.

\ttmnbkey{=}{in {\em object-header}}
(or \ttmnbkey{=:}{in {\em object-header}})
indicates that the object being represented should not previously
exist, or if it does exist, must not have been defined by any previous
{\em raw-object-representation} (it may have been defined as the value of an
attribute).  Second, any attribute label represented in the object
representation, if it previously exists because it was part of a
{\em double-attribute-representation}, must be represented with exactly
the same flags as it already has.

At the other extreme,
\ttmnbkey{>>}{in {\em object-header}}
(or \ttmnbkey{>>:}{in {\em object-header}})
adds to existing objects.
The object being represented can previously exist.  Any attribute
representation in the object representation creates a new attribute value.
Any flags on an attribute label are added to the flags of the label if
that label already exists.

\ttmnbkey{>}{in {\em object-header}}
(or \ttmnbkey{>:}{in {\em object-header}})
is like \verb|>>| (or \verb|>>:|)
except that the object representation cannot
add new values to previously existing attributes of the object represented.
More precisely, the attribute label of any attribute representation in
the object representation must not have previously (before the object
representation is read) been an attribute label of the represented object.
Thus \verb|>:| is used to introduce new attributes to an existing object.
Note that reverse attribute labels are not attribute labels in the sense
of this paragraph.

Double attributes must have only one representation.  If they
are given two representations, one for each end of the attribute
(double headed arrow),
\underline{two} identical double attributes (two double headed arrows with the
same end points and labels) will be created.
Usually one end of a double attribute is
thought of as the primary end, and its object representation is used to
include the sole representation of the double attribute.

The {\em object-name} \ttnbkey{@0} is special; it always names
a particular object, the \ttkey{.GLOBAL} object,
whose its attributes are called \skey{global variables}.  One of the global
variables is named {\tt .GLOBAL} and has as its value the {\tt .GLOBAL}
object itself, a situation which can be achieved by the data representation:

\begin{indpar}\begin{verbatim}
@0>:
    .GLOBAL = @0
\end{verbatim}\end{indpar}

Labels beginning with `\ttkey{.}' are reserved for use by
the MIN system, and should not be defined by MIN users.  {\tt .GLOBAL}
is an example of such a word.

The CASTLE parsers
(\secref{LEXICAL-PARSING} and \secref{EXPRESSION-PARSING})
parse\label{RAW-PARSING}
{\em raw-representations}.
Because special
symbols are avoided in attribute labels and values, the parser does
little with these.  However, the lexical parser
does two things that affect attribute labels
and values.

The first is recognizing several lexeme {\em real-numbers}
(\secref{NUMBERS}),
such as \verb|1.23e-2| and \verb|1 3/4|.  In all cases
a single numeric atom is stored inside the computer, and
details of its representation are lost.  Thus \verb|1.23e-2| and
\verb|0.0123| store the same number, and \verb|1 3/4| and \verb|7/4|
store the same number.

The second thing the lexical parser does to attribute labels and values
is lexeme replacement (\secref{LEXEME-REPLACEMENT}).  Thus the
{\em raw-attribute-representation}
\begin{center}
\verb|Mary's power = people|
\end{center}
would standardly be turned into
\begin{center}
\verb|Mary 's power = person|
\end{center}
since possessives are standardly separated and
plural nouns are standardly replaced by singular nouns.

\subsection{Lists}

Objects are implemented so that attributes whose labels are small
strictly positive integers can be accessed with more efficiency
than other attributes.  If an object has attributes with consecutive
labels from \verb|1| to $N$, with no gaps,
then these values are said to form a \key{list} that is represented
by the object.  An example is

\begin{indpar}\begin{verbatim}
@93 =:
    1 = this
    2 = is
    3 = a
    4 = sentence
    .terminator = "."
    .initiator = capital
\end{verbatim}\end{indpar}

which represents the list
\begin{indpar}
\verb|this is a sentence|
\end{indpar}

but also has some additional attributes, labeled \verb|.terminator|
and \verb|.initiator|.  An alternative {\em raw-object-representation}
to the one just given is:

\begin{indpar}\begin{verbatim}
@93 = this is a sentence:
    .terminator = "."
    .initiator = capital
\end{verbatim}\end{indpar}

Any {\em single-attribute-values} following the {\em object-header}
are assigned as values of the attributes labeled \verb|1|, \verb|2|,
\verb|3|, \ldots.  Additional attribute values can be given by
following these by \verb|:| and then by indented
{\em raw-attribute-representations}, or \verb|{ }| bracketted and
\verb|;| separated {\em raw-attribute-representations}.

\subsection{Cooked Representations}

As noted above (\pagref{RAW-PARSING}),
{\em raw-single-attribute-values} in a {\em raw-representation}
are mostly left alone by the CASTLE parsers.  This is because the
use of special symbols are not allowed in these, aside from
{\em radix-indicators} and {\em exponent-indicators} which are
only recognized when adjacent to quoted string or number lexemes.

However, special symbols can be used in attribute values representations
to create attribute values that are complex objects produced by the
CASTLE parsers in their full glory.  When this is done, the object
representation is said to be `\key{cooked}' instead of `\key{raw}'.

The syntax of {\em cooked-representations} is that of
{\em raw-representations} with `{\em raw-}' replaced by {\em cooked-}
and two syntax equations adjusted as follows:

\begin{indpar}

\begin{tabular}{l}
\emkey{cooked-object-representation} ::=
\\\hspace*{0.5in}
    {\em object-header} {\em expression-option}
    {\em cooked-attribute-representations}
\end{tabular}

\begin{tabular}{l}
\emkey{cooked-single-attribute-value} ::= {\em expression}
		~~~~~ [see \secref{EXPRESSION-PARSING}]
\end{tabular}

\end{indpar}

In the {\em cooked-object-representation} the list of {\em raw-single-attribute-values} that could follow the {\em object-header} has been replaced by
an {\em expression}, while the {\em cooked-single-attribute-value} can be
any {\em expression}

As a first example,

\begin{indpar}\begin{verbatim}
@93 = `This is a sentence.'
\end{verbatim}\end{indpar}

is the cooked representation of the object

\begin{center}
\begin{tabular}[b]{@{}l@{}}
\verb|@93 =:|\\
\verb|    1 = this|\\
\verb|    2 = is|\\
\verb|    3 = a|\\
\verb|    4 = sentence|\\
\verb|    .terminator = "."|\\
\verb|    .initiator = capital|\\
\end{tabular}
~~~~~
\begin{picture}(4.1,1.5)
\put(0,0){\framebox(4.1,1.5){}}
\put(0.3,1.00){\makebox(3.4,0.3){\tt @93}}
\put(2.0,1.15){\oval(3.4,0.3)}
\put(1.00,1.00){\vector(0,-1){0.4}}
\put(0.95,0.85){\makebox(0,0)[r]{\tt .initiator}}
\put(1.00,0.50){\makebox(0,0)[c]{\tt capital}}
\put(1.50,1.00){\vector(0,-1){0.6}}
\put(1.45,0.85){\makebox(0,0)[r]{\tt 1}}
\put(1.50,0.30){\makebox(0,0)[c]{\tt this}}
\put(1.85,1.00){\vector(0,-1){0.6}}
\put(1.80,0.85){\makebox(0,0)[r]{\tt 2}}
\put(1.85,0.30){\makebox(0,0)[c]{\tt is}}
\put(2.10,1.00){\vector(0,-1){0.6}}
\put(2.05,0.85){\makebox(0,0)[r]{\tt 3}}
\put(2.10,0.30){\makebox(0,0)[c]{\tt a}}
\put(2.60,1.00){\vector(0,-1){0.6}}
\put(2.55,0.85){\makebox(0,0)[r]{\tt 4}}
\put(2.60,0.30){\makebox(0,0)[c]{\tt sentence}}
\put(3.00,1.00){\vector(0,-1){0.4}}
\put(3.00,0.50){\makebox(0,0)[c]{\tt "."}}
\put(3.05,0.85){\makebox(0,0)[l]{\tt .terminator}}
\end{picture}
\end{center}


The second example contains simple code:

\begin{indpar}\begin{verbatim}
@45 = { straight 3.2; left; straight (y + 9.4) }
\end{verbatim}\end{indpar}

is the cooked representation of the objects

\begin{center}
\begin{tabular}[b]{@{}l@{}}
\verb|@42 =:|\\
\verb|    1 = straight|\\
\verb|    2 = 3.2|\\
\verb|@43 =:|\\
\verb|    1 = "+"|\\
\verb|    2 = y|\\
\verb|    3 = 9.4|\\
\verb|    .initiator = "("|\\
\verb|    .terminator = ")"|\\
\verb|@44 =:|\\
\verb|    1 = straight|\\
\verb|    2 = @43|\\
\verb|@45 =:|\\
\verb|    1 = @42|\\
\verb|    2 = left|\\
\verb|    3 = @44|\\
\verb|    .initiator = "{"|\\
\verb|    .terminator = "}"|\\
\verb|    .separator = ";"|\\
\end{tabular}
~~~~~
\begin{picture}(4.1,3.7)
\put(0,0){\framebox(4.1,3.7){}}
\put(1.4,0.0){
\put(0.0,0.90){\makebox(2.0,0.3){\tt @43}}
\put(1.0,1.05){\oval(2.0,0.3)}
\put(0.40,0.90){\vector(0,-1){0.4}}
\put(0.35,0.75){\makebox(0,0)[r]{\tt .initiator}}
\put(0.40,0.40){\makebox(0,0)[c]{\tt "("}}
\put(0.70,0.90){\vector(0,-1){0.6}}
\put(0.65,0.75){\makebox(0,0)[r]{\tt 1}}
\put(0.70,0.20){\makebox(0,0)[c]{\tt "+"}}
\put(1.00,0.90){\vector(0,-1){0.6}}
\put(0.95,0.75){\makebox(0,0)[r]{\tt 2}}
\put(1.00,0.20){\makebox(0,0)[c]{\tt y}}
\put(1.30,0.90){\vector(0,-1){0.6}}
\put(1.25,0.75){\makebox(0,0)[r]{\tt 3}}
\put(1.30,0.20){\makebox(0,0)[c]{\tt 9.4}}
\put(1.60,0.90){\vector(0,-1){0.4}}
\put(1.60,0.40){\makebox(0,0)[c]{\tt ")"}}
\put(1.65,0.75){\makebox(0,0)[l]{\tt .terminator}}
}
\put(0.6,1.3){
\put(0.0,0.50){\makebox(1.2,0.3){\tt @42}}
\put(0.60,0.65){\oval(1.2,0.3)}
\put(0.30,0.50){\vector(0,-1){0.3}}
\put(0.25,0.35){\makebox(0,0)[r]{\tt 1}}
\put(0.30,0.10){\makebox(0,0)[c]{\tt straight}}
\put(0.90,0.50){\vector(0,-1){0.3}}
\put(0.85,0.35){\makebox(0,0)[r]{\tt 2}}
\put(0.90,0.10){\makebox(0,0)[c]{\tt 3.2}}
}
\put(2.2,1.3){
\put(0.0,0.50){\makebox(1.2,0.3){\tt @44}}
\put(0.60,0.65){\oval(1.2,0.3)}
\put(0.30,0.50){\vector(0,-1){0.3}}
\put(0.25,0.35){\makebox(0,0)[r]{\tt 1}}
\put(0.30,0.10){\makebox(0,0)[c]{\tt straight}}
\put(0.90,0.50){\vector(0,-1){0.6}}
\put(0.85,0.35){\makebox(0,0)[r]{\tt 2}}
}
\put(0.2,2.7){
\put(0.0,0.50){\makebox(3.2,0.3){\tt @45}}
\put(1.60,0.65){\oval(3.2,0.3)}
\put(0.80,0.50){\vector(0,-1){0.3}}
\put(0.75,0.35){\makebox(0,0)[r]{\tt .initiator}}
\put(0.80,0.10){\makebox(0,0)[c]{\tt "\LEFTBRACKET"}}
\put(1.30,0.50){\vector(0,-1){1.1}}
\put(1.25,0.35){\makebox(0,0)[r]{\tt 1}}
\put(1.70,0.50){\vector(0,-1){0.4}}
\put(1.65,0.30){\makebox(0,0)[r]{\tt 2}}
\put(1.70,0.00){\makebox(0,0)[c]{\tt left}}
\put(2.30,0.50){\vector(0,-1){1.1}}
\put(2.25,0.35){\makebox(0,0)[r]{\tt 3}}
\put(2.70,0.50){\vector(0,-1){0.8}}
\put(2.75,-0.15){\makebox(0,0)[l]{\tt .separator}}
\put(2.70,-0.40){\makebox(0,0)[c]{\tt ";"}}
\put(2.90,0.50){\vector(0,-1){0.3}}
\put(2.95,0.35){\makebox(0,0)[l]{\tt .terminator}}
\put(2.90,0.10){\makebox(0,0)[c]{\tt "\RIGHTBRACKET"}}
}
\end{picture}
\end{center}

A third example uses multiple indented lines to represent code, so that

\begin{indpar}\begin{verbatim}
@138 = function (x,y):

          if (x > y):
              return y
          else:
              return x
\end{verbatim}\end{indpar}

is the cooked representation of the object in
Figure~\ref{EXAMPLE-CODE-OBJECT-REPRESENTATION}.


\begin{boxedfigure}

\begin{center}
\begin{tabular}[t]{@{}l@{}}
\verb|@130 =:|\\
\verb|    1 = x|\\
\verb|    2 = y|\\
\verb|    .separator = ","|\\
\verb|    .initiator = "("|\\
\verb|    .terminator = ")"|\\
\verb|@131 =:|\\
\verb|    1 = ">"|\\
\verb|    2 = x|\\
\verb|    3 = y|\\
\verb|    .initiator = "("|\\
\verb|    .terminator = ")"|\\
\verb|@132 =:|\\
\verb|    1 = return|\\
\verb|    2 = y|\\
\verb|    .initiator = ":"|\\
\verb|@133 =:|\\
\verb|    1 = if|\\
\verb|    2 = @131|\\
\verb|    3 = @132|\\
\verb|@134 =:|\\
\verb|    1 = return|\\
\verb|    2 = x|\\
\verb|    .initiator = ":"|\\
\verb|@135 =:|\\
\verb|    1 = else|\\
\verb|    2 = @134|\\
\verb|@136 =:|\\
\verb|    1 = @133|\\
\verb|    2 = @135|\\
\verb|    .initiator = ":"|\\
\end{tabular}
~
\begin{tabular}[t]{@{}l@{}}
\verb|@137 =:|\\
\verb|    1 = function|\\
\verb|    2 = @130|\\
\verb|    3 = @136|\\[2ex]
\begin{picture}(4.0,5.5)
\put(0,0){\framebox(4.0,5.5){}}
\put(0.6,0.0){
\put(0.0,0.50){\makebox(2.0,0.3){\tt @131}}
\put(1.0,0.65){\oval(2.0,0.3)}
\put(0.40,0.50){\vector(0,-1){0.25}}
\put(0.35,0.40){\makebox(0,0)[r]{\tt .initiator}}
\put(0.40,0.15){\makebox(0,0)[c]{\tt "("}}
\put(0.70,0.50){\vector(0,-1){0.25}}
\put(0.65,0.40){\makebox(0,0)[r]{\tt 1}}
\put(0.70,0.15){\makebox(0,0)[c]{\tt ">"}}
\put(1.00,0.50){\vector(0,-1){0.25}}
\put(0.95,0.40){\makebox(0,0)[r]{\tt 2}}
\put(1.00,0.15){\makebox(0,0)[c]{\tt x}}
\put(1.30,0.50){\vector(0,-1){0.25}}
\put(1.25,0.40){\makebox(0,0)[r]{\tt 3}}
\put(1.30,0.15){\makebox(0,0)[c]{\tt y}}
\put(1.60,0.50){\vector(0,-1){0.25}}
\put(1.65,0.40){\makebox(0,0)[l]{\tt .terminator}}
\put(1.60,0.15){\makebox(0,0)[c]{\tt ")"}}
}
\put(1.4,1.4){
\put(0.0,0.50){\makebox(1.3,0.3){\tt @132}}
\put(0.65,0.65){\oval(1.3,0.3)}
\put(0.20,0.50){\vector(0,-1){0.25}}
\put(0.15,0.40){\makebox(0,0)[r]{\tt .initiator}}
\put(0.20,0.15){\makebox(0,0)[c]{\tt ":"}}
\put(0.70,0.50){\vector(0,-1){0.25}}
\put(0.65,0.40){\makebox(0,0)[r]{\tt 1}}
\put(0.70,0.15){\makebox(0,0)[c]{\tt return}}
\put(1.10,0.50){\vector(0,-1){0.25}}
\put(1.05,0.40){\makebox(0,0)[r]{\tt 3}}
\put(1.10,0.15){\makebox(0,0)[c]{\tt y}}
}
\put(2.6,0.7){
\put(0.0,0.50){\makebox(1.3,0.3){\tt @134}}
\put(0.65,0.65){\oval(1.3,0.3)}
\put(0.20,0.50){\vector(0,-1){0.25}}
\put(0.15,0.40){\makebox(0,0)[r]{\tt .initiator}}
\put(0.20,0.15){\makebox(0,0)[c]{\tt ":"}}
\put(0.70,0.50){\vector(0,-1){0.25}}
\put(0.65,0.40){\makebox(0,0)[r]{\tt 1}}
\put(0.70,0.15){\makebox(0,0)[c]{\tt return}}
\put(1.10,0.50){\vector(0,-1){0.25}}
\put(1.05,0.40){\makebox(0,0)[r]{\tt 3}}
\put(1.10,0.15){\makebox(0,0)[c]{\tt x}}
}
\put(0.2,2.0){
\put(0.0,0.50){\makebox(1.2,0.3){\tt @133}}
\put(0.60,0.65){\oval(1.2,0.3)}
\put(0.30,0.50){\vector(0,-1){0.25}}
\put(0.25,0.40){\makebox(0,0)[r]{\tt 1}}
\put(0.30,0.15){\makebox(0,0)[c]{\tt if}}
\put(0.60,0.50){\line(0,-1){0.45}}
\put(0.50,0.05){\oval(0.2,0.2)[br]}
\put(0.50,-0.05){\line(-1,0){0.40}}
\put(0.10,-0.15){\oval(0.2,0.2)[tl]}
\put(0.00,-0.15){\line(0,-1){1.10}}
\put(0.10,-1.25){\oval(0.2,0.2)[bl]}
\put(0.10,-1.35){\vector(1,0){0.30}}
\put(0.55,0.40){\makebox(0,0)[r]{\tt 2}}
\put(0.90,0.50){\line(0,-1){0.35}}
\put(1.00,0.15){\oval(0.2,0.2)[bl]}
\put(1.00,0.05){\vector(1,0){0.2}}
\put(0.85,0.40){\makebox(0,0)[r]{\tt 3}}
}
\put(2.8,2.0){
\put(0.0,0.50){\makebox(0.8,0.3){\tt @135}}
\put(0.40,0.65){\oval(0.8,0.3)}
\put(0.20,0.50){\vector(0,-1){0.25}}
\put(0.15,0.40){\makebox(0,0)[r]{\tt 1}}
\put(0.20,0.15){\makebox(0,0)[c]{\tt else}}
\put(0.60,0.50){\vector(0,-1){1.0}}
\put(0.55,0.40){\makebox(0,0)[r]{\tt 2}}
}
\put(1.5,2.4){
\put(0.2,1.00){\makebox(1.3,0.3){\tt @136}}
\put(0.85,1.15){\oval(1.3,0.3)}
\put(0.40,1.00){\vector(0,-1){0.25}}
\put(0.35,0.90){\makebox(0,0)[r]{\tt .initiator}}
\put(0.40,0.65){\makebox(0,0)[c]{\tt ":"}}
\put(0.70,1.00){\line(0,-1){0.65}}
\put(0.60,0.35){\oval(0.2,0.2)[br]}
\put(0.60,0.25){\vector(-1,0){0.70}}
\put(0.65,0.90){\makebox(0,0)[r]{\tt 1}}
\put(1.00,1.00){\line(0,-1){0.65}}
\put(1.10,0.35){\oval(0.2,0.2)[bl]}
\put(1.10,0.25){\vector(1,0){0.20}}
\put(0.95,0.90){\makebox(0,0)[r]{\tt 2}}
}
\put(0.6,3.2){
\put(0.2,1.00){\makebox(1.3,0.3){\tt @130}}
\put(0.85,1.15){\oval(1.3,0.3)}
\put(0.40,1.00){\vector(0,-1){0.25}}
\put(0.35,0.90){\makebox(0,0)[r]{\tt .initiator}}
\put(0.40,0.65){\makebox(0,0)[c]{\tt "("}}
\put(0.70,1.00){\vector(0,-1){0.25}}
\put(0.65,0.90){\makebox(0,0)[r]{\tt 1}}
\put(0.70,0.65){\makebox(0,0)[c]{\tt x}}
\put(1.00,1.00){\vector(0,-1){0.25}}
\put(0.95,0.90){\makebox(0,0)[r]{\tt 2}}
\put(1.00,0.65){\makebox(0,0)[c]{\tt y}}
\put(1.30,1.00){\vector(0,-1){0.25}}
\put(1.35,0.90){\makebox(0,0)[l]{\tt .terminator}}
\put(1.30,0.65){\makebox(0,0)[c]{\tt ")"}}
\put(1.50,1.15){\vector(1,0){1.0}}
\put(1.55,1.20){\makebox(0,0)[l]{\tt .separator}}
\put(2.55,1.15){\makebox(0,0)[l]{\tt ","}}
}
\put(0.2,4.5){
\put(0.0,0.50){\makebox(3.6,0.30){\tt @137}}
\put(1.80,0.65){\oval(3.6,0.3)}
\put(0.30,0.50){\vector(0,-1){0.25}}
\put(0.25,0.40){\makebox(0,0)[r]{\tt 1}}
\put(0.30,0.15){\makebox(0,0)[c]{\tt function}}
\put(1.25,0.50){\vector(0,-1){0.5}}
\put(1.20,0.40){\makebox(0,0)[r]{\tt 2}}
\put(3.40,0.50){\line(0,-1){1.35}}
\put(3.30,-0.85){\oval(0.2,0.2)[br]}
\put(3.30,-0.95){\vector(-1,0){0.5}}
\put(3.35,0.40){\makebox(0,0)[r]{\tt 3}}
}
\end{picture}
\end{tabular}
\end{center}

\caption{Example Code Object Representation}
\label{EXAMPLE-CODE-OBJECT-REPRESENTATION}
\end{boxedfigure}

Cooked representations may replace raw object names in the
description of other objects, as in

\begin{indpar}\begin{verbatim}
@291: text = `This is a sentence.'
      outline = { straight 3.2, left, straight (y + 9.4) }
      min = function (x,y):

                if (x > y):
                    return y
                else:
                    return x
\end{verbatim}\end{indpar}

which is the cooked representation of the object

\begin{indpar}\begin{verbatim}
@291:
    text: @93
    outline: @45
    min: @137
\end{verbatim}\end{indpar}

given the above examples.

One question left unanswered by the discussion so far is whether

\begin{indpar}\begin{verbatim}
@291: text A: This is a sentence.
      text B: This is a sentence.
\end{verbatim}\end{indpar}

represents

\begin{indpar}\begin{verbatim}
@291:
    text A: @93
    text B: @93
\end{verbatim}\end{indpar}

or instead

\begin{indpar}\begin{verbatim}
@291:
    text A: @93
    text B: @999
\end{verbatim}\end{indpar}

where object \verb|@999| happens to have the same structure as
object \verb|@93|.  The default is to make both \verb|text A|
and \verb|text B| be the same object, \verb|@93|, and to make
that object `immutable', meaning that it cannot be changed.  The
rule is that unless otherwise indicated, only immutable objects
have the property that their cooked representations can replace
their raw object names in the cooked representations of other
objects.

\section{Lexical Parsing}
\label{LEXICAL-PARSING}

After input text is converted to a sequence of lexemes, the lexemes
are read from left to right by an lexical parser and converted into
lexical expressions, which are sequences of lexemes and explicit
subexpressions.  During this process lexemes may be
inserted or replaced.  Except for explicitly bracketted subexpressions,
lexical parsing only affects short sequences of lexemes, and is
thereby distinguished from expression parsing, which is applied to
the lexical expressions, and which affects arbitrarily
long sequences of lexemes.

All forms of parsing are controlled by parsing definitions, which
are input as a separate and distinct piece of program code, before
the code being parsed is input.  These parsing definitions are
placed in the parsing definition stack.
See~\secref{PARSING-DEFINITION-STACK}.

Lexical parsing consists of the following steps which are done in
the order given:

\begin{indpar}[0.8in]
Lexeme Replacement (Spelling Regularization, Possessive Splitting)
    (\secref{LEXEME-REPLACEMENT}) \\
Explicit Subexpression Recognition
    (\secref{EXPLICIT-SUBEXPRESSION-RECOGNITION}) \\
Radix Number Recognition (\secref{RADIX-NUMBER-RECOGNITION}) \\
Scientific Number Recognition (\secref{SCIENTIFIC-NUMBER-RECOGNITION}) \\
Number Pair Recognition (\secref{NUMBER-PAIR-RECOGNITION}) \\
Number Unit Grouping (\secref{NUMBER-UNIT-GROUPING}) \\
Unit Multiplication Insertion (\secref{UNIT-MULTIPLICATION-INSERTION})
\end{indpar}

Thus the output of the lexeme replacement lexical parsing
algorithm is the input to the explicit subexpression recognition
lexical parsing algorithm, and so forth.


\subsection{Lexeme Replacement}
\label{LEXEME-REPLACEMENT}

The \key{lexeme replacement}
process replaces a string of one or more lexemes by a string of zero or
more lexemes.  Lexeme replacement is done before all other steps of
lexical parsing, so these other steps operate on the lexeme sequence
after lexeme replacements have been made.

Lexeme replacement may be done by either a dictionary or a function.
Replacement is controlled by \skey{lexeme replacement definition}s
in the parsing definition stack (\pagref{PARSING-DEFINITION-STACK}).

There are two kinds of lexeme replacement definitions:
dictionary and function.  These have the syntax:

\begin{indpar}
\key{lexeme-replacement-definition}\,
		     \begin{tabular}[t]{rl}
                     ::= & {\em lexeme-dictionary-definition} \\
		     $|$ & {\em lexeme-function-definition}
		     \end{tabular}
\label{LEXEME-REPLACEMENT-DEFINITION}%
		     \\[1ex]
\ikey{lexeme-dictionary-definition}{lexeme-dictionary-!definition} \\
	\hspace*{0.5in}::= \begin{tabular}[t]{@{}l@{}l@{}}
	                   \verb|define | & \verb|lexeme dictionary|
                                            {\em dictionary-name}
					    {\em parsing-selectors} \\
				& {\em lexeme-dictionary-entries}
		     \end{tabular} \\[1ex]
\key{dictionary-name} ::= {\em symbol} {\em symbol}\,$^\star$
	\\[1ex]
\key{parsing-selectors}\,
                    \begin{tabular}[t]{rl}
		    ::= & {\em empty} \\
                    $|$ & \verb|[| {\em parsing-selector-list} \verb|]|
		    \end{tabular}
\label{PARSING-SELECTORS}%
		    \\[1ex]
\key{parsing-selector-list}
\label{PARSING-SELECTOR-LIST}%
		     \\
		     \hspace*{0.5in}\begin{tabular}[t]{@{}rl@{}}
                     ::= & {\em parsing-selector} \\
		     $|$ & {\em parsing-selector-list} \verb|,|
		           {\em parsing-selector}
		     \end{tabular}
		     \\[1ex]
\key{parsing-selector} ::= {\em symbol} {\em symbol}\,$^\star$
	\\[1ex]
\key{lexeme-dictionary-entries}
                    ::= \underline{\LEFTBRACKET}
		        {\em lexeme-dictionary-entry-list}
			\underline{\RIGHTBRACKET}
		    \\[1ex]
\key{lexeme-dictionary-entry-list} \\
		     \hspace*{0.5in}\begin{tabular}[t]{@{}rl@{}}
                     ::= & {\em lexeme-dictionary-entry} \\
		     $|$ & {\em lexeme-dictionary-entry-list} \verb|;|
		           {\em lexeme-dictionary-entry}
		     \end{tabular} \\[1ex]
\key{lexeme-dictionary-entry} \\
    \hspace*{0.5in}::=
	{\em replaced-lexemes} \verb|==>| {\em replacing-lexemes}
	\\[1ex]
\key{replaced-lexemes} ::=
	{\em symbol} {\em symbol}\,$^\star$ \\[1ex]
\key{replacing-lexemes} ::=
	{\em symbol}\,$^\star$ \\[1ex]
\key{lexeme-function-definition} \\
	\hspace*{0.5in}::= \verb|define lexeme function|
				{\em function-name}
				{\em parsing-selectors} \\[1ex]
\key{function-name} ::=
	{\em symbol} {\em symbol}\,$^\star$
\label{FUNCTION-NAME}
\end{indpar}

A \key{lexeme dictionary entry} gives a sequence of lexemes
that is to be replaced
and a sequence of lexemes that replace it.  For example, the entry

\begin{center}
\verb|people ==> person|
\end{center}

causes the word `\verb|people|' to be replaced by the word `\verb|person|'.

A \key{lexeme function} is a function that is called with a list of
lexemes as its single argument and which returns either
`\verb|false|' if the lexeme at the beginning of the list is not to be
replaced, or returns a pair consisting of first a list of replacing
lexemes and second the in input list with the replaced lexemes removed
from its beginning.
For example, given the lexeme function definition

\begin{indpar}
\begin{verbatim}
define lexeme function replace people [operator]
\end{verbatim}
\end{indpar}

and the function definition

\begin{indpar}
\begin{verbatim}
replace people X <-- list ( X ):
    if first X == `people':
        value = ( `person', rest X )
    else:
        value = false
\end{verbatim}
\end{indpar}

then

\begin{center}
\verb|replace people `people with hats'| $\Longrightarrow$
\verb|(`person',`with hats')|

\verb|replace people `fee fie foe fum'| $\Longrightarrow$ \verb|false|
\end{center}


Lexeme replacement is \underline{not} recursive: the replacement lexemes are
not themselves subject to replacement.

A quoted string in a {\em replaced-lexemes} or {\em replacing-lexemes}
sequence of lexemes denotes the lexeme made by removing its outer quotes.
Thus \verb|","| denotes the separator
\verb|,| and \verb|"\",\""| denotes the quoted string \verb|","|.

The {\em parsing-selectors} are used to specify the parsing contexts in
which a lexeme replacement definition is active.  The standard parsing
selectors for lexeme replacement definitions
are `{\tt operator}' and `{\tt list}'.
See~\secref{PARSING-SELECTORS} for details.

If several different lexeme replacement definitions could be used to
replace lexemes at the beginning of a lexeme sequence, the topmost
definition in the parsing definition stack
(\pagref{PARSING-DEFINITION-STACK}) is used.

The following lexeme dictionaries and functions are
defined in the initial parsing definition stack.
Their definitions are ordered in the
stack so the first given below is at the top of the stack and is the
first that replaces lexemes.

\begin{list}{}{}

\item
\verb|define lexeme dictionary english lexeme dictionary [operator list]|\\[1ex]
This dictionary translates common English irregular plurals,
to their singular form, and decomposes
irregular possessives to their singular decomposed form.
This dictionary also protects irregular singular forms that might be
mistaken for regular plural forms (e.g., `\verb|news|').
Some example translations are:

\begin{center}
\begin{tabular}{l}
\verb|people| $\longrightarrow$ \verb|[person]| \\
\verb|women| $\longrightarrow$ \verb|[woman]| \\
\verb|geese| $\longrightarrow$ \verb|[goose]| \\
\verb|fungi| $\longrightarrow$ \verb|[fungus]| \\
\verb|news| $\longrightarrow$ \verb|[news]| \\
\end{tabular}
\end{center}

\item
\verb|define lexeme function english lexeme function [operator list]|\\[1ex]
This function translates common English standard plurals
to their singular form, and decomposes
standard possessives to their singular decomposed form.
Some example translations are:

\begin{center}
\begin{tabular}{l}
\verb|boys| $\longrightarrow$ \verb|[boy]| \\
\verb|boy's| $\longrightarrow$ \verb|[boy 's]| \\
\verb|boxes| $\longrightarrow$ \verb|[box]| \\
\end{tabular}
\end{center}

\end{list}

Because CASTLE, outside the context of quotes,
insists on mapping different forms of a word to a single
word, some subtleties of language are lost.  For example, `\verb|people|'
can be a singular word referring to a group of people, but CASTLE will
standardly confuse it with `\verb|person|'.

\subsection{Explicit Subexpression Recognition}
\label{EXPLICIT-SUBEXPRESSION-RECOGNITION}

\ikey{Explicit subexpressions}{explicit subexpression}
are subexpressions surrounded by explicit brackets or subexpressions
introduced by an indented subexpression marks and defined by
indentation.

\ikey{Explicit brackets}{explicit bracket}
are defined by bracket definitions in the
parsing definition stack, and are used to surround
\skey{explicitly bracketted subexpression}s.  An example bracket
definition is

\begin{indpar}\begin{tabular}{@{}l@{~}l}
\verb|define| & \verb|bracket "{" ... "}" [operator]| \\
              & \ldots
\end{tabular}\end{indpar}

This specifies that \verb|{| is an \key{opening bracket}
and \verb|}| is its corresponding \key{closing bracket}.  More details on
bracket definitions can be found in \secref{BRACKET-DEFINITION}.
The lexical parser recognizes opening explicit brackets in
its input list of lexemes.  Once an opening bracket is recognized,
its corresponding closing bracket can be recognized, as long as it
is not inside an explicit subexpression.

\ikey{Indented expression marks}{indented expression mark}
are defined by indented expression
mark definitions in the parsing definition stack and are used to introduce
\skey{indented subexpression}s.
An example indented expression mark definition is

\begin{indpar}\begin{verbatim}
define indented expression mark * ":" [operator]
       with separator ";"
\end{verbatim}\end{indpar}

This specifies that a mark ending in \verb|:| that is at the end
of a line introduces an indented subexpression.  The following
example contains 3 indented subexpressions:

\begin{indpar}\begin{verbatim}
sum from X through Y <-- integer X, integer Y:
    `Sum of integers from X through Y.'
    if ( X > Y ):
        value = 0
    else:
        value = X + sum (X+1) through Y
\end{verbatim}\end{indpar}

Here the \verb|:| at the end of the first line introduces an
indented subexpression consisting of all following lines, and
the \verb|:|'s at the end of the `\verb|if|' and `\verb|else|'
lines each introduce one line indented subexpressions.

The output of the \underline{lexical} parser for this example
is the same as its output for:

\begin{indpar}\begin{verbatim}
@1 = sum from X through Y "<--" integer X "," integer Y @2
@2 = @3 @4 @5 { .initiator = ":" }
@3 = `Sum of integers from X through Y.'
@4 = if ( X > Y ) @6
@6 = @7 { .initiator = ":" }
@7 = value "=" 0
@5 = else @8
@8 = @9 { .initiator = ":" }
@9 = value "=" X "+" sum ( X "+" 1 ) through Y
\end{verbatim}\end{indpar}

where we have not done lexical parsing for explicitly
bracketted subexpressions.  The output of lexical parsing
on the objects above that include explicitly
bracketted subexpressions is the same as:

\begin{indpar}\begin{verbatim}
@3 = Sum of integers from X through Y "."
         { .initiator = "`"; .terminator = "'" }

@4 = if @10 @6
@10 = X ">" Y { .initiator = "("; .terminator = ")" }

@9 = value "=" X "+" sum @11 through Y
@11 = X "+" 1 { .initiator = "("; .terminator = ")" }
\end{verbatim}\end{indpar}

Note that expression parsing, which is done after lexical parsing,
can transform the results of lexical parsing significantly.  Thus
after expression parsing \verb|@3| becomes:

\begin{indpar}\begin{verbatim}
@3 = sum of integers from X through Y
         { .initiator = capital; .terminator = "." }
\end{verbatim}\end{indpar}

in which the \verb|` '| brackets have disappeared completely,
\verb|"."| has been recognized as a \verb|.terminator|, and
capitalization has been encoded in as an \verb|.initiator|.

The \mkey{indentation}{of line} of a line is the
column number of the first non-white-space character in the line.

An \key{indented subexpression} is introduced by an
\key{indented subexpression mark} that ends a line.  This mark must
be defined by an indented subexpression mark definition, as per the
example above.  If the mark is preceeded in its definition by
\ttmkey{*}{in indented subexpression mark definition}, then may be
\mkey{glued}{indented subexpression mark}
to another mark immediately preceding it.  For example,
`\verb|= :|' may be written as `\verb|=:|'.

An indented subexpression is a list of lines.
The \mkey{indentation}{of indented subexpression}
of the subexpression is the indentation of the first line,
and all the other lines must have the same indentation.  The output of
the lexical parser for an indented subexpression is a list whose elements
are the output of the lexical parser for each line, and 
whose \verb|.initiator| is the indented subexpression mark that introduced
the subexpression.  Lines indented by more than the subexpression indentation
are continuations of the preceding line.

The \key{top level}, the file containing the text being parsed,
is treated similarly
to an indented subxpression introduced by an implied mark before the
beginning of the file.  Each element of the top level is a line indented
the same as the first line of the file.  These elements are read and
processed sequentially.  It is an error for a file line to have less
indentation that the first line of the file.

Consider the file:

\begin{indpar}\begin{verbatim}
@3 =:
    v =:
        w
        x y
    z =:
@4 = a b c
@5 =:
\end{verbatim}\end{indpar}

When the first element of this file is read using the
lexical parser, it becomes the object \verb|@6| in:

\begin{indpar}\begin{verbatim}
@6 = "@" 3 "=" @7
@7 = @8 @9 { .initiator  = ":" }
@8 = v "=" @10
@10 = w @11 { .initiator = ":" }
@11 = x y
@9 = z "=" @12
@12 = { .initiator = ":" }
\end{verbatim}\end{indpar}

Note the list \verb|@12| introduced by line `\verb|z =:|' is
empty, because the next line is indented by more than
this line, and therefore the indented subexpression containing
this line ends right after the line.

The second element read from the above file is \verb|@13| in:

\begin{indpar}\begin{verbatim}
@13 = "@" 4 "=" a b c
\end{verbatim}\end{indpar}

and the third and last element is \verb|@14| in:

\begin{indpar}\begin{verbatim}
@14 = "@" 5 "=" @15
@15 = { .initiator = ":" }
\end{verbatim}\end{indpar}

Here \verb|@15| is the empty list because the file ends
after the line `\verb|@5 =:|' that introduces it.

It is a general rule of CASTLE that lists with \verb|{ }| brackets
and `\verb|;|' separator are semantically equivalent to indented
subexpressions introduced by `\verb|:|'.  Thus

\begin{indpar}\begin{verbatim}
@3 =:
    v =:
        w
        x y
    z =:
@4 = a b c
@5 =:
\end{verbatim}\end{indpar}

and

\begin{indpar}\begin{verbatim}
@3 = {
    v = {
        w;
        x y };
    z = {} }
@4 = a b c
@5 = {}
\end{verbatim}\end{indpar}

are semantically equivalent files.  But they do \underline{not}
parse the same.  Also, the lines of the top level may optionally
be ended by `\verb|;|', as in

\begin{indpar}\begin{verbatim}
@3 = {
    v = {
        w;
        x y };
    z = {} };
@4 = a b c;
@5 = {};
\end{verbatim}\end{indpar}

without semantic effect, as long as indentation subexpressions
are not used outside explicit brackets.

\subsubsection{Explicit Subexpression Recognition Algorithm}
\label{EXPLICIT-SUBEXPRESSION-RECOGNITION-ALGORITHM}

The \key{explicit subexpression recognition algorithm} is the
lexical parsing subalgorithm that recognizes explicitly bracketted
and indented subexpressions.  Here we describe this algorithm, which
runs on the output of the lexeme replacement algorithm.

The algorithm maintains a
stack of indentation records, called the \key{indentation stack}.
An \key{indentation record} is an \key{indentation} (column number),
a pointer to a bracket definition, and an \key{implicit bracket flag}.
The bracket definition specifies an \key{indentation opening bracket},
an \key{indentation closing bracket}, an \key{indentation separator},
and an \key{indentation indicator}, which in the above definition are
respectively \verb|"{"|, \verb|"}"|, \verb|";"|, and \verb|* ":"|.
All these bracket definition components are optional.
The implicit bracket flag indicates whether
or not an implied opening bracket lexeme was inserted at the same time the
indentation record was pushed onto the indentation stack.

The \verb|*| in the indentation indicator \verb|* ":"| specifies that
any lexeme that ends with \verb|:| is an indentation indicator.  If
the \verb|*| were missing, only the 1-character lexeme \verb|:| would
be an indentation indicator.

Initially the indentation stack contains a single indentation record with
1 indentation, a pointer to the bracket definition:
\begin{indpar}\begin{verbatim}
define bracket [operator]
       with indentation separator ";"
\end{verbatim}\end{indpar}
and an off implicit bracket flag.
Note all the components of the bracket definition are missing except
the indentation separator, which specified that a semi-colon is to
be inserted between non-indented lines.
The stack cannot become empty;
the bottommost indentation record on the stack is always the same.

The indentation in the indentation record at the top of the indentation
stack is called the \key{current indentation record}, and its components
are referred to as `current' (e.g., `\key{current indentation}', `\key{current
indentation opening bracket}').

Indentation lexemes are then inserted during lexical parsing
by the following \key{indentation lexeme insertion algorithm}.
This algorithm is 
applied to the lexeme stream immediately after lexical replacement, and
executes the following steps in order before passing
lexemes onto the next stage in lexical parsing.

\begin{indpar}

{\bf Indentation Error Step.}\index{Indentation Error Step}
\begin{indpar}
When the first lexeme of a line is encountered, if
\begin{list}{}
	     {\setlength{\itemsep}{0ex}%
	      \setlength{\topsep}{0ex}%
	      \setlength{\parsep}{0ex}%
	      \setlength{\leftmargin}{0.5in}%
	      \setlength{\rightmargin}{0.5in}}%
\item[(1)] there is a current indentation separator or
	   the current implicit bracket flag is on, and
\item[(2)] the indentation of this first lexeme in a line
is 1 less than or 1 greater
than the current indentation,
\end{list}
then a lexical parsing error is announced.
This ensures that when indentation is
used to insert implicit lexemes, important indentation
differences must be by at least
2 columns, and cannot be by just 1 column.
\end{indpar}

{\bf Indentation Separator Step.}\index{Indentation Separator Step}
\begin{indpar}
When the first lexeme of a line is encountered, if
\begin{list}{}
	     {\setlength{\itemsep}{0ex}%
	      \setlength{\topsep}{0ex}%
	      \setlength{\parsep}{0ex}%
	      \setlength{\leftmargin}{0.5in}%
	      \setlength{\rightmargin}{0.5in}}%
\item[(1)] there is a current indentation separator,
\item[(2)] the indentation of the lexeme of a line equals the current
indentation,
\item[(3)] this lexeme is not the first encountered after
the current indentation record was created, and
\item[(4)] the lexeme
previous to this lexeme (the last on the previous non-blank line)
does not equal the indentation separator,
\item[(5)] the lexeme is not the first of a sequence of lexemes
that matches the current indentation closing bracket, or the current
implicit bracket flag is on
\end{list}
then a copy of the indentation separator is inserted before the first
lexeme of the line (or equivalently, is inserted at the end of the
previous line).
\end{indpar}

{\bf Implicit Closing Bracket Step.}\index{Implicit Closing Bracket Step}
\begin{indpar}
When the first lexeme of a line is encountered, if
\begin{list}{}
	     {\setlength{\itemsep}{0ex}%
	      \setlength{\topsep}{0ex}%
	      \setlength{\parsep}{0ex}%
	      \setlength{\leftmargin}{0.5in}%
	      \setlength{\rightmargin}{0.5in}}%
\item[(1)] the current implicit bracket flag is on, and
\item[(2)] the indentation of this first lexeme is 2 or more columns
less than the current indentation,
\end{list}
then a copy of the current indentation closing bracket is inserted before
the first lexeme of the line and
the current indentation record is popped from the indentation
record stack.
\end{indpar}

{\bf Implicit Bracket Step.}\index{Implicit Bracket Step}
\begin{indpar}
If the last lexeme of a line is encountered that
matches the indentation indicator of some
current bracket definition
(see current parsing definitions, \pagref{CURRENT-PARSING-DEFINITION},
and bracket definition indentation indicators,
\pagref{INDENTATION-INDICATOR}),
this bracket definition is called the \key{matched bracket definition}
and the following are done:

\begin{list}{}
	     {\setlength{\itemsep}{0ex}%
	      \setlength{\topsep}{0ex}%
	      \setlength{\parsep}{0ex}%
	      \setlength{\leftmargin}{0.5in}%
	      \setlength{\rightmargin}{0.5in}}%
\item[(1)] 
The indentation indicator is removed from the end of this lexeme.
If the lexeme becomes empty, it is deleted from the lexeme stream.

\item[(2)] If the indentation of the first lexeme of the next line
is not greater than the current indentation, or there is no next
line, both the opening and closing brackets from the matched
bracket definition are output at the end of the current line.

\item[(3)] If the indentation of the first lexeme of the next line
is 1 greater than the current indentation, an error is announced.

\item[(4)] If the indentation of the first lexeme of the next line
is greater than the current indentation, the opening bracket
from the matched bracket definition is output at the end of the
current line, and a new indentation record is pushed into the
indentation stack.  The new record has the indentation of the
next lexeme, a pointer to the matched bracket definition, and
an on implicit bracket flag.
\end{list}

\end{indpar}

{\bf Explicit Opening Bracket Step.}\index{Explicit Opening Bracket Step}
\begin{indpar}
If an opening bracket from a
current bracket definition
(see current parsing definitions, \pagref{CURRENT-PARSING-DEFINITION})
is encountered, then
a new indentation record is pushed into the stack.

The indentation of the new indentation record is the indentation of
the next lexeme.  The implicit bracket flag is off.  The record
points at the bracket definition containing the opening bracket.
\end{indpar}

{\bf Explicit Closing Bracket Step.}\index{Explicit Closing Bracket Step}
\begin{indpar}
If the current indentation closing bracket is encountered, and the
current implicit bracket flag is off, then
the current indentation record is popped from the stack.
\end{indpar}

\end{indpar}

Note that when an indentation record is pushed, the bracket definition
it points at may specify a {\em new-parsing-selector-set}, which will
be pushed into the parsing selector set stack:
see \secref{BRACKET-NEW-PARSING-SELECTOR-SET}.   If this happens, the
parsing selector set will be popped from its stack when the indentation
record is popped from its stack.

The following are example inputs and outputs from the indentation lexeme
insertion parsing algorithm using the bracket definitions given in this
section.

\begin{indpar}[0.1in]
\tt \ttbrackets
\begin{tabular}{@{}p{2in}@{~~~~~~~~~~}l}
{\rm Input String}		& {\rm Output Lexemes} \\[1ex]
hi \{ x; y z; w \}		& \tt hi \{ x ; y z ; w \} \\[1ex]
hi \{				& hi \{ \\
~~~~x				& x \\
~~~~y z				& ; y z \\
~~~~w \}			& ; w \}
\end{tabular}
\end{indpar}
\begin{indpar}[0.1in]
\tt \ttbrackets
\begin{tabular}{@{}p{2in}@{~~~~~~~~~~}l}
hi				& hi \\
\{				& ; \{ \\
~~~~x				& x \\
~~~~y z				& ; y z \\
~~~~w				& ; w \\
\}				& \}
\end{tabular}
\end{indpar}
\begin{indpar}[0.1in]
\tt \ttbrackets
\begin{tabular}{@{}p{2in}@{~~~~~~~~~~}l}
hi:				& hi \{ \\
~~~~x				& x \\
~~~~y z				& ; y z \\
~~~~w				& ; w \\
				& \}
\end{tabular}
\end{indpar}
\begin{indpar}[0.1in]
\tt \ttbrackets
\begin{tabular}{@{}p{2in}@{~~~~~~~~~~}l}
hi \{				& hi \{ \\
~~~~x				& x \\
~~~~y `this			& ; y ` this \\
is another context.		& is another context . \\
' foo bar			& ' foo bar \\
~~~~w \}			& ; w \}
\end{tabular}
\end{indpar}
\begin{indpar}[0.1in]
\tt \ttbrackets
\begin{tabular}{@{}p{2in}@{~~~~~~~~~~}l}
hi \{				& hi \{ \\
~~~~x				& x \\
~~~~\{				& ; \{ \\
ho				& ho \\
hum \} y			& ; hum \} y \\
~~~~z \}			& ; z \}
\end{tabular}
\end{indpar}

\subsection{Numbers}
\label{NUMBERS}

Number lexemes are decimal numbers with an optional decimal point
or slash
and optional commas every 3 digits.  \ikey{Numbers}{number} are sequences of
lexemes that are identified during \key{lexical number parsing},
which is applied to the output of the indentation lexeme insertion algorithm. 
When a number contains more than one lexeme, it is surrounded by
the implicit \verb|(# #)| brackets.

The following are the top level syntax equations for numbers.

\begin{indpar}
\key{number} ::= {\em real-number} $|$ {\em number-unit-group} \\[1ex]
\key{real-number} ::= {\em decimal-number} $|$ {\em radix-number}
				           $|$ {\em scientific-number}
				           $|$ {\em number-pair}
\end{indpar}%
\label{REAL-NUMBER}\label{NUMBER}

Note that numbers are all unsigned.  Signs are all considered to
be arithmetic operators (except for exponent signs in
{\em scientific-numbers}).

\subsubsection{Decimal Numbers}
\label{DECIMAL-NUMBERS}

\ikey{Decimal numbers}{decimal number} are just number lexemes, which
are sequences of digits with optional commas and
an optional decimal point or slash.

\begin{indpar}
\key{decimal-number} \begin{tabular}[t]{rl}
                              ::= & {\em decimal-integer} \\
		              $|$ & {\em decimal-integer} \verb|.|
		                    {\em decimal-fraction} \\
		              $|$ & \verb|.| {\em decimal-fraction} \\
		              $|$ & {\em decimal-numerator} \verb|/|
		                    {\em decimal-denominator} \\
		              \end{tabular} \\[1ex]
\key{decimal-integer} ::= {\em decimal-natural}
\label{DECIMAL-INTEGER}
\\[1ex]
\key{decimal-fraction} ::= {\em decimal-natural}
\label{DECIMAL-FRACTION}
\\[1ex]
\key{decimal-numerator} ::= {\em decimal-natural}
\label{DECIMAL-NUMERATOR}
\\[1ex]
\key{decimal-denominator} ::= {\em decimal-natural}
\label{DECIMAL-DENOMINATOR}
\\[1ex]
\key{decimal-natural} ::= {\em decimal-digits}
		     $|$ {\em decimal-natural} \verb|,| {\em decimal-digits}
		     \\[1ex]
\key{decimal-digits} ::= {\em digit} {\em digit}\,$^\star$
\end{indpar}

Decimal Number Examples:

\begin{indpar}[0.1in]
\tt
\begin{tabular}{l@{~~~~~}l@{~~~~~}l@{~~~~~}l@{~~~~~}l}
123	& 1,234		& 12,345	& 1,234,567 \\
123.0	& .123		& 0.0		& 1,234.987654	& 1,234.987,654 \\
1/2	& 134/874	& 1,345/3	& 1234/987654   & 1,234/987,645
\end{tabular}
\end{indpar}

In a number lexeme, and therefore in a {\em decimal-number},
a decimal point must be followed by
a digit, commas must be surrounded by digits, and slashes must be surrounded
by digits.

Some number lexemes are \skey{illegal decimal number}s, meaning
that they are number lexemes that cannot be converted to numbers.
A number lexeme with more than one decimal point, more than one
slash, or both a decimal point and a slash is illegal.
Commas are optional, but if present in a {\em decimal-fraction} or
{\em decimal-denominator}, they must also be used in any
{\em decimal-integer} or {\em decimal-numerator} that is part of the
same number lexeme.
In addition, commas if present must be located every 3 digits from the right
end of a {\em decimal-integer}, {\em decimal-denominator}, or
{\em decimal-numerator}, or from the left end of a {\em decimal-fraction}.
Lastly, a {\em decimal-denominator} may not be zero.
Failure to follow the rules of this paragraph will result in an
error when the lexeme is converted to a number,
but is \underline{not} an error of lexeme formation, and
is \underline{not} a parsing error.

The following are examples of illegal decimal numbers:

\begin{indpar}[0.1in]
\tt
\begin{tabular}{l@{~~~~~}l@{~~~~~}l@{~~~~~}l@{~~~~~}l}
1.2.3	& 1.86,54	& 1,234567.892	& 12345.678,92	& 1.234567,892 \\
3/4/5   & 3/0.5         & 1.45/3        & 1000/3,000    & 5/0
\end{tabular}
\end{indpar}

\subsubsection{Radix Number Recognition}
\label{RADIX-NUMBER-RECOGNITION}

\ikey{Radix-numbers}{radix-number} permit binary, octal, or hexadecimal
radi\-ces to the used instead of decimal.  In fact, other number representation
schemes are permitted.

\begin{indpar}
\key{radix-number} \\
	\hspace*{0.5in}::= {\em radix-indicator}
		        \verb|"| {\em radix-number-mark}
		        {\em radix-number-mark}\,$^\star$ \verb|"|
		        \\[1ex]
\key{radix-indicator} ::= {\em symbol} {\em symbol}\,$^\star$ \\[1ex]
\key{radix-number-mark} ::= {\em character-representative}
~~~~~ [See Figure \figref{CHARACTER-REPRESENTATIVES}]
\end{indpar}

A {\em radix-number} is thus a {\em radix-indicator} followed by
any quoted string.  Some examples of legal {\em radix-numbers}
using standard {\em radix-indicators} are:

\begin{indpar}[0.1in]
\tt
\begin{tabular}{l@{~~~~~}l@{~~~~~}l@{~~~~~}l}
B\#"10110100"	& O\#"7534201" & D\#"9758"	& X\#"E8A932B" \\
B\#"01101"	& O\#".7753"   & D\#"97.58"	& X\#".fe8a932b" \\
B\#"0,1101"	& O\#"2,3456"  & D\#".123,5"	& X\#"E8A,932B.7CCD,83" \\
\end{tabular}
\end{indpar}

The following {\em radix-indicators} are standard.

\begin{center}
\begin{tabular}{l@{~~~~~}l@{~~~~~}l@{~~~~~}l}
Radix	& Radix		 & Allowed Number	& Allowed Digits \\
Name	& Indicators     & Marks (Digits)	& Between Commas \\[1ex]
binary	& \tt b\#~~~B\#	 & \tt 0 1		& 3 or 4 \\
octal	& \tt o\#~~~O\#	 & \tt 0 1 2 3 4 5 6 7	& 3 \\
decimal	& \tt d\#~~~D\#	 & \tt 0 1 2 3 4 5 6 7 8 9
						& 3 \\
hexadecimal
	& \tt x\#~~~X\#	 & \tt 0 1 2 3 4 5 6 7 8 9
						& 4 \\
	&		 & \tt a b c d e f A B C D E F
\end{tabular}
\end{center}

Standard {\em radix-indicators} permit a single decimal point, which must
be followed by a digit, or alternatively, as single slash, which must
be surrounded by digits.
Standard {\em radix-indicator}
rules for comma location are the same as for {\em decimal-numbers}
(\secref{DECIMAL-NUMBERS}), except the number of digits between commas may
be 3 or 4, depending on the {\em radix-indicator}.  You cannot mix two
different inter-comma distances, i.e.~both 3 and 4,
in the same {\em radix-number}.

{\em Radix-numbers} may be unconvertible to numbers.  Such are
called \skey{illegal radix number}s.  The following are some examples
using standard {\em radix-indicators}:

\begin{indpar}[0.1in]
\tt
\begin{tabular}{l@{~~~~~}l@{~~~~~}l@{~~~~~}l}
B\#"5,7b63"	& O\#"2/3.456"	& D\#"-0.1"	& X\#".E8A932B.7CCD"
\end{tabular}
\end{indpar}

When a {\em radix-number} is encountered during number lexical parsing,
it is surrounded by \verb|(# #)| implicit brackets.  Thus if
\verb|B#"10011"| is input to number lexical parsing,
\verb|(# B # "10011" #)| will be output.

Radix numbers are recognized after indentation lexemes have been
inserted.

{\em Radix-indicators} are defined by \skey{radix indicator definition}s:

\begin{indpar}
\ikey{radix-indicator-definition}{radix-indicator!definition} \\
	\hspace*{0.5in}::= \begin{tabular}[t]{@{}l@{}l@{}}
	                   \verb|define | & \verb|radix indicator|
                                            {\em radix-indicator}
					    {\em parsing-selectors} \\
	    			& \verb|with conversion function|
				    {\em function-name} \\
		     \end{tabular}
\label{RADIX-INDICATOR-DEFINITION}
		     \\[1ex]
\key{radix-indicator} ::= {\em symbol} {\em symbol}\,$^\star$
	\\[1ex]
{\em parsing-selectors} ::= see \pagref{PARSING-SELECTORS}
	\\[1ex]
{\em function-name} ::= see \pagref{FUNCTION-NAME}
\end{indpar}

Given such a definition, the defined {\em radix-indicator}
will be recognized as such whenever it is followed by a quoted
string in the input.

The conversion function is passed the quoted string from a
{\em radix-number} as its only argument, and must return
either a number if conversion is successful, or an error message
otherwise.


\subsubsection{Scientific Number Recognition}
\label{SCIENTIFIC-NUMBER-RECOGNITION}

A {\em scientific-number} is a {\em decimal-number} or a {\em radix-number}
followed by an exponent.

\begin{indpar}
\key{scientific-number} \begin{tabular}[t]{rl}
                        ::= & {\em decimal-number} {\em exponent} \\
			$|$ & {\em radix-number} {\em exponent}
		        \end{tabular} \\[1ex]
\key{exponent} ::= {\em exponent-indicator}
		   {\em exponent-sign-and-digits} \\[1ex]
\key{exponent-indicator} ::= \verb|e| $|$ \verb|E| \\[1ex]
\key{exponent-sign-and-digits} ::= {\em decimal-digits}
			    $|$ {\em sign} {\em decimal-digits}
\end{indpar}

The following are examples of legal {\em scientific-numbers} using
standard radix indicators:

\begin{indpar}[0.1in]
\tt
\begin{tabular}{l@{~~~~~}l@{~~~~~}l@{~~~~~}l@{~~~~~}l}
123e0		& 123e+2	& 123e-321	& 1,234e9 \\
123E0		& 123E+2	& 123E-321	& 0.123,456e-3	\\
.123e0	& .123e+2
				& 0.123,456e-3 & 1,234.567890e6 \\
X\#"a9"e0	& B\#"1011"e-3	& O\#"0.7753"e-5
					    & X\#"0.FE8A,932B,E"e+5 \\
\end{tabular}
\end{indpar}

Note that exponents cannot contain commas.

The digits in an exponent are always decimal, even when the number has
a radix indicator such as {\tt B\#} or {\tt X\#} that indicates a different
radix.  However, the interpretation of the exponent depends upon the
radix indicator.  Standard radix indicators interpret the exponent as
multiplication by their radix to the exponent power.  Thus
{\tt B\#"1101"e-2} and {\tt B\#"11.01"} are both equal to {\tt 3.25}.

When a {\em scientific-number} is encountered during number lexical parsing,
it is surrounded by \verb|(# #)| implicit brackets.  Thus if
\verb|B\#"1101"e-2| is input to number lexical parsing,
\begin{center}
\verb|(# (# B # "10011" #) e - 2 #)|
\end{center}
will be output.

An \key{illegal scientific number} is a {\em scientific number}
that cannot be converted to a number.  These include
{\em scientific numbers} whose number lexemes are illegal,
and {\em scientific numbers} with no or standard radix indicators
whose number lexemes contain a slash (\verb|/|).
The following are some examples of illegal scientific numbers:

\begin{indpar}[0.1in]
\tt
\begin{tabular}{l@{~~~~~}l@{~~~~~}l@{~~~~~}l@{~~~~~}l}
1,23e6	& 3/4e2	& B\#"5,7b63"e32  & O\#"2/3"e-2	& X\#".E.7"e-4
\end{tabular}
\end{indpar}

Scientific numbers are recognized after radix numbers have been
recognized.

\subsubsection{Number Pair Recognition}
\label{NUMBER-PAIR-RECOGNITION}

A \key{number pair} is a pair of {\em decimal-numbers}, the first
of which is in integer and the second of which is a fraction
containing a slash.

\begin{indpar}
\key{number-pair} ::= {\em decimal-integer}
		   {\em decimal-numerator} \verb|/| {\em decimal-denominator}
		   \\[1ex]
{\em decimal-integer} ::= see \pagref{DECIMAL-INTEGER} \\[1ex]
{\em decimal-numerator} ::= see \pagref{DECIMAL-NUMERATOR} \\[1ex]
{\em decimal-denominator} ::= see \pagref{DECIMAL-DENOMINATOR}
\end{indpar}

Some examples of number pairs are:

\begin{indpar}[0.1in]
\tt
\begin{tabular}{l@{~~~~~~~~~~}l@{~~~~~~~~~~}l@{~~~~~~~~~~}l}
1 1/2	& 55 3/4	& 174 15/16  & 1,234,567 2,875/3,408
\end{tabular}
\end{indpar}

When a {\em number-pair} is encountered during number lexical parsing,
it is surrounded by \verb|(# #)| implicit brackets and a \verb|+| is
inserted between its two parts.  Thus if
\verb|41 3/4| is input to number lexical parsing,
\verb|(# 41 + 3/4 #)|
will be output.

A number pair is illegal if either of its two parts is illegal.

Number pairs are recognized after scientific numbers have been
recognized.

\subsubsection{Number Unit Grouping}
\label{NUMBER-UNIT-GROUPING}

A {\em number-unit-group} is a sequence of one or more {\em number-unit-pairs}
each of which consists of two lexemes: a {\em real-number}
and a {\em unit-specifier}.
The syntax equations are:

\begin{indpar}
\key{number-unit-group} ::= {\em number-unit-pair}
			    {\em number-unit-pair}\,$^\star$ \\[1ex]
\key{number-unit-pair} \begin{tabular}[t]{rl}
                     ::= & {\em prefix-unit-specifier} {\em real-number} \\
                     $|$ & {\em real-number} {\em postfix-unit-specifier} \\
		     \end{tabular} \\[1ex]
\key{prefix-unit-specifier} ::= {\em symbol} {\em symbol}\,$^\star$ \\[1ex]
\key{postfix-unit-specifier} ::= {\em symbol} {\em symbol}\,$^\star$ \\[1ex]
\key{unit-specifier} ::= {\em prefix-unit-specifier} $|$
                         {\em postfix-unit-specifier}
\end{indpar}

In order to be recognized as a {\em unit-specifier} a {\em symbol} sequence
must be defined as a {\em unit-specifier-name} by the following:

\begin{indpar}
\key{unit-specifier-definition} \\
	\hspace*{0.5in}::= \verb|define unit specifier|
	    \begin{tabular}[t]{l}
	    {\em unit-specifier-fixity} \\
	    {\em unit-specifier} {\em parsing-selectors}
	    \end{tabular}
\label{UNIT-SPECIFIER-DEFINITION}
	    \\[1ex]
\key{unit-specifier-fixity} ::= \ttkey{prefix} $|$ \ttkey{postfix} \\[1ex]
{\em parsing-selectors} ::= see \pagref{PARSING-SELECTORS}
\end{indpar}

The \key{number unit grouping} phase of lexical
parsing recognizes {\em number-unit-groups} containing more than
one {\em number-unit-pair}, places
\verb|(# #)| implied brackets around them,
and places implied `\verb|+|' operators
between their {\em number-unit-pairs}.  This is done after lexeme replacement
(\secref{LEXEME-REPLACEMENT}).

For example, if `\verb|hr|' and `\verb|min|'
are {\em postfix-unit-specifiers},
`\verb|7 hr 30 min|' is a {\em number-unit-group} containing
2 {\em number-unit-pairs} that number unit grouping transforms into
\begin{center}
\verb/(# 7 hr + 30 min #)/
\end{center}
As another example,
if `\verb|ft|' and `\verb|in|' are {\em postfix-unit-specifiers},
`\verb|12ft 11 3/4in|' becomes
\begin{center}
\verb|(# 12 ft + (# 11 + 3/4 #) in #)|
\end{center}

Number unit groups are recognized after number pairs have been
recognized.

\subsubsection{Unit Multiplication Insertion}
\label{UNIT-MULTIPLICATION-INSERTION}

The \key{unit multiplication insertion} phase of lexical
parsing inserts a multiplication operator lexeme, `\verb|*|',
before a {\em postfix-unit-specifier}, and
after a {\em prefix-unit-specifier}, unless the point at which the
`\verb|*|' is to be inserted is already occupied by a
`\verb|*|' or `\verb|/|' lexeme.  This is done after number unit
grouping (\secref{NUMBER-UNIT-GROUPING}).

For example, if `\verb|sec|', `\verb|ft|', and `\verb|lb|'
are {\em postfix-unit-specifiers},
then
\begin{indpar}\begin{verbatim}
some function ( 3 ft 2 1/4 in / sec,
                9 ft ^ 2 lb / sec,
                $3.50 )
\end{verbatim}\end{indpar}
becomes
\begin{indpar}\begin{verbatim}
some function ( (# 3 * ft + (# 2 + 1/4 #) * in #) / sec,
                9 * ft ^ 2 * lb / sec,
                $ * 3.50 )
\end{verbatim}\end{indpar}

Unit multiplication insertion is done after number unit groups have been
recognized.

\section{Expression Parsing}\index{parsing!expression}
\label{EXPRESSION-PARSING}

An \key{expression} is a sequence of symbols, separators, and subexpressions.
A \key{subexpression} is a pair of matched lexeme sequences called
\skey{bracket}s, e.g.~\verb|( )| or
\verb|` '|, and all the lexemes in between.
There are many kinds of brackets: for example, \skey{square bracket}s
\verb|[ ]|, \skey{curly bracket}s \verb|{ }|, \key{parentheses} \verb|( )|,
and \skey{quote}s \verb|` '|.

Some expressions and subexpressions can contain lexeme sequences called
\skey{operator}s.  When they do,
matched \ikey{implicit brackets}{implicit brackets} \verb/(| |)/
are inserted into the expressions or subexpressions
according to rules of operator precedence, and these
implicit brackets create new subexpressions.
Certain lexemes used to separate elements of lists,
such as `{\tt ,}' and `{\tt ;}',
are treated as operators during parsing.

Some expressions and subexpressions can contain lexeme sequences called
\skey{sentence terminator}s and \skey{phrase separator}s.  When they do,
matched \ikey{implicit brackets}{implicit brackets} are inserted around
paragraphs, sentences, and phrases.  A paragraph becomes a list of
sentences surrounded by implicit \verb|(* *)| brackets, a sentence
becomes a list of symbols, separators, subexpressions, and phrases
surrounded by implicit \verb|<* *>| brackets, and so forth.

A process called \key{expression parsing}\index{parsing!expression}
inserts implicit brackets into expressions,
further reformats some expressions,
and associates evaluators with some subexpressions.
The evaluator of a subexpression
is a function that is eventually called to evaluate the subexpression.

Explicit brackets control the parser used
to parse the subexpression they surround.  The set of brackets and operators
this parser recognizes is also controlled.
For example, \verb|` '| invokes the text parser that
recognizes sentence terminators and phrase separators, while
\verb|{ }| invokes the operator parser that recognizes operators
and list separators.

\subsection{Subexpressions}
\label{SUBEXPRESSIONS}

The first step in expression parsing is to identify \skey{subexpression}s within
an expression, without inserting any implicit brackets,
by applying the following syntax equations.

\begin{indpar}
\key{EXPRESSION} ::= {\em expression-item}\,$^\star$ \\[1ex]
\key{expression-item} ::= {\em symbol} $|$ {\em separator}
				     $|$ {\em subexpression} \\[1ex]
\key{subexpression} ::= {\em opening-bracket} {\em EXPRESSION}
			{\em closing-bracket} \\[1ex]
\key{opening-bracket} ::=
	\{ {\em symbol} $|$ {\em separator} \}
	\{ {\em symbol} $|$ {\em separator} \}\,$^\star$ \\[1ex]
\key{closing-bracket} ::=
	\{ {\em symbol} $|$ {\em separator} \}
	\{ {\em symbol} $|$ {\em separator} \}\,$^\star$
\end{indpar}\label{EXPRESSION-ITEM}

The {\em opening-bracket} and {\em closing-bracket} of a subexpression
are a matched pair of brackets specified by a bracket definition
(\secref{BRACKET-DEFINITION}).

The subexpressions identified by this rule have explicit
brackets.  These subexpressions are actually identified by the
indentation lexeme insertion algorithm (\secref{INDENTATION-LEXEME-INSERTION}).
Below we introduce subexpressions with operators
that have implicit brackets.

The syntactic category name {\em EXPRESSION} is capitalized because in
this document syntactic categories representing CASTLE expressions
are given completely capitalized names.

\subsection{Parsing Overview}
\label{PARSING-OVERVIEW}

Parsing is controlled by a parsing definition
stack and a parsing selector set stack.
The \key{parsing definition stack},\label{PARSING-DEFINITION-STACK}
contains definitions of parsers, brackets, operators, phrase separators,
sentence terminators, section initiators, lexeme replacements,
and unit specifiers.
The \key{parsing selector set stack},\label{PARSING-SELECTOR-SET-STACK}
contains parsing selector sets.  A \key{parsing selector} is
a sequence of one or more symbols that can be attached to parsing definitions.
A \key{parsing selector set}
is a set of parsing selectors that selects those parsing stack definitions
which share at least one parsing selector with the set.
The set at the top of the parsing selector set stack is
called the \key{current parsing selector set}, its members are called
\skey{current parsing selector}s, and the parsing stack
definitions the set selects
are call the \skey{current parsing definition}s.%
\label{CURRENT-PARSING-DEFINITION}

If a subexpression begins and ends with matched explicit
brackets, a parsing selector
set determined by the bracket definition (\secref{BRACKET-DEFINITION})
may be pushed into the parsing
selector set stack before parsing the subexpression.  At the end of
the subexpression parsing, this selector set is popped from the stack.

A summary of the standard affects of brackets is:

\begin{center}
\begin{tabular}{l@{~~~~~~}l@{~~~~~~}l}
With      &           			& Sets \\
Parsing   &				& Parsing \\
Selector  & Brackets  			& Selectors To \\[1ex]
-	  & \verb|(|\ldots\verb|)|	& [no change] \\
-	  & \verb|{|\ldots\verb|}|	& operator \\
operator  & \verb|[|\ldots\verb|]|	& list \\
list	  & \verb|[|\ldots\verb|]|	& list \\
text      & \verb|[|\ldots\verb|]|	& operator \\
-	  & \verb|`|\ldots\verb|'|	& text     \\
\end{tabular}\label{CONTEXT-SWITCHES}
\end{center}

Thus the \verb|{ }| brackets, whose definition is always current
(signified by `-' in the above table), pushes into the parsing
selector set stack the set whose only member is the `operator'
parsing selector.  There are two \verb|[ ]| bracket definitions, 
one selected by the `operator' and `list' selectors that pushes
the selector set whose only member is `list', and one selected
by the `text' selector that pushes the selector set whose only
member is `operator'.

The following is a list of the kinds of
\skey{parsing definition}s that may be in
the \mkey{parsing definition stack}{kinds of definition in}:%
\label{PARSING-STACK-DEFINITION-KINDS}

\begin{center}
\begin{tabular}{ll}
parser & \secref{PARSER-DEFINITION} \\
bracket & \secref{BRACKET-DEFINITION} \\
operator & \secref{OPERATOR-DEFINITION} \\
lexeme replacement & \secref{LEXEME-REPLACEMENT-DEFINITION} \\
radix indicator & \secref{RADIX-INDICATOR-DEFINITION} \\
unit specifier & \secref{UNIT-SPECIFIER-DEFINITION} \\
phrase separator & \secref{PHRASE-SEPARATOR-DEFINITION} \\
sentence terminator & \secref{SENTENCE-TERMINATOR-DEFINITION} \\
section initiator & \secref{SECTION-INITIATOR-DEFINITION}
\end{tabular}
\end{center}

A parser is a function that is called with a list of lexemes and
returns a parsed expression.  At any time there can be only one
current parser definition, and that is used to select the current
parser.  There are two standard parsers:

\begin{center}
\begin{tabular}{l@{~~~~~~}l@{~~~~~~}l@{~~~~~~}l@{~~~~~~}l}
	 &            &            & Does	& Recognizes \\
	 & Recognizes & Recognizes & Lexical	& Sentences, \\
Parser	 & Brackets   & Operators  & Parsing	& Phrases, etc. \\[1ex]

operator & yes	      & yes        & yes 	& no \\
text     & yes	      & no         & yes        & yes \\
\end{tabular}
\end{center}

The `operator' parser has a definition selected by either the `operator'
or `list' parsing selectors, and recognizes any
operators whose definitions are current
(list separators are treated as operators),
whereas the `text' parser has a definition selected
by the `text' selector, and recognizes phrase separators, sentence
terminators, and section initiators whose definitions are current.
The 'operator' parser does \underline{not} recognize
any phrase separators, sentence terminators, or section initiators,
and the `text'
parser does \underline{not} recognize any operator
definitions.
Both operator and text parsers recognize brackets and do lexical
parsing, but all standard
lexical parsing definitions do not have the `text' parsing selector,
and therefore are ignored by standard text parsing.

A definitional operator (\pagref{DEFINITIONAL})
may push parsing definitions onto the parsing
definition stack.  After the expression containing the operator has been parsed,
these definitions will be popped from the stack.


\ikey{Implicit brackets}{implicit brackets} introduced by parsers
can also be represented explicitly, though this is mostly done
for purposes of debugging.  For example, the implicit brackets
introduced by operators are represented by \verb@(| |)@.
Other kinds of implicit brackets are introduced by the text parser.
Here is a complete list of implicit brackets and the kinds of subexpressions
they surround:

\begin{center}
\begin{tabular}{l@{~~~~~~}l}
\verb@(| |)@	& Operator subexpressions and list elements. \\
\verb@<* *>@	& Phrases inside sentences. \\
\verb@(* *)@	& Sentences. \\
\verb@[* *]@	& Paragraphs. \\
\verb@{* *}@	& Parts, chapters, sections, sub-sections, etc. \\
\end{tabular}
\end{center}\label{IMPLIED-BRACKETS}


For example,
the operators parser with the `operators' parsing selector recognizes
the operators `\verb|+|', `\verb|-|', and `\verb|*|' in the expression
\begin{center}
\verb|x + y - 5 * z|
\end{center}
and turns this expression into
\begin{center}
\verb@x + y - (| 5 * z |)@.
\end{center}
The operator parser with the `list' selector only recognizes separators,
and turns
\begin{center}
\verb|[george, betty sue, bill]|
\end{center}
into
\begin{center}
\verb@[ george, (| betty sue |), bill ]@
\end{center}
The text parser, which is invoked by
\verb|`'| quotes, recognizes the phrase separator `\verb|,|' and
the sentence terminator `\verb|!|' and turns
\begin{center}
\verb|`I think!  Therefore, I am!'|
\end{center}
into
\begin{center}
\verb@[* (* I think ! *) (* Therefore , <* I am *> ! *) *]@
\end{center}

In addition, lexical parsing (\secref{LEXICAL-PARSING}) is performed
by parsers, though lexical parsing definitions standardly do not have
the `text' selector and are therefore standardly not active during
text parsing.  During lexical parsing, number unit grouping
(\pagref{NUMBER-UNIT-GROUPING}) can insert implicit brackets.

Bracket and operator definitions may specify reformatters
which reformat subexpressions after they have been normally parsed.
A \key{reformatter}\label{REFORMATTER} is a function that
is called with the parsed
subexpression that is surrounded by brackets or that has the
operator as its lead operator.  The reformatter returns
the reformatted subexpression.

These definitions may also specify evaluators
that are functions called to evaluate parsed subexpressions.


\subsection{Parsers}
\label{PARSERS}

A \key{parser} is a function which when called with
a list of lexemes returns the parsed subexpression, which
is a list of {\em expression-items} (\pagref{EXPRESSION-ITEM}).

Parsers are defined by
\skey{parser definition}s\label{PARSER-DEFINITION}.
The topmost current parser definition
(\pagref{CURRENT-PARSING-DEFINITION})
in the parsing stack names the parser used to parse expressions.

Parser definitions have the syntax:

\begin{indpar}
\key{parser-definition}
	::= \verb|define parser| {\em parser-name}
				{\em parsing-selectors} \\[1ex]
\key{parser-name} ::= {\em symbol} {\em symbol}\,$^\star$ \\[1ex]
{\em parsing-selectors} ::= [see \pagref{PARSING-SELECTORS}]
\end{indpar}

There are two standard \ikey{parsers}{parser!standard},
the \key{operator parser} and the \key{text parser}, that have the
definitions:

\begin{indpar}\begin{verbatim}
define parser -OPERATOR-PARSER- [operator,list]
define parser -TEXT-PARSER- [text]
\end{verbatim}\end{indpar}

The difference between these two parsers is that only the operator
parser recognizes current operator definitions,
and only the text parser recognizes phrase separator, sentence
terminator, and section initiator definitions.

\subsection{Brackets}
\label{BRACKETS}

Brackets surround a subexpression and can specify the parsing
selector set that determines how the subexpression is parsed.



\subsubsection{Bracket Definitions}
\label{BRACKET-DEFINITION}

\ikey{Bracket definitions}{bracket definition} can be pushed onto
the parsing stack, and are used by both the operators and text
parsers.
A bracket definition specifies for each bracket pair the following:

\begin{indpar}[1in]
Name and Parsing Selectors \\
New Parsing Selector Set \\
Reformatter \\
Evaluator
\end{indpar}

\subsubsection{Bracket Definition Syntax}
\label{BRACKET-DEFINITION-SYNTAX}

The syntax of bracket definitions is:

\begin{indpar}
\key{bracket-definition} \\
	\hspace*{0.5in}::= \ttkey{define bracket}
	    \begin{tabular}[t]{@{}l@{}}
	    {\em bracket-name} {\em parsing-selectors} \\
	    {}[ \verb|with parsing-selectors|
	        {\em new-parsing-selector-set} ] \\
	    {}[ \verb|with reformatter|
	        {\em reformatter-name} ] \\
	    {}[ \verb|with evaluator| {\em evaluator-name} ] \\
	    {}[ \verb|with indentation separator|
		{\em indentation-separator} ] \\
	    {}[ \verb|with indentation indicator|
		{\em indentation-indicator} ] \\
	    \end{tabular}
	    \\[1ex]
\key{bracket-name} ::=
	{\em opening-bracket-name}
	\verb|...|
	{\em closing-bracket-name}
	\\[1ex]
\key{opening-bracket-name} ::=
	{\em symbol} {\em symbol}$^\star$
	\\[1ex]
\key{closing-bracket-name} ::=
	{\em symbol} {\em symbol}$^\star$
	\\[1ex]
{\em parsing-selectors} ::= [see \pagref{PARSING-SELECTORS}]
	\\[1ex]
\key{new-parsing-selector-set} ::= {\em parsing-selector-list}
			[see \pagref{PARSING-SELECTOR-LIST}]
	\\[1ex]
\key{reformatter-name} ::= {\em function-name }
	\\[1ex]
\key{evaluator-name} ::= {\em function-name }
	\\[1ex]
\key{function-name} ::=
	{\em symbol} {\em symbol}\,$^\star$
	\\[1ex]
\key{indentation-separator} ::=
	{\em symbol} {\em symbol}\,$^\star$
	\\[1ex]
\key{indentation-indicator} ::= {\em mark}
\end{indpar}


\subsubsection{Bracket Name}\ttmindex{name}{of bracket}
\label{BRACKET-NAME}
A bracket definition has a sequence of lexemes that is the
{\em name} of the brackets.  This name
has two subsequences of lexemes, an
\key{opening bracket name} and
a \key{closing bracket name}, separated by 
a `\verb/.../' lexeme.

If there are any opening or closing
lexemes in the name, they must be in matching pairs.
Thus \verb|[ (* ... *) ]| and \verb|[ $($ ... $)$ ]| are legal,
but \verb![ << ... | ]! is not.

By abuse of language, 
`\key{opening bracket}\,'
is used as a synonym for `opening bracket name' and `\key{closing bracket}\,'
is used as a synonym for `closing bracket name'.

When a subexpression is surrounded by brackets, the brackets
are included in the subexpression.

The {\em parsing-selectors} provided with the {\em bracket-name} determine when
the {\em bracket-definition} will be active (\secref{PARSING-SELECTORS}).

\subsubsection{Bracket New Parsing Selector Set}%
\label{BRACKET-NEW-PARSING-SELECTOR-SET}

If given in the bracket definition, the
\emkey{new-parsing-selector-set}\index{parsing selector set!of bracket}
is pushed into the parsing selector set stack
(\pagref{PARSING-SELECTOR-SET-STACK}) just before a subexpression
beginning and ending with the defined brackets is parsed, and then
this set is popped off the stack after the subexpression is parsed.
The selector set controls that parsing definitions used to parse
the subexpression, and thereby determines the parser used
(\secref{PARSING-OVERVIEW}).


\subsubsection{Bracket Reformatter}\ttmindex{reformatter}{of bracket}
\label{BRACKET-REFORMATTER}


A {\em reformatter-name}
is the name of the function that is called with a parsed expression
as its single argument in order to reformat the expression
(\pagref{REFORMATTER}).  The reformatter is optional.

\subsubsection{Bracket Evaluator}\ttmindex{evaluator}{of bracket}
\label{BRACKET-EVALUATOR}


An {\em evaluator-name}
is the name of the function that is called with a reformatted expression
as its single argument in order to evaluate the expression.  The evaluator
returns the value of the expression as its result.  There will generally
be side effects of evaluation.

Evaluation occurs at a completely different time than parsing occurs.
During parsing, the evaluator function name is just added to the attributes
of the parsed expression.

The following are standard evaluators:

\begin{indpar}

The \ttkey{standard evaluator}.  Calls functions.

The \ttkey{quote evaluator}.  Does not evaluate the expression, but
may evaluate \verb|[ ]| bracketed subexpressions.  See TBD.

\end{indpar}

\subsection{Operators}
\label{OPERATORS}

Operators restructure expressions in which they occur.  Operators
are defined by operator definitions that can be added to the
parsing stack.  Certain operators are `definitional'
(\pagref{DEFINITIONAL}), and it is just these operators which accept
definitions to be pushed into the parsing stack.

\subsubsection{Operator Definitions}
\label{OPERATOR-DEFINITION}

\ikey{Operator definitions}{operator definition} can be pushed onto
the parsing stack, and are used by the operators parser, but
\underline{not} by the text parser.  List separators are treated
during parsing as operators, and have operator definitions.
An operator definition specifies for each operator the following:

\begin{indpar}[1in]
Name and Selectors \\
Precedence \\
Operator Flags \\
Reformatter \\
Evaluator
\end{indpar}

\subsubsection{Operator Definition Syntax}
\label{OPERATOR-DEFINITION-SYNTAX}

The syntax of operator definitions is:

\begin{indpar}
\key{operator-definition} \\
	\hspace*{0.5in}::= \ttkey{define operator}
	    \begin{tabular}[t]{@{}l@{}}
	    {\em operator-name} {\em parsing-selectors} \\
	    {\em operator-flag}$^\star$ \\
	    {}[ \verb|with precedence| {\em precedence} ] \\
	    {}[ \verb|with reformatter| {\em reformatter-name} ] \\
	    {}[ \verb|with evaluator| {\em evaluator-name} ] \\
	    \end{tabular}
	    \\[1ex]
\key{bracket-name} ::=
	{\em opening-bracket-name}
	\verb|...|
	{\em closing-bracket-name}
	\\[1ex]
\key{opening-bracket-name} ::=
	{\em symbol} {\em symbol}$^\star$
	\\[1ex]
\key{closing-bracket-name} ::=
	{\em symbol} {\em symbol}$^\star$
	\\[1ex]
\key{operator-flag} ::= \ttmkey{definitional}{operator flag}
                    $|$ \ttmkey{prefix}{operator flag}
                    $|$ \ttmkey{infix}{operator flag}
                    $|$ \ttmkey{postfix}{operator flag}
	\\[1ex]
\key{reformatter-name} ::= {\em function-name }
	\\[1ex]
\key{evaluator-name} ::= {\em function-name }
	\\[1ex]
\key{function-name} ::=
	{\em symbol} {\em symbol}$^\star$
\end{indpar}

\subsubsection{Operator Name}\ttmindex{name}{of operator}
\label{OPERATOR-NAME}
An operator definition has a sequence of lexemes that is the
{\em name} of the operator.  The operator
inside a subexpression is just this sequence of lexemes.
By abuse of language, the term `\key{operator}' is often used
as a synonym for `operator name'.

\subsubsection{Operator Flags}\ttmindex{flag}{of operator}
\label{OPERATOR-FLAGS}
Operators can have \skey{operator flag}s that
affect parsing of subexpressions of the operator.  These are:

\begin{indpar}

\begin{labpar}[0.1in]{{\bf prefix}, {\bf infix}, {\bf postfix}, {\bf nofix}}%
    \index{prefix flag@{\tt prefix} flag}\label{PREFIX}%
    \index{infix flag@{\tt infix} flag}\label{INFIX}%
    \index{postfix flag@{\tt postfix} flag}\label{POSTFIX}%
    \index{nofix flag@{\tt nofix} flag}\label{POSTFIX}
These flags determine the operator
\key{fixity}.  By default an operator is nofix.

An \key{infix} operator must be between two non-empty operands,
while a \key{prefix} operator must precede a non-empty operand,
and a \key{postfix} operator must follow a non-empty operand.

A \key{nofix} operator is like an infix operator but may have
empty operands.  It may appear at the beginning or ending of
an expression, or two nofix operators may be consecutive.

Inside an expression, an operator that can be prefix if it
begins an expression,
follows an opening bracket, or or follows another operator that is not
postfix.  An operator can be postfix if it ends an
expression, precedes a closing bracket, or
precedes another operator that is not prefix.  
An operator can be infix if it does not begin an expression,
follow an opening bracket, follow an operator that is prefix,
precede an expression end, 
precede a closing bracket, or precede an operator that is postfix.

A nofix operator cannot be infix, prefix, or postfix, and a postfix
operator cannot be infix.  An operator may be only nofix, only infix,
only prefix, only postfix, prefix and postfix, or prefix and infix.
An operator that can be prefix
and either postfix or infix is taken to be prefix if and only if it follows
an expression beginning, an opening bracket, or an operator previously
determined in a left-to-right scan to be prefix, infix, or nofix.

\end{labpar}

\begin{labpar}[0.1in]{\bf definitional}%
\index{definitional flag@{\tt definitional} flag}%
\label{DEFINITIONAL}~~~~~
This flag may only be given for an infix or nofix operator.
It causes operands preceding the operator to be inspected to see if they are
an expressions beginning with the word `\ttkey{define}' or `\ttkey{undefine}'.
Such an expression is called a \key{definition}, and is pushed into
the parsing stack.
See \pagref{PARSING-STACK-DEFINITION-KINDS} for a list of the kinds of
definition that may be pushed into the parsing stack.

When an definition operand is pushed onto the parsing stack, it and
its following definitional operator are removed from the input being
parsed.

If an operand is not a definition, nothing special is done by
a definitional operator during parsing.

\end{labpar}

\end{indpar}

\subsubsection{Operator Precedence}\ttmindex{precedence}{of operator}
\label{OPERATOR-PRECEDENCE}
The precedence of an operator is an integer.  Precedence is used to
determine which operators are inside and outside implicit brackets.
Operators with higher precedence are placed inside the 
implicit brackets that surround operands of operators of lower precedence.

The precedence
in an operator definition applies only to the operator when it is used
as an infix or nofix operator; prefix and postfix operators are always
treated as having precedence higher than any infix or nofix operator.
If several prefix and postfix operators apply to a single operand,
the prefix operators are all inside the implicit brackets surrounding
the postfix operator operands (i.e., the prefix operators are
`executed first').

\subsubsection{Operator Parser}\ttmindex{parser}{of operator}
\label{OPERATOR-PARSER}

A parser is the name of the function that is called with an expression
as its single argument in order to parse the expression.

Parsers can be pushed onto the parsing stack.
The parser used for subexpressions of an expression is the parser
nearest the top of the parsing stack.

The \verb|parser| of an operator definition is an optional symbol sequence that
names a parser.  If present, a {\em PARSER-DEFINITION}
(\pagref{PARSER-DEFINITION}) naming the parser is pushed onto the parsing
stack before subexpressions are parsed, and popped from the parsing stack
after subexpressions have been parsed.

The following are standard parsers:

\begin{indpar}

The \key{operators parser}, \ttkey{-OPERATORS-PARSER-}.
Lexical parsing is done.
Then operators, qualifiers, qualifier shortcuts,
and the \verb|::?| optional argument,
\verb|<:>| reorder, \verb|::>| remainder,
\verb|@@| required qualifier, and
\verb|??| optional qualifier marks are recognized.
The special constructs of text parsing, e.g., the \verb/|/ format separator,
are \underline{not} recognized.

The \key{marks parser}, \ttkey{-MARKS-PARSER-}.
Lexical parsing is \underline{not} done.
The \verb|::?| optional argument,
\verb|<:>| reorder, \verb|::>| remainder,
\verb|@@| required qualifier, and
\verb|??| optional qualifier marks are recognized.
Operators, qualifiers, qualifier shortcuts, and the special constructs
of text parsing, e.g., the \verb/|/ format separator,
are \underline{not} recognized.

The \key{text parser}, \ttkey{-TEXT-PARSER-}.
Lexical parsing is \underline{not} done.
The special constructs of text parsing (\secref{TEXT-PARSING}) are
recognized.
Operators, qualifiers, qualifier shortcuts, and the \verb|::?| optional
argument, \verb|<:>| reorder, \verb|::>| remainder,
\verb|@@| required qualifier, and
\verb|??| optional qualifier marks are \underline{not} recognized.

\end{indpar}

\subsection{Expression Reformatting}
\label{EXPRESSION-REFORMATTING}

TBD

The \key{parser expansion} algorithm inputs an object output
by the operator scanning algorithm and outputs an
expanded object that replaces the input object.
The parser expansion algorithm goes through its input
looking for objects with a {\tt .parser} attribute, and for each
such object, calls its {\tt .parser} attribute value as a function with
the object as input and the function output as the expansion of the input
object.  The expansion algorithm works only on the top level: when the
algorithm calls the {\tt .parser} attribute function of an expression,
the algorithm leaves it up to that function to call the {\tt .parser}
attribute functions of subexpressions.  The standard parsers do this
first, thus effecting a bottom up algorithm, similar to expression
evaluation.

A {\tt .parser} attribute value is known as a \key{parser}, and is associated
with an operator priority level
(see Figure \figref{SPECIAL-LEXEMES} and \secref{OPERATOR-DEFINITION}).
Immediately below are the standard parsers and their effects.

In describing effects, we use notation such as

\begin{center}
\verb|x <- y <- z + w| ~~~ $\Longrightarrow$ ~~~
\verb|<- x (<- y (+ x w))|
\end{center}

Here $\Longrightarrow$ means `is rewritten as'.  Furthermore, the
parentheses introduced by the rewrite are \underline{implied},
which means that the lists they bracket have \underline{no}
\verb|.initiator| or \verb|.terminator|, and the parentheses are
merely written here to indicate sublists in the expression structure.

\newpage

\begin{indpar}[1em]

\newcommand{\OP}[1]{\ttmkey{#1}{parsing}}
\newcommand{\NBOP}[1]{\ttmnbkey{#1}{parsing}}
\newcommand{\MAC}[2]{\hfill #1, \ttmkey{#2}{parsing macro}}

\bigskip

\ttmkey{sentence}{parser} \hfill
	\skey{terminator}s: \NBOP{.} ~ \NBOP{!} ~ \NBOP{?}

\begin{indpar}[0.5em]
Terminators may not be consecutive, may not begin an expression,
and must end an expression.  Thus each between-terminator subexpression
is non-empty and is followed by a terminator.
Each between-terminator subexpression is converted if necessary
to a list.  Then a \ttmkey{.terminator}{produced by parsing}
attribute is added to this list whose value is the terminator following the
subexpression.  If there is only one subexpression, the list it produces
is the parse result.  Otherwise the result is the list of all the subexpression
lists.
\end{indpar}

\bigskip


\ttmkey{subsentence}{parser} \hfill
	\key{subsentence separator}: \NBOP{;} \\
\ttmkey{phrase}{parser} \hfill
	\key{phrase separator}: \NBOP{,}

\begin{indpar}[0.5em]
Here `\verb|;|' or `\verb|,|' is the \key{separator}.  These have different
priority levels and different parsers, and so cannot appear together
in the same expression.

A list of all between-separator subexpressions is made, with empty
between-separator subexpressions being represented by objects with
no attributes.  There will be at least two subexpressions: one following
the last separator and one preceding the first separator.
The list of subexpressions is given a
\ttmkey{.separator}{produced by parsing}
attribute with value of the separator (\verb|";"| or \verb|","|),
and is returned as the result of the parse.
\end{indpar}

\bigskip

\ttmkey{assign}{parser} \hfill
	\skey{assign operator}s: \NBOP{<-} ~ \OP{BECOMES}

\begin{indpar}[0.5em]
Assign operators may not be consecutive and may not begin or end an expression.
The two different kinds of assignment operator, \verb|<-| and \verb|BECOMES|,
may not be mixed in the same expression.
The results are rewritten using the two-argument assignment function \verb|<-|,
making multiple assignments from right to left.

\begin{indpar}[0.5em]
\verb|x <- y <- z + w| ~~~ $\Longrightarrow$ ~~~
\verb|<- x (<- y (+ x w))| \\
\verb|x BECOMES y BECOMES z + w| ~~~ $\Longrightarrow$ ~~~
\verb|<- x (<- y (+ x w))|
\end{indpar}
\end{indpar}

\bigskip

\ttmkey{logical}{parser} \hfill
	\skey{logical operator}s: \OP{AND} ~ \OP{OR} ~ \OP{NOT}

\begin{indpar}[0.5em]
One expression cannot have both {\tt AND} and {\tt OR} operators
outside explicitly bracketed subexpressions.  The {\tt NOT} operator
can only occur at the beginning of an expression or just after {\tt AND}
or {\tt OR}.  Subexpressions cannot be empty, except for the subexpressions
before a {\tt NOT}, which must always be empty.

The expression is rewritten using a multi-argument {\tt AND}
or {\tt OR} function and a single argument {\tt NOT} function.

\begin{indpar}[0.5em]
\verb|NOT x = 8| ~~~ $\Longrightarrow$ \verb|NOT (x = 8)| \\
\verb|NOT x AND NOT y AND z AND w| ~~~ $\Longrightarrow$ ~~~
\verb|AND (NOT x) (NOT y) z w| \\
\verb|NOT x = 8 OR NOT y < 9 OR z = 0| ~~~ $\Longrightarrow$
\\\hspace*{1in}
\verb|OR (NOT (x = 8)) (NOT (y < 9)) (z = 0)|
\end{indpar}

Note that {\tt NOT} is not a classical prefix operator, which would have
higher priority than \verb|=| or \verb|<|.  Also note that {\tt AND}
and {\tt OR} may not be used in the same logical expression without using
explicit brackets.
\end{indpar}

\bigskip

\ttmkey{compare}{parser} \hfill
	\skey{compare operator}s:
	\NBOP{=} ~ \NBOP{<} ~ \NBOP{>} ~
	\NBOP{/=} ~ \NBOP{!=} ~
	\NBOP{=>} ~ \NBOP{>=} ~
	\NBOP{=<} ~ \NBOP{<=}

\begin{indpar}[0.5em]
Subexpressions cannot be empty, and a compare operator may not
begin or end an expression.
The expression is rewritten using a multi-argument {\tt AND}
function and two-argument compare functions.  Temporary variables
(\secref{TEMPORARY-VARIABLES})
are used to name intermediate expression values to
avoid recomputing arguments.

\begin{indpar}[0.5em]
\verb|x < y < z| ~~~ $\Longrightarrow$ ~~~
\verb|AND (< x (<- (.tmp 56) y)) (< (.tmp 56) z))| \\
\verb|x = y + z != w/2 <= x| ~~~ $\Longrightarrow$
\\\hspace*{1in}\begin{tabular}{@{}ll@{}}
	       \verb|AND| & \verb|(= x (<- (.tmp 57) (+ y z)))| \\
			  & \verb|(!= (.tmp 57) (<- (.tmp 58) (/w 2)))| \\
			  & \verb|(<= (.tmp 58) x)| \\
	       \end{tabular}
\end{indpar}

Note that sequences of comparison operators are treated as they are
in mathematics and not as they are in classical programming languages.
E.g., \verb|x<y<z| means \verb|x<y AND y<z| and \underline{not}
\verb|(x<y)<z|.
\end{indpar}

\bigskip

\ttmkey{sum}{parser} \hfill
	\skey{addition operator}s: \NBOP{+} ~ \NBOP{-}

\begin{indpar}[0.5em]
Addition operators may not be consecutive and may not end an expression.
The results are rewritten using the multi-argument summation function \verb|+|
and the unary negation function \verb|-|.

\begin{indpar}[0.5em]
\verb|- x + y + z - w| ~~~ $\Longrightarrow$ ~~~
\verb|+ (- x) y z (- w)|
\end{indpar}
\end{indpar}

\bigskip

\ttmkey{product}{parser} \hfill
	\skey{multiplication operator}s: \NBOP{*} ~ \NBOP{/}

\begin{indpar}[0.5em]
The two different kinds of multiplication operators, \verb|*| and \verb|/|,
cannot be mixed in the same expression.
Multiplication operators may not be consecutive and may neither begin
nor end an expression.  The division operator \verb|/| must have exactly
two operands.  The results are rewritten using
the multi-argument multiplication function \verb|*| or the binary
division function \verb|/|.  E.g.:

\begin{indpar}[0.5em]
\verb|x * y * z| ~~~ $\Longrightarrow$ ~~~ \verb|* x y z| \\
\verb|x / y| ~~~ $\Longrightarrow$ ~~~ \verb|/ x y|

\end{indpar}
\end{indpar}


\end{indpar}



\subsection{Text Parsing}
\label{TEXT-PARSING}

\ikey{Text parsing}{text parsing} is performed by the \ttkey{-TEXT-PARSER-},
which is the parser for subexpressions of the
\verb|`|...\verb|'|, etc. matchfix operators.
The \verb/|/ format separator and sentence and paragraph ends are
recognized by text processing, while
operators, qualifiers, qualifier shortcuts, and
the \verb|::?|, \verb|<:>|, \verb|::>|, \verb|@@|, and
\verb|??| marks are \underline{not} recognized.

Text parsing is normally done in the context of a pair of matched
{\em quotes}, and in this context {\em white-space} pre-lexemes
become lexemes.  Note that {\em white-space} lexemes all consist
of zero or more {\em vertical space} characters followed by zero or
more {\em single-space} characters (\secref{WHITE-SPACE-CONVERSION}).
There are three kinds of {\em white-space} lexemes
used by text parsing:

\begin{list}{}{}

\item[{\bf Spacer Lexemes}.]
A \key{spacer} lexeme is a {\em white-space} lexeme containing
only single spaces.  Spacers are used in text parsing if they follow
a \verb\|\ format separator on a line.

\item[{\bf Line Separator Lexemes}.]
A \key{line separator} lexeme is a {\em white-space}
lexeme that contains a single {\em line-feed} character and no other
{\em vertical-space} characters.  Such lexemes separate
non-blank lines, and are used by text parsing to end lines containing
a \verb\|\ format separator.

\item[{\bf Blank Line Lexemes}.]
A \key{blank line} lexeme is a {\em white-space}
lexeme that contains either two or more {\em line-feed} characters or contains
a {\em vertical-space} character that is not a {\em line-feed} character.
Such lexemes
represent blank lines between non-blank lines, and are used by text parsing
both to end lines containing a \verb\|\ format separator and
to separate paragraphs.

\end{list}

\subsubsection{Section, Paragraph, and Sentence Parsing}
\label{SECTION-PARAGRAPH-AND-SENTENCE-PARSING}

If the text being parsed does not contain any format separators,
the text is parsed into phrases, sentences, and paragraphs.

First the text is divided by blank line lexemes into paragraphs.
The sequence of paragraphs comprises a section.

Then in each paragraph, sentence terminators are located.
White-space lexemes in the paragraph are deleted after sentence terminators
are located.
Each sequence
of lexemes or subexpressions ending in a sentence terminator
is made into a sentence, and any
non-empty sequence
of lexemes or subexpressions following the last sentence terminator
is made into a phrase.
The paragraph is then a sequence of zero or more sentences 
possibly followed by a phrase.  However, a paragraph cannot be empty.

The syntax of the result is:

\begin{indpar}
\key{section} ::= \verb|[-SECTION-| {\em paragraph} {\em paragraph}\,$^\star$
                  \verb|]| \\[1ex]
\key{paragraph}
	\begin{tabular}[t]{rl}
	::= &  \verb|[-PARAGRAPH-| {\em sentence} {\em sentence}\,$^\star$
	       \verb|]| \\
	$|$ &  \verb|[-PARAGRAPH-| {\em sentence}\,$^\star$ {\em phrase}
	       \verb|]|
	\end{tabular} \\[1ex]
\key{sentence} ::= \verb|[-SENTENCE-| {\em sentence-non-terminator}\,$^\star$
                                    {\em sentence-terminator}
                  \verb|]| \\[1ex]
\key{phrase}
	\begin{tabular}[t]{rl}
	::= &  \verb|[| \begin{tabular}[t]{@{}l@{}}
			{\em sentence-non-terminator}
			{\em sentence-non-terminator} \\
		        {\em sentence-non-terminator}\,$^\star$ \verb|]|
			\end{tabular} \\
	$|$ &  {\em sentence-non-terminator}
	\end{tabular} \\[1ex]
\key{sentence-terminator} ::= \verb|.| $|$
                              \verb|?| $|$
                              \verb|!| \\[1ex]
\key{sentence-non-terminator} ::= {\em symbol} $|$
                                  {\em subexpression}
\end{indpar}

Note that a {\em phrase} with more than one {\em sentence-non-terminator}
is a list, but a {\em phrase} with just one {\em sentence-non-terminator}
is not a list, but just the single {\em sentence-non-terminator} by itself.

There are several rules that modify the description just given:

{\bf Sentence Terminator Rule.}\index{Sentence Terminator Rule}
A \key{sentence-terminator} is any lexeme that is syntactically
a sentence terminator, that is not preceded by a {\em white-space}
lexeme, and that is followed by a {\em white-space} lexeme, a
{\em closing-mark} lexeme, or the
end of the lexeme sequence.  All other lexemes and all subexpressions are
\skey{sentence-non-terminator}s.

{\bf Initial Capitalization Rule.}\index{Initial Capitalization Rule}
A {\em word} consisting of an initial capital letter followed
by zero or more lower case letters is converted
to an all lower case word if it begins a sentence.
A {\em word} consisting of an initial
\verb|^|\index{^@{\tt \Circumflex}} followed by an upper
case letter followed by zero or more lower case letters has the
initial \verb|^| removed.

{\bf Text Simplification Rule.}\index{Text Simplification Rule}
If the {\tt -TEXT-PARSER-} is to return a {\em section} with just
one {\em paragraph} and that {\em paragraph} contains nothing but
just one {\em sentence} or {\em phrase},
then just the {\em sentence} or {\em phrase} is returned.
Otherwise, if a {\em section} with just one {\em paragraph} is
to be returned, just the {\em paragraph} is returned.


Some examples follow:

\begin{center}
\begin{tabular}{lcl}

\verb|`the wife of Bob'|
& parses as &
\verb|[-PHRASE- the wife of Bob]|
\\[2ex]
\verb|`She hit the ball.'|
& parses as &
\verb|[-SENTENCE- she hit the ball .]|
\\[2ex]
\begin{tabular}{@{}l@{}}
\verb|`^Bill swung.| \\
\verb|  But he missed!'|
\end{tabular}
& parses as &
\begin{tabular}{@{}l@{}}
\verb|[-PARAGRAPH- [-SENTENCE- Bill swung .]| \\
\verb|             [-SENTENCE- but he missed !]]|
\end{tabular}
\\[5ex]
\begin{tabular}{@{}l@{}}
\verb|`^I liked| \\
\verb|  the party.| \\
\verb|| \\
\verb|  Later, we caught| \\
\verb|  the bus.'|
\end{tabular}
& parses as &
\begin{tabular}{@{}l@{}}
\verb|[-SECTION-| \\
\verb|   [-PARAGRAPH-| \\
\verb|      [-SENTENCE- I liked the party .]]| \\
\verb|   [-PARAGRAPH-| \\
\verb|      [-SENTENCE- later , we caught the| \\
\verb|                  bus .]]]| \\
\end{tabular}

\end{tabular}
\end{center}

Note that capitalized words like proper names and `\verb|I|' need to be
prefixed by `\verb|^|' if they begin a sentence or phrase.


\subsubsection{Text with Format Separators}
\label{TEXT-WITH-FORMAT-SEPARATORS}

TBD

\subsection{The Parsing Algorithm}
\label{THE-PARSING-ALGORITHM}
Parsing is done by a recursive descent left-to-right algorithm.
A parser is called to parse each subexpression.  This parser is
given the following explicit arguments:

\begin{center}
\begin{tabular}{l}
a list of lexemes to parse \\
an optional (closing) bracket definition \\
an optional (terminating) operator precedence \\
\end{tabular}
\end{center}

The bracket definition, if given, specifies a closing bracket
which must appear in the list of lexemes.  When the parser
finds this bracket outside other brackets, the parser terminates
the parse.

The operator precedence, if given, specifies that infix or
nofix operators of this and lower precedence will terminate the parsing if
they are encountered in the list of lexemes.

In addition the parser is given the following implicit
arguments:

\begin{center}
\begin{tabular}{l}
the parsing definition stack \\
the parsing selector set stack
\end{tabular}
\end{center}

The parser returns

\begin{center}
\begin{tabular}{l}
the parsed expression \\
the unparsed final segment of the input lexeme list
\end{tabular}
\end{center}

When parsing is terminated by finding a closing bracket matching
the closing bracket definition argument, then the part of the
input lexeme list after this closing bracket is returned as the
unparsed final segment of the input lexeme list.  When parsing is
terminated by finding a terminating operator of precedence equal to or lower
than an operator precedence argument, the part of the input
lexeme list beginning with this terminating operator is returned as the
unparsed final segment of the input lexeme list.  Otherwise the
returned unparsed final segment of the input lexeme list is empty.

There are two standard kinds of parser: the operator parser
and the text parser.  These use somewhat different algorithms.

\subsubsection{The Operator Parser}
\label{THE-OPERATOR-PARSER}

The operator parser uses an input list which is initialized to the parser's
lexeme list input argument, and an output list which is initially
empty.  The parser executes a parsing loop that removes lexemes
from the beginning of the input list and adds {\em expression-items}
to the end of the output list.  When the parser terminates, the output
list becomes the returned parsed expression, and what is left of the input
list becomes the returned unparsed lexeme list.

During the execution of the algorithm below, a \key{terminating bracket}
is defined to be an instance of the closing bracket of the closing bracket
definition, if that definition is given.  A \key{terminating operator}
is defined to be an instance of an operator whose definition is current
and whose precedence is equal to or below that of the terminating precedence,
if that is given.
A \key{parsing terminator} is defined to be a terminating bracket,
a terminating operator, or the end of the input list.

Operators in the output list are identified when they are moved from beginning
of the input list to the end of the output list.
The first such operator in the output list is called the \key{lead operator},
and its definition is called the \key{lead operator definition}.
This definition provides things like reformatters and evaluators when
the output list is viewed as an expression.

During the execution of this algorithm a list of {\em expression-items}
may be \ikey{reformatted}{reformat}
by a reformatter.  This is done by calling the reformatter,
which is a function, with the list as its input argument, replacing the
list by the returned result, which is also a list of {\em expression-items}.


The \key{parsing loop} repeats the following:

\begin{enumerate}

\item If there is no closing bracket definition argument
and the input list is empty, the parsing loop terminates.

\item If there is a closing bracket definition argument
and the input list is empty, a parsing error is announced and
the parsing loop terminates.

\item The beginning of the input list is inspected to see if it
begins with a terminating bracket, a current operator, or a current
opening bracket.  If more than one of these qualifies, the longest is
selected.  If more than one thing is left after this selection,
a parsing error is announced, and the following preference order
is used to make a selection: terminating bracket, opening bracket,
operator.

\item If the input list begins with a terminating bracket,
this bracket is removed from the beginning of
the input list, and the parsing loop terminates.

\item If the input list begins with a terminating operator,
the parsing loop terminates \underline{without} removing the
operator from the input list.

\item If the input list begins with an opening bracket from
a current bracket definition, then:

\begin{enumerate}

\item The bracket is removed from the beginning of the input list.

\item If the bracket definition has a {\em new-parsing-selector-set},
that is pushed into the parsing selector set stack.

\item The current parser is called with the input list as its input
lexeme list argument, the closing bracket definition as an argument,
and no terminating precedence.

\item The input list is set to the unparsed lexeme list returned by the
parser call.

\item The parsed expression returned by the parser call, reformatted
by the reformatter of the bracket definition if that exists, is
pushed as a single {\em expression-item} to the end of the
output list.

\item If a {\em new-parsing-selector-set} from the bracket definition
was previously pushed onto the parsing selector set stack,
that is now popped from this stack.

\end{enumerate}

\item If the input list begins with a non-terminating operator from
a current operator definition, then:

\begin{enumerate}

\item
If the output list has more than one {\em expression-item}, then
the entire output list becomes an operand, this operand is reformatted
by the reformatter of its lead operator definition, if any,
and then the output list is
replaced by a list whose only {\em expression-item} is this operand.
This effectively inserts implicit brackets around the output list.
Note that after this has been done, the output list no longer contains
any operators (i.e., operators outside implicit brackets).

\item If the output list is empty
and the operator cannot be nofix or prefix, then an error operand
is inserted into the output list, and a parsing error is announced.

\item If the output list is non-empty
and the operator cannot be nofix, infix, or postfix,
then an error nofix operator is inserted at the \underline{beginning}
of the \underline{input list}, a parsing error is announced, and
the parsing loop repeats (permitting the error operator to be a
terminating operator).

\item The fixity of the operator is determined as follows:

\begin{enumerate}

\item If the output list is empty, the operator is designated to be
either prefix if it has the prefix flag or nofix if it has the
nofix flag (it cannot have both flags).

\item If the output list is non-empty and the operator does not have
the postfix flag, the operator is designated to be
either infix if it has the infix flag or nofix if it has the
nofix flag (it cannot have both flags).

\item If the output list is non-empty and the operator has the postfix
flag, the operator is designated to be postfix.

\end{enumerate}

\item The operator precedence is determined by the operator
definition if the operator has been determined to be infix
or nofix, and is otherwise the error precedence if the operator is an error
nofix operator, the prefix precedence if the operator was determined to
be prefix, or the postfix precedence if the operator was determined to be
postfix.

\item The operator is removed from the input list and copied
to the output list.

\item
If the operator is prefix, infix, or nofix, then a
\key{parsing subloop} that repeats the following is executed:

\begin{enumerate}

\item The current parser is called with the input list as its lexeme
list, the operator precedence as its terminating precedence argument,
and a copy of the closing bracket definition argument.

\item Upon return from the parser call
the returned lexeme list becomes the input list.

\item If the returned parsed expression is the empty list, and
the operator is prefix or infix, the returned parsed expression is
replaced by an error operand, and a parsing error is announced.

\item If the returned parsed expression contains zero or one element,
it is added by concatenation to the end of the output list.
If it contains more than one element, it is pushed as a single
{\em expression-item} to the end of the output list.

\item If the operator was a prefix operator, or if
the input list now begins with a parsing terminator, the
parsing subloop terminates.

\item The input list must now begin with a current operator whose
precedence equals the operator precedence.  That operator is moved
from the input list to the output list and the parsing subloop repeats.

\end{enumerate}

\item When the parsing subloop ends (or if it is never executed),
if the operator definition has a reformatter, that is applied to reformat
the output list.

\end{enumerate}

\item If the input list does not begin with a current operator,
open bracket, or parsing terminator, the lexeme at the beginning
of the input list is moved to the end of the output list.

\end{enumerate}

When the parsing loop terminates, the input and output lists are
returned to the caller of the parser as the remaining lexeme list and 
the parsed expression, respectively.

\subsubsection{The Text Parser}
\label{THE-TEXT-PARSER}

The text parser divides the input into paragraphs that are separated by
blank lines.

Paragraphs are classified as tabular or free-form according
to whether their first line is a tabular format line.  A
\key{tabular format line} contains optional whitespace characters,
followed by a `\ttmnbkey{+}{in tabular format line}', followed
by any number of `{\tt +}' or
`\ttmnbkey{-}{in tabular format line}' characters,
followed by a `{\tt +}' that ends the line, except that superfluous
whitespace characters are allowed after the `line ending' {\tt+}.
An example of a tabular paragraph is:


\begin{indpar}\begin{verbatim}
+------------------------+--------+------+
 ice melt                 40 lbs    $4.50
 2x4's, 8ft               10       $27.70
 16d nails                 2 lbs     3.21
\end{verbatim}\end{indpar}


A paragraph that is not tabular is \ikey{free-form}{paragraph}.
Each free-form paragraph is scanned for explicitly bracketed subexpressions,
phrase separators, and sentence terminators.  The paragraph is divided into
sentences using sentence terminators outside brackets, and each sentence
is given \verb|<* *>| implicit brackets.
Each sentence is then divided into
phrases if it has any phrase separators, and 



\section{Expression Evaluation}
\label{EXPRESSION-EVALUATION}

An expression is evaluated by first searching for an expression definition
that matches the expression.  Expression definitions also have guards, which
are expressions that must evaluate to true in order for the expression
definition match to succeed.
An expression definition may have an expression block
that executes in order to produce a value for the expression if the definition
matches.  If a matching
expression definition has no expression block, the expression
evaluates to `\ttkey{true}'.  If no expression definition matches an
expression, the expression evaluates to `\ttkey{false}'.

Expression definitions are searched for in a context, which is a list
of expression definitions and pointers to other contexts.
Each point in the program has a lexical context, which is used by default
for expression evaluation.  There is also a global context to which
definitions may be added or from which they may be deleted.
The block of an expression definition usually evaluates expressions in the
lexical context of its expression definition,
but may evaluate expressions in the lexical context of the expression being
evaluated by the expression definition.

When an expression definition is found that matches an expression, a
copy of the expression definition is made, and a part of this copy called
the pattern is unified with the matched expression.  This unification defines
variables in the expression definition and null nodes in the matched
expression that are values of variables outside the expression definition.
Expression definition variables that receive no value in this way,
but which have default values, are given the default values.
However, values received from unification may be incomplete, in that they
may be expressions which include null nodes that represent unknown values
of other variables.
When the guards of the expression definition
are matched in turn with other expression
definitions, and unified with patterns in copies of these matched definitions,
the incomplete values may become complete.  For this reason,
matching of guards with definitions and unification of guards
is done as much as possible before any blocks are evaluated.

The expression being evaluated may also have null nodes that represent
unknown values of variables.  During evaluation
these null nodes may be unified with patterns in expression definitions,
and cease to become null nodes.  This process is known as
`\key{completing the expression}' being evaluated.  An expression with
no null nodes is said to be \mkey{complete}{expression}, whereas
an expression with null nodes is said to be \mkey{incomplete}{expression}.

After an expression definition pattern is unified with an
expression the definition matches, and after default values are assigned,
some variable values are evaluated and replaced by their evaluated values.
These variables are called evaluated variables, and typically have names
beginning with a capital letter, whereas other variables are
called unevaluated variables, and typically have names beginning with
`\verb|#|' followed by a capital letter.  Evaluation of evaluated variable
values happens before guard expressions are matched to definitions,
so guard expressions see only the evaluated value of evaluated variables.
The values which are evaluated in this manner must not be incomplete,
and their evaluation must have no visible side effects.

After all guards are matched with definitions and unified,
blocks are evaluated, beginning with any blocks in the definitions matched
to guards.  If any of these guard blocks fails to produce the value true,
the expression definition match fails, and the search for other matching
definitions continues.
Evaluations of guard blocks are required to have no visible side effects.

\subsection{Expression Definitions}
\label{EXPRESSION-DEFINITION}

\ikey{Expression definitions}{expression definition} have the syntax:

\begin{indpar}
\key{EXPRESSION-DEFINITION}\label{EXPRESSION-DEFINITION} ::=
	{\em pattern} \verb|<--| {\em guard-list-option} {\em block-option}
	\\[1ex]
\key{pattern} ::= {\em EXPRESSION} \\[1ex]
\key{guard-list-option} ::= {\em empty} $|$ {\em guard-list} \\[1ex]
\key{guard-list} ::= {\em guard} \{ \verb|,| {\em guard} \}\,$^\star$ \\[1ex]
\key{guard} ::= {\em EXPRESSION} \\[1ex]
\key{block-option} ::= {\em empty} $|$ {\em block} \\[1ex]
\key{block} ::= \verb|{| {\em statement}
                         \{ \verb|;| {\em statement} \}\,$^\star$ \verb|}|
\end{indpar}%
\label{PATTERN}

{\em Blocks} and {\em statements} are further defined in
\secref{BLOCKS}.

In use, an expression definition being matched to an expression is
copied, and then the pattern of the copy is call unified
(\secref{CALL-UNIFICATION}) with the expression to be matched.
If unification fails, the definition does not match.  If
unification succeeds, variables bound to null values are given their
default values, evaluated variable values are evaluated,
and then the matching process continues by searching for
definitions that match the guards.

An expression definition is an expression graph which may have variables
as well as graph nodes.   When an expression definition is copied,
the copy has its own variables that are distinct from the variables in
the original expression definition or in any other expression definition copy.

\subsection{The Evaluation Algorithm}
\label{EVALUATION-ALGORITHM}

The \key{evaluation algorithm} inputs an expression to be evaluated
and a context.  The context (\secref{CONTEXTS}) provides a list of expression
definitions that may match the expression.

An expression to be evaluated may contain variables that are assigned
values during matching.  The result of evaluation is both a value for
the expression and an assignment of values for these variables.

More than one definition may match an expression.
More than one definition may match a guard of a definition,
and different guard definitions may lead to different completions of
values of variables in the expression being evaluated.
In matching a definition, more than
one argument order assignment (\pagref{ARGUMENT-ORDER-ASSIGNMENT})
may allow the definition to be matched.  So expression
evaluation is a search process to find a choice of expression definitions
and argument order assignments which leads to success, and more than
one choice may succeed.

Note that the guards of an expression are always matched from left to
right, so order of guard matching is not a choice.  Similarly guard
block evaluation order is fixed, left to right, depth first, so this
is not a choice.  Lastly evaluation of evaluated variable values and
of guard blocks are required to have no side effects, so these can be
undone trivially when part of the search fails.

Evaluation may be done in any of the following modes:

\begin{list}{}{}

\item[\ttkey{first-value}]~\\
The first definitions in contexts and first
argument order assignments tried that lead to successful matches
are the only ones
used.  Definitions are tried in the order they are given in the contexts
used in evaluation.
The order in which argument order assignments are tried is implementation
dependent.

\item[\ttkey{all-values}]~\\
All possible choices are tried and the
successful results are collected in a set of results.  Each result
in this set consists of a value for the expression being evaluated
and values for each null node in that expression.

\item[\ttkey{consistent-values}]~\\
All possible choices are tried and the
successful results are collected in a set of values.  Then these results
are tested to see if they are pairwise equal.
All the values of the expression
being evaluated must be equal, and all the values of each null node
contained in the expression must be equal.  If all values of the expression
or of a null node are equal, one of these values is returned as the value
of the expression or null node.  If some of the values are unequal, an
error value giving the context of the evaluation and the unequal values
is returned as the value of the expression or null node.

\item[\ttkey{consistent-reordering}]~\\
Definitions are 
tried in the order they are given in the contexts used in evaluation,
and the first definitions that match are used.  However, for each definition
all possible argument order assignments are tried.  The results are collected
in a set of results that is tested for pairwise equality.
All the values of the expression
being evaluated must be equal, and all the values of each null node
contained in the expression must be equal.  If all values of the expression
or of a null node are equal, one of these values is returned as the value
of the expression or null node.  If some of the values are unequal, an
error value giving the context of the evaluation and the unequal values
is returned as the value of the expression or null node.
\end{list}

If the expression match search process yields no matches at all,
the expression is given the value `\verb|false|', and variables in the
expression are not changed.

In the following description of algorithms we use a `\key{choose operation}'
as if there were an oracle that allowed us to make appropriate
choices.  In actuality a search process is used, as indicated above.

Evaluating an expression uses subalgorithms for matching an expression with
a definition and for evaluating a block.

The following subalgorithm is used to match an expression to be matched
with an expression definition.

\begin{enumerate}

\item
Make a copy of the expression definition.  Variables in this copy are
distinct from other variables of the same name in memory.

\item
If there are reorderable arguments in the expression definition pattern,
choose an argument order.

\item

Call unify (\secref{CALL-UNIFICATION})
the pattern (\secref{EXPRESSION-DEFINITION})
from the definition copy with the expression to be matched,
using the chosen argument order if any.
If the unification fails, the definition does not match.  If the
unification succeeds, it provides values for the variables
in the pattern and for null nodes in the matched expression.

\item
For any pattern variable bound to a null node, rebind the variable
to its default value, if the variable has a default value.

\item\label{PROTECTED-VARIABLE}
For any pattern variable whose name does \underline{not} begin
with `\ttkey{\#}', evaluate the value of that variable to obtain
a new variable value.  Then simultaneously replace all the evaluated
variable values by their new values.  Each replacement is done by
forwarding a variable value graph node to the new value graph node.

These variable value evaluations are not permitted to have
visible side effects (\secref{VISIBLE-SIDE-EFFECTS}).

\end{enumerate}

The subalgorithm for evaluating a block is given in \secref{BLOCK-EVALUATION}.

Evaluating an expression is as follows:

\begin{enumerate}

\item
Choose and expression definition in the appropriate context that
matches the expression to be evaluated, and match the definition
with the expression.

Note the evaluated variable value evaluations of
\ref{PROTECTED-VARIABLE} above are done before guard expression matching
is done.

\item
For each guard of the expression definition, from left to right,
choose an expression definition
in the appropriate context that matches the guard, and match the definition
with the guard.

\item
For each guard that has a block, evaluate the block, working in left
to right depth first order of guards.  If a guard block evaluates to
something other
than `\verb|true|', declare the choices made so far to be a failure,
and continue the search.  These guard block evaluations are not
permitted to have visible side effects (\secref{VISIBLE-SIDE-EFFECTS}).

\item
If the definition matched to the expression to be evaluated has no block,
the value of the expression is `\verb|true|'.
If it has a block, the block is evaluated to produce a value and possibly
side effects (\secref{BLOCK-EVALUATION}).

\end{enumerate}

It is always an error if a null node is to be evaluated.  In particular,
the value of an evaluated variable just before the value is to be evaluated
must not be a null node.

\subsection{Contexts}
\label{CONTEXTS}

An expression is evaluated in a context.  The context is searched
for an expression definition whose pattern matches the expression being
evaluated, and that definition is then used to evaluate the expression.

A \key{context} is either a list or a set of expression definitions and
other contexts.  Context elements that are expression definitions are
matched to the expression being evaluated.  Context elements that are
themselves contexts are searched recursively.

\ikey{Context lists}{list!context} are searched in order.
\ikey{Context sets}{set!context} are searched exhaustively,
and it is always an error if matching definitions are found in more than
one element of a set.

An expression definition is an object (\secref{OBJECTS})
of \ttkey{expression-definition}
type that consists of a pattern, a list of guards,
an optional block, and an optional context.  An
{\em EXPRESSION-DEFINITION} expression (\pagref{EXPRESSION-DEFINITION})
computes an expression definition that has no context.
A context can be added to the expression definition later by executing:

\begin{indpar}
\verb|set| {\em EXPRESSION-DEFINITION} \verb|context| {\em CONTEXT}
\end{indpar}

Once a context has been added to an expression definition, the context
cannot be changed.

A new expression definition can be made from an old one by
the expression:

\begin{indpar}
	\verb|an| \ttkey{expression-definition}
	      {\em EXPRESSION-DEFINITION}
	      {\em CONTEXT}
\end{indpar}

The new expression definition has a different context, given by
the second argument, than the first argument does.  The special
value \ttmkey{UNDEFINED}{argument of!an expression-definition@{\tt an
expression-definition}} can be given as the {\em CONTEXT} argument
to create a new expression definition whose pattern, guards, and block
are the same as those of {\em EXPRESSION-DEFINITION} argument
but whose context part is missing and can be set later.

There are two kinds of contexts: \mkey{immutable}{context} and
\mkey{mutable}{context}.
An immutable context cannot be modified.  A mutable context can have
its list (or set) modified.
Each kind can be either a set or a list.

A context can be created by:

\begin{indpar}
\verb|a| \ttkey{context}
    \begin{tabular}[t]{@{}l@{}}
    \verb|(| {\em CONTEXT-ELEMENT} \{ \verb|,| {\em CONTEXT-ELEMENT} \}
	\verb|)|
    \\
    \begin{tabular}[t]{@{}rl@{}}
    [ & \ttmkey{is list}{of context!of {\tt context}} {\em LIST} \\
    $|$ & \ttmkey{is mutable}{of context!of {\tt context}}
          {\em MUTABLE} \\
    $|$ & \ttmkey{with contexts missing}{of context!of {\tt context}}
           {\em CONTEXTS-MISSING} ]\opt
    \end{tabular}
    \end{tabular}
\end{indpar}

in which each {\em CONTEXT-ELEMENT} is either an expression definition or
a context, and {\em LIST}, {\em MUTABLE}, and {\em CONTEXTS-MISSING}
are either `{\tt false}' (the default) or `{\tt true}'.
If {\em CONTEXTS-MISSING} is {\tt false} (the default), any expression
definition {\em CONTEXT-ELEMENTS} that do not have their
contexts set will have them set equal to the context being created.

Thus given expression definitions that do not have their contexts set,
the default is to create an immutable context set whose expression definitions
have the new context and therefore can reference each other.  Blocks
containing {\em EXPRESSION-DEFINITIONs} perform exactly this kind of
context creation.

The {\em CONTEXT-ITEM} list of a context object is a list object
(\pagref{LIST}) which can be extracted from the context object by

\begin{indpar}
\verb|the| \ttmkey{list}{of context} \verb|of| {\em CONTEXT}
\end{indpar}

This list object is a list or set according to whether or not the
context is a list or set, and the list object is immutable or mutable
according to whether or not the context object is immutable or mutable.
If mutable, altering the list object will alter its containing context
object, and this is in fact the only way to mutate a mutable context.

The above expressions are defined by the
expression definitions (\secref{EXPRESSION-DEFINITION}):

\begin{indpar}
\begin{verbatim}
an expression-definition {
    on an expression-definition EXPRESSION-DEFINITION CONTEXT
       <-- expression-definition EXPRESSION-DEFINITION,
           context CONTEXT
    on set SELF context CONTEXT <-- context CONTEXT
}
a context {
    on a context CONTEXT-ELEMENT-LIST
       ?? is list ( LIST ~ false )
       ?? is mutable ( MUTABLE ~ false )
       ?? with context missing ( CONTEXT-MISSING ~ false )
       <-- list CONTEXT-ELEMENT-LIST of context-items
}
context-item X <-- expression-definition X
context-item X <-- context X
\end{verbatim}
\end{indpar}

\section{Blocks}
\label{BLOCKS}

A block is a set of variables, values for some of the variables, and
code for computing these values.

\subsection{Block Syntax}
\label{BLOCK-SYNTAX}

The code of a block has the following syntax:

\begin{indpar}
\key{block} ::= \verb|{| {\em group}
                         \{ {\em sequence-break} {\em group} \}\,$^\star$
			 \verb|}| \\[1ex]
\key{sequence-break} ::= \ttnbkey{---}\verb|-|$^\star$
	(1 word consisting of 3 or more \verb|-|'s) \\[1ex]
\key{group} ::= {\em declaration-group} $|$ {\em statement-group}
			 \\[1ex]
\key{declaration-group}\label{DECLARATION-GROUP} ::= {\em declaration}
    \{ \verb|;| {\em declaration} \}$^\star$ \\[1ex]
\key{statement-group} ::= {\em statement}
	\{ \verb|;| {\em statement} \}$^\star$ \\[1ex]
\key{declaration}
    \begin{tabular}[t]{rl}
    ::= & {\em expression-definition} \\
    $|$ & {\em method-definition} \\
    $|$ & {\em empty} \\
    \end{tabular} \\[1ex]
\key{expression-definition} ::= {\em EXPRESSION-DEFINITION} 
				(see \pagref{EXPRESSION-DEFINITION}) \\[1ex]
\key{method-definition} ::= \ttkey{on} {\em EXPRESSION-DEFINITION} \\[1ex]
\key{statement} ::= {\em qualified-statement} $|$ {\em empty} \\[1ex]
\key{qualified-statement}
    \begin{tabular}[t]{rl}
    ::= & {\em assignment-statement} \\
    $|$ & {\em unguarded-subblock} \\
    $|$ & {\em guarded-statement} \\
    $|$ & {\em statement-qualifier} {\em qualified-statement}
    \end{tabular} \\[1ex]
\key{statement-qualifier} ::= \ttkey{first}
			  $|$ \ttkey{always}
			  $|$ \ttkey{default}
			  \\[1ex]
\key{assignment-statement}
	\begin{tabular}[t]{rl}
	::= & {\em variable-assignment-statement} \\
	$|$ & {\em pattern-assignment-statement}
	\end{tabular} \\[1ex]
\key{variable-assignment-statement} ::=
	{\em output-variable} \ttkey{=} {\em right-side} \\[1ex]
\key{right-side} \
    \begin{tabular}[t]{rl}
    ::= & {\em right-side-expression} \\
    $|$ & {\em right-side-expression} \ttnbkey{=>} {\em output-variable}
		\{ \verb|,| {\em output-variable} \}\,$^\star$
    \end{tabular} \\[1ex]
\key{right-side-expression} ::= {\em EXPRESSION} \\[1ex]
\key{output-variable} ::= {\em variable-name} $|$ {\em next-variable} \\[1ex]
\key{input-variable} ::= {\em variable-name} $|$ {\em next-variable} \\[1ex]
\key{next-variable} ::= \ttkey{next} \verb|(| {\em variable-name} \verb|)|
		\\[1ex]
\key{variable-name} ::= {\em word} \\[1ex]
\key{pattern-assignment-statement} ::=
	{\em assignment-pattern} \verb|~=~|\index{~=~@{\tt \Tilde=\Tilde}}
	{\em right-side} \\[1ex]
\key{assignment-pattern} ::= {\em EXPRESSION} \\[1ex]
\key{unguarded-subblock} ::= \verb|{| {\em statement-group} \verb|}| \\[1ex]
\key{guarded-statement} ::=
      {\em if-statement} $|$ {\em when-statement} \\[1ex]
\key{if-statement} ::=
      \begin{tabular}[t]{l}
      \ttkey{if} {\em guard} {\em guarded-subblock} \\
      {\em else-if-continuation}\,$^\star$ \\
      {\em else-continuation-option}
      \end{tabular} \\[1ex]
\key{else-if-continuation} ::=
      \verb|;| \ttkey{else if} {\em guard} {\em guarded-subblock} \\[1ex]
\key{else-continuation-option} ::= {\em empty} $|$
      \verb|;| \ttkey{else} {\em guard} {\em guarded-subblock} \\[1ex]
\key{when-statement} ::=
      \ttkey{when} {\em guard} {\em guarded-subblock} \\[1ex]
\key{guard} ::= {\em right-side} \\[1ex]
\key{guarded-subblock} ::= \verb|{| {\em statement-group} \verb|}|
\end{indpar}

A block is parsed when the statement that contains it (typically
an {\em EXPRESSION-DEFINI\-TION}, \pagref{EXPRESSION-DEFINITION})
is parsed.  Because the \ttmkey{;}{statement separator} operator used
as a statement separator in a {\em block} is by default
{\tt definitional} (\pagref{DEFINITIONAL}), in addition to {\em statements}
a {\em block}
can contain definitions that control parsing but do not become part of the
parsed block.  Such definitions are omitted from the above syntax.

When the pattern and guard parts of an expression definition are parsed,
they are parsed together to create an expression graph, and
implicit conversion (\pagref{IMPLICIT-CONVERSION}) of variable names
is used to produce variables for that graph.
Any {\em block} part of the expression
definition is parsed separately to produce a separate expression graph that
has no expression graph variables (it does have variables in
a different sense: see \secref{BLOCK-VARIABLE-NAMES}).
Implicit conversion is not used for any part of {\em block} parsing,
except for {\em assignment-patterns}, {\em expression-definitions},
and {\em method-definitions}, each of which becomes a separate
expression graph with its own separate expression graph variables
[TBD: how is this represented and done?].

\subsection{Block Variable Names}
\label{BLOCK-VARIABLE-NAMES}

After parsing, the {\em variable-names} in the code of
a block are identified.  Each
{\em variable-name} is a subexpression consisting of a single
{\em word}, but not all such subexpressions are {\em variable-names}.
Some {\em variable-names} may be \mkey{inherited}{variable-name}
from a statement containing the block.
Some are {\em output-variables} in {\em assignment-statements}
or {\em guards}.
Some are expression graph variables of {\em assignment-patterns}.
All the {\em variable-names}
in the block are inherited or can be identified by looking at the left
sides of {\em assignment-statements} or at the {\em output-variables}
following \verb|=>| in {\em assignment-statements} or {\em guards}.

When identifying {\em variable-names} in a {\em block}, {\em statements} in a
{\em subblock} of the {\em block} are treated as if they
were in the {\em block} proper.  Thus variables named in the
{\em subblock} are variables named in the {\em block}.\footnote{
CASTLE does not have the notion of name space nesting, because the
{\tt \CurlyBra\CurlyKet} brackets that would
indicate nesting can be implied by the {\tt :} construction.}

If a {\em block} is part of an {\em EXPRESSION-DEFINITION}
(\pagref{EXPRESSION-DEFINITION}), the names of expression graph variables of
the {\em pattern} and {\em guard-list} expression tree
become {\em variable-names} inherited by the {\em block}.
Thus in

\begin{indpar}[1in]
\verb|sum from X through Y <-- integer X, integer Y| {\em block}
\end{indpar}

the variable names \verb|X| and \verb|Y| are inherited by the {\em block}.

An {\em assignment-pattern} is parsed to an expression graph with its
own expression graph variables.  These variables are called
\skey{pattern variable}s, and their names become
{\em variable-names} of the {\em block} containing the
{\em assignment-pattern}.  Thus in the statement

\begin{indpar}[1in]
\verb|X + Y ~=~ `5 + ( 7 * y )'|
\end{indpar}

the variable names \verb|X| and \verb|Y| are pattern variable names
that are {\em variable-names} of the {\em block} containing this
{\em pattern-assignment-statement}.

The variable named before the \verb|=| in a {\em variable-assignment-statement}
is an {\em output-variable}.
Variables named after \verb|=>| following an expression in
a {\em right-side} are also {\em output-variables}.  In the statements

\begin{indpar}[1in]\begin{verbatim}
when sort x to y => y:
    z = first 
\end{verbatim}\end{indpar}

\verb|y| and \verb|z| are {\em output-variables}.

From the point of view of block evaluation there is no distinction between
variable names beginning with \verb|#| and other variable names.  The
only distinction occurs in {\em EXPRESSION-DEFINITION} {\em patterns},
where the values obtained by call unification for input variables
whose names do not begin with \verb|#| are replaced by their evaluations
(\pagref{PROTECTED-VARIABLE}).

TBD: Arrays and array element names.

\subsection{Block Evaluation}
\label{BLOCK-EVALUATION}

\ikey{Blocks}{block!evaluation}
are divided into \ikey{groups}{group!evaluation} by \skey{sequence-break}s.
The {\em groups} are evaluated in order: each group being completely
evaluated before the next group is evaluated.  However,
evaluation within a \mkey{statement-group}{evaluation}
is driven by availability of variable values,
and not by the order of the {\em statements} in the group.

Each variable in a block can be assigned at most one value: it is
an error if the variable is assigned a value more than once during
a block evaluation, even if all the values assigned are the same.

The \skey{input-variable}s of a {\em right-side-expression} are all
variables in the expression that are not {\em output-variables} or
{\em pattern-variables} of
the {\em assignment-statement} or {\em guard} containing the expression.
Each {\em right-side-expression} in a {\em statement-group}
is evaluated only when all its input variables have values.
When the {\em right-side-expression} of an {\em assignment-statement}
is evaluated, the variables named on the left side of the statement and any
{\em output-variables} named after a \verb|=>| in the {\em right-side}
are given values.
When the {\em right-side-expression} of a {\em guard} is evaluated, any
{\em output-variables} named after a \verb|=>| in the {\em guard}
are given values.

None of the statements in an {\em if-statement}
{\em guarded-block} are
evaluated until the block's {\em guard} has been evaluated to true.
If the guard evaluates to false, no statement in the
{\em guarded-block} is ever evaluated.  An {\em else-if-continuation}
{\em guard} is not evaluated until all {\em guards}
in any preceding {\em if-statement}
or {\em else-if-continuations} in the same {\em guard-statement}
have been evaluated to false.  The {\em guarded-block} of an
{\em else-continuation} is evaluated if and only if
all {\em guards} in any preceding {\em if-statement}
or {\em else-if-continuation} in the same {\em guard-statement}
have been evaluated to false.

An example application of these rules is:

\begin{indpar}\begin{verbatim}
{
  z = y1
  z = y2
  if X > 5:
    y1 = 9
  else:
    y2 = 10
}
\end{verbatim}\end{indpar}

where \verb|X| is an inherited variable name.  If \verb|X > 5| is true,
the variable \verb|y1| is given the value \verb|9| and then
\verb|z| is given this value, while the variable \verb|y2|
is never given a value.  If \verb|X > 5| is false,
the variable \verb|y2|
is given the value \verb|10| and then \verb|z| is given this
value, while the variable \verb|y1| is never given a value.

A {\em when-statement} is just like an {\em if-statement} that has
no {\em else-if-continuation} or {\em else-continu\-a\-tion}.
[TBD: what about making a variable true if it has ANY value, for the
purposes of a {\em when-statement}?]

A {\em statement-group} terminates when all the
{\em right-side-expressions} in it have either been evaluated or
cannot be evaluated because of lack of an input variable value or
because of {\em guards}.
Once a {\em statement-group}
terminates, no part of the group can be evaluated, even if another group
later in the block defines that part's input variables.

However, group evaluation is additionally modified by {\em statement-qualifiers}
(\secref{DEFAULT-STATEMENTS}, \secref{ITERATION}).

The \ikey{declarations}{declaration!evaluation} of a
\mkey{declaration-group}{evaluation} are evaluated in order.  Evaluation of a
{\em declaration} just adds its definition to the current context.
The {\em declaration-group} terminates when its last {\em declaration}
has evaluated.  There are no {\em guards} or block variables in a declaration
group (the variables of a definition are not variables of the block).

\ikey{Empty-statements}{empty-statement!evaluation} and
\ikey{empty-declarations}{empty-declaration!evaluation} do nothing
when they evaluate.

The {\em groups} of a {\em block} are evaluated in order.  No part of
a {\em group}
can evaluate until all previous {\em groups} of the block have completely
finished evaluating.  Once a {\em group} starts to evaluate, no part of
a previous {\em group} can evaluate.

A {\em block} terminates when its last group terminates.

When a block terminates, the \mkey{value}{of block} of the block is the
value of its {\tt value} variable\index{value variable@{\tt value} variable},
if any.  Thus the block

\begin{center}
\verb|{ value = X + Y }|
\end{center}

which inherits the variables \verb|X| and \verb|Y| will return
the sum of its inherited variables as the value of the block.

If a block finishes without producing a value for a variable named
{\tt value}, the value of the block is \ttmkey{true}{block value}.

Block evaluation is additionally modified by {\em statement-qualifiers}
and {\em next-variables}
(\secref{DEFAULT-STATEMENTS} and \secref{ITERATION}).

\subsection{Default Statements}
\label{DEFAULT-STATEMENTS}

The \ttkey{default} {\em statement-qualifier} modifies group execution.
A statement qualified by {\tt default}
is called a \key{default statement}.  Default statements in a {\em group}
are initially inactive, meaning that they are treated as if they do not exist,

After the {\em group} without its default statements finishes executing,
any default statement in the {\em group} that has
\underline{no} output or pattern variable with a value
is made active.  All default statements that can be made active in this
way are made active at the same time.  Then the {\em group}, which now
consists of all non-default statements and all active default statements,
continues executing, until no more non-default or active default statement
can be executed.

Since all default statements that become active in a group become active
at the same time, it is possible for an error to occur if two such
statements assign values the same variable.

An example application of these rules is:

\begin{indpar}\begin{verbatim}
{
  if X > 5:
    value = `true'
  default value = `false'
}
\end{verbatim}\end{indpar}

where \verb|X| is an inherited variable name.  If \verb|X > 5| is true,
the value of the block is `{\tt true}' and the {\tt default}
{\em assignment-statement} remains inactive, but if \verb|X > 5| is false,
the {\tt default} {\em assignment-statement} becomes active and
the value of the block is `{\tt false}'.

\subsection{Iteration}
\label{ITERATION}

A block can \key{iterate}, meaning that it generates another block
that is the next block in a sequence of blocks.  A block
iterates if it does \underline{not} produce a value of a {\tt value}
variable and if it does produce a value for a {\em next-variable}.
The sequence of blocks are called the
\skey{iteration}s of the sequence.  Evaluation of a block can always
be thought of as producing a sequence of iterations, though this
sequence might include only one block which does not iterate.

A {\em next-variable} is named by a {\em variable-name} that is the
operand of a \ttkey{next} unary operator.  A {\em next-variable}
is effectively a new variable with a name derived from the
{\em variable-name}.  We will used the notation \verb|next(|$V$\verb|)|
to denote the {\em next-variable} made from the variable name $V$.
The value of \verb|next(|$V$\verb|)| at the end of execution of the
current block iteration becomes the value of $V$ at the beginning
of execution of the next block iteration.  In order for there to be
a next iteration, the current iteration must compute the value of
some {\em next-variable}, and the current iteration must not compute
the value of the {\tt value} variable.

{\em Next-variables} can be both output and input variables.
When used as input variables they are just like other input variable.
The {\tt next} operator can be applied to an expression that does not
consist solely of a {\em variable-name}.  When this is done, it is
as if the {\tt next} operator had instead been applied to every
{\em variable-name} in the expression.  Thus `\verb|next(x+y)|' is
the equivalent of `\verb|next(x) + next(y)|'.

If a default statement outputs a {\em next-variable}, the statement
cannot become active unless some other {\em next-variable} has already
been given a value.  Thus the decision to iterate cannot be made inside
a default statement.

A statement of the form

\begin{center}
\verb|default| \verb|next(|$V$\verb|)| = $V$
\end{center}

is implied in the last group of a block
for every inherited {\em variable-name} $V$ provided
no other default statement in the last group of the block
outputs \verb|next(|$V$\verb|)|.
Thus inherited variables are normally propagated unchanged from
one iteration to the next.

If a {\em next-variable} is given the value of
the expression `\ttkey{UNDEFINED}',\label{UNDEFINED}
the variable will become undefined
at the beginning of the next iteration.  Thus the statement

\begin{center}
\verb|default| \verb|next(|$V$\verb|) = UNDEFINED|
\end{center}

for an inherited {\em variable-name} $V$ will keep the inherited
variable from being propagated from one iteration to the next.
The expression `{\tt UNDEFINED}' cannot be used to set a
non-{\em next-variable}.

A \ttkey{first} qualified {\em statement} is only visible in the
first iteration of a block sequence.

An \ttkey{always} qualified {\em statement} is equivalent to the {\em statement}
qualified by {\tt first} plus additional {\em statements} of the form

\begin{center}
\verb|default| \verb|next(|$V$\verb|) = |$V$
\end{center}

for every {\em variable-name} $V$ that can be assigned by the
{\tt always} qualified {\em statement}.  Thus the
{\tt always} qualified {\em statement} will assign values on the first
iteration, and these values will then be propagated to subsequent iterations.


\section{Objects}
\label{OBJECTS}

An object is a typed block that can be used as a value.
A typed block, or object, has a type and inherits code from its type.

An \key{object} can be created by an {\em OBJECT} expression:


\begin{indpar}
\key{OBJECT} ::= \{ \ttkey{a} $|$ \ttkey{an} \} {\em type-name}
		      {\em block-option} \\[1ex]
\key{type-name} ::= {\em word}
\end{indpar}

The code in the {\em block} becomes a permanent part of the object.
The variable values defined by this code become \skey{component}s of the object.
These components can be retrieved by expressions of the form:

\begin{center}
\ttmkey{the}{the of@{\tt the} \ldots {\tt of}}
{\em variable-name}
\ttmkey{of}{the of@{\tt the} \ldots {\tt of}}
{\em object}
\end{center}

Objects are updated by adding code to them either permanently or temporarily.
Whenever code is added to an object, the code executes as much as it
can to define variable values that are then components of the object.
When the code can execute no further (\secref{BLOCK-EVALUATION},
\secref{DEFAULT-STATEMENTS}, \secref{ITERATION}), any
variables that do not have values become undefined components.  If some of
undefined components are given values later, any code that is a permanent
part of the object may restart and produce additional variable values that
define additional components.

Recall that the concept of being a variable of a block
of code is defined syntactically and independently of which variable values
the block actually computes (\secref{BLOCK-VARIABLE-NAMES}).
The components of an object are more precisely the syntactic variables
of the code added permanently to the object, whether or not these
variables have values defined by code added permanently or temporarily
to the object.  Variables of code added temporarily that are not
syntactically variables of code added permanently are
\underline{not} components of the object,
and are not visible outside the temporarily added code.

TBD: need a way to declare an object component without otherwise referencing
it in permanent code.

The permanent code of an object all belongs to the same group.  Blocks
of permanent code cannot have {\em sequence-breaks}, and therefore
have only one {\em group}.  Code that is added temporarily
to an object can have several groups, and the permanent code of the
object behaves as
if it were a separate group executed after the temporary code is executed.

A statement of the form:

\begin{indpar}
\ttkey{for every} {\em type-name} {\em block} 
\end{indpar}

adds the code in its block permanently to every object of the given type,
including both existing objects and objects that are
created in the future.  The code in the block is associated with the
type and is said to be `\skey{inherit}{ed}' by every object of that type.

A statement of the form:

\begin{indpar}
\ttkey{update} {\em OBJECT} {\em block} 
\end{indpar}\label{UPDATE}

where {\em OBJECT} evaluates to an object adds the code in the
{\em block} temporarily to the object.  The code is added and all
code in the object executes until it can do nothing more.  Then
the temporary code is removed from the object.

When code is added to an object and executes, the statement qualifier
{\tt default} acts when execution stops to enable execution of {\tt default}
statements, as per \secref{DEFAULT-STATEMENTS}.  Similarly
the {\tt next} operator can be used to create iterations of the
object.  Each iteration replaces the previous iteration of the object
wherever the object is referenced.  Thus if two variables equal
the object, and one is used to cause the object to iterate, both variable
values will become the new iterated object.

A statement of the form

\begin{center}
\verb|default| \verb|next(|$C$\verb|) = |$C$
\end{center}

is implied in the permanent code
for every component name $C$ of an object, provided
no other default statement in the permanent code
outputs \verb|next(|$C$\verb|)|.
Thus components are normally propagated unchanged from
one object iteration to the next.  A statement of the form

\begin{center}
\verb|default| \verb|next(|$C$\verb|) = UNDEFINED|
\end{center}

can be used to override this behavior to
make $C$ have no value at the beginning of the next object
iteration.

When an iteration of an object is created by temporary code, the
sequence of actions is:

\begin{center}
\begin{tabular}{lp{5.5in}}
(1) & Add the temporary code to the object. \\
(2) & Execute all object code until it terminates. \\
(3) & If any {\tt next} component values were defined by the
      execution in step (2), create
      the next iteration of the object, giving this
      iteration only the permanent code of the object. \\
(4) & In the next iteration of the object execute all
      code until it terminates.
\end{tabular}
\end{center}

Code can be temporarily added to an object by invoking methods.
A \key{method} is defined by a \key{method definition}
that is an expression definition which is part of the code of an object.
The method is callable from code inside or outside the object code block.
The syntax for a method definition is:

\begin{center}
\ttkey{on} {\em expression-definition}
\end{center}

When the method definition is called, the method code block
is added temporarily to the code that contained
the method definition.  The object whose code this is
may be referred to within its
code by the name \ttkey{SELF}, which may or may not also be an argument
of the method definition.  If it is an argument, the method definition
has an implicit guard that requires the {\tt SELF} argument value to be
equal to the object whose code contains the method definition.

If there is no {\tt SELF} argument, a new object
is created when the method is called, and the permanent code plus
method code is executed for that object.  The permanent code must
contain the method definition in this case.  Such a method is
called a {\tt constructor}, and the object created is said to be
constructed by the method execution.  Constructor executions usually return
the object they construct, but this is not required by the language.
Constructors usually
have patterns that begin with `\{ \verb|a| $|$ \verb|an| \} {\em type-name}',
where {\em type-name} names the type of object they construct, but
this is not required by the language either.

TBD: protection; protection zones.


\section{Side Effects}
\label{SIDE-EFFECTS}

A \key{side effect} is an action that changes memory, inputs information from
the outside world, or outputs information to the outside world.
When an expression is evaluated, it may or may not have side effects.

The order in which side effects are executed is determined by
{\em sequence-breaks} that divide a {\em block} into {\em groups}
further (\secref{BLOCK-EVALUATION}).  A programmer typically writes code
so there is at most one side effect per {\em group}, in order to
ensure side effects execute in the desired order.

TBD: could this last rule be enforced.

The \key{side effect mode} controls the execution of side effects.
It has three settings: {\tt execute}, {\tt delay}, and {\tt error}.
In \ttkey{execute mode} a side effect simply executes.  In
\ttkey{error mode} an attempt to execute a side effect raises an error,
and the side effect is not executed.

In \ttkey{delay mode} input and memory change side effects execute,
but put operations on an {\tt undo} list that can undo their effects,
while output side effects do not execute, but are instead put on a
{\tt todo} list.

There are two lists maintained that permit side effects to be delayed
or undone.  The \ttmkey{todo}{list} list is a list of delayed output
actions that have been delayed.  The \ttmkey{undo}{list} list is
a list of input and memory change actions that can be undone.
The position of these lists can be recorded and an undo
operation can be performed that backs up to previously recorded positions
by deleting actions form the end of the {\tt todo} list and undoing
actions on the end of the {\tt undo} list.

To control the side effect mode there is a \key{side effect mode stack}.
This contains items each of which contains a side effect mode and
positions in the {\tt todo} and {\tt undo} stacks.  The side effect mode
of the top item on the side effect mode stack is the effective side
effect mode for current execution.
Whenever an item is pushed to the side effect mode stack, the current
positions of the {\tt todo} and {\tt undo} lists are recorded in the
item.

The following statements operate on the side effect mode stack:

\begin{list}{}{}
\item[\ttkey{begin executing side effects}]~~~Push a new item with side effect
execute mode onto the side effect mode stack.  Before the push the
stack must be empty or the top item in the stack must have execute or
error mode.

\item[\ttkey{end executing side effects}]~~~Pop the top item from
the side effect mode stack.  This top item must have
execute mode.

\item[\ttkey{begin forbidding side effects}]~~~Push a new item with side effect
error mode onto the side effect mode stack.  Before the push the
stack must be empty or the top item in the stack must have execute or
error mode.

\item[\ttkey{end forbidding side effects}]~~~Pop the top item from the
side effect mode stack.  This top item must have
error mode.

\item[\ttkey{delay side effects}]~~~Push a new item with side effect
delay mode onto the side effect mode stack.

\item[\ttkey{commit side effects}]~~~Pop the top item from the
side effect mode stack.  This top item must have
delay mode.  It the resulting stack has a new top item that is not
delay mode, discard the contents of the {\tt undo} stack, and execute
and then discard the contents of the {\tt todo} stack.

\item[\ttkey{abort side effects}]~~~Pop the item from the
the side effect mode stack.  This top item must have
delay mode.  Consider the {\tt todo} and {\tt undo} list positions
of the new item at the top of the stack, or take these positions to be
the beginning of the lists if the stack has become empty.  Remove
elements from ends of the lists until these considered positions become
the current list positions.  When removing an element from the end of the
{\tt undo} list, perform the undo action specified by the element.

\end{list}

\section{Debugging}

Design:

Debugging is based on the notion that almost all
CASTLE programs will run quickly.
Input checkpointing is used to record all inputs to a computation
so the computation can be deterministically rerun.  Detailed
traces can be generated which explain for each value how it was generated.
Values have a sequence number that identifies the point in the execution
where they were generated.  It is therefore possible to ask for a detailed
accounting of how any value was generated, provided the run is short enough
to be repeated once or a few times so the computer can turn the history
tracing on appropriately.

\section{Design Notes}

These are some detailed design rules to be incorporated in the language
definition later.

\begin{list}{}{}

\item
{\bf Blank Algebraic Operators}.
The blank, or missing operator, denotes \verb|*| when it precedes a word,
as in \verb|5x| being equivalent to \verb|5*x|.  When it is between a
preceding integer and a following ratio, it adds the ratio to the integer,
as in \verb|41 1/3|.

\end{list}

\section{To Do}

Why doesn't `\verb|define qualifier xxx|' mean define expressions equal
to `\verb|qualifier xxx|'.

\verb|missing(#X)| is true if \verb|#X| is a null node.
\verb|integer(#X)| is true if \verb|#X| is an integer.

Qualifier shortcuts should be conditioned on the first words of
the expression being qualified.  E.g., if these words are
`\verb|define operator|' the shortcut `\verb|left => |{\tt with
associativity [left]}' would be defined.

Expressions to be evaluated can have sets of possible values.

Imaginary Units\label{IMAGINARY-UNITS}

Visible Side Effects\label{VISIBLE-SIDE-EFFECTS}

List Objects\label{LIST}

Qualifier Definition\label{QUALIFIER-DEFINITION}

Qualifier Shortcut Definition\label{QUALIFIER-SHORTCUT-DEFINITION}

Automatic Optional Marks\label{AUTOMATIC-OPTIONAL-MARKS}

\bibliographystyle{plain}
\bibliography{castle}

\printindex

\end{document}

