%  RECKON (Personal Reckoning Langauge)
%
% File:         reckon.tex
% Author:       Bob Walton (walton@deas.harvard.edu)
% Date:		See \date below.

% Possible alternative names:
%
%	RECKON	Personal Reckoning Language
%	CASTLE  Calculation and Simulation Total Language Environment
%	MFL	Multi-Facetted Language
%	ROPE	Really Omni Programming Environment
%	RIPE	Robert's Information Processing Environment
%	AGILE	Another Goofy Information Language and Environment
%	OMNI	Omni-Programming Language
%	OPL	Omni-Programming Language
%	OPE	Omni-Programming Environment
%	APE	A Programming Environment
%	RUG	Really Useful Gadget
%	RUCL	Really Useful Computer Language
  
\documentclass[12pt]{article}

\usepackage[T1]{fontenc}
\usepackage{times}
\usepackage{makeidx}
\usepackage{pictex}
\usepackage{etoolbox}

\makeindex

\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}
\raggedbottom

\setlength{\unitlength}{1in}

\pagestyle{headings}
\setlength{\parindent}{0.0in}
\setlength{\parskip}{1ex}

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}
\newcommand{\subsubsubsection}[1]{\paragraph[#1]{#1.}}
\newcommand{\subsubsubsubsection}[1]{\subparagraph[#1]{#1.}}

% Begin \tableofcontents surgery.

\newcount\AtCatcode
\AtCatcode=\catcode`@
\catcode `@=11	% @ is now a letter

\renewcommand{\contentsname}{}
\renewcommand\l@section{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\l@table{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\tableofcontents{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{0.8in}%
	      \setlength{\rightmargin}{0.8in}}%
    \item\@starttoc{toc}%
    \end{list}}
\renewcommand\listoftables{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}%
	      }%
    \item\@starttoc{lot}%
    \end{list}}

\catcode `@=\AtCatcode	% @ is now restored

% End \tableofcontents surgery.

\newcommand{\CN}[2]%	Change Notice.
    {\hspace*{0in}\marginpar{\sloppy \raggedright \it \footnotesize
     $^{\mbox{#1}}$#2}}
    % Change notice.

\newcommand{\TT}[1]{{\tt \bfseries #1}}

\newcommand{\key}[1]{{\bf \em #1}\index{#1}}
\newcommand{\lkey}[2]{{\bf \em #1 #2}\index{#1!#2}}
\newcommand{\mkey}[2]{{\bf \em #1}\index{#1!#2}}
\newcommand{\skey}[2]{{\bf \em #1#2}\index{#1}}
\newcommand{\smkey}[3]{{\bf \em #1#2}\index{#1!#3}}
\newcommand{\slkey}[3]{{\bf \em #1 #2#3}\index{#1!#2}}
\newcommand{\ikey}[2]{{\bf \em #1}\index{#2}}
\newcommand{\ttkey}[1]{\TT{#1}\index{#1@{\tt #1}}}
\newcommand{\ttlkey}[2]{\TT{#1 #2}\index{#1@{\tt #1}!#2@{\tt #2}}}
\newcommand{\ttmkey}[2]{\TT{#1}\index{#1@{\tt #1}!#2}}
\newcommand{\ttdkey}[1]{\TT{.#1}\index{#1@{\tt .#1}}}
\newcommand{\ttdmkey}[2]{\TT{.#1}\index{#1@{\tt .#1!#2}}}
\newcommand{\ttnbdkey}[1]{\TT{.#1}\index{#1@{\tt .#1}}}
\newcommand{\tttkey}[1]{\TT{<#1>}\index{#1@{\tt <#1>}}}
\newcommand{\tttmkey}[2]{\TT{<#1>}\index{#1@{\tt <#1>}!#2}}
\newcommand{\tttbkey}[1]{{\TT {<#1|}\ldots\TT{|#1>}}%
    \index{#1@\TT{<#1|}\ldots\TT{|#1>}}}
\newcommand{\tttbmkey}[2]{{\TT{<#1|}\ldots\TT{|#1>}}%
    \index{#1@\TT{<#1|}\ldots\TT{|#1>}!#2}}
\newcommand{\ttindex}[1]{\index{#1@{\tt #1}}}
\newcommand{\ttmindex}[2]{\index{#1@{\tt #1}!#2}}
\newcommand{\emkey}[1]{{\bf \em #1}\index{#1@{\em #1}}}
\newcommand{\emlkey}[2]{{\bf \em #1#2}\index{#1@{\em #1}!#2@{\em #2}}}
\newcommand{\emskey}[2]{{\bf \em #1#2}\index{#1@{\em #1}}}
\newcommand{\emikey}[2]{{\bf \em #1}\index{\em #2}}
\newcommand{\emindex}[1]{\index{#1@{\em #1}}}

\newcommand{\opt}{$^!$}

\newcommand{\itemref}[1]{\ref{#1}$\,^{p\,\pageref{#1}}$}
\newcommand{\secref}[1]{\ref{#1}$\,^{p\,\pageref{#1}}$}
\newcommand{\stepref}[1]{\ref{#1}\,$^{p\,\pageref{#1}}$}
\newcommand{\appref}[1]{\ref{#1}$\,^{p\,\pageref{#1}}$}
\newcommand{\figref}[1]{\ref{#1}$\,^{p\,\pageref{#1}}$}
\newcommand{\pagref}[1]{p\pageref{#1}}
\newcommand{\pagnote}[1]{$\,^{p\,\pageref{#1}}$}

\newcommand{\EOL}{\penalty \exhyphenpenalty}

\newcommand{\STAR}{{\Large $^\star$}}
\newcommand{\PLUS}[1][]{{$^{+#1}$}}
\newcommand{\QMARK}{{$^{\,\mbox{\footnotesize ?}}$}}
\newcommand{\OPEN}{{$\{$}}
\newcommand{\CLOSE}{{$\}$}}

\newcommand{\VSP}{\textvisiblespace}

\newlength{\figurewidth}
\setlength{\figurewidth}{\textwidth}
\addtolength{\figurewidth}{-0.40in}

\newsavebox{\figurebox}

\newenvironment{boxedfigure}[1][!btp]%
	{\begin{figure*}[#1]
	 \begin{lrbox}{\figurebox}
	 \begin{minipage}{\figurewidth}

	 \vspace*{1ex}}%
	{
	 \vspace*{1ex}

	 \end{minipage}
	 \end{lrbox}
	 \begin{center}
	 \fbox{\hspace*{0.1in}\usebox{\figurebox}\hspace*{0.1in}}
	 \end{center}
	 \end{figure*}}

\newenvironment{indpar}[1][0.3in]%
	{\begin{list}{}%
		     {\setlength{\itemsep}{0in}%
		      \setlength{\topsep}{0in}%
		      \setlength{\parsep}{1ex}%
		      \setlength{\labelwidth}{#1}%
		      \setlength{\leftmargin}{#1}%
		      \addtolength{\leftmargin}{\labelsep}}%
	 \item}%
	{\end{list}}

\newenvironment{labpar}[2][0.3in]%
	{\begin{list}{}%
		     {\setlength{\itemsep}{0in}%
		      \setlength{\topsep}{0in}%
		      \setlength{\parsep}{1ex}%
		      \setlength{\labelwidth}{#1}%
		      \setlength{\leftmargin}{#1}%
		      \addtolength{\leftmargin}{\labelsep}}%
	 \item[#2]}%
	{\end{list}}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{lemma}[theorem]{Lemma}

\begin{document}
        
\title{Personal Reckoning Language\\[2ex]
       RECKON\\[2ex]
       (Draft 2a)}

\author{Robert L. Walton\thanks{Copyright 2016 Robert L. Walton.
Permission to copy this document verbatim is granted by the author
to the public.  This document was partly inspired
by teaching courses at Suffolk University, and by the work of Thomas
Cheatham and Stuart Shieber.}}

\date{May 6, 2016}

\maketitle

\newpage
\begin{center}
\large \bf Table of Contents
\end{center}

\bigskip

\tableofcontents 

\newpage

\section{Introduction}

This document describes the programming language RECKON.  RECKON,
for what its worth, stands for `Personal Reckoning Language',
which hints at its purpose.

RECKON is designed for naive programmers: that is, for people who may never
be able to program computers well.  It is a fairly simple language with
powerful data types that make it easier to write small programs
that do a variety of tasks a person might want to do.  Generally
the tasks fall into the categories of calculating things (taxes,
probabilities, statistics) or simulating things
(computer games, construction designs, mathematics demonstrations).
Included are:

\begin{center}
\begin{tabular}{l}
Calculations that might be done with a spreadsheet. \\
Drawing pictures. \\
Simulating popular board games and creating new ones. \\
Creating simple computer games, including dialog games. \\
Computing and analyzing documents. \\
Doing elementary algebra and calculus problems. \\
Doing matrix calculations. \\ 
Calculating basic probabilities and statistics. \\
Simulating two and three dimensional objects. \\
Simulating simple electrical, mechanical, chemical, and biological systems.\\
Solving problems in elementary logic. \\
\end{tabular}
\end{center}

There are many computer languages that have some powerful data type that adapts
them for a specific kind of computation.  RECKON tries to combine these.
Some previous computer languages that have influenced RECKON, and
the data types they particularly support, are:

\begin{center}
\begin{tabular}{l@{\hspace{0.5in}}l}
Various Spreadsheets		& Spreadsheets \\
Various Data Base Languages	& Data Bases \\
Various Script Languages	& Documents \\
MATLAB				& Matrices \\
Mathematica			& Mathematical Formulae \\
TCL				& Character Strings and Lists \\
Lisp				& Words and Phrases \\
PROLOG				& Logical Expressions \\
\end{tabular}
\end{center}

RECKON is \underline{not} designed to be a computer-efficient language.
It is designed to be person-efficient, and to do small calculations
rapidly enough with inexpensive modern computers.

\section{Remarks}

RECKON was created as an answer to the question: what programming language
should you teach beginning programming students most of whom do not have
the talent or will not develop the inclination
to become serious programmers?  The initial answer, that it does
not matter provided you implement some powerful types of data in the
language you choose, has a flaw.  The flaw is that without the right powerful
data types, the language will be useless to the students after the course
is over.  So what is needed is a programming language that will be useful
to students after a first course in programming, and the essence of
such a language is the integration within it of many powerful and useful
data types.

The basic principles of the RECKON design were developed
by the author while teaching the intended customers of
RECKON.\footnote{Specifically, while teaching CS121 at Suffolk University
using the C programming language.}
The language should have as few parts as possible, to cut down
on the amount of detail that must be remembered to use the language, but
conversely, there is no limit to the conceptual complexity of any well-used
part.\footnote{There was no problem teaching recursion, but it was better
not to teach many different looping constructs.}
The language should have powerful data types, well integrated into
the syntax of the language.  As much as possible, statement executions
in the language should have visible effect.

RECKON is also based on the `\key{Syntactic Hypothesis}', which is that
people reason syntactically and not in any other way, and therefore
syntax matters a lot.  In particular, different kinds of reasoning
require different syntactic support.

The current version of RECKON is not stable, because it has not been
implemented, and because, unlike most programming languages, RECKON
has lots of subtle important interactions between its various features.  The
hope is that after implementation and experimentation a stable sensible
version of RECKON, integrating all its data types, can be achieved.

\section{Overview}

RECKON has two major kinds of data: expressions and blocks.  Numbers are
the simplest expressions.  More complex expressions are math
expressions or document expressions.  A block is a set of variables
and pieces of code.  Each variable can have a value, which is an expression.
Each block has a unique indentifier, which by itself can be used as
an expression that names the block.
The code contains expressions that can be evaluated under appropriate
circumstances to produce values for variables.

In RECKON a `description' is a block that has an associated `type'.  For
example, there may be a description `george' with type `person'.  All
descriptions of the same type have the same code,
and many of the same variables,
but typically have different variable values.

You can use RECKON as a calculator by typing into it expressions to
be evaluated, assignments of values to variables, and definitions
of functions, predicates, and blocks.  Some examples involving numbers are:

\begin{indpar}\begin{verbatim}
> 9
9
> 9 + 8
17
> x = 9
9
> y = 9 + 8
17
> x + y
26
> f (b, c, x) = b * x + c
function (b, c, x) evaluates to (b * x + c)
> f (10, x, y)
179
\end{verbatim}\end{indpar}

Here the `\TT{>~}' at the beginning of some lines is the RECKON \key{prompt}
that tells you its OK to input an expression to be evaluated.
Except for this prompt, lines beginning with `\TT{> }' are input lines to
a RECKON interpreter, and other lines are output lines.

Note that in RECKON names must be separated by whitespace.  Thus
`\TT{b * x}' names three things: the variable `\TT{b}', the
operator `\TT{*}', and the variable `\TT{x}'.  In contrast,
`\TT{b*x}' would name one thing, a variable (with a strange name).
However parentheses such as `\TT{(}' and `\TT{)}' need not be
separated from anything else by whitespace, and separators such as
`\TT{,}' need not be separated by what is \underline{before} them
by whitespace.

At somewhat the opposite extreme from numbers are words, phrases, sentences,
and paragraphs.  You can calculate with these `\skey{document expression}s\,'.%
\footnote{In what follows,
if we followed LISP, each \TT{[]} would cancel one \TT{`~'},
so \TT{`{}`[g]'{}'} would evaluate to \TT{`[g]'}
and \TT{`{}`[[g]]'{}'} would evaluate to \TT{`hello'}.  But we do the
reverse of this, so in RECKON \TT{`{}`[g]'{}'} evaluates to \TT{`hello'}
and \TT{`{}`[[g]]'{}'} evaluates to \TT{`[g]'}.}

\begin{indpar}
\verb|> g = `hello'| \\
hello \\
\verb|> `[g] there'| \\
hello there \\
\verb|> z = `I thought he said `[g]'.'| \\
I thought he said `hello'. \\
\verb/> notice = `This document is meant to be read./ \\
\verb/+           Reading this document is good, but.../ \\
\verb/+           / \\
\verb/+           [z].'/ \\
This document is meant to be read.  Reading this document is good, but\ldots
\\[2ex]
I thought he said `hello'. \\
\verb|> `When you add [x] and [y] you get [x+y].'| \\
When you add 9 and 17 you get 26. \\
\verb|> `This is a paragraph.| \\
\verb|> | \\
\verb|> And a second paragraph.| \\
\verb|> With two sentences.'| \\
This is a paragraph. \\[2ex]
And a second paragraph. With two sentences.
\end{indpar}

Modern math computes with expressions, and not just numbers.
You can compute with \skey{math expression}s in RECKON.

\begin{indpar}
\verb/> f = {{ 10 x ^ 2 - 3.67 x - 0.04 }}/ \\
$10x^2-3.67x-0.04$ \\
\verb/> h = (- 0.96 + 0.67 x) in x/ \\
$-0.96+0.67x$ \\
\verb/> (f + h) in x/ \\
$10x^2-3x-1$ \\
\verb/> solve (f + h = 0) for x/ \\
$x = (-0.2, 0.5)$ \\
\verb/> (f + h) at (x = (3, 4, 5))/ \\
\verb/(78.95, 145.28, 231.61)/ \\
\verb/> g = {{ integral (x ^ 2 dx) }}/ \\
$\int x^2 dx$ \\
\verb/> simplify g/ \\
$\frac{1}{3} x^3$ \\
\verb/> v = g from (x = 1) to (x = 5)/ \\
\verb:41 1/3: \\
\verb/> out = `The value of {{[g] from (x = 1) to (x = 5)}}/ \\
\verb/>        is [v].'/ \\
The value of $\int_{x = 1}^{x = 5} x^2 dx$ is $41\frac{1}{3}$.
\end{indpar}

Matrices are another kind of data that you can compute
with:

\begin{indpar}
\verb/> V =# {| 1  2  3 |}/ \\
\verb/1 2 3/ \\
\verb/> M =#:/ \\
\verb/+     0  1   1/ \\
\verb/+    -1  1   0/ \\
\verb/+     1  0  -1/ \\
\verb/ 0  1   1/ \\
\verb/-1  1   0/ \\
\verb/ 1  0  -1/ \\
\verb/> V ^ T/ \\
\verb/1/ \\
\verb/2/ \\
\verb/3/ \\
\verb/> M * V ^ T/ \\
\verb/ 5/ \\
\verb/ 1/ \\
\verb/-2/
\end{indpar}

Another kind of datum you can compute with in RECKON is
the block.  A \key{block} contains a set of variables, each of which
can have a value which is either an expression or the identifier of a
block.  A block can also
have code, which contains expressions that are evaluated under appropriate
circumstances to produce values for the block's variables.

In RECKON a \key{description}
is a block that has an associated \key{type}.  For
example, there may be a description named `Jack' with type `person'.
All descriptions
of the same type have the same code, and many of the same variables,
but typically have different variable values.  For example:

\begin{indpar}
\verb|> a person:| \\
\verb|+     name = `Jack'| \\
\verb|+     weight = 123 lb| \\
\verb|+     height = 5 ft 9 in| \\
\verb|+     age = 23 yr 2 mo| \\
\begin{tabular}{|r|l|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf type} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000000 & person & Jack & \tt 123 lb & \tt 5 ft 9 in & \tt 23 yr 2 mo \\
\hline
\end{tabular} \\[0.5ex]
\verb|> a person:| \\
\verb|+     name = `Jill'| \\
\verb|+     weight = 110 lb| \\
\verb|+     height = 5 ft 7 in| \\
\verb|+     age = 21 yr 8 mo| \\
\begin{tabular}{|r|l|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf type} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000001 & person & Jill & \tt 110 lb & \tt 5 ft 7 in & \tt 21 yr 8 mo \\
\hline
\end{tabular} \\[0.5ex]
\verb|> all persons| \\
\begin{tabular}{|r|l|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf type} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000000 & person & Jack & \tt 123 lb & \tt 5 ft 9 in & \tt 23 yr 2 mo \\
\tt @1000001 & person & Jill & \tt 110 lb & \tt 5 ft 7 in & \tt 21 yr 8 mo \\
\hline
\end{tabular} \\[0.5ex]
\verb|> the person Jack| \\
\begin{tabular}{|r|l|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf type} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000000 & person & Jack & \tt 123 lb & \tt 5 ft 9 in & \tt 23 yr 2 mo \\
\hline
\end{tabular} \\[0.5ex]
\verb|> the person named Jack's height| \\
\verb|5 ft 9 in| \\
\verb|> the weight of the person named Jack| \\
\verb|123 lb| \\
\verb|> @1000001| \\
\begin{tabular}{|r|l|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf type} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000001 & person & Jill & \tt 110 lb & \tt 5 ft 7 in & \tt 21 yr 8 mo \\
\hline
\end{tabular} \\[0.5ex]
\verb|> the weight of @1000001| \\
\verb|110 lb|
\end{indpar}

It is possible to add code to a type such as `\TT{person}'.  This has
the affect of adding the code to all blocks that are descriptions of that type.
For example:

\begin{indpar}
\verb|> for every person:| \\
\verb|+     body mass index = 703.06958 * weight in lbs| \\
\verb|+                     / (height in inches)^2| \\
\verb|> all persons| \\
\begin{tabular}{@{}|r|l|l|r|r|r|r|@{}}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf type} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} &
\multicolumn{1}{|c|}{\bf \shortstack{body mass\\index}} \\
\hline
\tt @1000000 & person & Jack
	     & \tt 123 lb & \tt 5 ft 9 in & \tt 23 yr 2 mo & \tt 18.1637 \\
\tt @1000001 & person & Jill
	     & \tt 110 lb & \tt 5 ft 7 in & \tt 21 yr 8 mo & \tt 17.2282 \\
\hline
\end{tabular}
\end{indpar}

One can use definitions to define expressions that compute values:

\begin{indpar}
\verb|> sum from X through Y <-- integer X, integer Y:| \\
\verb|+     `Sum of integers from X through Y.'| \\
\verb|+     if ( X > Y ):| \\
\verb|+         value = 0| \\
\verb|+     else:| \\
\verb|+         value = X + sum (X+1) through Y| \\
\verb|> sum from 5 through 10| \\
\verb|45| \\
\verb|> all (sums from X through Y)| \\
\begin{tabular}{|r|r|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf parent} &
\multicolumn{1}{|c}{\bf X} &
\multicolumn{1}{|c}{\bf Y} &
\multicolumn{1}{|c|}{\bf value} \\
\hline
\tt @1000002 &       		& \tt 5	& \tt	10	& \tt 45 \\
\tt @1000003 & \tt @1000002	& \tt 6	& \tt	10	& \tt 40 \\
\tt @1000004 & \tt @1000003	& \tt 7	& \tt	10	& \tt 34 \\
\tt @1000005 & \tt @1000004	& \tt 8	& \tt	10	& \tt 27 \\
\tt @1000006 & \tt @1000005	& \tt 9	& \tt	10	& \tt 19 \\
\tt @1000007 & \tt @1000006	& \tt 10	& \tt	10	& \tt 10 \\
\tt @1000008 & \tt @1000007	& \tt 11	& \tt	10	& \tt 0 \\
\hline
\end{tabular} \\[0.5ex]
\verb|> sum from 1 through 2| \\
\verb|3| \\
\verb|> all (sums from X through Y)| \\
\begin{tabular}{|r|r|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf parent} &
\multicolumn{1}{|c}{\bf X} &
\multicolumn{1}{|c}{\bf Y} &
\multicolumn{1}{|c|}{\bf value} \\
\hline
\tt @1000002 &       		& \tt 5		& \tt	10	& \tt 45 \\
\tt @1000003 & \tt @1000002	& \tt 6		& \tt	10	& \tt 40 \\
\tt @1000004 & \tt @1000003	& \tt 7		& \tt	10	& \tt 34 \\
\tt @1000005 & \tt @1000004	& \tt 8		& \tt	10	& \tt 27 \\
\tt @1000006 & \tt @1000005	& \tt 9		& \tt	10	& \tt 19 \\
\tt @1000007 & \tt @1000006	& \tt 10	& \tt	10	& \tt 10 \\
\tt @1000008 & \tt @1000007	& \tt 11	& \tt	10	& \tt 0 \\
\tt @1000009 &       		& \tt 1		& \tt	2	& \tt 3 \\
\tt @1000010 & \tt @1000009	& \tt 2		& \tt	2	& \tt 2 \\
\tt @1000011 & \tt @1000010	& \tt 3		& \tt	2	& \tt 0 \\
\hline
\end{tabular}
\end{indpar}

Executions can be examined in detail, because
when an expression is computed, the block that computes it is remembered
for some time.  However, as memory is finite, eventually these
computations are forgotten as they can always be regenerated if
needed.

The sum above was computed by recursion: to compute the sum of 5 through 10
one adds 5 to the sum of 6 through 10.  One can also compute sums by
iteration.

\begin{indpar}
\verb|> sum from X through Y <-- integer X, integer Y:| \\
\verb|+     `Sum of integers from X through Y.'| \\
\verb|+     first sum = 0| \\
\verb|+     if ( X <= Y ):| \\
\verb|+         next sum = sum + X| \\
\verb|+         next X = X + 1| \\
\verb|+     else:| \\
\verb|+         value = sum| \\
\verb|> sum from 5 through 10| \\
\verb|45| \\
\verb|> all (sums from X through Y)| \\
\begin{tabular}{|r|r|r|r|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf previous} &
\multicolumn{1}{|c}{\bf next} &
\multicolumn{1}{|c}{\bf X} &
\multicolumn{1}{|c}{\bf Y} &
\multicolumn{1}{|c}{\bf sum} &
\multicolumn{1}{|c|}{\bf value} \\
\hline
\tt @1000012 &              & \tt @1000013
	     & \tt 5	& \tt 10   & \tt 0	& \\
\tt @1000013 & \tt @1000012 & \tt @1000014
	     & \tt 6	& \tt 10   & \tt 5	& \\
\tt @1000014 & \tt @1000013 & \tt @1000015
	     & \tt 7	& \tt 10   & \tt 11	& \\
\tt @1000015 & \tt @1000014 & \tt @1000016
	     & \tt 8	& \tt 10   & \tt 18	& \\
\tt @1000016 & \tt @1000015 & \tt @1000017
	     & \tt 9	& \tt 10   & \tt 26	& \\
\tt @1000017 & \tt @1000016 & \tt @1000018
	     & \tt 10	& \tt 10   & \tt 35	& \\
\tt @1000018 & \tt @1000017 &
	     & \tt 11	& \tt 10   & \tt 45	& \tt 45 \\
\hline
\end{tabular}
\end{indpar}

One can also iterate over data.

\begin{indpar}
\verb|> average weight of X <-- list X of persons:| \\
\verb|+     first count = 0| \\
\verb|+     first sum = 0| \\
\verb|+     if X = ():| \\
\verb|+         if count = 0:| \\
\verb|+             value = error `Cannot average 0 things.'| \\
\verb|+         else:| \\
\verb|+             value = sum / count| \\
\verb|+     else:| \\
\verb|+         next count = count + 1| \\
\verb|+         next sum = sum + the weight of (first X)| \\
\verb|+         next X = rest X| \\
\verb|> average weight of (all persons)| \\
\verb|116.5 lbs| \\
\verb|> z = 10 + average weight of (all persons named Bill)| \\
\verb|error `Cannot average 0 things.'| \\
\verb|      occurred during: average weight of| \\
\verb|                      (all persons named Bill)| \\
\verb|      occurred during: 10 + ditto| \\
\verb|      occurred during: z = ditto|
\end{indpar}

In case you wonder how some of the above works, here are some hints.

RECKON tends to ignore word endings: thus `\TT{person}' and
`\TT{persons}' are to RECKON the same word.
RECKON can even be told that `\TT{person}'
and `\TT{people}' are the same word.
On the other hand, `\TT{Jack's}' is treated an abbreviation
of two separate words `\TT{Jack}' and `\TT{'s}', where `\TT{'s}' is
a separate word by itself.

Expressions are just strings of words, numbers, and subexpressions.
Subexpressions must be parenthesized unless they
are delimited by operators.

Lists of values can be stored in \skey{list}s, which are computed by comma
separated lists in parentheses.  Thus

\begin{indpar}
\verb|> (the person named Jill, the person named Jack)| \\
\begin{tabular}{|r|l|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf type} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000001 & person & Jill & \tt 110 lb & \tt 5 ft 7 in & \tt 21 yr 8 mo \\
\tt @1000000 & person & Jack & \tt 123 lb & \tt 5 ft 9 in & \tt 23 yr 2 mo \\
\hline
\end{tabular} \\[0.5ex]
\verb|> (the person named Jack, the person named Jill)| \\
\begin{tabular}{|r|l|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf type} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000000 & person & Jack & \tt 123 lb & \tt 5 ft 9 in & \tt 23 yr 2 mo \\
\tt @1000001 & person & Jill & \tt 110 lb & \tt 5 ft 7 in & \tt 21 yr 8 mo \\
\hline
\end{tabular} \\[0.5ex]
\verb|> raw (all persons)| \\
\verb|(the person named Jack, the person named Jill)| \\
\verb|> really raw (all persons)| \\
\verb|(@1000000, @1000001)|
\end{indpar}

The `\TT{raw}' form of a value represents the value
as you could input it in a way that reveals its internal structure.  Thus
`\TT{raw(all~persons)}' denotes the list of all persons, and it is the list
structure that is revealed, not the structure of the elements of the list.

`\TT{the person named Jack}' is a printed representation of the
internal name of a description.  Such printed representations are chosen
automatically from the set of all possible representations, which
in this case include `\TT{the person weighing 123 lbs}',
`\TT{the person named Jack weighing 123 lbs}', and so forth.

The `\TT{really raw}' form of a value identifies descriptions by their IDs.

A single non-list value is equivalent to a list with one element.
Lists cannot have other lists as elements; instead attempts to
compute such lists are \key{flattened}:

\begin{indpar}
\verb|> x = (1,(2,3),4)| \\
\verb|(1,2,3,4)| \\
\verb|> first x| \\
\verb|1| \\
\verb|> rest x| \\
\verb|(2,3,4)| \\
\verb|> rest (rest x)| \\
\verb|(3,4)| \\
\verb|> rest (rest (rest x))| \\
\verb|4| \\
\verb|> rest 4| \\
\verb|()|
\end{indpar}

For this reason RECKON lists are sometimes called `\skey{flat list}s'.

RECKON has different kinds of quotes or brackets.  The brackets
\verb|{{|\ldots\verb|}}| and \verb|`|\ldots\verb|'|
turn
evaluation off, while \verb|[|\ldots\verb|]| turns evaluation on.
The brackets \verb|`|\ldots\verb|'| turn
recognition of operators (e.g., \verb|+| and \verb|=|) off, and turn
recognition of sentence and phrase terminators
(e.g., `\verb|.|' and `\verb|;|') on,
while \verb|[|\ldots\verb|]| and \verb|{{|\ldots\verb|}}|
turn recognition of operators on, and turn recognition of
sentence and phrase terminators off.

RECKON can store information as expressions.  For example:

\begin{indpar}
\verb|> (a person named `Jack') is husband of| \\
\verb|+     (a person named `Jill') <--| \\
\verb|> Y is wife of X <-- X is husband of Y|
\end{indpar}

Here `\verb|<--|' means `is asserted' or `is asserted if'.
All the assertions that have been made can be queried:

\begin{indpar}
\verb|> (a person named `Jill') is wife of| \\
\verb|+     (a person named `Jack') ?| \\
\verb|true| \\
\verb|> (a person named `Jack') is wife of| \\
\verb|+     (a person named `Jill') ?| \\
\verb|false| \\
\verb|> (a person named X) is wife of| \\
\verb|+     (a person named `Jack') ?| \\
\verb|X = `|Jill\verb|'| \\
\verb|> X is wife of (a person named `Jack') ?| \\
\verb|X = (a person named `Jill')| \\
\verb|> @1000001 is wife of (a person named `Jack') ?| \\
\verb|true| \\
\verb|> @1000001 = (a person named `Jill') ?| \\
\verb|true| \\
\verb|> @1000001 = (a person named `Jack') ?| \\
\verb|false|
\end{indpar}

RECKON supports pictorial data
that are expressions displayed as pictures:

\begin{indpar}
\verb/> x = {{circle 0.4}}/ \\[1ex]
\begin{picture}(0.4,0.4)
\put(0.2,0.2){\circle{0.4}}
\end{picture} \\
\verb/> y = {{rectangle (0.4,0.2)}}/ \\[1ex]
\begin{picture}(0.4,0.2)
\put(0,0){\framebox(0.4,0.2){}}
\end{picture} \\
\verb/> z = {{(circle 0.4) labeled `Jack'}}/ \\[1ex]
\begin{picture}(0.4,0.4)
\put(0.2,0.2){\circle{0.4}}
\put(0.0,0.0){\makebox(0.4,0.4){Jack}}
\end{picture} \\
\verb/> {{([x] right of [y]) above [z]}}/ \\[1ex]
\begin{picture}(0.8,0.8)
\put(0.6,0.6){\circle{0.4}}
\put(0.0,0.5){\framebox(0.4,0.2){}}
\put(0.4,0.2){\circle{0.4}}
\put(0.2,0.0){\makebox(0.4,0.4){Jack}}
\end{picture} \\
\verb/> {{row([x],[y],[z])}}/ \\[1ex]
\begin{picture}(1.4,0.4)
\put(0.2,0.2){\circle{0.4}}
\put(0.4,0.1){\framebox(0.4,0.2){}}
\put(1.0,0.2){\circle{0.4}}
\put(0.8,0.0){\makebox(0.4,0.4){Jack}}
\end{picture} \\
\verb/> p = {{column (row([x],[y],[z]), row([z],[y],[x]))}}/ \\[1ex]
\begin{picture}(1.4,0.8)
\put(0.2,0.6){\circle{0.4}}
\put(0.4,0.5){\framebox(0.4,0.2){}}
\put(1.0,0.6){\circle{0.4}}
\put(0.8,0.4){\makebox(0.4,0.4){Jack}}
\put(1.0,0.2){\circle{0.4}}
\put(0.4,0.1){\framebox(0.4,0.2){}}
\put(0.2,0.2){\circle{0.4}}
\put(0.0,0.0){\makebox(0.4,0.4){Jack}}
\end{picture} \\
\verb/> raw x/ \\
\verb/{{circle 0.4}}/ \\
\verb/> raw p/ \\
\verb/{{column (row (circle 0.4,/ \\
\verb/               rectangle (0.4,0.2),/ \\
\verb/               (circle 0.4) labeled `Jack'),/ \\
\verb/          row ((circle 0.4) labeled `Jack',/ \\
\verb/               rectangle (0.4,0.2),/ \\
\verb/               circle 0.4))}}/
\end{indpar}

You can also change how an expression is displayed.

\begin{indpar}
\newlength{\ovalraise}
\setlength{\ovalraise}{-0.1in}
\addtolength{\ovalraise}{0.8ex}
\verb/> display ( P ) <-- person ( P ) has name ( X ):/ \\
\verb/+     value = {{oval (0.4,0.2) labeled [X]}}/ \\
\verb/> (a person named `Jack')/ \\
\begin{picture}(0.4,0.2)
\put(0.2,0.1){\oval(0.4,0.2)}
\put(0.0,0.0){\makebox(0.4,0.2){Jack}}
\end{picture} \\
\verb/> ` [a person named `Jill'] is wife of/ \\
\verb/+   [a person named `Jack'] '/ \\
\verb/`/
\raisebox{\ovalraise}{\begin{picture}(0.4,0.2)
\put(0.2,0.1){\oval(0.4,0.2)}
\put(0.0,0.0){\makebox(0.4,0.2){Jill}}
\end{picture}}
{is wife of}
\raisebox{\ovalraise}{\begin{picture}(0.4,0.2)
\put(0.2,0.1){\oval(0.4,0.2)}
\put(0.0,0.0){\makebox(0.4,0.2){Jack}}
\end{picture}}
\verb/'/
\end{indpar}

Displays can be used to make demonstrations:

\begin{indpar}
\verb|> for every demo:| \\
\verb|+     on a demo with angle X:| \\
\verb|+         angle = X| \\
\verb|> x = a demo with angle 30 degrees| \\
\begin{tabular}{|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf type} &
\multicolumn{1}{|c|}{\bf angle} \\
\hline
\tt @1000043 & demo & 30 degrees \\
\hline
\end{tabular} \\[0.5ex]
\verb|> for every demo:| \\
\verb|+     on update THIS to X:|\\
\verb|+         next angle = X| \\
\verb|+     on increment THIS by X:| \\
\verb|+         next angle = angle + X| \\
\verb|> update x to 40 degrees| \\
\begin{tabular}{|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf type} &
\multicolumn{1}{|c|}{\bf angle} \\
\hline
\tt @1000044 & demo & 40 degrees \\
\hline
\end{tabular} \\[0.5ex]
\verb|> increment x by 5 degrees| \\
\begin{tabular}{|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf type} &
\multicolumn{1}{|c|}{\bf angle} \\
\hline
\tt @1000045 & demo & 45 degrees \\
\hline
\end{tabular} \\[0.5ex]
\verb/> display ( D ) <-- demo ( D ) with angle ( X ):/ \\
\verb/+     c = {{circle 1.0 dotted center (0.0,0.0)}}/ \\
\verb/+     x axis = {{arrow from (-0.75,0.0) to (0.75,0.0)}}/ \\
\verb/+     y axis = {{arrow from (0.0,-0.75) to (0.0,0.75)}}/ \\
\verb/+     line = {{line from (0.0,0.0)/ \\
\verb/+                   to [(0.5*cos X, 0.5*sin X)]}}/ \\
\verb/+     arc = {{arc arrow from (0.3,0.0)/ \\
\verb/+                       to [(0.3*cos X, 0.3*sin X)]}}/ \\
\verb/+     theta = {{Greek th}}/ \\
\verb/+     value = {{label (/ \\
\verb/+                `Depiction of Angle [theta]=[X]',/ \\
\verb/+                overlap (/ \\
\verb/+                  [c],/ \\
\verb/+                  [x axis] labeled `X Axis',/ \\
\verb/+                  [y axis] labeled `Y Axis',/ \\
\verb/+                  [line],/ \\
\verb/+                  [arc] labeled `[theta]' ) ) }}/ \\
\verb/> show x/ \\
See `Depiction of Angle $\theta=45^\circ$' \\
\verb|> increment x by -15 degrees| \\
See `Depiction of Angle $\theta=30^\circ$'
\end{indpar} 

\begin{center}
\newcommand{\anglestuff}{
    \put(1.0,0.95){\qbezier[40](0.5,0.0)(0.46,0.46)(0.0,0.5)}
    \put(1.0,0.95){\qbezier[40](0.0,0.5)(-0.46,0.46)(-0.5,0.0)}
    \put(1.0,0.95){\qbezier[40](-0.5,0.0)(-0.46,-0.46)(0.0,-0.5)}
    \put(1.0,0.95){\qbezier[40](0.0,-0.5)(0.46,-0.46)(0.5,0.0)}
    \put(1.0,0.2){\vector(0,1){1.5}}
    \put(0.0,1.7){\makebox(2.0,0.2){Y Axis}}
    \put(0.25,0.95){\vector(1,0){1.5}}
    \put(1.80,0.85){\makebox(0.7,0.2)[l]{X Axis}}
}
\begin{picture}(5.5,1.9)
\put(0,0){
    \anglestuff
    \put(1.0,0.95){\qbezier[1000](0,0)(0.1767765,0.1767765)(0.353553,0.353553)}
    \put(1.0,0.95){
	\qbezier[250](0.3,0.0)(0.3,0.124264)(0.212132,0.212132)
	\put(0.212132,0.212132){\vector(-1,1){0.00}}
	\put(0.31,0.1){$\theta$}}
    \put(0.0,0.0){\makebox(2.0,0.2){Depiction of Angle $\theta=45^\circ$}}
}
\put(3.0,0){
    \anglestuff
    \put(1.0,0.95){\qbezier[1000](0,0)(0.2165065,0.125)(0.433013,0.25)}
    \put(1.0,0.95){
	\qbezier[250](0.3,0.0)(0.32,0.0745584)(0.2598078,0.15)
	\put(0.2598078,0.15){\vector(-1,1){0.00}}
	\put(0.33,0.05){$\theta$}}
    \put(0.0,0.0){\makebox(2.0,0.2){Depiction of Angle $\theta=30^\circ$}}
}
\end{picture}

\end{center}

In this example we first define a `constructor'
of the form `\TT{a demo with angle X}' to make new \TT{demo} descriptions,
and then we define two `methods', namely `\TT{update THIS to X}' and
`\TT{in\-cre\-ment THIS by X}', to change a \TT{demo} description.  Changing
a \TT{demo} description is like iterating a loop to make a new description.

Next we define how to display a \TT{demo} description.  Then we use the
`\TT{show x}' command
to cause the \TT{demo} description value of \TT{x}
to be displayed in a separate window.
Every time this \TT{demo} description
changes, the window is updated, and every time the description
is to be printed,
`See `Depiction of Angle $\theta=\ldots^\circ$'\,'
is printed instead, where `Depiction \ldots' is the \TT{label} part of
the display.


TBD: example of a simple game.

The rest of this document is a reference manual for RECKON.

\begin{boxedfigure}

\begin{verbatim}
for every board:
    on a board of dimension S:
        `Make a board of size SxS.'
        size = S
        `Allowed vessels have lengths 2 (destroyer),
         3 (cruiser), 5 (battleship).  vessels(L) is
         number of length L.'
        array vessels of size 5
              with initial element 0
        `maximum vessels(L) is maximum number of vessels of
         length L.'
        array maximum vessels of size 5
              with initial element 0
        maximum vessels(2) = 5
        maximum vessels(3) = 2
        maximum vessels(5) = 1
        `state(I,J) is `none', `miss', or `hit' iff shell
         has not struck square (I,J), struck square (I,J)
         but that square had no ship, or struck square (
         ,J) and hit a ship at that square.'
        array hit of size (S,S) with initial element `none'
        `vessel(I,J) is the vessel at (I,J)'
        array vessel of size (S,S)
              with initial element `none'
\end{verbatim}

\caption{Code for the Battleship Game, Part I}
\label{CODE-FOR-BATTLESHIP-1}
\end{boxedfigure}


\begin{boxedfigure}

\begin{verbatim}
direction vector of D:
    `given a direction N, NE, E, SE, S, SW, W, NW,
     return a vector with unit components in the
     given direction.'
    if D == `N':
        value = (1,0)
    else if D == `NE':
        value = (1,1)
    else if D == `E':
        value = (1,0)
    else if D == `SE':
        value = (1,-1)
    else if D == `S':
        value = (0,-1)
    else if D == `SW':
        value = (-1,-1)
    else if D == `W':
        value = (-1,0)
    else if D == `NW':
        value = (-1,1)
\end{verbatim}

\caption{Code for the Battleship Game, Part II}
\label{CODE-FOR-BATTLESHIP-2}
\end{boxedfigure}

\begin{boxedfigure}

\begin{verbatim}
for every vessel:
    on a vessel of length L with direction D from (I,J) on B:
        `make a vessel of length L positioned in direction D
         from origin (I,J) on boards B; directions are N,
         NE, E, SE, S, SW, W, NW'
        length = L
        direction = D
        origin = (I,J)
        vector = direction vector of D
        destination = L * vector + origin
        board = B
        conflict =:
            first p = origin
            first k = 0
            next k = k + 1
            next p = p + vector
            TBD
        if L < 2 or L > 5:
            value = error `bad length [L]'
        else if maximum vessels(L) of B >= vessels(L) of B:
            value = error `two many vessels of length [L]
                           on board [B]'
        else:
            vessels(L) of B += 1
\end{verbatim}

\caption{Code for the Battleship Game, Part III}
\label{CODE-FOR-BATTLESHIP-3}
\end{boxedfigure}

\newpage

\section{Lexemes}

Input text is a sequence of characters.  This is scanned from
left to right and top to bottom to produce a sequence of lexemes,
which include words, marks, separators, numerics, and quoted strings.

For example, the input
\begin{center}
\begin{tabular}{l}
\verb|x = 7ft 1_3/4 in;| \\
\verb|y = `This is (we think) a sentence.'|
\end{tabular}
\end{center}
contains in order the following lexemes:
\begin{center}
\begin{tabular}{ll@{\hspace{1in}}ll}
\tt x		& word 		& \tt y & word \\
\tt =		& mark		& \tt ` & (leading) separator \\
\tt 7ft		& numeric with embedded unit	& \tt This & word \\
\tt 1\_3/4	& numeric	& \tt is & word \\
\tt in		& unit		& \tt ( & (strict) separator \\
\tt ;		& (trailing) separator	& \tt we & word \\
		& 		& \tt think & word \\
		& 		& \tt ) & (strict) separator \\
		& 		& \tt a & word \\
		& 		& \tt sentence & word \\
		& 		& \tt . & (trailing) separator \\
		& 		& \tt ' & (trailing) separator \\
\end{tabular}
\end{center}

\ikey{Lexemes}{lexeme} are defined more specifically as follows:

\begin{indpar}
\emkey{lexeme}
	::= {\em middle-lexeme}
	$|$ {\em separator}
	$|$ {\em quoted-string}
	$|$ {\em comment}
\label{LEXEME}
\\[2ex]
\emkey{strict-separator} :::= \TT{(} $|$ \TT{)} $|$
				 \TT{[} $|$ \TT{]} $|$
				 \{ $|$ \} $|$
				 \TT{|}\PLUS{}
\\[0.5ex]
\emkey{strict-separator-character} :::= \TT{(} $|$ \TT{)} $|$
                                           \TT{[} $|$ \TT{]} $|$
				           \{ $|$ \} $|$
				           \TT{|}
\\[1ex]
\emkey{quoted-string}
    :::= \TT{"} {\em character-representative}\STAR{} \TT{"}
\\[0.5ex]
\emkey{character-representative}
    \begin{tabular}[t]{rl}
    :::= & {\em graphic-character} other than \TT{"} \\
    $|$  & {\em single-space-character} \\
    $|$  & {\em special-character-representative} \\
    \end{tabular}
\\[0.5ex]
\emkey{graphic-character} :::= character that prints some mark
\\[1ex]
\emkey{lexical-item} :::= {\em lexical-item-character}\PLUS{}
                       not beginning with \TT{//}
\\[0.5ex]
\emkey{lexical-item-character} :::= {\em graphic-character}
	other than {\em strict-separator-character} or \TT{"}

\emkey{lexical-item} :::= {\em leading-separator}\STAR{}
			  {\em middle-lexeme}\QMARK{}
                          {\em trailing-separator}\STAR{}
\\[0.5ex]
\emkey{middle-lexeme} :::=
    \begin{tabular}[t]{l}
    {\em lexical-item} \\
    not beginning with a {\em leading-separator} \\
    or ending with a {\em trailing-separator} \\
    \end{tabular}
\\[0.5ex]
\emkey{leading-separator} :::= \TT{`}
\\[0.5ex]
\emkey{trailing-separator} :::= \TT{'} $|$
				   \TT{!}\PLUS{} $|$
				   \TT{?}\PLUS{} $|$
				   \TT{.}\PLUS{} $|$
				   \TT{:}\PLUS{} $|$
				   \TT{;} $|$
				   \TT{,}
\\[0.5ex]
\emkey{separator}
    \begin{tabular}[t]{@{}rl}
    ::= & {\em strict-separator} \\
    $|$ & {\em leading-separator} \\
    $|$ & {\em trailing-separator}
    \end{tabular}
\\[1ex]
\emkey{comment} :::=
    \TT{//} {\em comment-character}\STAR{}
\\[1ex]
\emkey{comment-character} :::= {\em graphic-character}
                           $|$ {\em horizontal-space-character}
\label{COMMENT}

\end{indpar}

Lexemes may be separated by \key{white-space}, which
is a sequence of white-space characters (single space, horizontal tab, form
feed, etc.), but is not itself a lexeme.

\begin{indpar}
\emkey{white-space} :::= {\em white-space-character}\PLUS{} \\[1ex]
\emkey{white-space-character}
    \begin{tabular}[t]{rl}
    :::= & {\em horizontal-space-character} \\
    $|$ & {\em vertical-space-character}
    \end{tabular}
    \\[1ex]
\emkey{horizontal-space-character} :::=
    \key{single-space-character} $|$ \key{horizontal-tab-character} \\[1ex]
\emkey{vertical-space-character}
    \begin{tabular}[t]{rl}
    :::= & \key{line-feed-character} \\
    $|$ & \key{vertical-tab-character} \\
    $|$ & \key{form-feed-character} \\
    \end{tabular}
\end{indpar}

The character set is UTF-8 encoded UNICODE.

The symbol `\ttmkey{:::=}{in syntax equation}' is used in syntax equations
that define lexemes or parts of lexemes whose syntactic elements are
character sequences that must \underline{not} be separated by {\em white-space}.
The symbol `\ttmkey{::=}{in syntax equation}'
is used in syntax equations that define sequences of lexemes that may
and sometimes must be separated by \emkey{white-space}.
{\em Comments} are treated as lexemes, but are discarded before the
lexeme stream is transmitted to the parser.

Non-{\em white-space} control characters are ignored, as if they
did not exist, except that a warning message may be issued.  However
no warning is issued for \emskey{carriage-return-character}s that are next to
a {\em vertical-space-character}.

The tabs stops used by the \emkey{horizontal-tab-character} are set every
8 columns.

Every \emkey{vertical-space-character} causes the current position to
return to the beginning of a new line.
\emikey{Horizontal-space-characters}{horizontal-space-character}
before a {\em vertical-space-character}
are ignored, as if they did not exist.
Warning messages are issued for \emskey{form-feed-character}s
and \emskey{vertical-tab-character}s
that occur when the column position is not at the beginning of a line.

The definition of a \emkey{middle-lexeme} is unusual: it is what is left over
after removing \emkey{leading-separators} and \emkey{trailing-separators}
from a \emkey{lexical-item}.  The lexical scan first scans a
{\em lexical-item}, and then removes
{\em leading-separators} and {\em trailing-separators} from it.
Also {\em trailing-separators} are removed
from the end of a {\em lexical-item} by a right-to-left scan, and not
the usual left-to-right scan which is used for everything else.
Thus the {\em lexical-item} `\TT{`4,987,{},::'}' yields the
{\em leading-separator} `\TT{`}', the {\em middle-lexeme} `\TT{4,987}',
and the four {\em trailing-separators} `\TT{,}' `\TT{,}', `\TT{::}', and
`\TT{'}'.

{\em Middle-lexemes}, {\em separators}, and {\em quoted-strings} can represent 
\skey{symbol}s\label{SYMBOL} that store character strings.
The character strings represented by
{\em middle-lexemes} and {\em separators}
are exactly the character strings of these lexemes.
Some {\em middle-lexemes} can alternatively represent numbers.

The string of characters represented by a
\emkey{quoted-string}\label{QUOTED-STRING}
is recognized by
a left-to-right scan in which each {\em character-representative}
is translated into one UNICODE character.
Most characters
simply translate to themselves, but {\em special-character-representatives}
are sequences of characters that represent just one UNICODE character.
The beginning and ending quotes (\TT{"}) are \underline{not}
included in the represented character string.

Figure \itemref{SPECIAL-CHARACTER-REPRESENTATIVES} defines
{\em special-character-representatives}.  Mnemonics are given
for ASCII control characters and the \TT{"} character.
For other characters, any hexadecimal number in
\TT{<~>} brackets that begins with a decimal digit is interpreted as
representing the UNICODE character whose character code is the given
hexadecimal number.  Thus that \TT{<FF>} represents the ASCII form feed,
while \TT{<0FF>} represents the UNICODE \"y character which has character
code FF in hexadecimal.

\emikey{Middle-lexemes}{middle-lexeme} are further classified as
follows:

\begin{indpar}
\emkey{middle-lexeme} ::= {\em word} $|$ {\em numeric} $|$ {\em mark}
\\[1ex]
\emkey{word} ::=
    \begin{tabular}[t]{l}
    {\em middle-lexeme} that \\
    \begin{tabular}[t]{rll}
        & (1) & contains a letter \\
    and & (2) & does not contain any \TT{\#} \\
    and & (3) & does not have any digit before its first letter \\
    and & (4) & does not have any digit adjacent to a character \\
        &     & that is neither a letter nor a digit \\
    \end{tabular}
    \end{tabular}
\\[1ex]
\emkey{numeric} ::=
    \begin{tabular}[t]{l}
    {\em middle-lexeme} that \\
    \begin{tabular}[t]{rll}
        & (1) & contains a digit or both a \TT{\#} and a letter \\
    and & (2) & is not a {\em word} \\
    \end{tabular}
    \end{tabular}
\\[1ex]
\emkey{mark} ::= {\em middle-lexeme} that is not a {\em word} or {\em numeric}
\end{indpar}

There are many special kinds of {\em numerics}:
\begin{indpar}
    \begin{tabular}[t]{l@{~~~~~}lll}
          & Section & Examples \\[1ex]
      {\em natural-numeric}
    & \itemref{NATURAL-NUMERIC}
    & \TT{43} 
    & \TT{9,587} \\
      {\em integral-numeric}
    & \itemref{INTEGRAL-NUMERIC}
    & \TT{+43} 
    & \TT{-9,587} \\
      {\em fractional-numeric}
    & \itemref{FRACTIONAL-NUMERIC}
    & \TT{4/3}
    & \TT{-1\_1/3} \\
      {\em scientific-numeric}
    & \itemref{SCIENTIFIC-NUMERIC}
    & \TT{4.3}
    & \TT{-0.0098} \\
      {\em date}
    & \itemref{DATE}
    & \TT{4may2003}
    & \TT{May-03} \\
      {\em time-interval}
    & \itemref{TIME-INTERVAL}
    & \TT{4:30}
    & \TT{4:30:23.78} \\
      {\em time}
    & \itemref{TIME}
    & \TT{4:30pm}
    & \TT{20may05:12:30pm-EDT} \\
      {\em radix-numeric}
    & \itemref{RADIX-NUMERIC}
    & \TT{x\#4b3e\#}
    & \TT{b\#1.00110101001\#e+3}
    \end{tabular}
\end{indpar}

Some other kinds of special {\em middle-lexemes} are:
\begin{indpar}
    \begin{tabular}[t]{l@{~~~~~}lll}
          & Section & Examples \\[1ex]
      {\em natural-numeric}
      {\em unit}
    & \itemref{UNITS}
    & \TT{mi}
    & \TT{mi/hr} \\
      {\em format}
    & \itemref{FORMATS}
    & \TT{/.1/}
    & \TT{/10.1c/} \\
    \end{tabular}
\end{indpar}

Non-{\em numerics} can be used to form names of variables,
constants, and functions:
which are called `\skey{defined names}'\label{DEFINED-NAME}:

\begin{indpar}
\emkey{name} ::=
    \{ {\em word} $|$ {\em quoted-mark} $|$ {\em quoted-separator} \}\PLUS{}
\\[1ex]
\emkey{quoted-mark} :::= \TT{"} {\em mark} \TT{"} \\
\emkey{quoted-separator} :::= \TT{"} {\em separator} \TT{"}
\end{indpar}

Note that digits can appear adjacent to leters in a name, but not
elsewhere.

If a name is to be used as a constant it must be \TT{`~'} quoted.

Some examples are:

\begin{indpar}\begin{verbatim}
"+" = 5
X = "+" + 1
Y15 = `X + 3' 
Z0 = `X'
T = `"A line.<LF>"'
\end{verbatim}\end{indpar}

These statements define
a variable named \TT{"+"} with value \TT{5}, a variable
name \TT{X} with value \TT{6}, and
a variable named \TT{Y15} with value the text \TT{X + 3},
i.e., the vector whose 3 elements are the symbols
\TT{X}, \TT{+}, and \TT{3}.  \TT{Z0} is a variable whose
value is a single symbol whose character string contains
the single character \TT{X}.
\TT{T} is a variable whose value is the single symbol
whose character string is that of the {\em quoted-string} \TT{"A line.<LF>"}.

Some {\em names} have builtin definitions, such as the
words `\TT{ft}' and `\TT{inch}' which in some contexts denote the
units `foot' and `inch' (see Section~\itemref{UNITS}),
and `\TT{PI}' which in some contexts denotes the mathematical
constant $\pi$ (see Section~\itemref{BUILTIN-CONSTANTS}).

Special lexemes are described in the following sections.  Some of these
represent numbers.  When translated into internal computer form,
which is IEEE double precision floating point,
integers in the range
\begin{center}
$-9,007,199,254,740,992~~~~~..~~~~~+9,007,199,254,740,992$
\end{center}
are exactly represented, and numbers with absolute values in the range
\begin{center}
$2.2250738585072014\times 10^{-308}~~~~~..~~~~~1.7976931348623157\times
                                                               10^{+308}$
\end{center}
are represented with a relative error of
$2^{-53} \approx 1.110223\times 10^{-16}$,
or $15.95$ decimal digits precision.  Numbers with absolute value less than
$2.2250738585072014\times 10^{-308}$ are represented as zero.



\begin{boxedfigure}[!t]

\begin{center}
\begin{tabular}{lp{2in}}
\tttkey{NUL} & nul \\
\tttkey{SOH} & start of heading \\
\tttkey{STX} & start of text \\
\tttkey{ETX} & end of text \\
\tttkey{EOT} & end of transmission \\
\tttkey{ENQ} & enquiry \\
\tttkey{ACK} & acknowledge \\
\tttkey{BEL} & bell \\
\tttkey{BS}  & backspace \\
\tttkey{HT}  & horizontal tab \\
\tttkey{LF}  & line feed \\
\tttkey{VT}  & vertical tab \\
\tttkey{FF}  & form feed \\
\tttkey{CR}  & carriage ret \\
\tttkey{SO}  & shift out \\
\tttkey{SI}  & shift in \\
\tttkey{DLE} & data link escape
\\[1ex]
\tttkey{NL}  & new line (equals \TT{<LF>}) \\
\end{tabular}
\begin{tabular}{lp{2in}}
\tttkey{DC1} & device control 1 \\
\tttkey{DC2} & device control 2 \\
\tttkey{DC3} & device control 3 \\
\tttkey{DC4} & device control 4 \\
\tttkey{NAK} & negative ack. \\
\tttkey{SYN} & synchronous idle \\
\tttkey{ETB} & end of transmission block \\
\tttkey{CAN} & cancel \\
\tttkey{EM}  & end of medium \\
\tttkey{SUB} & substitute \\
\tttkey{ESC} & escape \\
\tttkey{FS}  & file separator \\
\tttkey{GS}  & group separator \\
\tttkey{RS}  & record separator \\
\tttkey{US}  & unit separator \\
\tttkey{SP}  & single space \\
\tttkey{DEL} & delete
\\[1ex]
\tttkey{Q}  & double quote (\TT{"}) \\
\end{tabular}
\\[1ex]
{\em special-character-representative}
    \begin{tabular}[t]{@{}rl}
    :::= & one of the above \\
     $|$ & \TT{<} {\em decimal-digit} {\em hexadecimal-digit}\STAR{} \TT{>}
    \end{tabular}
\end{center}

\caption{Special Character Representatives}
\label{SPECIAL-CHARACTER-REPRESENTATIVES}
\end{boxedfigure}


\subsection{Integral Numerics}
\label{INTEGRAL-NUMERIC}

A \emkey{natural-numeric} is a {\em numeric} with contains only digits
and commas.  An \emkey{integral-numeric} is a {\em natural-numeric}
optionally preceeded by a {\em sign}:

\begin{indpar}
\emkey{natural-numeric} :::= {\em digit}\PLUS{}
	$|$ {\em digit}\QMARK{} {\em digit}\QMARK{} {\em digit}
	    \{ \TT{,} {\em digit} {\em digit} {\em digit} \}\PLUS{}
\label{NATURAL-NUMERIC}
\\[1ex]
\emkey{integral-numeric} :::= {\em sign}\QMARK{} {\em natural-numeric}
\\[1ex]
\emkey{sign} ::= \TT{+} $|$ \TT{-}
\end{indpar}

Note that commas, if present, must appear every 3 digits.

\subsection{Fractional Numerics}
\label{FRACTIONAL-NUMERIC}

A \emkey{fractional-numeric} is an {\em integral-numeric}
followed by either a single \TT{/} and one or more {\em digits},
or by a \TT{\_}, one or more {\em digits}, a \TT{/}, and one or
more {\em digits}:

\begin{indpar}
\emkey{fractional-numeric}
    \begin{tabular}[t]{rl}
    :::= & {\em integral-numeric} \TT{/} {\em digit}\PLUS{} \\
     $|$ & {\em integral-numeric}
           \TT{\_} {\em digit}\PLUS{} \TT{/} {\em digit}\PLUS{}
    \end{tabular}
\end{indpar}

Some examples are:
\begin{center}
\tt
1/3 ~~~~~~ +48/97 ~~~~~~ 42\_3/8 ~~~~~~ -10\_7/10
\end{center}
Here `\TT{\_}' denotes `and', as in \TT{10} and \TT{7/10}'ths,
so the last example equals \TT{-10.7}.

Internally a fraction is stored as an IEEE double precision floating
point number.  If an internally stored number can print as a fraction
with a small denominator more accurately than it can be printed with
some given number of decimal places, it may in some contexts be
printed as a fraction.  Thus in these contexts a number input as
\TT{1/3} will print as \TT{1/3} and not as \TT{0.333333}.

The fraction \TT{0/0} denotes the IEEE \key{NaN} value, which
stands of `Not a Number'.  The fraction \TT{$N$/0} for $N>0$
denotes \TT{+Inf}, or plus infinity, while \TT{-$N$/0} denotes
\TT{-Inf}, or minus infinity.

\subsection{Scientific Numeric}
\label{SCIENTIFIC-NUMERIC}

A \emkey{scientific-numeric} is a {\em numeric} consisting
of an {\em integral-numeric} optionally followed by a {\em fractional-part}
which is optionally followed by an {\em exponent-part}:

\begin{indpar}
\emkey{scientific-numeric} ::= {\em integer-numeric}
			       {\em fractional-part}\QMARK{}
			       {\em exponent-part}\QMARK{}
\\[1ex]
\emkey{fractional-part} :::= \TT{.} {\em digit}\PLUS{}
	$|$ \TT{.} \{ {\em digit} {\em digit} {\em digit} \TT{,} \}\PLUS{}
	    {\em digit} {\em digit}\QMARK{} {\em digit}\QMARK{}
\\[1ex]
\emkey{exponent-part} ::= {\em exponent-indicator} {\em sign}\QMARK{}
                          {\em digit}\PLUS{}
\\[1ex]
\emkey{exponent-indicator} ::= \TT{e} $|$ \TT{E}
\end{indpar}

{\em Commas} must be every three {\em digits} from the end of
a {\em integral-numeric} or the beginning of a {\em fractional-part}.
If the {\em scientific-numeric} contains a decimal point, it must
be preceeded by a digit (write \TT{0.5} and not \TT{.5}).
An {\em exponent} shifts the decimal point (including the implied
decimal point at the end of the {\em scientific-numeric} that has
no decimal point); a positive exponent shifts right and a negative
exponent shifts left.
There may be at most one point.
Commas may be used before the point without being used after the
point, and vice versa.
Exponents cannot contain commas.

Some examples are:

\begin{indpar}[0.1in]
\tt
\begin{tabular}{l@{~~~}l@{~~~}l@{~~~}l}
123e0		& 123e-2	& 123e-321	& 1,234e9 \\
123E0		& 123E-2	& 123E-321	& 0.123,456e-3	\\
.123e3	& .123e+1
				& 0.123,456e-3 & 1,234.567890e6 \\
\end{tabular}
\end{indpar}

\subsection{Radix Numerics}
\label{RADIX-NUMERIC}

A \emkey{radix-numeric} is the same as a {\em scientific-numeric},
except that it is prefaced (after any {\em sign}) by a
{\em radix-indicator}, the (non-exponent) digits are surrounded by
`\TT{\#}'s, and the
permissible {\em digits} and comma spacings depend upon the radix indicator:

\begin{indpar}
\emkey{radix-numeric} ::= \\
\hspace*{0.2in}
    {\em sign}\QMARK{} {\em radix-indicator} \TT{\#}
    {\em radix-natural-part}
    {\em radix-fractional-part}\QMARK{}
    \TT{\#}
    {\em exponent-part}\QMARK{}
\\[1ex]
\emkey{sign} ::= \TT{+} $|$ \TT{-}
\\[1ex]
\emkey{radix-indicator} ::= \TT{B} $|$ \TT{b} $|$
                            \TT{O} $|$ \TT{o} $|$
			    \TT{D} $|$ \TT{d} $|$
			    \TT{X} $|$ \TT{x}
\\[1ex]
\emkey{radix-natural-part} :::= {\em radix-digit}\PLUS{}
	    \{ \TT{,} {\em radix-digit}\PLUS{} \}\STAR{} ~~~ [see text]
\\[1ex]
\emkey{radix-fractional-part} :::= \TT{.} {\em radix-digit}\PLUS{}
	    \{ \TT{,} {\em radix-digit}\PLUS{} \}\STAR{} ~~~ [see text]
\\[1ex]
\emkey{exponent-part} ::= {\em exponent-indicator} {\em sign}\QMARK{}
                          {\em digit}\PLUS{} \\[1ex] 
\emkey{exponent-indicator} ::= \TT{e} $|$ \TT{E}
\end{indpar}

The {\em radix-indicators} have the following denotations:

\begin{center}
\begin{tabular}{clll}
\bf Radix Indicator
	& \bf Meaning	& \bf Digits 		& \bf Comma Positions
\\[1ex]
\TT{B} or \TT{b}
        & binary	& \TT{0}, \TT{1}	& every 2, 3, 4, or 5 digits \\
\TT{O} or \TT{o}
        & octal		& \TT{0}, \TT{1}, \TT{2}, \TT{3},
			  \TT{4}, \TT{5}, \TT{6}, \TT{7}
			  			& every 2, 3, or 4 digits \\
\TT{D} or \TT{d}
        & decimal	& \TT{0}, \TT{1}, \TT{2}, \TT{3},
			  \TT{4}, \TT{5}, \TT{6}, \TT{7}
			  \TT{8}, \TT{9}	& every 3 digits \\
\TT{X} or \TT{x}
        & hexa-decimal	& \TT{0}, \TT{1}, \TT{2}, \TT{3},
			  \TT{4}, \TT{5}, \TT{6}, \TT{7}
			  \TT{8}, \TT{9},	& every 2 or 4 digits \\
	&		& \TT{A}, \TT{B}, \TT{C}, \TT{D},
			  \TT{E}, \TT{F}, \\
	&		& \TT{a}, \TT{b}, \TT{c}, \TT{d},
			  \TT{e}, \TT{f} \\
\end{tabular}
\end{center}

Only certain {\em radix-digits} are permitted: e.g., the digit \TT{2}
is not allowed in \TT{B\#\ldots\#} and the digit \TT{E} is not allowed
with \TT{D\#\ldots\#}.  Only certain comma spacings are permitted, and comma
spacing must be consistent.  Thus \TT{x\#A,C9,BD,8F\#} is permitted but
\TT{x\#A,C9B,D8F\#} is not (3-spacing not allowed for hexa-decimal),
and \TT{x\#A,C9,BD8F\#} is not permitted (2-spacing combined with
4-spacing is not consistent).
There may be at most one decimal point.
Commas may be used before the point without being used after the
point, and vice versa, but if used in both places, the comma spacing
must be the same.

Some example {\em radix-numbers} are:

\begin{indpar}[0.1in]
\tt
\begin{tabular}{@{}l@{~~}l@{~~}l@{~~}l@{}}
b\#10110100\#	& o\#7534201\#   & d\#9758\#	& x\#E8A932B\# \\
b\#1011.0100\#	& o\#75.34201\#  & d\#97.58\#	& x\#E8,A9.32B\# \\
b\#101101\#E2	& o\#0.7753\#    & d\#97.58\#e5	& X\#0.fe8a\#e-4 \\
B\#10,1101\#E+2	& O\#2,3456\#E-3 & D\#0.123,5\#	& X\#E8A.7CCD,83\# \\
B\#101,101\#e2	& O\#0.2345,6\#  & D\#0.123,5\#	& X\#E8A,932B.7C\# \\
\end{tabular}
\end{indpar}

Just as for {\em scientific-numbers}\pagnote{SCIENTIFIC-NUMERIC}
the {\em exponent-part} shifts the decimal point right (if +) or left (if -)
by some number of digits (in the given radix).  The {\em digits}
in the {\em exponent-part} are always decimal.


\subsection{Dates}
\label{DATES}

A \key{date} is lexeme that denotes an integer
which gives the \key{Julian Day Number} of the day times
the number of seconds in one day ($60*60*24=86,400$).\footnote{
On days in which there are leap seconds, the last second of the
day is either double-length or zero-length, following the Network
Time Protocol (NTP).}
The Julian Day Number system assigns day \TT{0} to the day starting
at noon GMT on January 1, 4713 BC, in the Gregorian Calendar extended
backwards, and counts days forward and backward
from this day.\footnote{Julian Day Numbers are used for dates in astronomy.}
Note that in this system days start at noon, and not at midnight.

A variety of different date formats may be used:

\begin{indpar}
\emkey{date} \begin{tabular}[t]{rl}
	     :::= & {\em weekday-modifier}\QMARK{}
	           {\em date-numeric} {\em era}\QMARK{} \\
	     $|$ & {\em weekday-modifier}\QMARK{} {\em day} {\em month-name}
	           {\em year-name} {\em era}\QMARK{} \\
	     $|$ & \{ {\em weekday-modifier} $|$ TT{\#} \} {\em month-name}
	           {\em year-name} {\em era}\QMARK{} \\
	     $|$ & {\em short-year-name}
	     \end{tabular}
\label{DATE}
\\[1ex]
\emkey{weekday-modifier} :::=  {\em weekday} \TT{\#}
\\[1ex]
\emkey{weekday}
    \begin{tabular}[t]{rl}
    :::= & \TT{Mon} $|$ \TT{Monday} \\
    $|$ & \TT{Tue} $|$ \TT{Tues} $|$ \TT{Tuesday} \\
    $|$ & \TT{Wed} $|$ \TT{Wednesday} \\
    $|$ & \TT{Thu} $|$ \TT{Thur} $|$ \TT{Thursday} \\
    $|$ & \TT{Fri} $|$ \TT{Friday} \\
    $|$ & \TT{Sat} $|$ \TT{Satday} \\
    $|$ & \TT{Sun} $|$ \TT{Sunday} \\
    \end{tabular}
\\[1ex]
\emkey{date-numeric} :::= {\em month}\TT{/}{\em day}\TT{/}{\em year}
\\[1ex]
\emkey{month} :::=  {\em digit}\PLUS{}
\\[1ex]
\emkey{day} :::=  {\em digit}\PLUS{}
\\[1ex]
\emkey{year} :::= {\em digit} {\em digit}\PLUS{}
\\[1ex]
\emkey{month-name}
    \begin{tabular}[t]{rl}
    ::= & \TT{jan} $|$ \TT{Jan} $|$ \TT{January} \\
    $|$ & \TT{feb} $|$ \TT{Feb} $|$ \TT{February} \\
    $|$ & \TT{mar} $|$ \TT{Mar} $|$ \TT{March} \\
    $|$ & \TT{apr} $|$ \TT{Apr} $|$ \TT{April} \\
    $|$ & \TT{may} $|$ \TT{May} $|$ \TT{May} \\
    $|$ & \TT{jun} $|$ \TT{Jun} $|$ \TT{June} \\
    $|$ & \TT{jul} $|$ \TT{Jul} $|$ \TT{July} \\
    $|$ & \TT{aug} $|$ \TT{Aug} $|$ \TT{August} \\
    $|$ & \TT{sep} $|$ \TT{Sep} $|$ \TT{September} \\
    $|$ & \TT{oct} $|$ \TT{Oct} $|$ \TT{October} \\
    $|$ & \TT{nov} $|$ \TT{Nov} $|$ \TT{November} \\
    $|$ & \TT{dec} $|$ \TT{Dec} $|$ \TT{December} \\
    \end{tabular}
\\[1ex]
\emkey{year-name} :::=  {\em year} $|$ {\em short-year-name}
\\[1ex]
\emkey{short-year-name} :::=  \TT{'} {\em digit}\PLUS{}
\\[1ex]
\emkey{era} :::=  \TT{AD} $|$ \TT{BC} $|$ \TT{ADG} $|$ \TT{ADJ}
                          $|$ \TT{BCG} $|$ \TT{BCJ}
\end{indpar}

{\em Weekdays} are superfluous; if they are input and are wrong,
a warning message is issued.

The default {\em era} is \TT{AD}.
A `\TT{G}' at the end of an {\em era} indicates the date is in the
Gregorian Calendar, and a `\TT{J}' indicates the date is in the Julian
Calendar.  If neither is given, the date is Gregorian if it is on
or after 15 October 1582, and Julian otherwise.  Years always begin
at the midnight just before January 1.
There is no year \TT{0}; \TT{1AD} is immediately preceeded
by \TT{1BC}.

A date consisting of just a {\em year-name} refers to January 1 of that
year; e.g., \TT{'05} and \TT{01/01/2005} are the same date.
A date consisting of just a {\em month-name} and a {\em year-name}
refers to the first day of the month;
e.g., \TT{May'05}. \TT{May05}, \TT{May-05}, and
\TT{05/01/2005} are the same date.

If no {\em era} is given and the {\em year} is \TT{999} or less,
the {\em year} is taken to denote the year nearest the current
year which ends in the same digits as given in {\em year}.
Thus in 2014 \TT{97} denotes 1997 and \TT{114} denotes 2114.

A warning message is issued if {\em month} is out of the range
\TT{1..12}, but the date is still computed letting \TT{0} denote
December of the previous year, \TT{13} denote January of the
next year, etc.  A warning message is issued if {\em day} is
\TT{0} or too large for the given month and year, but again
the date is still computed with \TT{0} denoting the last day of
the previous month, etc.

Most {\em dates} are {\em numerics}, but those beginning with
a {\em month-name} are {\em words}.

\subsection{Times}
\label{TIMES}

A \key{time} is a {\em numeric} containing digits, possibly a decimal
point, and one or two colons, optionally followed by a meridiem indication
and/or a time zone, and optionally preceeded by a colon and a date.

\begin{indpar}
\emkey{time} \begin{tabular}[t]{rl}
    :::= & {\em time-interval} \\
     $|$ & {\em time-of-day} \\
     $|$ & {\em date} \TT{:} {\em time-interval} \\
     $|$ & {\em date} \TT{:} {\em time-of-day} \\
    \end{tabular}
\label{TIME}
\\[1ex]
\emkey{time-interval} :::= {\em hour} \TT{:} {\em minute}
                          \{ \TT{:} {\em seconds} \}\QMARK{}
\label{TIME-INTERVAL}
\\[1ex]
\emkey{time-of-day} \begin{tabular}[t]{rl}
    :::= & {\em time-interval} {\em meridian} \\
     $|$ & {\em time-interval} \TT{-} {\em time-zone} \\
     $|$ & {\em time-interval} {\em meridian} \TT{-} {\em time-zone} \\
    \end{tabular}
\\[1ex]
\emkey{hour} :::= {\em digit}\QMARK{} {\em digit}
\\[1ex]
\emkey{minute} :::= {\em digit} {\em digit}
\\[1ex]
\emkey{seconds} :::=
	{\em digit} {\em digit} {\em fractional-seconds}\QMARK{}
\\[1ex]
\emkey{fractional-seconds} :::= \TT{.} {\em digit}\PLUS{}
	$|$ \TT{.} \{ {\em digit} {\em digit} {\em digit} \TT{,} \}\PLUS{}
	    {\em digit} {\em digit}\QMARK{} {\em digit}\QMARK{}
\\[1ex]
\emkey{meridiem} ::= \TT{am} $|$ \TT{AM} $|$ \TT{pm} $|$ \TT{PM}
                 $|$ \TT{noon} $|$ \TT{midnight}
\\[1ex]
\emkey{time-zone}
    \begin{tabular}[t]{rl}
    :::= & \TT{UTC} \\
    $|$ & \TT{UTC} {\em sign} {\em digit}\QMARK{} {\em digit}
	   \{ \TT{:} {\em digit} {\em digit} \}\QMARK{} \\
    $|$ & {\em defined-time-zoned}
    \end{tabular}
\end{indpar}



A {\em time-interval} represents the number
$60*(60*hour+minute)+seconds$.  A {\em minutes} or
{\em seconds} value equal or greater than $60$ merely causes a warning
message to be issued.

A {\em meridiem} limits the {\em time-interval}
to be equal to or greater than \TT{1:00} and strictly less than
\TT{13:00}; else a warning message is issued.  A \TT{noon}
or \TT{midnight} {\em meridiem} limits the {\em time-interval}
to be equal to \TT{12:00}; else a warning message is issued.
The absence of a {\em meridiem} limits the {\em time-interval}
to be equal to or less than {\TT 24:00}.

If \TT{am} or \TT{AM} is given, $12$ hours is subtracted from
{\em time-interval} values equal to or greater than \TT{12:00}.
If \TT{pm} or \TT{PM} is given, $12$ hours is added to
{\em time-interval} values that are strictly less than \TT{12:00}.
The time \TT{12:00 midnight} is interpreted as \TT{24:00}.

\begin{boxedfigure}[t]

\footnotesize

\begin{center}
\begin{tabular}{l|l}
\begin{tabular}{@{}lll@{}}
      &                               & UTC \\
HST   & Hawaii Standard Time          & -10:00 \\
AKST  & Alaska Standard Time          & -09:00 \\
AKDT  & Alaska Daylight Time          & -08:00 \\
PST   & Pacific Standard Time         & -08:00 \\
PDT   & Pacific Daylight Time         & -07:00 \\
MST   & Mountain Standard Time        & -07:00 \\
MDT   & Mountain Daylight Time        & -06:00 \\
CST   & Central Standard Time         & -06:00 \\
CDT   & Central Daylight Time         & -05:00 \\
EST   & Eastern Standard Time         & -05:00 \\
EDT   & Eastern Datlight Time         & -04:00 \\
AST   & Atlantic Standard Time        & -04:00 \\
ADT   & Atlantic Daylight Time        & -03:00 \\
ART   & Argentina Time                & -03:00 \\
BRT   & Brasilia Time                 & -03:00 \\
BRST  & Brasilia Summer Time          & -02:00 \\
GMT   & Greenwich Mean Time           & +00:00 \\
WET   & Western European Time         & +00:00 \\
\end{tabular}
&
\begin{tabular}{@{}lll@{}}
      &                               & UTC \\
BST   & British Summer Time           & +01:00 \\
CET   & Central European Time         & +01:00 \\
WAT   & West Africa Time              & +01:00 \\
CEST  & Central European Summer Time  & +02:00 \\
EET   & Eastern European Time         & +02:00 \\
CAT   & Central Africa Time           & +02:00 \\
EEST  & Eastern European Summer Time  & +03:00 \\
EAT   & Eastern Africa Time           & +03:00 \\
GST   & Gulf Standard Time            & +04:00 \\
PKT   & Pakistan Standard Time        & +05:00 \\
IST   & India Standard Time           & +05:30 \\
CST   & China Standard Time           & +08:00 \\
JST   & Japan Standard Time           & +09:00 \\
AWST  & Australia Western Standard Time        & +09:00 \\
AWDT  & Australia Western Daylight Time        & +10:00 \\
ACST  & Australia Central Standard Time        & +09:30 \\
ACDT  & Australia Central Daylight Time        & +10:30 \\
AEST  & Australia Eastern Standard Time        & +10:00 \\
AEDT  & Australia Eastern Daylight Time        & +11:00 \\
NZST  & New Zealand Standard Time     & +12:00 \\
NZST  & New Zealand Daylight Time     & +13:00 \\
\end{tabular}
\end{tabular}
\end{center}
\vspace*{-3ex}
\caption{Pre-Defined Time Zones}
\label{PRE-DEFINED-TIME-ZONES}
\end{boxedfigure}

A {\em time-zone} such as \TT{UTC-05:00} refers to Greenwich Mean Time
(\TT{UTC}, Temps Universel Coordonn\'e in French)
minus 5 hours (\TT{-05:00}) and is the same as
Eastern Standard Time, or \TT{EST}.   When localities that use \TT{EST}
go in Daylight Savings Time, they convert to Eastern Daylight Time, or
\TT{EDT}, which is that same as \TT{UTC-04:00}.

As another example, \TT{NZST}, New Zealand Standard Time, is the same
as \TT{UTC+12:00}.

If a {\em time-zone} is given, the difference between the {\em time-zone}
time and GMT is subtracted from the {\em time-interval}.
Thus for \TT{UTC-5:00} 5 hours is added to the {\em time-interval},
and for \TT{UTC+12:00} 12 hours is subtracted from the {\em time-interval}.
It is possible to get negative numbers, which indicate a time in the previous
GMT day.

The standard time zones pre-defined in RECKON are given in
Figure~\ref{PRE-DEFINED-TIME-ZONES}.

Additional time zones can be defined, or existing time zone
definitions can be replaced, by the statement:
\begin{center}
\TT{define time zone} {\em short-name}
    \TT{`}{\em long-name}\TT{' UTC}$\pm${\em offset}
\end{center}

as for example
\begin{indpar}\begin{verbatim}
define time zone WGST `West Greenland Summer Time' UTC-02:00
define time zone AZOST `Azores Summer Time' UTC+00:00
define time zone BST `Bangladesh Standard Time' UTC+06:00
       // Replaces British Summer Time, UTC+01:00
define time zone VLAT `Vladivostok Time' UTC+10:00
\end{verbatim}\end{indpar}

Short names may be capitalized or not in defining statements, and
similarly in usage.

Some example {\em times} are:

\begin{indpar}[0.1in]
\tt
\begin{tabular}{@{}l@{~~}l@{~~}l@{}}
1:15	& 12:00   & 05:37:23 \\
1:15am	& 12:00noon   & 05:37:23PM \\
1:15edt	& 12:00est   & 05:37:23WDT \\
1:15am-edt	& 12:00midnight-EET   & 05:37:23pm-WDT \\
May1975:1:15am-edt	& 05/04/1999:00:00EET   & 05/07/99:17:37:23WDT \\
may1975:1:15am-edt	& 04may'99:00:00EET   & 07May99:17:37:23WDT \\
\end{tabular}
\end{indpar}

{\em Times} are {\em numerics} except for those that begin with
{\em month-names} which are {\em words}.


\subsection{Units}
\label{UNITS}

Values may have units, such as `\TT{ft}' for `feet' or
`\TT{inch}' for inch (`\TT{in}' is useful as a preposition and
is therefore not used as a unit).  Units can be combined in
a single lexeme by using the operators
`\TT{/}' for division,
`\TT{*}' for multiplication,
and `\TT{\textasciicircum}' for exponentiation:
\begin{indpar}
\emkey{unit}
    \begin{tabular}[t]{rl}
    :::= & {\em unit-product} \\
     $|$ & {\em unit-product} \TT{/} {\em unit-product} \\
    \end{tabular}
\\
\emkey{unit-product}
    \begin{tabular}[t]{rl}
    :::= & {\em unit-factor} \\
     $|$ & {\em unit-product} \TT{*} {\em unit-factor} \\
    \end{tabular}
\\
\emkey{unit-factor}
    \begin{tabular}[t]{rl}
    :::= & {\em unit-name} \\
     $|$ & {\em unit-name} \TT{\textasciicircum}
           {\em unsigned-integral-numeric} \\
    \end{tabular}
\end{indpar}

Some examples are
\begin{indpar}[0.1in]
\tt
\begin{tabular}{l@{~~~}l@{~~~}l@{~~~}l}
ft		& inch	& m	& kg \\
lb*ft		& inch\textasciicircum 3    & kg*m & kg*m\textasciicircum 2 \\
ft/sec		& ft/sec/sec	& m/sec\textasciicircum 2 & lb*ft/sec \\
ft\textasciicircum 2/sec
		& ft/sec*sec	& sec\textasciicircum 2/m\textasciicircum 2
				& sec/lb*ft \\
\end{tabular}
\end{indpar}

Note that there can be at most one `\TT{/}' in a {\em unit}, and
`\TT{*}' takes precedence over `\TT{/}'.

{\em Units} can be separate {\em word} lexemes, or they can be glued
to a preceding {\em scientific-numeric} lexeme,
from which they will be automatically split.  In addition several
{\em glued-lexemes} of this kind can themselves be glued together:
\begin{indpar}
\emkey{glued-lexeme}
    \begin{tabular}[t]{rl}
    :::= & \{ {\em scientific-numeric} {\em unit} \}\PLUS{} \\
     $|$ & other
    \end{tabular}
\end{indpar}


Thus `\TT{5inch}' is a {\em glued-lexeme} that will be split into
`\TT{5 inch}', and `\TT{4ft3inch}' will be split into `\TT{4 ft 3 inch}'.

Units may be defined by statements of the form:
\begin{center}
\TT{define unit} {\em unit-name}
    \{ \TT{=} {\em unit-expression} \}\QMARK{}
\end{center}

as for example
\begin{indpar}\begin{verbatim}
define unit m
define unit cm = 0.01m
define unit inch = 2.54cm
define unit ft = 12 inch
define unit yd = 3ft
define unit inch = yd / 36
define unit inch = ft / 36
define unit sqft = ft^2
define unit cuft = ft^3
define unit degC
define unit degF = 1.8degC + 32
define unit degK = degC + 273.15
\end{verbatim}\end{indpar}

Here
\begin{indpar}
\emkey{unit-expression}
    \begin{tabular}[t]{rl}
    ::= & {\em unit-quotient} \\
    $|$ & {\em unit-expression} \TT{+} {\em unit-number-constant} \\
    $|$ & {\em unit-expression} \TT{-} {\em unit-number-constant} \\
    \end{tabular}
\\
\emkey{unit-quotient}
    \begin{tabular}[t]{rl}
    ::= & {\em unit-product} \\
    $|$ & {\em unit-quotient} \TT{/} {\em unit-number-constant} \\
    $|$ & {\em unit-quotient} \TT{/} {\em unit-product} \\
    $|$ & {\em unit-number-constant} \TT{/} {\em unit-product} \\
    \end{tabular}
\\
\emkey{unit-product}
    \begin{tabular}[t]{rl}
    ::= & {\em unit-factor} \\
    $|$ & {\em unit-number-constant} \TT{*} {\em unit-factor} \\
    $|$ & {\em unit-product} \TT{*} {\em unit-number-constant} \\
    $|$ & {\em unit-product} \TT{*} {\em unit-factor} \\
    \end{tabular}
\\
\emkey{unit-factor} ::= see above
\\
\emkey{unit-number-constant} ::=
      {\em scientific-numeric} without any leading {\em sign}
\end{indpar}

Note that operators in {\em unit-expressions} are separate
lexemes.
Also, the second operand of `\TT{+}', and
`\TT{-}' must always be a {\em unit-number-constant},
it is not possible to write non-integral or negative exponents,
and {\em unit-factors} are the same in {\em unit-expressions}
as they are in {\em units}.

A unit may appear in many `\TT{define unit}' statements in order to describe
its relation to other units.  The statements must be consistent;
e.g.,
\begin{center}
\tt inch = yd / 36 = (3 ft) / 36 = 3 * (12 inch) / 36 = (36 inch) / 36 = 1 inch
\end{center}
Equations will be automatically derived from `\TT{define unit}' statements
when such can be done by linear algebra and simple substitution; e.g.
`{\tt yd = 36 inch}' and `{\tt sqft = 144 inch\textasciicircum 2}'
will be derived automatically when needed.



\subsection{Formats}
\label{FORMATS}

A \emkey{format} tells how to print a value, usually a number, but
sometimes a symbol (character string).  {\em Formats} are {\em lexemes}
that begin and end with `\TT{/}'.

Some examples are (where {\tt \VSP} denotes a single
space character):
\begin{indpar}[0.1in]
\tt
\begin{tabular}{l@{~~~}l@{~~~}l@{~~~~~~}l@{~~~}l@{~~~}l}
\rm Value & \rm Format & \rm Printout &
\rm Value & \rm Format & \rm Printout
\\[1ex]
5.4321	  & /0.4/	& 5.4321 &
Hello	  & 		& Hello \\
5.4321	  & /0.4rm/	& \rm 5.4321 &
Hello	  & /rm/	& \rm Hello \\
5.4321	  & /0.4ss/	& \sf 5.4321 &
Hello	  & /ss/	& \sf Hello \\
5.4321	  & /0.2b/	& \bf 5.43 &
Hello	  & /b/		& \bf Hello \\
5.4321	  & /w5sc/0.2/	& \sc \VSP 5.43 &
Hello	  & /rw7sc/	& \sc \VSP\VSP Hello \\
5.4321	  & /cw6sl/0.2/	& \sl \VSP 5.43\VSP &
Hello	  & /w7/sl/	& \sl \VSP Hello\VSP \\
5.4321	  & /w6i/0.2/	& \it \VSP\VSP 5.43 &
Hello	  & /rw7i/	& \it \VSP\VSP Hello \\
\end{tabular}
\end{indpar}

A {\em format} is a {\em middle-lexeme} consisting of a sequence of
{\em format-items} surrounded by and optionally separated by
slashes `\TT{/}':
\begin{indpar}
\begin{tabular}{rcl}
\hspace*{1.7in} \\[-2ex]
\emkey{format}
    & ::= & \TT{/} {\em format-item}
                   \{ \TT{/}\QMARK{} {\em format-item} \}\STAR{} \TT{/}
\end{tabular}
\end{indpar}

The following is a complete list of {\em format-items}.
The items are presented in groups unless otherwise noted conflict
with each other; see the rules below for resolving conflicts.
The slashes (\TT{/}) between {\em format-items} in a {\em format}
may be omitted if no ambiguity arises.

\newcommand{\BEGINGROUP}[2][]{
\begin{tabular}{rllp{4.0in}}
\hspace*{0.1in} & \hspace*{0.1in} & \hspace*{0.4in} \\[-2ex]
& \multicolumn{3}{l}{{\bf #2}\ifstrequal{}{#1}{}{ ~~~~~ #1}} \\
}
\newcommand{\GROUPENTRY}[2][]{
&& \ttmkey{#2}{table format}\ifstrequal{}{#1}{}{\TT{<}{\em #1}\TT{>}} &
}
\newcommand{\GROUPNEWLINE}{\\&&&}
\newcommand{\ENDGROUP}{\end{tabular}}

\BEGINGROUP[(non-monospace unless indicated)]{Font Style Group}
\GROUPENTRY{ty} typewriter (monospace) [default] \\
\GROUPENTRY{rm} roman (normal non-monospace) \\
\GROUPENTRY{ss} sans-serif \\
\GROUPENTRY{b} bold \\
\GROUPENTRY{i} italic \\
\GROUPENTRY{sl} slanted \\
\GROUPENTRY{sc} small caps \\
\ENDGROUP \\
\BEGINGROUP{Font Size Group}
\GROUPENTRY[ratio]{fs} adjust the font size to {\em ratio}\% of normal.
\ENDGROUP \\
\BEGINGROUP{Background Color Group}
\GROUPENTRY{gray} light gray background \\
\GROUPENTRY{white} white background \\
\ENDGROUP \\
\BEGINGROUP{Adjust Group}
\GROUPENTRY{r} right adjust [default for numbers] \\
\GROUPENTRY{l} left adjust \\
\GROUPENTRY{c} center adjust [default for symbols] \\
\ENDGROUP \\
\BEGINGROUP{Numeric Group}
\GROUPENTRY[places]{.}
    output with exactly {\em places} decimal places \\
\GROUPENTRY[places]{0.}
    ditto but with \TT{0} in the units position if less than \TT{1} \\
\GROUPENTRY{0}
    ditto but with zero {\em places} and \underline{no} decimal point \\
\GROUPENTRY[precision]{p}
    output with exactly {\em precision} significant decimal digits  \\
\GROUPENTRY[time-format]{T}
    format time (or date) as per below; \GROUPNEWLINE
    conflicts with \TT{\%} \TT{\$} \TT{,} \TT{()} \TT{+} and \TT{-} \\
\ENDGROUP \\
\BEGINGROUP{Unit Group}
\GROUPENTRY{\%} multiply numbers by 100 and add a \% sign \\
\GROUPENTRY{\$} add \$ sign to numbers; \GROUPNEWLINE
                make \TT{0.2} the Numeric Group default \\
\GROUPENTRY{!unit} no unit
\ENDGROUP \\
\BEGINGROUP{Sign Group}
\GROUPENTRY{()} indicate negative numbers by parentheses instead of sign \\
\GROUPENTRY{+} indicate positive and zero numbers by sign, + or - \\
\GROUPENTRY{-} indicate negative numbers by sign (-) and positive by absence
               of sign \\
\ENDGROUP \\
\BEGINGROUP{Numeric Comma Group}
\GROUPENTRY{,} add commas to numbers \\
\GROUPENTRY{!,} undo ditto \\
\ENDGROUP \\
\BEGINGROUP{Width Group}
\GROUPENTRY[columns]{w}
    adjust width by given number of {\em columns} \\
\GROUPENTRY{!w}
    set width to `only as wide as necessary' \\
\ENDGROUP \\
\BEGINGROUP{Height Group}
\GROUPENTRY[lines]{h}
    adjust height by given number of {\em lines} \\
\GROUPENTRY{!h}
    set height to `only as high as necessary' \\
\ENDGROUP \\
\BEGINGROUP[(\TT{left} does not conflict with \TT{right})]%
           {Horizontal Margin Group}
\GROUPENTRY[points]{side}
    adjust space to left and right of entry by {\em points} \\
\GROUPENTRY[points]{left}
    adjust space to left of entry by {\em points} \\
\GROUPENTRY[points]{right}
    adjust space to right of entry by {\em points} \\
\ENDGROUP \\
\BEGINGROUP[(no conflicts)]{Vertical Margin Group}
\GROUPENTRY[points]{top}
    adjust space at top of entry by {\em points} \\
\GROUPENTRY[points]{bottom}
    adjust space at bottom of entry by {\em points} \\
\ENDGROUP

To `adjust' a value V by a parameter P in the above is to
set V to P if P has no sign, or to add P to the current V if
P has a sign.  Thus `\TT{w7}' sets the width to 7 columns while
`\TT{w-2}' subtracts two columns from the current width and
`\TT{w+2}' adds two columns to the current width.

The {\em format-items} are applied left to right, with a {\em format-item}
cancelling conflicting {\em format-items} to its left.  In applying this
rule, however, {\em format-items} that adjust a value by adding
or subtracting a parameter to the value do not conflict with any
{\em format-item}.

In some contexts
there are multiple formats applied in a given order.  For example,
in tables the table format, column format, and row format are applied in
order, so the column format overrides the table format, and the row
format overrides the other formats.



A {\em time-format} is a string of any characters that are
allowed inside a word in which the following \emskey{time-code}s
are replaced as indicated in the following:
\begin{center}
\begin{tabular}{lp{4.0in}}
\ttmkey{\{~\}}{{\em time-code}} & surround the format by \TT{\{~\}} if the
				  format contains slashes \\
\ttmkey{dd}{{\em time-code}} & day of month: \TT{01} \ldots{} \TT{31} \\
\ttmkey{ddd}{{\em time-code}} & day of year: \TT{01} \ldots{} \TT{366} \\
\ttmkey{ww}{{\em time-code}} & day of weak: \TT{01} \ldots{} \TT{07} \\
\ttmkey{www}{{\em time-code}} & day of weak: \TT{sun} \ldots{} \TT{sat} \\
\ttmkey{Www}{{\em time-code}} & day of weak: \TT{Sun} \ldots{} \TT{Sat} \\
\ttmkey{WWW}{{\em time-code}} & day of weak: \TT{SUN} \ldots{} \TT{SAT} \\
\ttmkey{mm}{{\em time-code}} & month: \TT{01} \ldots{} \TT{12}
                               if next to \TT{/} \\
\ttmkey{mmm}{{\em time-code}} & month: \TT{jan} \ldots{} \TT{dec} \\
\ttmkey{Mmm}{{\em time-code}} & month: \TT{Jan} \ldots{} \TT{Dec} \\
\ttmkey{MMM}{{\em time-code}} & month: \TT{JAN} \ldots{} \TT{DEC} \\
\ttmkey{yy}{{\em time-code}} & year: \TT{00} \ldots{} \TT{99} \\
\ttmkey{yyyy}{{\em time-code}} & year: \TT{0000} \ldots{} \TT{9999} \\
\ttmkey{xm}{{\em time-code}} & meridian: \TT{am} or \TT{pm} \\
\ttmkey{XM}{{\em time-code}} & meridian: \TT{AM} or \TT{PM} \\
\ttmkey{hh}{{\em time-code}} & hour: \TT{00} \ldots{} \TT{12}
			       if xm or XM in {\em time-format} \\
			     & or: \TT{00} \ldots{} \TT{23}
			       if xm and XM \underline{not}
			       in {\em time-format} \\
\ttmkey{mm}{{\em time-code}} & minute: \TT{00} \ldots{} \TT{59} \\
                               if next to \TT{:} \\
\ttmkey{ss}{{\em time-code}} & second: \TT{00} \ldots{} \TT{59} \\
\ttmkey{\_}{{\em time-code}} & single space \\
\ttmkey{zzz}{{\em time-code}} & local time zone (e.g. \TT{est}),
                                and adjust time to be in that zone \\
\ttmkey{ZZZ}{{\em time-code}} & local time zone (e.g. \TT{EST}),
				and adjust time to be in that zone \\
\ttmkey{gmt}{{\em time-code}} & do not replace,
				and adjust time to be gmt \\
\ttmkey{GMT}{{\em time-code}} & do not replace,
				and adjust time to be gmt \\
\ttmkey{\textbackslash}{{\em time-code}} & delete the `\TT{\textbackslash}'
                                and keep the following character without
				giving it a special interpretation
\end{tabular}
\end{center}

Some example {\em time-formats} and associated times are:
\begin{center}
\tt
\begin{tabular}{ll}
\{mm/dd/yyyy\} & 02/21/2014 \\
\{dd/mm/yyyy\} & 21/02/2014 \\
\{mm/yyyy\} & 02/2014 \\
www\_dd\_mmm\_'yy & fri 21 feb '14 \\
Www\_ddmmmyy & Fri 21feb14 \\
\{hh::mm:ss\} & 13:27:58 \\
hh::mm:ssXM & 1:27:58PM \\
hh::mm:ss & 00:27:58 \\
hh::mm:ssXM & 12:27:58AM \\
hh::mm:ss & 12:27:58 \\
hh::mm:ssXM & 12:27:58PM \\
Www\_Mmm\_dd\_hh:mm:ss\_ZZZ\_yyyy & Fri Feb 21 13:27:58 EST 2014 \\
Www\_Mmm\_dd\_hh:mm:ss\_GMT\_yyyy & Fri Feb 21 18:27:58 GMT 2014 \\
\end{tabular}
\end{center}

\section{Logical Lines and Paragraphs}
\label{LOGICAL-LINES-AND-PARAGRAPHS}

Lexemes are contained in lines, and are tagged with the line and column numbers
of their first character and of the first character following the lexeme
(or of an imaginary end-of-file character).
Physical lines that begin with a comment can contain only that comment,
and are called \skey{comment line}s.
The beginning column number of the
first lexeme in a non-blank, non-comment physical line is called
the \mkey{indent}{of physical line} of the physical line
and can be used to indicate that one physical line is a
continuation of the current logical line
and to organize lines into indented subparagraphs.

Thus the physical lines:

\begin{indpar}\begin{verbatim}
This is a line
     which is continued
       // A comment.
   and continued.
\end{verbatim}\end{indpar}

represent one logical line containing the lexeme sequence:

\begin{indpar}\begin{verbatim}
This is a line which is continued and continued .
\end{verbatim}\end{indpar}

At any point there is an \key{current paragraph indent}, which is
initially \TT{0}.  A physical
line whose indent equals the current paragraph indent begins a new
\key{logical line}.  A physical line whose indent exceeds the current
paragraph indent continues the current logical line, and is called
a \key{continuation line}, unless it is the first physical line of an indented
paragraph as described in the following.

A `\TT{:}' lexeme at the end of a physical line begins an
\key{indented paragraph}.  If the indent of the next non-blank, non-comment
physical line exceeds the current paragraph indent, the indent of this
line becomes the new current paragraph indent, and this line
begins the first logical line of the paragraph.  The paragraph
ends just \underline{before} the next non-blank, non-comment physical line
whose indent is less than the new paragraph indent, or just
before the end-of-file if that occurs first.

The current paragraph indent is saved when the paragraph begins
and restored when the paragraph ends.  If the first non-blank, non-comment
physical line after
the `\TT{:}' has an indent that does not exceed the current paragraph
indent (before it is reset), the paragraph is empty (has no logical lines).

Thus we have:

\begin{indpar}\begin{verbatim}
This is a logical line.
And another
    logical line.
And a logical line ending with an indented paragraph:

    // A comment that can be ignored.
    The first logical line of the
        indented paragraph.

    The second logical line
        of the indented paragraph.
    The third logical line of the indented
        paragraph containing an indented subparagraph:

            Line 1 of subparagraph.

            Line 2 of subparagraph.

        that is not at the end of this third logical
             line.
             // A comment that can be ignored.
    The fourth logical line of the indented paragraph.
// A comment that can be ignored.
The line after the indented paragraph.
\end{verbatim}\end{indpar}

The paragraph becomes a subexpression of the logical line that included
the paragraph beginning `\TT{:}'.  It is usually the last subexpression
in this logical line, but need not be if the paragraph containing
logical line has a continuation line after the paragraph, as is the
case in the example where the third logical line of the indented
paragraph contains an embedded subparagraph.

There are some special rules for gluing together lexemes within
a logical line:

\begin{enumerate}
\item Two consecutive \emskey{quoted-string}s in a logical line
are concatenated \underline{after} {\em character-represen\-ta\-tives}
have been replaced by the characters they represent.

Thus \TT{"<" "LF" ">"} is equivalent to a single {\em quoted-string}
lexeme with the 4 characters `\TT{<}', `\TT{L}', `\TT{F}', and
`\TT{>}', whereas \TT{"<LF>"} is a {\em quoted-string} with only
1 character, a line feed.

\label{CONTINUATION-GLUING}
\item
If a physical line which is immediately followed by a continuation line
ends with a {\em word-item} that
contains 4 or more characters ending with a `\TT{-}',
and the continuation line begins with a {\em word-item},
the two {\em word-items}
will be glued together with the line ending `\TT{-}' deleted.
The {\em word-item} on the continuation line may also begin
with a `\TT{-}', which will not be deleted.

For example,

\begin{indpar}\begin{verbatim}
This is a word-
     -that-is-con-
     tinued.
\end{verbatim}\end{indpar}

translates to the lexeme squence

\begin{indpar}\begin{verbatim}
This is a word-that-is-continued .
\end{verbatim}\end{indpar}

\item
If a physical line which is immediately followed by a continuation line
ends with a {\em word-item} that
contains 4 or more characters ending with a `\TT{\_}',
`\TT{/}', `\TT{@}', or `\TT{\&}',
and the continuation line begins with a {\em word-item},
the two {\em word-items}
will be glued together
(but the line ending `\TT{\_}', `\TT{/}', `\TT{@}', `\TT{\&}'
will \underline{not} be deleted).

For example,

\begin{indpar}\begin{verbatim}
The URL is http://www.qed.fmp/
    whatsits@
    bits_and_
    pieces.
\end{verbatim}\end{indpar}

translates to the lexeme squence

\begin{indpar}[0.1in]\begin{verbatim}
The URL is http://www.qed.fmp/whatsits@bits_and_pieces .
\end{verbatim}\end{indpar}

\end{enumerate}

\section{Low Level Data}

A low level \key{datum} in RECKON is either an atom, an object, or an arrow.

Expressions, blocks, and descriptions are higher level data layered
on top of these low level data.  An expression is either an atom or
a particular kind of object.  A block is a particular kind of object,
and a description is a particular kind of block.

An \key{atom} is a symbol, a number, or a label.
A \key{label} is a sequence of 0 or more atoms.
A single symbol or number is treated as if were a label whose only element
is the symbol or number itself.

An object is just a place in memory, and is like a dot on a blank page.
It can be the source or target of arrows, and it is different from
every other object and from every atom.  But it is nothing more.

However, as a place in memory, an object has a identifier.  Objects are assigned
\skey{raw object identifier}s
of the form `\ttmkey{@}{in raw object identifier}$N$' where $N$
is a natural number (non-negative integer).
Raw object identifiers of this form are assigned only to objects
that must be named in an output stream (e.g., printed output).
The first object named in an output stream is assigned the identifier
\TT{@1}, the second object named in the output stream is assigned
the identifier \TT{@2},
and so forth.  The same object may be assigned different identifiers
in different output streams.%
\footnote{A possible implementation is to give objects that
have been assigned identifiers
in an output stream a hidden system defined output
stream specific attribute (\pagref{ATTRIBUTE})
equal to the object's identifier integer.  Another implementation uses a
hash table per stream.}

There are two kinds of arrows: single and double.

A \key{single arrow} is an arrow from an object to either another object
or to an atom.  The arrow has a label, which is an atom, and is
most commonly either a symbol or a small positive integer.

A \key{double arrow} is a double headed arrow between two objects.
It has a separate label for each direction, with each label being a
sequence of zero or more atoms.  A double arrow is equivalent to a
\underline{related pair}
of single arrows going in opposite directions between the same two objects.
The difference between a double arrow and a pair of single arrows is that
it is possible to delete only one direction of a pair of single arrows, but 
when deleting a double arrow, both directions are deleted.

An \key{arrow label} is an atom (a.k.a., a label).
Two arrows leaving the same object may have the same label.  Thus
an object and an arrow label together name
a set of arrows sourced at the object.
We say that the object and label together specify a set of values,
each of which is an atom or an object.

\ikey{Arrow flags}{arrow flag} may be attached to arrow labels.
More precisely, a set of arrow flags is defined for each object
and each arrow label, and these flags apply to all arrows sourced at the
object that have the given label.
The standard flags are the \key{dot flag} (\ttmkey{.}{dot flag}),
and the \key{maybe flag} (\ttmkey{?}{maybe flag}).
Arrows with a dot flagged label are not to be output when their source
is output.
Targets of arrows with a maybe flagged label may be garbage collected
(made to disappear automatically, see \secref{GARBAGE-COLLECTION})
if they cannot be reached except by traversing arrows whose labels
have maybe flags.

We will give examples in the next section along with a basic way of
representing sets of objects in text.  In the rest of this document
arrows are called \skey{attribute}s,\label{ATTRIBUTE} arrow labels are called
\skey{attribute label}s, arrow flags are called \skey{attribute flag}s,
and arrow targets are called \skey{attribute value}s.
Also `\ikey{attribute L of object O}{attribute!of an object}\,'
denotes the set of all values (arrow targets) of attributes
of object O (arrows sourced at O) which have the attribute label
(arrow label) L.

A double arrow is called a \key{double attribute}.  When viewed from
an object at one end of the double arrow, the double arrow is an
attribute of that object, the label of the arrow directed away from that object
is the \mkey{attribute label}{of double attribute} of the double attribute,
the object at the other end is the \mkey{attribute value}{of double attribute}
of the double attribute,
and the label of the arrow directed toward the object is the
\mkey{reverse attribute label}{of double attribute} of the double attribute.

For a given object, an attribute label may label both single and double
arrows.  A distinction is made between the set of values of the single
arrows, and the set of values of the double arrows.  The values of double
arrows, of course, must all be objects, which the values of the single
arrows may be either objects or atoms.


\subsection{Raw Object Representations}
\label{RAW-OBJECT-REPRESENTATIONS}

A set of objects can be written to a text file or read from a text file.
When this is done, a textual representation of the object set is used
in the file.  The most basic representation of an object
is the \key{raw object representation}, which we now describe.

A raw object representation is a special case of an {\em object-representation}.
This special case makes minimal use of the parser and is used when
data is written to a file without any attempt to format the data.

A {\em object-representation} is a logical line beginning
with a {\em object-identifier} lexeme, which consists of `\TT{@}'
followed by digits, and which turns all non-bracket parsing off.

\begin{indpar}[0.5em]
\begin{tabular}{l}
\emkey{object-representation}
\\\hspace*{0.5in}
	\begin{tabular}[t]{rl}
        := {\em bll} & {\em object-identifier} ~
	               {\em object-assignment-operator} ~
	               {\em object-element}\STAR{} \\
	             & \{ {\em bip} ~
		          {\em attribute-representation}\STAR{} ~
			  {\em eip} \}\QMARK{} ~ {\em ell} \\
        \end{tabular}
\end{tabular}

\begin{tabular}{l}
\emkey{object-identifier} :::=
	\ttmkey{@}{in {\em object-identifier}}
	{\em digit}\PLUS{} \\
\end{tabular}

\begin{tabular}{l}
\emkey{object-assignment-operator} ::= ~~~
	\ttmkey{=}{object assignment operator} $|$
	\ttmkey{=>}{object assignment operator} $|$
	\ttmkey{=>{}>}{object assignment operator}
\end{tabular}

\begin{tabular}{l}
\emkey{object-element}
    ::= {\em object-identifier} $|$ {\em atom-name} \\
\emkey{atom-name}
    ::= {\em word} $|$ {\em quoted-string}
		   $|$ {\em number-name} $|$ {\em bracketed-label} \\
\emkey{number-name}
    ::= {\em integral-numeric} $|$ {\em fractional-numeric} $|$
        {\em scientific-numeric} $|$ {\em radix-numeric} \\
\emkey{bracketed-label}
    ::= \TT{\{*}~~{\em atomic-name}\STAR{}~~\TT{*\}} \\
\end{tabular}

\begin{tabular}{l}
\emkey{attribute-representation}\label{ATTRIBUTE-REPRESENTATION}
    \begin{tabular}[t]{rl}
    ::= & {\em single-attribute-representation} \\
    $|$ & {\em double-attribute-representation} \\
    \end{tabular}
\end{tabular}

\begin{tabular}{l}
\emlkey{single-attribute-}{representation}%
\label{SINGLE-ATTRIBUTE-REPRESENTATION}
::=
\\\hspace*{0.5in}
	{\em bll} {\em single-attribute-label}
	\begin{tabular}[t]{l}
	{\em attribute-label-flags}\QMARK{} ~
	{\em attribute-assignment-operator} \\
	{\em single-attribute-values} ~ {\em ell}
	\end{tabular}
\end{tabular}

\begin{tabular}{l}
\emkey{single-attribute-label}\label{SINGLE-ATTRIBUTE-LABEL}
    ::= {\em defined-name}\pagnote{DEFINED-NAME} $|$ {\em index}\pagnote{INDEX}
\end{tabular}

\begin{tabular}{l}
\emkey{attribute-label-flags} ::=
    \TT{[} {\em flag-lexeme}\STAR{} \TT{]}
\end{tabular}%
\index{flags!attribute label}%
\index{attribute label!flags}

\begin{tabular}{l}
\emkey{flag-lexeme}
    ::= {\em word} $|$ {\em mark} $|$ {\em quoted-string}
\end{tabular}

\begin{tabular}{l}
\emkey{attribute-assignment-operator}
    ::= ~~ \TT{=} $|$ \TT{=>} $|$ \TT{=>{}>}
\end{tabular}

\begin{tabular}{l}
\emkey{single-attribute-value}\label{SINGLE-ATTRIBUTE-VALUE}
    ::= {\em atom-name}\STAR{} $|$ {\em object-identifier} \\
\emkey{single-attribute-values}\label{SINGLE-ATTRIBUTE-VALUES}
    ::= {\em single-attribute-value}
        \{ \TT{,} {\em single-attribute-value} \}\STAR{}
\end{tabular}

\begin{tabular}{l}
\emlkey{double-attribute}{-representation}%
\label{DOUBLE-ATTRIBUTE-REPRESENTATION}
    ::=
\\\hspace*{0.5in}
	{\em bll} {\em double-attribute-label}
	{\em attribute-label-flags}\QMARK{}
\\\hspace*{1.0in}
	\begin{tabular}[t]{@{}l@{}}
	\TT{=} {\em double-attribute-values} \\
	\TT{=} {\em reverse-attribute-label}
	       {\em attribute-label-flags}\QMARK{} {\em ell}
	\end{tabular}
\end{tabular}

\begin{tabular}{l}
\emkey{double-attribute-label}
    ::= {\em defined-name}\pagnote{DEFINED-NAME}
        $|$ {\em index}\pagnote{INDEX} \\
\emkey{reverse-attribute-label}
    ::= {\em defined-name}\pagnote{DEFINED-NAME}
        $|$ {\em index}\pagnote{INDEX} \\
\end{tabular}

\begin{tabular}{l}
\emkey{double-attribute-value} ::= {\em object-identifier} \\
\emkey{double-attribute-values}\label{DOUBLE-ATTRIBUTE-VALUES}
    ::= {\em double-attribute-value}
        \{ \TT{,} {\em double-attribute-value} \}\STAR{}
\end{tabular}

\end{indpar}

{\em Raw-object-representations} are lines beginning with \TT{@}.
For example,

\begin{indpar}\begin{verbatim}
@1 =:
    type = woman
    name = Jill
    husband = @2 = wife
@2 =:
    type = man
    name = Jack
\end{verbatim}\end{indpar}

These are {\em object-representations} of an object pair that can
be represented pictorially as:

\begin{center}
\begin{picture}(3.0,1.5)
\put(0,0){\framebox(3.0,1.5){}}
\put(0.3,1.00){\makebox(0.8,0.3){\tt @1}}
\put(0.7,1.15){\oval(0.8,0.3)}
\put(0.5,1.00){\vector(0,-1){0.5}}
\put(0.45,0.75){\makebox(0,0)[r]{\tt type}}
\put(0.5,0.4){\makebox(0,0){\tt woman}}
\put(0.9,1.00){\vector(0,-1){0.7}}
\put(0.95,0.55){\makebox(0,0)[l]{\tt name}}
\put(0.9,0.2){\makebox(0,0){\tt Jill}}
\put(1.9,1.00){\makebox(0.8,0.3){\tt @2}}
\put(2.3,1.15){\oval(0.8,0.3)}
\put(2.1,1.00){\vector(0,-1){0.5}}
\put(2.05,0.75){\makebox(0,0)[r]{\tt type}}
\put(2.1,0.4){\makebox(0,0){\tt man}}
\put(2.5,1.00){\vector(0,-1){0.7}}
\put(2.55,0.55){\makebox(0,0)[l]{\tt name}}
\put(2.5,0.2){\makebox(0,0){\tt Jack}}
\put(1.1,1.17){\vector(1,0){0.8}}
\put(1.9,1.13){\vector(-1,0){0.8}}
\put(1.5,1.15){\oval(0.07,0.12)}
\put(1.5,1.30){\makebox(0,0){\tt husband}}
\put(1.5,1.00){\makebox(0,0){\tt wife}}
\end{picture}
\end{center}

There are two single attributes of object \TT{@1} (arrows sourced
at \TT{@1}),
one attribute labeled \TT{type} whose value (target) is the atom \TT{woman},
and one attribute labeled \TT{name} whose value is the atom \TT{Jill}.
There are two similar single attributes from object \TT{@2}.
There is a double attribute (double arrow)
between the two objects which has the
label \TT{husband} when going from \TT{@1} to \TT{@2}
and the label \TT{wife} when going in the reverse direction.

It is possible to place \skey{attribute flag}s on attribute labels
by putting flag characters in {\em flag-lexemes} inside
\TT{[ ]} brackets after a label.
It may be necessary to use a
{\em quoted-string} {\em flag-lexeme} in order to include
separator characters or digits as flag characters.
The following is the same as the above example except that flags
have been added to some of the attributes:

\begin{center}
\begin{tabular}[b]{@{}l@{}}
\verb/@1 =:/\\
\verb|    type = woman|\\
\verb|    name[-] = Jill|\\
\verb|    husband[*] = @2 wife[*]|\\
\verb/@2 =:/\\
\verb|    type = man|\\
\verb|    name[+] = Jack|\\
\end{tabular}
~~~~~~~~~
\begin{picture}(3.2,1.5)
\put(0,0){\framebox(3.2,1.5){}}
\put(0.3,1.00){\makebox(0.8,0.3){\tt @1}}
\put(0.7,1.15){\oval(0.8,0.3)}
\put(0.5,1.00){\vector(0,-1){0.5}}
\put(0.45,0.75){\makebox(0,0)[r]{\tt type}}
\put(0.5,0.4){\makebox(0,0){\tt woman}}
\put(0.9,1.00){\vector(0,-1){0.7}}
\put(0.95,0.55){\makebox(0,0)[l]{{\tt name}$^{\mbox{\tt -}}$}}
\put(0.9,0.2){\makebox(0,0){\tt Jill}}
\put(1.9,1.00){\makebox(0.8,0.3){\tt @2}}
\put(2.3,1.15){\oval(0.8,0.3)}
\put(2.1,1.00){\vector(0,-1){0.5}}
\put(2.05,0.75){\makebox(0,0)[r]{\tt type}}
\put(2.1,0.4){\makebox(0,0){\tt man}}
\put(2.5,1.00){\vector(0,-1){0.7}}
\put(2.55,0.55){\makebox(0,0)[l]{{\tt name}$^{\mbox{\tt +}}$}}
\put(2.5,0.2){\makebox(0,0){\tt Jack}}
\put(1.1,1.17){\vector(1,0){0.8}}
\put(1.9,1.13){\vector(-1,0){0.8}}
\put(1.5,1.15){\oval(0.07,0.12)}
\put(1.5,1.30){\makebox(0,0){{\tt husband}$^{\mbox{\tt *}}$}}
\put(1.5,1.00){\makebox(0,0){{\tt wife}$^{\mbox{\tt *}}$}}
\end{picture}
\end{center}

In the picture the attribute flags have been added as superscripts on the
attribute labels, and in the text the flags have been added
inside \TT{[ ]} brackets that follow attribute labels.

Several attributes of the same object (arrows sourced at the object)
may have the same attribute
label.  An example of this, in which object \TT{@1} has two
attributes labeled \TT{child}, is:

\begin{center}
\begin{tabular}{l@{\hspace*{0.5in}}l}
\begin{tabular}{@{}l@{}}
\\[-20ex]
\verb/@1 =:/\\
\verb|    child = @2 = parent|\\
\verb|    child = @3 = parent|\\
\end{tabular}
&
\begin{picture}(3.1,1.5)
\put(0,0){\framebox(3.1,1.5){}}
\put(0.3,1.00){\makebox(2.4,0.3){\tt @1}}
\put(1.5,1.15){\oval(2.4,0.3)}
\put(0.65,1.00){\vector(0,-1){0.6}}
\put(0.60,0.80){\makebox(0,0)[r]{\tt child}}
\put(0.75,0.40){\vector(0,1){0.6}}
\put(0.80,0.55){\makebox(0,0)[l]{\tt parent}}
\put(2.25,1.00){\vector(0,-1){0.6}}
\put(2.20,0.80){\makebox(0,0)[r]{\tt child}}
\put(2.35,0.40){\vector(0,1){0.6}}
\put(2.40,0.55){\makebox(0,0)[l]{\tt parent}}
\put(0.3,0.10){\makebox(0.8,0.3){\tt @2}}
\put(0.7,0.25){\oval(0.8,0.3)}
\put(1.9,0.10){\makebox(0.8,0.3){\tt @3}}
\put(2.3,0.25){\oval(0.8,0.3)}
\end{picture}
\end{tabular}
\end{center}

We say that the value of the \TT{child} attribute of \TT{@1} is
the set to two elements, \TT{@2} and \TT{@3}.

The differences between \TT{=}, \TT{=>}, and \TT{=>{}>} in a
{\em object-representation} relate
to what is done when an object or attribute label previously exists.

\ttmkey{=}{in {\em object-representation}}
indicates that the object being represented should not previously
exist, or if it does exist, must not have been defined by any previous
{\em object-representation} (it may have been defined as the value of an
attribute).  Second, any attribute label represented in the
{\em object-representation}, if it previously exists because it was part of a
{\em double-attribute-representation} of another {\em object-representation},
must be represented with exactly the same flags as it already has.

At the other extreme,
\ttmkey{=>{}>}{in {\em object-representation}}
adds to existing objects.
The object being represented can previously exist.  Any attribute
representation in the {\em object-representation} creates a new attribute value
to be added to the set of values of the given attribute label (which
is created if it did not previously exist).
Any flags on an attribute label are added to the flags of the label if
that label already exists.

\ttmkey{=>}{in {\em object-representation}}
is like \TT{=>{}>}
except that the {\em object-representation} cannot
add new values to previously existing attributes of the object being
represented.
More precisely, the {\em attribute-label} of any
{\em attribute-representation}
in the {\em object-representation} must not have previously (before the
{\em object-representa\-tion} is read)
been an {\em attribute-label} of the represented object.
Thus \TT{=>} is used to introduce new attributes to an existing object.

However, if \TT{=>} is used to add a double attribute to
object $O1$ whose value is object $O2$, then while
the {\em double-attribute-label}
of the added attribute must \underline{not} have previously existed for $O1$,
the {\em reverse-attribute-label} \underline{may} have previously existed
for $O2$.

Double attributes must have only one representation.  If they
are given two representations, one for each end of the attribute
(double headed arrow),
\underline{two} identical double attributes (two double headed arrows with the
same end points and labels) will be created.
Usually one end of a double attribute is
thought of as the primary end, and its object representation is used to
include the sole representation of the double attribute.

The {\em object-identifier} \ttkey{@0} is special; it always names
a particular object, the \ttnbdkey{GLOBAL} object,
whose attributes are called \skey{global variables}.  One of the global
variables is named \TT{.GLOBAL} and has as its value the \TT{.GLOBAL}
object itself, a situation which can be achieved by the
{\em object-representation}:

\begin{indpar}\begin{verbatim}
@0=>:
    .GLOBAL = @0
\end{verbatim}\end{indpar}

Labels beginning with `\ttkey{.}' are reserved for use by
the RECKON system, and should not be defined by RECKON users.  \TT{.GLOBAL}
is an example of such a label.

The RECKON parser (\secref{PARSING}) parses {\em object-representations}.
However, within {\em object-representa\-tions} that begin with
\TT{@} the parser only recognizes brackets and separators, and does
not recognize operators, numeric units, formats, sentence and phrase
terminators, etc.\label{RAW-PARSING}  The parser does recognize
lists as described in the next sections.  In order to ensure that
the parser does not mistakenly recognize {\em separators} and {\em marks}
as delimiting lists,
both {\em separators} and {\em marks} must be quoted as per \TT{"} when
they are used in {\em atom-names}.

\subsection{Lists}

Objects are implemented so that attributes whose labels are small
strictly positive integers can be accessed with more efficiency
than other attributes.  If an object has attributes with consecutive
labels from \TT{1} to $N$, with no gaps,
then these values are said to form a \key{list} that is represented
by the object.  An example is

\begin{indpar}\begin{verbatim}
@93 =:
    1 = this
    2 = is
    3 = a
    4 = sentence
    .type = s
    .initiator = "`"
    .terminator = "'"
    capitalize = true
    end mark = "."
\end{verbatim}\end{indpar}

which represents the list
\begin{indpar}
\verb|this is a sentence|
\end{indpar}

but also has some additional attributes, labeled \TT{.type},
\TT{.initiator}, \TT{.terminator},
\TT{cap\-it\-al\-ize}, and \TT{end mark}.
An alternative raw {\em object-representation}
to the one just given is:

\begin{indpar}\begin{verbatim}
@93 = this is a sentence:
    .type = s
    .initiator = "`"
    .terminator = "'"
    capitalize = true
    end mark = "."
\end{verbatim}\end{indpar}

The {\em atom-names} and {\em object-identifiers} in an {\em object-list}
within an {\em object-representation} name atoms or object identifiers that
are assigned as values of the attributes labeled \TT{1}, \TT{2},
\TT{3}, \ldots.  Additional attribute values can be given by
following the {\em object-list} by a line ending `\TT{:}' that begins an
{\em attribute-representation-subparagraph}, which in this case
gives values to the \TT{.type}, \TT{.initiator}, \TT{.terminator},
\TT{capitalize}, and \TT{end mark} attributes.

\subsection{Cooked Representations}

If an {\em object-representation} contains a bracketed list, operators
are recognized by the parser within this list, and the representation
is said to be `\key{cooked}' instead of raw.  Also if
the \TT{=>} and \TT{=>{}>} {\em data-assignment-operators}
are used in place of the \TT{=} within any {\em attribute-representation}
in the {\em object-representation}, that representation is
said to be `cooked'.

The syntax of {\em object-representations} is augmented by adding
the following definition of {\em bracketed-list}:

\begin{indpar}[0.5in]

\begin{tabular}{l}
\emkey{bracketed-list}\label{BRACKETED-LIST}
    \begin{tabular}[t]{rlcl}
    ::= & \TT{(} {\em prefix-0-list} \TT{)} &
    $|$ & \TT{[} {\em prefix-0-list} \TT{]} \\
    $|$ & \TT{`} {\em prefix-0-list} \TT{'} \\
    $|$ & \TT{\{|} {\em prefix-0-list} \TT{|\}} &
    $|$ & \TT{\{<} {\em prefix-0-list} \TT{>\}} \\
    $|$ & \TT{\{(} {\em prefix-0-list} \TT{)\}} &
    $|$ & \TT{\{[} {\em prefix-0-list} \TT{]\}} \\
    $|$ & \TT{\{`} {\em prefix-0-list} \TT{'\}} &
    $|$ & \TT{\{\{} {\em prefix-0-list} \TT{\}\}} \\
    $|$ & \TT{\{} {\em m-type} {\em prefix-0-list} {\em m-type} \TT{\}} \\
    $|$ & \TT{\{} {\em w-type} {\em attributes}\QMARK{}
          \TT{|} {\em prefix-0-list}
          \TT{|\}} \\
    $|$ & \TT{\{} {\em w-type} {\em attributes}\QMARK{}
          \TT{||\}} \\
    $|$ & \TT{\{|} {\em prefix-0-list}
          \TT{|} {\em w-type} {\em attributes}\QMARK{} \TT{\}} \\
    $|$ & \TT{\{||} {\em w-type} {\em attributes}\QMARK{} \TT{\}} \\
    $|$ & \multicolumn{3}{l}{\TT{\{} {\em w-type} {\em attributes}\QMARK{}
          \TT{| } {\em prefix-0-list}
          \TT{|} {\em w-type} {\em attributes}\QMARK{} \TT{\}}} \\
    $|$ & \TT{\{\}} \\
    \end{tabular}
\end{tabular}

\begin{tabular}{ll}
In the above: & `\TT{||}' may be used to abbreviate `\TT{|~|}'
		(two separate `\TT{|}'s) \\
              & \TT{\{\}} may be used to abbreviate \TT{\{||\}}
	        (the empty list: see below)
\end{tabular}

\begin{tabular}{l}
\emkey{m-type} ::= {\em mark} other than \TT{<} or \TT{>}
\end{tabular}

\begin{tabular}{l}
\emkey{w-type} ::= {\em name}\pagnote{NAME}
\end{tabular}

\begin{tabular}{l}
\emkey{type} ::= {\em m-type} $|$ {\em w-type}
\end{tabular}

\begin{tabular}{l}
\emkey{list-opening}
    \begin{tabular}[t]{rl}
    ::= & \TT{(} $|$ \TT{[} $|$ \TT{`} $|$ \TT{\{|} $|$
          \TT{\{<} $|$ \TT{\{(} $|$ \TT{\{[} $|$ \TT{\{`} $|$ \TT{\{\{} \\
    $|$ & \TT{\{} {\em m-type} \\
    $|$ & \TT{\{} {\em w-type} {\em attributes}\QMARK{} \TT{|} \\
    \end{tabular}
\end{tabular}

\begin{tabular}{l}
\emkey{list-closing}
    \begin{tabular}[t]{rl}
    ::= & \TT{)} $|$ \TT{]} $|$ \TT{'} $|$ \TT{|\}} $|$
          \TT{>\}} $|$ \TT{)\}} $|$ \TT{]\}} $|$ \TT{'\}} $|$ \TT{\}\}} \\
    $|$ & {\em m-type} \TT{\}} \\
    $|$ & \TT{|} {\em w-type} {\em attributes}\QMARK{} \TT{\}} \\
    \end{tabular}
\end{tabular}

\begin{tabular}{l}
\emkey{prefix-n-list}
    ::= \{ {\em prefix-n} {\em prefix-n+1-list} \}\STAR{}
    $|$ {\em simple-list} \\
\end{tabular}

\begin{tabular}{l}
\emkey{prefix-n} ::= {\em prefix} \\
\end{tabular}

\begin{tabular}{l}
\emkey{prefix}\label{PREFIX}
    ::= \TT{\{} {\em m-type} \TT{\}}
    $|$ \TT{\{} {\em w-type} {\em attributes}\QMARK{} \TT{\}}
\\[1ex]
\end{tabular}

\begin{center}
All {\em prefix-n}'s in a {\em prefix-n-list} have the same type.
\end{center}

\begin{tabular}{l}
\emkey{simple-list} ::= {\em list-element}\STAR{} \\
\emkey{list-element} ::= {\em single-attribute-value}%
                         \pagnote{SINGLE-ATTRIBUTE-VALUE}
\end{tabular}

\begin{tabular}{l}
\emkey{attributes}
    \begin{tabular}[t]{rl}
    ::= & \TT{:} {\em attribute} \{ \TT{,} {\em attribute} \}\STAR{} \\
    $|$ & \TT{\{:} {\em attribute} \{ \TT{<*>} {\em attribute} \}\STAR{}
          \TT{:\}} \\
    \end{tabular}
\end{tabular}

\begin{tabular}{l}
\emkey{attribute}
    \begin{tabular}[t]{rl}
    ::= & {\em attribute-representation} \\
    $|$ & {\em single-attribute-label}\pagnote{SINGLE-ATTRIBUTE-LABEL} \\
    $|$ & \TT{no} {\em single-attribute-label} \\
    \end{tabular}
\end{tabular}

\begin{tabular}{l}
\emkey{attribute-representation} \\
\hspace*{0.3in}
    \begin{tabular}[t]{rl}
    ::= & {\em single-attribute-representation}%
          \pagnote{SINGLE-ATTRIBUTE-REPRESENTATION}
	  with \TT{=} {\em attribute-assignment-operator} \\
    $|$ & {\em double-attribute-representation}%
          \pagnote{DOUBLE-ATTRIBUTE-REPRESENTATION}
    \end{tabular}
\end{tabular}

\end{indpar}

{\em Prefixes}, {\em types}, and {\em attributes} are explained
below.  First we give some examples involving just parsed untyped
{\em bracketed-lists} without {\em attributes}.  In some of these
the fact is used that
`\TT{\{!~!\}}' brackets translate to a list of \TT{.type} \TT{"!"}.

As a first example,

\begin{indpar}\begin{verbatim}
@93 = `This is a sentence.'
\end{verbatim}\end{indpar}

is the cooked representation of the object

\begin{center}
\begin{tabular}[b]{@{}l@{}}
\verb/@93 =:/\\
\verb|    1 = this|\\
\verb|    2 = is|\\
\verb|    3 = a|\\
\verb|    4 = sentence|\\
\verb|    .type = s|\\
\verb|    .initiator = "`"|\\
\verb|    .terminator = "'"|\\
\verb|    capitalize = true|\\
\verb|    end mark = "."|\\
\end{tabular}
~~~~~
\begin{picture}(5.6,2.0)
\put(0,0){\framebox(5.6,2.0){}}
\put(0.2,1.50){\makebox(4.8,0.3){\tt @93}}
\put(2.6,1.65){\oval(4.8,0.3)}
\put(0.60,1.50){\vector(0,-1){0.4}}
\put(0.55,1.35){\makebox(0,0)[r]{\tt 1}}
\put(0.60,1.00){\makebox(0,0)[c]{\tt this}}
\put(0.95,1.50){\vector(0,-1){0.4}}
\put(0.90,1.35){\makebox(0,0)[r]{\tt 2}}
\put(0.95,1.00){\makebox(0,0)[c]{\tt is}}
\put(1.20,1.50){\vector(0,-1){0.4}}
\put(1.15,1.35){\makebox(0,0)[r]{\tt 3}}
\put(1.20,1.00){\makebox(0,0)[c]{\tt a}}
\put(1.70,1.50){\vector(0,-1){0.4}}
\put(1.65,1.35){\makebox(0,0)[r]{\tt 4}}
\put(1.70,1.00){\makebox(0,0)[c]{\tt sentence}}
\put(2.30,1.50){\vector(0,-1){0.6}}
\put(2.25,1.35){\makebox(0,0)[r]{\tt .type}}
\put(2.30,0.80){\makebox(0,0)[c]{\tt s}}
\put(2.60,1.50){\vector(0,-1){1.2}}
\put(2.55,0.55){\makebox(0,0)[r]{\tt .initiator}}
\put(2.60,0.20){\makebox(0,0)[c]{\tt "`"}}
\put(3.00,1.50){\vector(0,-1){1.2}}
\put(3.05,0.55){\makebox(0,0)[l]{\tt .terminator}}
\put(3.00,0.20){\makebox(0,0)[c]{\tt "'"}}
\put(4.15,1.50){\vector(0,-1){0.4}}
\put(4.10,1.35){\makebox(0,0)[r]{\tt capitalize}}
\put(4.15,1.00){\makebox(0,0)[c]{\tt true}}
\put(4.60,1.50){\vector(0,-1){0.6}}
\put(4.65,1.35){\makebox(0,0)[l]{\tt end mark}}
\put(4.60,0.80){\makebox(0,0)[c]{\tt "."}}
\end{picture}
\end{center}


The second example contains simple code:

\begin{indpar}\begin{verbatim}
@45 = {! straight 3.2; left; straight (y + 9.4) !}
\end{verbatim}\end{indpar}

is the cooked representation of the objects

\begin{center}
\begin{tabular}[b]{@{}l@{}}
\verb/@42 =:/\\
\verb|    1 = straight|\\
\verb|    2 = 3.2|\\
\verb/@43 =:/\\
\verb|    1 = "+"|\\
\verb|    2 = y|\\
\verb|    3 = 9.4|\\
\verb|    .initiator = "("|\\
\verb|    .terminator = ")"|\\
\verb/@44 =:/\\
\verb|    1 = straight|\\
\verb|    2 = @43|\\
\verb/@45 =:/\\
\verb|    1 = @42|\\
\verb|    2 = left|\\
\verb|    3 = @44|\\
\verb|    .type = "!"|\\
\verb|    .separator = ";"|\\
\end{tabular}
~~~~~
\begin{picture}(4.4,3.7)
\put(0,0){\framebox(4.4,3.7){}}
\put(1.5,0.0){
\put(0.0,0.90){\makebox(2.0,0.3){\tt @43}}
\put(1.0,1.05){\oval(2.0,0.3)}
\put(0.40,0.90){\vector(0,-1){0.4}}
\put(0.35,0.75){\makebox(0,0)[r]{\tt .initiator}}
\put(0.40,0.40){\makebox(0,0)[c]{\tt "("}}
\put(0.70,0.90){\vector(0,-1){0.6}}
\put(0.65,0.75){\makebox(0,0)[r]{\tt 1}}
\put(0.70,0.20){\makebox(0,0)[c]{\tt "+"}}
\put(1.00,0.90){\vector(0,-1){0.6}}
\put(0.95,0.75){\makebox(0,0)[r]{\tt 2}}
\put(1.00,0.20){\makebox(0,0)[c]{\tt y}}
\put(1.30,0.90){\vector(0,-1){0.6}}
\put(1.25,0.75){\makebox(0,0)[r]{\tt 3}}
\put(1.30,0.20){\makebox(0,0)[c]{\tt 9.4}}
\put(1.60,0.90){\vector(0,-1){0.4}}
\put(1.60,0.40){\makebox(0,0)[c]{\tt ")"}}
\put(1.65,0.75){\makebox(0,0)[l]{\tt .terminator}}
}
\put(0.7,1.3){
\put(0.0,0.50){\makebox(1.2,0.3){\tt @42}}
\put(0.60,0.65){\oval(1.2,0.3)}
\put(0.30,0.50){\vector(0,-1){0.3}}
\put(0.25,0.35){\makebox(0,0)[r]{\tt 1}}
\put(0.30,0.10){\makebox(0,0)[c]{\tt straight}}
\put(0.90,0.50){\vector(0,-1){0.3}}
\put(0.85,0.35){\makebox(0,0)[r]{\tt 2}}
\put(0.90,0.10){\makebox(0,0)[c]{\tt 3.2}}
}
\put(2.3,1.3){
\put(0.0,0.50){\makebox(1.2,0.3){\tt @44}}
\put(0.60,0.65){\oval(1.2,0.3)}
\put(0.30,0.50){\vector(0,-1){0.3}}
\put(0.25,0.35){\makebox(0,0)[r]{\tt 1}}
\put(0.30,0.10){\makebox(0,0)[c]{\tt straight}}
\put(0.90,0.50){\vector(0,-1){0.6}}
\put(0.85,0.35){\makebox(0,0)[r]{\tt 2}}
}
\put(0.3,2.7){
\put(0.0,0.50){\makebox(3.2,0.3){\tt @45}}
\put(1.60,0.65){\oval(3.2,0.3)}
\put(0.80,0.50){\vector(0,-1){0.3}}
\put(0.75,0.35){\makebox(0,0)[r]{\tt .type}}
\put(0.80,0.10){\makebox(0,0)[c]{\TT{"!"}}}
\put(1.30,0.50){\vector(0,-1){1.1}}
\put(1.25,0.35){\makebox(0,0)[r]{\tt 1}}
\put(1.70,0.50){\vector(0,-1){0.4}}
\put(1.65,0.30){\makebox(0,0)[r]{\tt 2}}
\put(1.70,0.00){\makebox(0,0)[c]{\tt left}}
\put(2.30,0.50){\vector(0,-1){1.1}}
\put(2.25,0.35){\makebox(0,0)[r]{\tt 3}}
\put(2.70,0.50){\vector(0,-1){0.8}}
\put(2.75,-0.15){\makebox(0,0)[l]{\tt .separator}}
\put(2.70,-0.40){\makebox(0,0)[c]{\tt ";"}}
}
\end{picture}
\end{center}

A third example uses multiple indented lines to represent code, so that

\begin{indpar}\begin{verbatim}
@138 = {! function (x,y):

            if (x > y):
                return y
            else:
                return x
       !}
\end{verbatim}\end{indpar}

is the cooked representation of the object in
Figures~\ref{EXAMPLE-CODE-OBJECT-REPRESENTATION-1}
and~\ref{EXAMPLE-CODE-OBJECT-REPRESENTATION-2}.
Note that here the \TT{:} indentation mark is used to introduce
subparagraphs within the code,
and not {\em attribute-representations}.


\begin{boxedfigure}

\begin{center}
\begin{tabular}[t]{l@{\hspace*{1in}}l}
\begin{tabular}[t]{l}
\verb/@130 =:/\\
\verb|    1 = x|\\
\verb|    2 = y|\\
\verb|    .separator = ","|\\
\verb|    .initiator = "("|\\
\verb|    .terminator = ")"|\\
\verb/@131 =:/\\
\verb|    1 = ">"|\\
\verb|    2 = x|\\
\verb|    3 = y|\\
\verb|    .initiator = "("|\\
\verb|    .terminator = ")"|\\
\verb/@132 =:/\\
\verb|    1 = return|\\
\verb|    2 = y|\\
\verb|    .type = ":"|\\
\verb/@133 =:/\\
\verb|    1 = if|\\
\verb|    2 = @131|\\
\verb|    3 = @132|\\
\end{tabular} & \begin{tabular}[t]{l}
\verb/@134 =:/\\
\verb|    1 = return|\\
\verb|    2 = x|\\
\verb|    .type = ":"|\\
\verb/@135 =:/\\
\verb|    1 = else|\\
\verb|    2 = @134|\\
\verb/@136 =:/\\
\verb|    1 = @133|\\
\verb|    2 = @135|\\
\verb|    .type = ":"|\\
\verb|    .separator = "<*>"|\\
\verb/@137 =:/\\
\verb|    1 = function|\\
\verb|    2 = @130|\\
\verb|    3 = @136|\\
\verb|    .type = "!"|\\
\end{tabular}
\end{tabular}
\end{center}
\vspace*{-3ex}
\caption{Example Code Object Representation I}
\label{EXAMPLE-CODE-OBJECT-REPRESENTATION-1}
\end{boxedfigure}

\begin{boxedfigure}

\begin{center}
\begin{picture}(4.0,5.5)
\put(0.6,0.0){
\put(0.0,0.50){\makebox(2.0,0.3){\tt @131}}
\put(1.0,0.65){\oval(2.0,0.3)}
\put(0.25,0.50){\vector(0,-1){0.25}}
\put(0.20,0.40){\makebox(0,0)[r]{\tt .initiator}}
\put(0.25,0.15){\makebox(0,0)[c]{\tt "("}}
\put(0.70,0.50){\vector(0,-1){0.25}}
\put(0.65,0.40){\makebox(0,0)[r]{\tt 1}}
\put(0.70,0.15){\makebox(0,0)[c]{\tt ">"}}
\put(1.00,0.50){\vector(0,-1){0.25}}
\put(0.95,0.40){\makebox(0,0)[r]{\tt 2}}
\put(1.00,0.15){\makebox(0,0)[c]{\tt x}}
\put(1.30,0.50){\vector(0,-1){0.25}}
\put(1.25,0.40){\makebox(0,0)[r]{\tt 3}}
\put(1.30,0.15){\makebox(0,0)[c]{\tt y}}
\put(1.75,0.50){\vector(0,-1){0.25}}
\put(1.80,0.40){\makebox(0,0)[l]{\tt .terminator}}
\put(1.75,0.15){\makebox(0,0)[c]{\tt ")"}}
}
\put(1.4,1.4){
\put(0.0,0.50){\makebox(1.3,0.3){\tt @132}}
\put(0.65,0.65){\oval(1.3,0.3)}
\put(0.20,0.50){\vector(0,-1){0.25}}
\put(0.15,0.40){\makebox(0,0)[r]{\tt .type}}
\put(0.20,0.15){\makebox(0,0)[c]{\tt ":"}}
\put(0.70,0.50){\vector(0,-1){0.25}}
\put(0.65,0.40){\makebox(0,0)[r]{\tt 1}}
\put(0.70,0.15){\makebox(0,0)[c]{\tt return}}
\put(1.15,0.50){\vector(0,-1){0.25}}
\put(1.10,0.40){\makebox(0,0)[r]{\tt 3}}
\put(1.15,0.15){\makebox(0,0)[c]{\tt y}}
}
\put(2.9,0.7){
\put(0.0,0.50){\makebox(1.3,0.3){\tt @134}}
\put(0.65,0.65){\oval(1.3,0.3)}
\put(0.20,0.50){\vector(0,-1){0.25}}
\put(0.15,0.40){\makebox(0,0)[r]{\tt .type}}
\put(0.20,0.15){\makebox(0,0)[c]{\tt ":"}}
\put(0.70,0.50){\vector(0,-1){0.25}}
\put(0.65,0.40){\makebox(0,0)[r]{\tt 1}}
\put(0.70,0.15){\makebox(0,0)[c]{\tt return}}
\put(1.15,0.50){\vector(0,-1){0.25}}
\put(1.10,0.40){\makebox(0,0)[r]{\tt 3}}
\put(1.15,0.15){\makebox(0,0)[c]{\tt x}}
}
\put(0.2,2.0){
\put(0.0,0.50){\makebox(1.2,0.3){\tt @133}}
\put(0.60,0.65){\oval(1.2,0.3)}
\put(0.30,0.50){\vector(0,-1){0.25}}
\put(0.25,0.40){\makebox(0,0)[r]{\tt 1}}
\put(0.30,0.15){\makebox(0,0)[c]{\tt if}}
\put(0.60,0.50){\line(0,-1){0.45}}
\put(0.50,0.05){\oval(0.2,0.2)[br]}
\put(0.50,-0.05){\line(-1,0){0.40}}
\put(0.10,-0.15){\oval(0.2,0.2)[tl]}
\put(0.00,-0.15){\line(0,-1){1.10}}
\put(0.10,-1.25){\oval(0.2,0.2)[bl]}
\put(0.10,-1.35){\vector(1,0){0.30}}
\put(0.55,0.40){\makebox(0,0)[r]{\tt 2}}
\put(0.90,0.50){\line(0,-1){0.35}}
\put(1.00,0.15){\oval(0.2,0.2)[bl]}
\put(1.00,0.05){\vector(1,0){0.2}}
\put(0.85,0.40){\makebox(0,0)[r]{\tt 3}}
}
\put(2.9,2.0){
\put(0.0,0.50){\makebox(0.8,0.3){\tt @135}}
\put(0.40,0.65){\oval(0.8,0.3)}
\put(0.20,0.50){\vector(0,-1){0.25}}
\put(0.15,0.40){\makebox(0,0)[r]{\tt 1}}
\put(0.20,0.15){\makebox(0,0)[c]{\tt else}}
\put(0.60,0.50){\vector(0,-1){1.0}}
\put(0.55,0.40){\makebox(0,0)[r]{\tt 2}}
}
\put(1.5,2.4){
\put(0.05,1.00){\makebox(1.8,0.3){\tt @136}}
\put(0.95,1.15){\oval(1.8,0.3)}
\put(0.40,1.00){\vector(0,-1){0.25}}
\put(0.35,0.90){\makebox(0,0)[r]{\tt .type}}
\put(0.40,0.65){\makebox(0,0)[c]{\tt ":"}}
\put(0.70,1.00){\line(0,-1){0.65}}
\put(0.60,0.35){\oval(0.2,0.2)[br]}
\put(0.60,0.25){\vector(-1,0){0.70}}
\put(0.65,0.90){\makebox(0,0)[r]{\tt 1}}
\put(1.10,1.00){\line(0,-1){0.65}}
\put(1.20,0.35){\oval(0.2,0.2)[bl]}
\put(1.20,0.25){\vector(1,0){0.20}}
\put(1.05,0.90){\makebox(0,0)[r]{\tt 2}}
\put(1.50,1.00){\vector(0,-1){0.25}}
\put(1.55,0.90){\makebox(0,0)[l]{\tt .separator}}
\put(1.50,0.65){\makebox(0,0)[c]{\tt "<*>"}}
}
\put(0.6,3.2){
\put(0.2,1.00){\makebox(1.3,0.3){\tt @130}}
\put(0.85,1.15){\oval(1.3,0.3)}
\put(0.40,1.00){\vector(0,-1){0.25}}
\put(0.35,0.90){\makebox(0,0)[r]{\tt .initiator}}
\put(0.40,0.65){\makebox(0,0)[c]{\tt "("}}
\put(0.70,1.00){\vector(0,-1){0.25}}
\put(0.65,0.90){\makebox(0,0)[r]{\tt 1}}
\put(0.70,0.65){\makebox(0,0)[c]{\tt x}}
\put(1.00,1.00){\vector(0,-1){0.25}}
\put(0.95,0.90){\makebox(0,0)[r]{\tt 2}}
\put(1.00,0.65){\makebox(0,0)[c]{\tt y}}
\put(1.30,1.00){\vector(0,-1){0.25}}
\put(1.35,0.90){\makebox(0,0)[l]{\tt .terminator}}
\put(1.30,0.65){\makebox(0,0)[c]{\tt ")"}}
\put(1.50,1.15){\vector(1,0){1.0}}
\put(1.55,1.25){\makebox(0,0)[l]{\tt .separator}}
\put(2.55,1.15){\makebox(0,0)[l]{\tt ","}}
}
\put(0.0,4.5){
\put(0.1,0.50){\makebox(4.0,0.30){\tt @137}}
\put(1.90,0.65){\oval(4.0,0.3)}
\put(0.20,0.50){\vector(0,-1){0.25}}
\put(0.15,0.40){\makebox(0,0)[r]{\tt .type}}
\put(0.20,0.15){\makebox(0,0)[c]{\tt "!"}}
\put(0.90,0.50){\vector(0,-1){0.25}}
\put(0.85,0.40){\makebox(0,0)[r]{\tt 1}}
\put(0.90,0.15){\makebox(0,0)[c]{\tt function}}
\put(1.45,0.50){\vector(0,-1){0.5}}
\put(1.40,0.40){\makebox(0,0)[r]{\tt 2}}
\put(3.60,0.50){\line(0,-1){1.35}}
\put(3.50,-0.85){\oval(0.2,0.2)[br]}
\put(3.50,-0.95){\vector(-1,0){0.15}}
\put(3.55,0.40){\makebox(0,0)[r]{\tt 3}}
}
\end{picture}
\end{center}

\caption{Example Code Object Representation II}
\label{EXAMPLE-CODE-OBJECT-REPRESENTATION-2}
\end{boxedfigure}

\newpage

Cooked representations may replace raw object identifiers in the
description of other objects, as in

\begin{indpar}\begin{verbatim}
@291 =:
      text = `This is a sentence.'
      outline = {! straight 3.2, left, straight (y + 9.4) !}
      min = {! function (x,y):

                  if (x > y):
                      return y
                  else:
                      return x
	    !}
\end{verbatim}\end{indpar}

is the cooked representation of the object

\begin{indpar}\begin{verbatim}
@291 =:
    text = @93
    outline = @45
    min = @137
\end{verbatim}\end{indpar}

given the above examples.

One question left unanswered by the discussion so far is whether

\begin{indpar}\begin{verbatim}
@291 =:
    text A = `This is a sentence.'
    text B = `This is a sentence.'
\end{verbatim}\end{indpar}

represents

\begin{indpar}\begin{verbatim}
@291 =:
    text A = @93
    text B = @93
\end{verbatim}\end{indpar}

or instead

\begin{indpar}\begin{verbatim}
@291 =:
    text A = @93
    text B = @999
\end{verbatim}\end{indpar}

where object \TT{@999} happens to have the same structure as
object \TT{@93}.  The default is to make both \TT{text A}
and \TT{text B} be the same object, \TT{@93}, and to make
that object `immutable', meaning that it cannot be changed.  The
rule is that unless otherwise indicated, only immutable objects
have the property that their cooked representations can replace
their raw object identifiers in the cooked representations of other
objects.

We now elaborate on the syntax and internal representation
of {\em bracketed-lists}.

A {\em list-closing} must match the {\em list-opening} of the last unclosed
list.  The closing `\TT{)}' matches only `\TT{(}', the closing
`\TT{]}' matches only `\TT{[}', and the
closing `\TT{'}' matches only `\TT{`}'.

Any `\TT{\}}' must match a corresponding `\TT{\{}', and in addition,
the lexemes before the `\TT{\}}' must match, though not
exactly, the lexemes after the `\TT{\{}'.  Specifically, any
`\TT{\}}' must be proceeded by a
`\TT{|}', `\TT{>}', `\TT{)}', `\TT{]}', `\TT{'}', `\TT{\}}',
`{\em m-type}', or `\TT{|} {\em w-type} {\em attributes}\QMARK{}' phrase,
and the corresponding `\TT{\{}' must be followed respectively
by a
`\TT{|}', `\TT{<}', `\TT{(}', `\TT{[}', `\TT{`}', `\TT{\{}',
`{\em m-type}', or `{\em w-type} {\em attributes}\QMARK{} \TT{|}' phrase,
and if either list opening or list closing has a {\em type}, both must
have the same {\em type}.
As special cases,
`\TT{\{} {\em w-type} {\em attributes}\QMARK{} \TT{|}' can be matched by
`\TT{|\}}' and `\TT{\{|}' can match
`\TT{|} {\em w-type} {\em attributes}\QMARK{} \TT{\}}'.

A beginning `\TT{\{||}' is equivalent to `\TT{\{|~|}', that is, in this
case the two `\TT{|}' are treated as separate 1-character lexemes, and
the `\TT{|~|}' denotes an empty list.  Similarly `\TT{||\}}' is
equivalent to `\TT{|~|\}}' and denotes an empty list.

A `\TT{\}}' can also end a {\em prefix}, which is a separate case.

A `\TT{\{}' that does not begin a {\em list-opening} or {\em prefix} is
in error, as is a `\TT{\}}' that does not end a {\em list-opening} or
{\em prefix}.

A {\em list-closing} is recognized even if it fails to match the
last unclosed {\em list-opening}, but in this case the {\em list-closing}
is treated as an error, and is either ignored if it does not
match any unclosed {\em list-opening}, or generates missing
{\em list-closings} if the {\em list-closing} matches some non-last unclosed
{\em list-opening}.

{\em Simple-lists} may be parsed after they have been read.
Operators, including
separators such as the semi-colon `\TT{;}'
and comma `\TT{,}', are recognized by such a parse.  See
\itemref{PARSING} for details.

\ikey{Untyped bracketed lists}{untyped bracketed list}
are given an \ttdmkey{initiator}{of bracketed list}
equal to their {\em list-opening} and a
\ikey{\TT{.termin\-ator}}{terminator@{\tt .terminator}!of bracketed list}
equal to their {\em list-closing}.
This includes lists with \TT{.initiators} \TT{"("}, \TT{"["}, \TT{"`"},
\TT{"\{<"}, \TT{"\{("}, \TT{"\{["}, \TT{"\{`"}, \TT{"\{\{"},
and \TT{.terminators} \TT{")"}, \TT{"]"}, \TT{"'"},
\TT{">\}"}, \TT{")\}"}, \TT{"]\}"}, \TT{"'\}"}, \TT{"\}\}"},
but \underline{not} `\TT{\{|\ldots|\}}' lists which are a special case.

\ikey{Typed bracketed lists}{typed bracketed list} are given a
\ttdmkey{type}{of list} attribute equal to their {\em m-type} or their
dequoted {\em w-type}.

Exceptions are
lists with the form
`\TT{\{|} {\em prefix-0-list} \TT{|\}}'.
and lists with {\em w-type} \TT{""}
(the empty {\em quoted-string}).
These are not given
any \TT{.type}, \TT{.initiator}, or \TT{.terminator}.
Thus `\TT{\{""||\}}' and `\TT{\{||\}}' both
denote the empty list with no attributes at all.
This can also be abbreviated by `\TT{\{\}}'.

The elements of the
list become the attributes labeled \TT{1}, \TT{2}, \TT{3}, \ldots.
In general the attributes of an object with these labels are referred
to as the \smkey{list element}s{of object} of the object, and their
sequence is the \mkey{list}{of object} of the object.

{\em Attributes} in a {\em w-typed} bracketed list can be the same as
raw {\em attribute-representations}, or they can be just a label with
no flags or value.  In the latter case, if
the {\em attribute-label} does not begin with the word `\TT{no}',
the value `\TT{true}' is implied, and if the label does begin with
`\TT{no}', the `\TT{no}' is removed from the beginning of the label
and the value `\TT{false}' is implied.
If no value is given, it is an error if the label is just
`\TT{no}' by itself.

Some examples are as follows.  First:
\begin{center}
\tt \{| a b c |\}
\end{center}
is equivalent to, among other things, any of the following:
\begin{center}
\begin{tabular}{l}
\tt \{""| a b c |\} \\
\tt \{"":~1 = a, 2 = b, 3 = c ||\} \\
\tt \{"":~3 = c, 1 = a, 2 = b ||\} \\
\tt \{| a b | "":~3 = c \} \\
\tt \{"":~3 = c | a | "":~2 = b \}
\end{tabular}
\end{center}

Second:

\begin{center}
\tt \{my list:~format, no capitalize, tweak = 5| a b c |\}
\end{center}
is equivalent to
\begin{center}
\tt
\begin{tabular}{@{}l@{}}
\{my list:~format = true, capitalize = false, \\
~~~~~~~~~~~~~~~~~~~~~~~~~tweak = 5| a b c |\} \\
\end{tabular}
\end{center}

{\em Prefixes} are an unusual kind of separator
that must appear at the beginning of the list as well as between
elements of the list, and their appearance at the beginning of the list
announces their use as a separator for the list and also establishes their
precedence relative to other {\em prefix} separators.
More explicitly, the {\em type} of the first {\em prefix-n}
in a {\em prefix-n-list}
specifies that all {\em prefixes} of that {\em type} shall be {\em prefix-n}'s,
and {\em prefixes} of other {\em types} shall not be {\em prefix-n}'s.

Algorithmically, during a left to right scan of a {\em prefix-0-list},
there is a stack of `\key{open list prefix types}'.  Initially we are
at the beginning of a sublist which is the entire {\em prefix-0-list}.
Then:
\begin{enumerate}

\item
When a {\em prefix} of a type that is not in the stack appears at the
beginning of a sublist, its type is pushed into the stack, and a sublist
of that type beginning just after the {\em prefix} is begun.

\item
When a {\em prefix} of a type that is in the stack appears, it pops the
stack until the type is the top of the stack.  Sublists of popped types
are terminated.  The sublist of the type now at the top of the stack
is terminated.  A new sublist of that type beginning just after the
{\em prefix} is begun.

\item
When a {\em prefix} of a type that is not in the stack appears inside
(not at the beginning of) a sublist, it is announced as an error and
ignored.

\item
Each sublist is associated with a {\em prefix} that begins the
sublist.  The type and attributes of this {\em prefix} become the
type and attributes of the sublist.

\end{enumerate}


These rules imply that a {\em prefix} that is not in the stack is
in error unless it occurs at the beginning of a {\em prefix-0-list}
or occurs immediately after a {\em prefix} whose type was placed
in the stack.

Thus we have the following example parse of a {\em prefix-0-list}:

\begin{tabular}{lll}
Text	& Separator &  Syntactic Category
\\\hline
\tt \{p\} \{s\} This is a sentence.	& \tt \{p\} & \em prefix-0-list \\
\tt ~~~ \{s\} And another. \\
\tt \{p\} \{s\} And a new \{foo\} paragraph.
\\\hline
\tt \{s\} This is a sentence.	& \tt \{s\} & \em prefix-1-list \\
\tt \{s\} And another.
\\\hline
\tt This is a sentence.	& (none) & \em prefix-2-list
\\\hline
\tt And another. & (none) & \em prefix-2-list
\\\hline
\tt \{s\} And a new \{foo\} paragraph. & \tt \{s\} & \em prefix-1-list
\\\hline
\tt And a new \{foo\} paragraph. & (none) & \em prefix-2-list \\
			       &        & \TT{\{foo\}} is in error \\
			       &        & and is ignored (deleted).
\end{tabular}

The {\em prefix-0-list} in this example is equivalent to:
\begin{indpar}\begin{verbatim}
{|  {p|  {s| This is a sentence . |}
         {s| And another . |} |}
    {p|  {s| And a new paragraph . |} |} |}
             // `{foo}' deleted
\end{verbatim}\end{indpar}

\section{Parsing}
\label{PARSING}

Input is read and parsed to form objects from {\em bracketed-lists}.
These objects are then further parsed to find operators, separators,
numeric units (e.g., \TT{lb} and \TT{\$}), and some other constructions
such as possessives (\TT{George's weight}).  The input to this parsing
is an object element list consisting of atoms and subobjects.

We will refer to the objects being parsed as {\em bracketed-lists}, even
though they are data objects and not strings of lexemes.

Note that the atoms in these lists have \underline{not} been dequoted;
in cooked data representations only atoms outside brackets are dequoted.

Parsing at this point is a top down process.  The parser is organized
into passes which are applied to the object element list in order until
one of the passes succeeds.  The first pass handles operators, the second
numeric units, the third possessives, and the forth dequoting.
If a pass succeeds it may discover subexpressions, which are formed
into objects and parsed independently as they are discovered.
In general parsing modifies the object being parsed.

The standard passes in order from first to last are:

\begin{center}
\begin{tabular}%
  {l@{\hspace*{0.3in}}l@{\hspace*{0.3in}}p{2.2in}}
\bf Pass & \bf Context & \bf Usage \\[1ex]
\TT{suffix} & \TT{expression}
	& split suffixes from words \\
\TT{operators} & \TT{expression}, \TT{text}
	& parse operators \\
\TT{units} & \TT{expression}
	& parse numeric units \\
\TT{dequoting} & \TT{expression}, \TT{text}
	& dequote symbols \\
\end{tabular}
\end{center}

Parsing contexts are described in the next section.

Tables such
as this are constructed from parsing instructions which appear
in a list called the parsing stack.  Parsing instructions can be
pushed into the stack and later popped from the stack in order
to undo their affects.  See \itemref{PARSER-CONTROL} for
details.

\subsection{Parsing Contexts}
\label{PARSING-CONTEXTS}

During parsing both the parsing passes and definitions of parsing units such as
operators are turned on or off by manipulating a \key{parsing context},
which is just a set of \skey{parsing selector}s.  Thus the passes and
definitions appropriate to text processing are turned on by the
`\TT{text}' selector, and those appropriate to code parsing are
turned on by the `\TT{code}' selector.

The parsing context can only be changed by \underline{explicit} brackets.  So,
for example, the \TT{`\ldots'} brackets always set the
parsing context to just the `\TT{text}' selector during the
parse of the \TT{`\ldots'} bracketed list.
As another example, `\TT{(\ldots)}' brackets do not change the
parsing context but instead inherit it from their containing object.

The following is a list of the standard selector-changing brackets:

\begin{center}
\begin{tabular}%
  {l@{\hspace*{0.3in}}l@{\hspace*{0.3in}}l@{\hspace*{0.3in}}p{2.2in}}
\bf Brackets & \bf Context & \bf New Context & \bf Usage \\[1ex]
\TT{\{*\ldots*\}} & all & none & comment \\
\TT{`\ldots'} & all & \TT{text} & text \\
\TT{\{!\ldots!\}} & all & \begin{tabular}[t]{@{}l@{}}
                          \TT{expression}, \\
			  \TT{code}
			  \end{tabular}
    & unevaluated code \\
\TT{\{\{\ldots\}\}} & all & \begin{tabular}[t]{@{}l@{}}
                          \TT{expression}, \\
			  \TT{math}
			  \end{tabular}
    & unevaluated math subexpression \\
\TT{[\ldots]} & \begin{tabular}[t]{@{}l@{}}
              \TT{text}, \\
	      \TT{math}
	      \end{tabular} & \TT{expression}
    & evaluated subexpression in text or math expression \\
\end{tabular}
\end{center}

According to this table, in any parsing context the \TT{\{*\ldots*\}}
brackets turn off all selectors,
the \TT{`\ldots'} brackets change
the context to have just the `\TT{text}' selector,
the \TT{\{!\ldots!\}} brackets change
the context to have both the `\TT{expression}' and `\TT{code} selectors,
and so forth.

Brackets not listed do not change the parsing context.
The \TT{[\ldots]} brackets only change the parsing context if their
containing parsing context has the `\TT{text}' or `\TT{math}' selectors.
None of the brackets change the context if there are no selectors on
in the current parsing context, as is the case inside a \TT{\{*\ldots*\}}
comment (but unquoted brackets are still recognized and must match inside
the comment).

\subsection{Parser Suffix Pass}
\label{PARSER-SUFFIX-PASS}

The \key{parser suffix pass} splits suffixes from words so that
they may be recognized as operators.  Thus `\TT{George's}'
is split to become `\TT{George~'s}'.

The following are standard suffixes:

\begin{center}
\TT{'s} ~~~ \TT{'S}
\end{center}

Suffixes split from words are usually recognized as operators
by the parser operator pass.

\subsection{Parser Operator Pass}
\label{PARSER-OPERATOR-PASS}

The \key{parser operator pass} identifies operators in a subexpression
and reformats subexpressions in which operators are found.  Each
operator can be enabled or disabled according to the current parser
context.

The following are the standard operators enabled by various selectors.

Enabled by `\TT{code}' selector:

\hspace*{0.2in}\begin{tabular}{rll@{\hspace*{2em}}l@{\hspace*{2em}}l}
\hspace*{0.8in} & \hspace*{1.5in} & \hspace*{0.8in} & \hspace*{0.6in} \\[-2ex]

Precedence & Reformatter	& Kind	& Name		& Meaning 
\\[2ex]
-2000	& \TT{separator}	& \TT{nofix}	& \ttkey{<*>}	& separator \\
\end{tabular}

\hspace*{0.2in}\begin{tabular}{rll@{\hspace*{2em}}l@{\hspace*{2em}}l}
\hspace*{0.8in} & \hspace*{1.5in} & \hspace*{0.8in} & \hspace*{0.6in} \\[-2ex]
-1000	& \TT{separator}	& \TT{nofix}	& \ttkey{;}	& separator \\
\end{tabular}

\hspace*{0.2in}\begin{tabular}{rll@{\hspace*{2em}}l@{\hspace*{2em}}l}
\hspace*{0.8in} & \hspace*{1.5in} & \hspace*{0.8in} & \hspace*{0.6in} \\[-2ex]
+0000	& \TT{define}	& \TT{nofix}	& \ttkey{<-{}-}	& define \\
	&			& \TT{afix}
	                        & \ttkey{\TT{\{:~:\}}}
				& block \\
\end{tabular}

\hspace*{0.2in}\begin{tabular}{rll@{\hspace*{2em}}l@{\hspace*{2em}}l}
\hspace*{0.8in} & \hspace*{1.5in} & \hspace*{0.8in} & \hspace*{0.6in} \\[-2ex]
+1000	& \TT{right}		& \TT{nofix}	& \ttkey{=}	& assignment \\
     	& \TT{associative}     	&          	& \ttkey{+=}	& increment \\
     	&               	&          	& \ttkey{-=}	& decrement \\
     	&               	&          	& \ttkey{*=}	& multiply by \\
     	&               	&          	& \ttkey{/=}	& divide by \\
\end{tabular}

Enabled by `\TT{operator}' selector:

\hspace*{0.2in}\begin{tabular}{rll@{\hspace*{2em}}l@{\hspace*{2em}}l}
\hspace*{0.8in} & \hspace*{1.5in} & \hspace*{0.8in} & \hspace*{0.6in} \\[-2ex]

Precedence & Reformatter	& Kind	& Name		& Meaning 
\\[2ex]

+2000	& \TT{separator}	& \TT{nofix}	& \ttkey{,}	& separator \\
\end{tabular}

\hspace*{0.2in}\begin{tabular}{rll@{\hspace*{2em}}l@{\hspace*{2em}}l}
\hspace*{0.8in} & \hspace*{1.5in} & \hspace*{0.8in} & \hspace*{0.6in} \\[-2ex]
+3000	& \TT{unary}	& \TT{nofix}		& \ttkey{NOT}	& logical not \\
+3000	& \TT{infix}	& \TT{nofix}		& \ttkey{BUT NOT}
								& logical but
								  not \\
\end{tabular}

\hspace*{0.2in}\begin{tabular}{rll@{\hspace*{2em}}l@{\hspace*{2em}}l}
\hspace*{0.8in} & \hspace*{1.5in} & \hspace*{0.8in} & \hspace*{0.6in} \\[-2ex]
+4000	& \TT{infix}	& \TT{nofix}		& \ttkey{AND}	& logical and \\
	&			&		& \ttkey{OR}	& logical or \\
\end{tabular}


\hspace*{0.2in}\begin{tabular}{rll@{\hspace*{2em}}l@{\hspace*{2em}}l}
\hspace*{0.8in} & \hspace*{1.5in} & \hspace*{0.8in} & \hspace*{0.6in} \\[-2ex]
+5000 	& \TT{infix to(AND)}
			& \TT{nofix}		& \ttkey{==}	& equal \\
	& 		&		& \ttkey{/=}  & not equal \\
	&			&		& \ttkey{!=}	& ditto \\
	&		      	&		& \ttkey{<}	& less than \\
	&			&		& \ttkey{<=}	& less than or
								  equal \\
	&			&		& \ttkey{=<}	& ditto \\
	&		      	&		& \ttkey{>}	& greater than
									\\
	&			&		& \ttkey{>=}	& greater than
								  or equal \\
	&			&		& \ttkey{=>}	& ditto \\
\end{tabular}

\hspace*{0.2in}\begin{tabular}{rll@{\hspace*{2em}}l@{\hspace*{2em}}l}
\hspace*{0.8in} & \hspace*{1.5in} & \hspace*{0.8in} & \hspace*{0.6in} \\[-2ex]
+6000	& \TT{summation(+,-)}	& \TT{infix}	&  \ttkey{+}	& addition \\
	& 			&		& \ttkey{-}	& subtraction \\
\end{tabular}

\hspace*{0.2in}\begin{tabular}{rll@{\hspace*{2em}}l@{\hspace*{2em}}l}
\hspace*{0.8in} & \hspace*{1.5in} & \hspace*{0.8in} & \hspace*{0.6in} \\[-2ex]
+6100	& \TT{binary}	& \TT{infix}	& \ttkey{/}	& division \\
+6200	& \TT{infix}	& \TT{infix}	& \ttkey{*}
							& multiplication \\
+6300	& \TT{binary}	& \TT{infix}	& \ttkey{\^~}
							& exponentiation \\
\end{tabular}

\hspace*{0.2in}\begin{tabular}{rll@{\hspace*{2em}}l@{\hspace*{2em}}l}
\hspace*{0.8in} & \hspace*{1.5in} & \hspace*{0.8in} & \hspace*{0.6in} \\[-2ex]
+10000	& \TT{right}		& \TT{infix}	& \ttkey{OF}	& attribute \\
     	& \TT{associative}     	&          	& \ttkey{of}	& selector \\
\end{tabular}

\hspace*{0.2in}\begin{tabular}{rll@{\hspace*{2em}}l@{\hspace*{2em}}l}
\hspace*{0.8in} & \hspace*{1.5in} & \hspace*{0.8in} & \hspace*{0.6in} \\[-2ex]
+11000	& \TT{left}		& \TT{infix}	& \ttkey{'S}	& attribute \\
     	& \TT{associative}     	&          	& \ttkey{'s}	& selector \\
\end{tabular}

\hspace*{0.2in}\begin{tabular}{rll@{\hspace*{2em}}l@{\hspace*{2em}}l}
\hspace*{0.8in} & \hspace*{1.5in} & \hspace*{0.8in} & \hspace*{0.6in} \\[-2ex]
none	& \TT{unary}		& \TT{prefix}	&  \ttkey{-}	& minus \\
	& 			& \TT{prefix}	&  \ttkey{+}	& plus \\
	& 			& \TT{prefix}	&  \ttkey{@}	& object
	                                                          identifier \\
\end{tabular}

\hspace*{0.2in}\begin{tabular}{rll@{\hspace*{2em}}l@{\hspace*{2em}}l}
\hspace*{0.8in} & \hspace*{1.5in} & \hspace*{0.8in} & \hspace*{0.6in} \\[-2ex]
none	& \TT{implied}	& \TT{postfix}	&  \ttkey{[...]}
								& subscript \\
	& \multicolumn{2}{l}{~~~~\TT{( subscript )}} \\
\end{tabular}

Enabled by `\TT{text}' selector:

\hspace*{0.2in}\begin{tabular}{rll@{\hspace*{2em}}l@{\hspace*{2em}}l}
\hspace*{0.8in} & \hspace*{1.5in} & \hspace*{0.8in} & \hspace*{0.6in} \\[-2ex]

Precedence & Reformatter	& Kind	& Name		& Meaning 
\\[2ex]
-10000	& \TT{terminator}
			& \TT{nofix}	& \ttkey{.}	& (sub)sentence \\
	& ~~\TT{(s,cap,noend)}
			& \TT{nofix}	& \ttkey{!}	& terminator \\
	& 		& \TT{nofix}	& \ttkey{?}	& \\
	& 		& \TT{nofix}	& \ttkey{;}	& \\
	& 		& \TT{nofix}	& \ttkey{:}	& \\

\end{tabular}

Each entry in these tables describes an `\key{operator parsing instruction}'.
Parsing instructions appear in an ordered list, called the
parsing instruction stack.

List \key{parsing} is performed by a left to right scan.
At each point in the scan an attempt is made to find an
operator instruction whose name begins at the scan point.
Instructions are rejected if the are not enabled by a selector
in the current parsing context.

Other instructions are rejected on the basis of their kind and
the scan point position:
for example, an infix instruction is rejected if the scan point is
at the beginning of the list, at the end of the list, right after
a just-recognized prefix operator, etc.

If there are non-rejected
instructions, those with the longest names beginning at the scan
point are selected, and among these, the one earliest in the parsing
instruction stack is used, unless that instruction has the
`\ttkey{undefined}' flag, in which case the
process is repeated with only shorter names allowed.

With this in mind the possible operator parsing instruction
\ikey{kinds}{kind!of operator parsing instruction}
are recognized according to the following rules:

\begin{indpar}[0.5in]
\hspace*{-0.3in}\ttkey{prefix} \\
To be recognized a prefix operator must begin the list,
or immediately follow a previously recognized prefix, infix, nofix,
or afix operator of less precedence,
or immediately follow a previously recognized prefix operator of
equal precedence.
Also the prefix operator may not end the list.

\hspace*{-0.3in}\ttkey{postfix} \\
To be recognized a postfix operator must immediately follow a non-operator,
or a postfix, nofix, or afix operator of higher
precedence, or another postfix operator of equal precedence.

\hspace*{-0.3in}\ttkey{infix} \\
To be recognized an infix operator must immediately follow a non-operator,
or a postfix, nofix, or afix operator of higher precedence.
Also the infix operator may not end the list.

\hspace*{-0.3in}\ttkey{nofix} \\
A nofix operator is always recognizable.

\hspace*{-0.3in}\ttkey{afix} \\
To be recognized an afix operator must appear after another
operator of equal precedence without any intervening operator
of less precedence.

\end{indpar}

You will note that in the above table some operators defined
to be \TT{nofix} can in fact only be used in \TT{infix} positions.
This is done to minimize coding errors by recognizing misplaced
operators.  However, this cannot be done with operators which
are different according to their kind, such as \TT{infix} `\TT{-}'
and \TT{prefix} `\TT{-}'.

During the left to right scan, errors are detected and processed
as follows:

\begin{indpar}[0.5in]
\hspace*{-0.3in}after \ttkey{prefix} \\
If an operator is found after a prefix operator that has lower
precedence than the prefix operator, or that has equal precedence
and is not itself a prefix operator, an error operand is inserted
between the two operators and an error is announced.

\hspace*{-0.3in}after \ttkey{infix} \\
If an operator is found after an infix operator that has
precedence lower than or equal to that of the infix operator,
an error operand is inserted
after the infix operator and an error is announced.

\hspace*{-0.3in}after \ttkey{postfix} \\
If an non-operator is found after a postfix operator,
or if an operator is found that has
precedence higher than the postfix operator,
or if a non-postfix operator is found that has
precedence equal to the postfix operator,
an error nofix operator of precedence one less than the
postfix operator is inserted after the postfix operator,
and an error is announced.

\end{indpar}

The output of the parse is obeys the following context
free grammar:

\begin{tabular}{rcl}
\hspace*{1.7in} \\[-2ex]
{\em expression-n}
    & ::= & {\em prefix-operand-n} {\em operand-continuation-n}\QMARK{} \\
    & $|$ & {\em operator-continuation-n} \\
    & $|$ & {\em symbol}\PLUS{} not part of an operator \\
{\em operand-continuation-n}
    & ::= & {\em infix-operator-n} {\em expression-n+1}
                                   {\em operand-continuation-n}\QMARK{} \\
    & $|$ & {\em infix-operator-n} {\em postfix-operand-n} \\
    & $|$ & {\em nofix-operator-n} {\em operator-continuation-n}\QMARK{} \\
    & $|$ & {\em afix-operator-n} {\em operator-continuation-n}\QMARK{} \\
{\em operator-continuation-n}
    & ::= & {\em expression-n+1} {\em operand-continuation-n}\QMARK{} \\
    & $|$ & {\em postfix-operand-n} \\
    & $|$ & {\em nofix-operator-n} {\em operator-continuation-n}\QMARK{} \\
    & $|$ & {\em afix-operator-n} {\em operator-continuation-n}\QMARK{} \\
{\em prefix-operand-n}
    & ::= & {\em prefix-operator-n} {\em expression-n+1} \\
    & $|$ & {\em prefix-operator-n} {\em prefix-operand-n} \\
{\em postfix-operand-n}
    & ::= & {\em expression-n+1} {\em postfix-operator-n} \\
    & $|$ & {\em postfix-operand-n} {\em postfix-operator-n} \\
{\em prefix-operator-n}
    & ::= & prefix operator of precedence n \\
{\em infix-operator-n}
    & ::= & infix operator of precedence n \\
{\em postfix-operator-n}
    & ::= & postfix operator of precedence n \\
{\em nofix-operator-n}
    & ::= & nofix operator of precedence n \\
{\em afix-operator-n}
    & ::= & afix operator of precedence n \\
\end{tabular}

Here {\em expression-n} denotes an expression whose operators are of
precedence n.
Not reflected in the above is the rule that an afix operator cannot
be the first operator in an expression.

An operator parsing instruction may associate an
\key{operator reformatter} with an operator.  After parsing a list,
if the first operator in a resulting expression has an
associated operator reformater, the expression is reformatted
according to that reformater.  For example, if the `\TT{*}' operator
has the `\TT{infix}' reformatter, then expression
`\TT{5 * x * y}' will be reformatted as `\TT{* 5 x y}'.  If in
addition the operator `\TT{/}' has the same precedence
as `\TT{*}', the expression `\TT{5 * x / y}' would be declared to
be in error because the `\TT{infix}' reformatter insists that
all operators in an expression it reformats be the same.

The possible reformatters are:

\begin{indpar}[0.5in]

\hspace*{-0.3in}\ttkey{infix} \\
It is an error unless the expression has alternating operands and operators and
begins and ends with an operand.

It is an error if all the operators in the expression are not
the same operator.

The first of these operators is moved to the
beginning of the expression and the remaining operators are removed
from the expression.

\hspace*{-0.3in}\ttkey{unary} \\
It is an error unless there is only one operator in the expression
and it is at the beginning of the expression.  The expression is
not itself changed.

\hspace*{-0.3in}\ttkey{binary} \\
It is an error unless there is only one operator in the expression
and it is surrounded by operands.  The operator is moved to the
beginning of the expression.

\hspace*{-0.3in}\ttkey{right associative} \\
It is an error unless the expression has alternating operands and operators and
begins and ends with an operand.

Brackets are introduced so the operators are all binary and the
rightmost is done first, and then all the binary operators are moved
to the beginning of their subexpressions:
e.g., 
\begin{center}
\tt x = y -= z += 5
\end{center}
becomes
\begin{center}
\tt = x \{| -= y \{| += z 5 |\} |\}
\end{center}
if `\TT{=}', `\TT{-=}', and `\TT{+=}' have the same precedence and
`\TT{=}' has this reformatter.

\hspace*{-0.3in}\ttkey{left associative} \\
Like \TT{right associative} except that brackets are introduced
so the leftmost is done first:
e.g.,
\begin{center}
\tt x + y - z + 5
\end{center}
becomes
\begin{center}
\tt + \{|- \{| + x y |\} z |\} 5
\end{center}
if `\TT{+}' and `\TT{-}' have the same precedence and `\TT{+}' has
this reformatter (but `\TT{+}' and `\TT{-}' have a different
reformatter in the above tables).

\hspace*{-0.3in}\ttkey{separator} \\
Only allowed for operators of `\TT{nofix}' kind.

It is an error if all the operators in the expression are not
the same operator.

Empty list operands (i.e., \TT{\{||\}} lists) are inserted so that all
the operators become infix.
Then all the operators are removed and the operator name is made
into the value of the `\TT{.separator}' property of the list.

Thus if `\TT{,}' is a nofix operator with this reformatter,
the expression
\begin{center}
\tt , w x,, y, z,
\end{center}
is reformatted to
\begin{center}
\tt \{"", .separator = ","| \{||\} \{| w x |\} \{||\} y z \{||\} |\}
\end{center}


\end{indpar}

It is possible to make new reformatters using \skey{reformatter constructor}s
that take arguments which are constant expressions.  There are examples
in the above tables; e.g., \TT{summation (`+', `-')}.

The following are the reforrmatter constructors:

\begin{indpar}[0.5in]

\hspace*{-0.3in}\ttkey{infix to} \TT{(} {\em and-op} \TT{)} \\
This reformatter is used for infix comparison operators such as
`\TT{<}', `\TT{==}', `\TT{<=}'.

It is an error unless the expression has alternating operands and operators and
begins and ends with an operand.

Each operator is executed separately from left to right and the
results combined by the `{\em and-op}' operator.  Thus
\begin{center}
\em x1 op1 x2 op2 x3
\end{center}
becomes
\begin{center}
\tt {\em and-op} \{| {\em op1} {\em x1} {\em x2} |\}
                 \{| {\em op2} {\em x2} {\em x3} |\}
\end{center}

\underline{except} that temporaries are introduced to prevent
non-end operands from being evaluated more than once, so the
actual final reformatting of the example just given is
\begin{center}
\tt {\em and-op} \{| {\em op1} {\em x1} \{| = \#\#1 {\em x2} |\} |\}
                 \{| {\em op2} \#\#1 {\em x3} |\}
\end{center}

where `\TT{\#\#1}' denotes a temporary variable
(see below\pagnote{TEMPORARY}).

\hspace*{-0.3in}\ttkey{summation}
        \TT{(} {\em plus-op}\TT{,} {\em minus-op} \TT{)} \\
It is an error unless the expression has alternating operands and operators and
begins and ends with an operand.

It is an error unless all the operators in the expression are either
{\em plus-op} or {\em minus-op}.

Each `{\em minus-op operand}' subsequence of the expression is
replaced by
\begin{center}
{\em plus-op} \verb/{|/ {\em minus-op} {\em operand} \verb/|}/
\end{center}
and then the expression is processed as by the \TT{infix} reformatter,
copying the first {\em plus-op} operator
to the beginning of the expression while
removing all the other {\em plus-op} operators.

Thus if `\TT{+}' has this reformatter with
arguments \TT{(+,-)}, and `\TT{+}' and `\TT{-}' are infix
operators with the same precedence, then the expression
\begin{center}
\tt w + x - y + z 
\end{center}
is first changed to
\begin{center}
\tt w + x + \{| - y |\} + z 
\end{center}
and finally reformatted as
\begin{center}
\tt + w x \{| - y |\} z
\end{center}

\hspace*{-0.3in}\ttkey{implied} \TT{(} {\em implied-op} \TT{)} \\
This reformatter is used for postfix operators which do not have
ordinary names but are instead explicitly bracketed subexpressions
named by their subexpression \TT{.type} or \TT{.initiator}.

No errors are detected.  The {\em implied-op} is merely added to the
beginning of the expression.

\end{indpar}

Sometimes \ikey{temporaries}{temporary}\label{TEMPORARY}
are introduced by reformatting.  The syntax involving temporaries is:

\begin{indpar}
\emkey{temporary-definition} ::= {\em temporary} {\em subexpression} \\[1ex]
\emkey{temporary} ::= \TT{\#\#} {\em integral-numeric}\pagnote{INTEGRAL-NUMERIC}
\end{indpar}

During reformatting, a subexpression may be replaced by
a {\em temporary-definition} containing the subexpression.  This
defines the {\em temporary} as a name for the value of the subexpression.
Then the {\em temporary} can be used in the reformatted
expression to refer to this value.  As an example, given the above
tables

\begin{center}
\verb|x == y + 3 == z|
\end{center}

becomes

\begin{center}
\verb/AND {| == x {| ##563 {| + y 3 |} |} |} {| == {| ##563 |} z |}/
\end{center}

Here the temporary has been used to avoid computing \TT{y + 3}
more than once.

The {\em decimal-naturals} in {\em temporaries} are assigned so no
two {\em temporary-definitions} ever have the same {\em temporary}.

\subsection{Parser Units Pass}
\label{PARSER-UNITS-PASS}

The function of the \key{parser units pass} is to identify numeric
units, such as \TT{ft} and \TT{lb}, and turn them into multipliers
and divisors.  For example, `\TT{35~ft~lb}' is reformatted as
`\TT{* 35 ft lb}' and `\TT{\$100~per~yr}' is reformatted as
`\TT{/ \{| * \$ 100 |\} yr}'.

The following are standard units:

\newcommand{\BU}{\STAR{}}

\hspace*{0.2in}\begin{tabular}{llllll}
\hspace*{1.0in} & \hspace*{0.8in} & \hspace*{0.8in} & \hspace*{0.4in} &
                  \hspace*{0.7in} \\[-2ex]

Unit		& Singular & Plural & Fixity & Type & Equivalent
\\[2ex]
Gram\BU		& \TT{g} & & postfix & continuous \\
Pound		& \TT{lb} & \TT{lbs} & postfix & continuous
                                               & \TT{453.59237 g} \\
Ounce		& \TT{oz} &          & postfix & continuous
                                               & \TT{28.349523 g} \\
Kilogram	& \TT{kg} & & postfix & continuous & \TT{1000 g} \\
\end{tabular}

\hspace*{0.2in}\begin{tabular}{llllll}
\hspace*{1.0in} & \hspace*{0.8in} & \hspace*{0.8in} & \hspace*{0.4in} &
                  \hspace*{0.7in} \\[-2ex]
Centimeter\BU	& \TT{cm} & & postfix & continuous \\
Meter		& \TT{m}  & & postfix & continuous & \TT{100 cm} \\
Foot		& \TT{ft} & & postfix & continuous & \TT{30.48 cm} \\
Yard		& \TT{yd} & & postfix & continuous & \TT{91.44 cm} \\
Mile		& \TT{mi} & & postfix & continuous & \TT{160934.4 cm} \\
\end{tabular}

\hspace*{0.2in}\begin{tabular}{llllll}
\hspace*{1.0in} & \hspace*{0.8in} & \hspace*{0.8in} & \hspace*{0.4in} &
                  \hspace*{0.7in} \\[-2ex]
Second\BU	& \TT{sec} & & postfix & continuous \\
Minute		& \TT{min} & & postfix & continuous & \TT{60 sec} \\
Hour		& \TT{hr} & & postfix & continuous & \TT{3600 sec} \\
\end{tabular}

\hspace*{0.2in}\begin{tabular}{llllll}
\hspace*{1.0in} & \hspace*{0.8in} & \hspace*{0.8in} & \hspace*{0.4in} &
                  \hspace*{0.7in} \\[-2ex]
Degrees C\BU	& \TT{C} & & postfix & continuous \\
Degrees F	& \TT{F} & & postfix & continuous & \TT{1.8 C + 32} \\
Degrees K	& \TT{K} & & postfix & continuous & \TT{1.0 C + 273.15} \\
\end{tabular}

\hspace*{0.2in}\begin{tabular}{llllll}
\hspace*{1.0in} & \hspace*{0.8in} & \hspace*{0.8in} & \hspace*{0.4in} &
                  \hspace*{0.7in} \\[-2ex]
Person		& \TT{person} & \TT{persons}, & postfix & discrete \\
		&	  & \TT{people} \\ 
\end{tabular}

The parser units pass attempts to parse a subexpression according to the
following syntax:

\begin{indpar}
\emkey{units-subexpression}
    \begin{tabular}[t]{@{}rl}
    ::= & {\em unit-phrase}\PLUS{} \\
    $|$ & {\em unit-prefix-subexpression} \\
        & {\em unitless-name} \\
        & {\em unit-suffix-subexpression}\QMARK{} \\
    $|$ & {\em bifrucated-number} \\
    \end{tabular}
\\[1ex]
\emkey{unit-phrase} ::= {\em unitless-name} {\em unit-suffix-subexpression}
\\[1ex]
\emkey{unitless-name}
    \begin{tabular}[t]{@{}rl}
    ::= & {\em bifrucated-number} \\
    $|$ & other {\em name}\pagnote{NAME} that does not contain
			  any {\em unit} or {\em unit-subexpression}
    \end{tabular}
\\[1ex]
\emkey{bifrucated-number} ::= {\em integer} {\em unsigned-fraction}
\\[1ex]
\emkey{unsigned-fraction} ::= {\em number} in the range $[0,1)$
\\[1ex]
\emkey{unit-prefix-subexpression} ::= {\em prefix-unit}\PLUS{}
\\[1ex]
\emkey{unit-postfix-subexpression}
    \begin{tabular}[t]{@{}r@{~}l}
    ::= & {\em postfix-unit}\PLUS{} \\
    $|$ & {\em postfix-unit}\STAR{} \TT{per} {\em postfix-unit}\PLUS{} \\
    $|$ & {\em unit-subexpression}
    \end{tabular}
\\[1ex]
\emkey{unit-subexpression} ::= \TT{(} {\em unit-expression} \TT{)}
\\[1ex]
\emkey{unit-expression}
    \begin{tabular}[t]{@{}r@{~}l}
    ::= & {\em unit-primary} \{ \TT{*}\QMARK{} {\em unit-primary} \}\STAR{} \\
    $|$ & {\em unit-primary} \TT{/} {\em unit-primary}
    \end{tabular}
\\[1ex]
\emkey{unit-primary}
    ::= {\em unit} $|$ \TT{(} {\em unit-expression} \TT{)}
\\[1ex]
\emkey{unit}
    ::= {\em prefix-unit} $|$ {\em postfix-unit}
\end{indpar}

If the pass finds any {\em unit} or {\em unit-expression} but
the subexpression does not conform to the above syntax, an error
message is issued.  If there is no {\em unit} or {\em unit-expression}
and the subexpression is not a {\em bifructed-number}, the
pass leaves the expression alone.  Otherwise the subexpression is reformatted
according to the following rules:
\begin{itemize}
\item[(1)] A `\TT{+}' is placed between consecutive {\em unit-phrases}.
\item[(2)] A `\TT{*}' is placed between consecutive {\em unit-primaries},
after any {\em unit-prefix-subexpression}, and before any
{\em unit-postfix-subexpression}.
\item[(3)] Any `\TT{per}' is replaced by `\TT{/}', any
{\em unit-postfix-subexpression} containing it is surrounded by
\TT{\{|~|\}} brackets, and if there is no {\em postfix-unit} before
the `\TT{per}', a `\TT{1.0}' is inserted before the `\TT{/}'. Thus
\begin{center}
\TT{40 lb per sec } $\Longrightarrow$ \TT{40 * \{| lb / sec |\}} \\
\TT{40 per sec } $\Longrightarrow$ \TT{40 * \{| 1.0 / sec |\}}
\end{center}
\item[(4)] Then subexpressions containing infix \TT{+}'s,\TT{*}'s, or
\TT{/}'s are
reformatted as per the operator pass.  This moves infix operators
to the beginning of the subexpression containing them.
\item[(6)] Next nested subexpressions beginning with \TT{*} are
collapsed: e.g.,
\begin{center}
\TT{* X \{|~* y z |\} W} $\Longrightarrow$ \TT{* X y z W}
\end{center}
\item[(7)] Lastly the two {\em numbers} in each {\em bifrucated-number}
are combined by addition.  E.g.,
\begin{center}
\TT{40 1/5} $\Longrightarrow$ \TT{40.2}
\end{center}
\end{itemize}

The following are examples of parser units pass subexpression reformatting:
\begin{center}
\TT{40 lb 3 oz} $\Longrightarrow$ \TT{+ \{| * 40 lb |\} \{| * 3 oz |\}}
\\
\TT{100 m per sec} $\Longrightarrow$ \TT{* 100 \{| / m sec |\}}
\end{center}



\subsection{Parser Dequoting Pass}
\label{PARSER-DEQUOTING-PASS}

\subsection{Parser Control}
\label{PARSER-CONTROL}

After input text is scanned into symbols and these are parsed into
typed lists, each typed list may optionally be parsed further using
instructions in a parsing table associated with the type of the list.
A \key{parsing table} is a list
of \skey{operator parsing instruction}s which have the form:

\begin{tabular}{rcl}
\hspace*{1.7in} \\[-2ex]
\emkey{operator-parsing-instruction}
    & ::= & \TT{\{ operator parsing instruction:} \\
    &     & ~~~ \TT{name =} {\em operator-name}\TT{,} \\
    &     & ~~~ \TT{kind =} {\em operator-kind}\PLUS{} \\
    &     & ~~~ \{ \TT{, undefine} \}\QMARK{} \\
    &     & ~~~ \{ \TT{, type =}
                   {\em operator-type} \}\QMARK{} \\
    &     & ~~~ \{ \TT{, precedence =}
                   {\em operator-precedence} \}\QMARK{} \\
    &     & ~~~ \{ \TT{, reformatter =}
                   {\em operator-reformatter} \}\QMARK{} \\
    &     & \TT{||\}} \\
\emkey{operator-name}
    & ::= & {\em word}\PLUS{} \\
\emkey{operator-kind}
    & ::= & \TT{prefix} $|$ \TT{infix} $|$ \TT{postfix} $|$
            \TT{nofix} $|$ \TT{afix} \\
\emkey{operator-type}
    & ::= & {\em word}\PLUS{} \\
\emkey{operator-precedence}
    & ::= & 32 bit signed integer \\
\emkey{operator-reformatter}
    & ::= & \TT{infix} $|$ \TT{unary} \\
    & $|$ & \TT{binary} $|$ \TT{infix to} \\
    & $|$ & \TT{right-associative} $|$ \TT{left-associative} \\
    & $|$ & \TT{separator} $|$ \TT{summation} \\
\end{tabular}






\subsubsection{Number Pair Recognition}
\label{NUMBER-PAIR-RECOGNITION}

A \key{number pair} is a pair of {\em decimal-numbers}, the first
of which is in integer and the second of which is a fraction
containing a slash.

\begin{indpar}
\emkey{number-pair} ::= {\em decimal-integer}
		   {\em decimal-numerator}\TT{/}{\em decimal-denominator}
		   \\[1ex]
{\em decimal-integer} ::= see \pagref{DECIMAL-INTEGER} \\[1ex]
{\em decimal-numerator} ::= see \pagref{DECIMAL-NUMERATOR} \\[1ex]
{\em decimal-denominator} ::= see \pagref{DECIMAL-DENOMINATOR}
\end{indpar}

Some examples of number pairs are:

\begin{indpar}[0.1in]
\tt
\begin{tabular}{l@{~~~~~}l@{~~~~~}l@{~~~~~}l}
1 1/2	& 55 3/4	& 174 15/16  & 1,234,567 2,875/3,408
\end{tabular}
\end{indpar}

When a {\em number-pair} is encountered during number parsing,
it is surrounded by \TT{(\# \#)} implicit brackets and a \TT{+} is
inserted between its two parts.  Thus if
\TT{41 3/4} is input to number parsing,
\TT{(\# 41 + 3/4 \#)}
will be output.

A number pair is illegal if either of its two parts is illegal.

Number pairs are recognized after scientific numbers have been
recognized.

\subsubsection{Number Unit Grouping}
\label{NUMBER-UNIT-GROUPING}

A {\em number-unit-group} is a sequence of one or more {\em number-unit-pairs}
each of which consists of two lexemes: a {\em real-number}
and a {\em unit-specifier}.
The syntax equations are:

\begin{indpar}
\emkey{number-unit-group} ::= {\em number-unit-pair}\PLUS{} \\[1ex]
\emkey{number-unit-pair} \begin{tabular}[t]{r@{~}l}
                     ::= & {\em prefix-unit-specifier} {\em real-number} \\
                     $|$ & {\em real-number} {\em postfix-unit-specifier} \\
		     \end{tabular} \\[1ex]
\emkey{prefix-unit-specifier} ::= {\em name} \\[1ex]
\emkey{postfix-unit-specifier} ::= {\em name} \\[1ex]
\emkey{unit-specifier} ::= {\em prefix-unit-specifier} $|$
                         {\em postfix-unit-specifier} \\[1ex]
{\em name} ::= see \pagref{NAME}
\end{indpar}

In order to be recognized as a {\em unit-specifier} a {\em symbol} sequence
must be defined as a {\em unit-specifier-name} by the following:

\begin{indpar}
\emkey{unit-specifier-definition} \\
	\hspace*{0.5in}::= \TT{define unit specifier}
	    \begin{tabular}[t]{l}
	    {\em unit-specifier-fixity} \\
	    {\em unit-specifier} {\em parsing-selectors}
	    \end{tabular}
\label{UNIT-SPECIFIER-DEFINITION}
	    \\[1ex]
\emkey{unit-specifier-fixity} ::= \ttkey{prefix} $|$ \ttkey{postfix}
	\\[1ex]
{\em parsing-selectors} ::= see \pagref{PARSING-SELECTORS}
\end{indpar}

The \key{number unit grouping} phase of
parsing recognizes {\em number-unit-groups} containing more than
one {\em number-unit-pair}, places
\TT{(\# \#)} implied brackets around them,
and places implied `\TT{+}' operators
between their {\em number-unit-pairs}.

For example, if `\TT{hr}' and `\TT{min}'
are {\em postfix-unit-specifiers},
`\TT{7 hr 30 min}' is a {\em number-unit-group} containing
2 {\em number-unit-pairs} that number unit grouping transforms into
\begin{center}
\verb/(# 7 hr + 30 min #)/
\end{center}
As another example,
if `\TT{ft}' and `\TT{in}' are {\em postfix-unit-specifiers},
`\TT{12ft 11 3/4in}' becomes
\begin{center}
\verb|(# 12 ft + (# 11 + 3/4 #) in #)|
\end{center}

Number unit groups are recognized after number pairs have been
recognized.

\subsubsection{Unit Multiplication Insertion}
\label{UNIT-MULTIPLICATION-INSERTION}

The \lkey{unit multiplication}{insertion} phase of
parsing inserts a multiplication operator lexeme, `\TT{*}',
before a {\em postfix-unit-specifier}, and
after a {\em prefix-unit-specifier}, unless the point at which the
`\TT{*}' is to be inserted is already occupied by a
`\TT{*}' or `\TT{/}' lexeme.  This is done after number unit
grouping (\secref{NUMBER-UNIT-GROUPING}).

For example, if `\TT{sec}', `\TT{ft}', and `\TT{lb}'
are {\em postfix-unit-specifiers},
then
\begin{indpar}\begin{verbatim}
some function ( 3 ft 2 1/4 in / sec,
                9 ft ^ 2 lb / sec,
                $3.50 )
\end{verbatim}\end{indpar}
becomes
\begin{indpar}\begin{verbatim}
some function ( (# 3 * ft + (# 2 + 1/4 #) * in #) / sec,
                9 * ft ^ 2 * lb / sec,
                $ * 3.50 )
\end{verbatim}\end{indpar}

Unit multiplication insertion is done after number unit groups have been
recognized.

\subsection{Text Parsing}
\label{TEXT-PARSING}

Text parsing is similar to operator parsing except that brackets and
most operators are `named'.
For example, `\TT{<p>}' is a standard paragraph operator,
and `\TT{<indented p>}' is a standard paragraph operator
that is a child of `\TT{<p>}'
and inherits attributes from `\TT{<p>}'.  As another example,
`\TT{<b|} \ldots{} \TT{|b>}' are standard `bold' brackets.

The named text brackets and operators
have the syntax:

\begin{indpar}
\emkey{named-operator} ::=
    \TT{<} {\em text-type} {\em arguments-option} {\em labels-option} \TT{>}
    \\[1ex]
\emkey{named-left-bracket} ::=
    \TT{<} {\em text-type} {\em arguments-option} {\em labels-option} \TT{|}
    \\[1ex]
\emkey{named-right-bracket} ::=
    \TT{|} {\em text-type} {\em arguments-option} {\em labels-option} \TT{>}
    \\[1ex]
{\em text-type} ::= {\em name}
    \\[1ex]
{\em arguments-option} ::= {\em empty} $|$ \TT{(} {\em argument-list} \TT{)}
    \\[1ex]
{\em argument-list} ::= {\em empty}
                    $|$ {\em argument} \{ \TT{,} {\em argument} \}\STAR{}
    \\[1ex]
{\em argument} ::= {\em name} $|$ {\em number} $|$ {\em quoted-string}
    \\[1ex]
{\em labels-option} ::= {\em empty} $|$ \TT{:} {\em label}
				\{ \TT{,} {\em label} \}\STAR{}
    \\[1ex]
{\em label} ::= {\em name}
    \\[1ex]
{\em name} ::= see \pagref{NAME}
    \\[1ex]
{\em number} ::= see \pagref{NUMBER}
    \\[1ex]
{\em quoted-string} ::= see \pagref{QUOTED-STRING}
\end{indpar}

The names of text brackets and operators are
referred to as `\skey{text type}s'.  For example, `\TT{<p>}' is a text
operator of text type `\TT{p}', and `\TT{<b|}~\ldots~\TT{|b>}'
are text brackets of text type `\TT{b}'.
Text types have attributes
such as `\TT{style}', `\TT{weight}', `\TT{indent}', and `\TT{adjust}',
that are used to format the text for printing and display.
For example `\TT{b}' has a the `\TT{weight}' attribute value
`\TT{heavy} and `\TT{n}', as in
`\TT{<n|}~\ldots~\TT{|n>}',
has a `\TT{weight}' attribute value `\TT{normal}'.

Text types
can also inherit attributes from other text types.  To facilitate this
there are also virtual text types that are never used in the text,
but can be ancestors of other text types and serve as repositories of
attributes.  Lastly it is possible to give several names to the same
text type, and to give names to attribute values (e.g., `\TT{default style}'
is a standard name for a `\TT{style}' attribute value).

If a text type has no value for an attribute, or has the value
`\ttmkey{none}{text attribute value}', a piece of text of that type
has no value for the attribute, and
gets the attribute value if it needs it from the surrounding text, or from an
\mkey{initial value}{for text attribute}
for the attribute if there is no surrounding text.
Thus since `\TT{p}' has no `\TT{weight}' attribute value, surrounding a
paragraph by `\TT{<b|}~\ldots~\TT{|b>}' produces a bold paragraph,
and not surrounding a paragraph by text with any `\TT{weight}' attribute
gets the initial `\TT{weight}' attribute, which is `\TT{normal}'.

Although there are many
standard text types, each with standard attributes, a large piece of
text typically defines new types specific to that text and resets some
attributes of the standard types in a way specific to the particular
text.

Text surrounded by named brackets like `\TT{<b|}~\ldots~\TT{|b>}'
is converted by the text parser
into a list which has the \ttdkey{text-type} and \ttdkey{label}
extra attributes supplied by the named brackets.
Similarly text prefaced by a named operator like `\TT{<p>}'
is converted to such a list.  So, for example, the text

\begin{indpar}\begin{verbatim}
<p>
This is a <b|bold|b> sentence.
\end{verbatim}\end{indpar}

is converted by the text parser to

\begin{indpar}\begin{verbatim}
@1 = @2 {| .text-type = p |}
@2 = this is a @3 sentence :|
    .text-type = s
    .initiator = capital 
    .terminator = "."
@3 = bold {| .text-type = b |}
\end{verbatim}\end{indpar}

Here the named operator `\TT{<p>}' prefaces the text included in \TT{@1},
the unnamed operator `\TT{.}' ends the text included in \TT{@2},
and the named brackets `\TT{<b|}~\ldots~\TT{|b>}' surround the text
included in \TT{@3}.  The unnamed operator `\TT{.}' terminates
a piece of text that is assigned the `\TT{s}' text type,
the `\TT{capital}' \TT{.initiator}, and
the `\TT{.}' \TT{.terminator}.  Here the text type `\TT{s}' denotes
a `sentence', and the result would be the same if
the named operator `\TT{<s>}' were explicitly included just before
`\TT{This}', as in

\begin{indpar}\begin{verbatim}
<p>
<s> This is a <b|bold|b> sentence.
\end{verbatim}\end{indpar}

A piece of text can be given a {\em label} by including the {\em label}
in the named bracket or named operator which gives the piece of text
its text type.
These labels are internal to the document, and not printed.
They are used to create references from one place in the document to
another.  For example:

\begin{indpar}\begin{verbatim}
<p: porch definition>
. . . <b: porch|porch|b> . . .
. . . . . . . . .
. . . <r|porch|r> . . .
. . . . . . . . .
. . . <r|porch definition|r> . . .
. . . . . . . . .
\end{verbatim}\end{indpar}

in which the \TT{<r|  |r>} bracketed {\em labels} are references
to the labeled bold text and labeled paragraph.  For convenience
`\TT{<k|}{\em text}\TT{|k>}' can be used to abbreviate
`\TT{<b:} {\em text}\TT{|}{\em text}\TT{|b>}', for example,
`\TT{<k|porch|k>}' could be used above instead of
`\TT{<b: porch|porch|b>}' (the text type `\ttmkey{k}{text type}'
denotes a `keyword').


The text parser converts text into a list whose elements are lexemes
and sublists, where in general each sublist has elements that are
lexemes and sublists.
The text types end up as \ttdkey{text-type}
attributes of these lists and sublists.
Similarly {\em labels} included in named brackets
or named operators end up as \ttdkey{label}
attributes.  Operators frequently cause additional reformatting
of the parse output.  {\em Arguments} in named operators and
brackets are passed to reformatters which use them to control
the reformatting and may insert them as various attributes in the
parsed output.  As an example, the text

\begin{indpar}\begin{verbatim}
<section(1)|A Section Header|>
<p>
<s: HERE>An important sentence.
Another sentence.
\end{verbatim}\end{indpar}

is converted by the text parser to

\begin{indpar}\begin{verbatim}
@1 = @3 :|
    .text-type = section
    .level = 1
    .title = @2
@2 = A Section Header
@3 = @4 @5 {| .text-type = p |}
@4 = an important sentence :|
    .text-type = s
    .label = HERE
    .initiator = capital 
    .terminator = "."
@5 = another sentence :|
    .text-type = s
    .initiator = capital 
    .terminator = "."
\end{verbatim}\end{indpar}

Here the entire bracketed subexpression
`\TT{<section(1)|} \ldots{} \TT{|>}'
also is the lowest precedence operator which reformats everything that
follows (and in general everything following up to the next operator of
equal or lower precedence or a closing outer bracket) into a single list.
It attaches the bracketed text to this list as the \TT{.title} attribute.
Also the `\TT{<section>}' operator is programmed to attach its argument,
`\verb|1|' in this case, to the list as the \TT{.level} attribute

In general named operators can be used in bracketed form to attach
a bracketed expression as a \TT{.title} attribute to the same text
the operator attaches its \TT{.text-type} to.  In general some
named operators or brackets are programmed to take arguments which
they may use to control formatting or compute text attribute values
(such as \TT{.level} in this example).

Note that closing brackets may omit their name, as `\TT{|>}' does
when it closes `\TT{<section(1)|}' in this example.  Its also allowed to
use either an initial or final segment of the name in a closing
named bracket, as in `\TT{<bold italic|} \ldots{} \TT{|bold>}'
or `\TT{<bold italic|} \ldots{} \TT{|italic>}'.
Arguments may be given in either the opening or closing bracket of a named
bracket, but if given in both, must be identical in both.  E.g.,
\begin{center}
\verb/<section(1)|/ \ldots{} \verb/|section>|/ \\
\verb/<section|/ \ldots{} \verb/|section(1)>|/ \\
\verb/<section(1)|/ \ldots{} \verb/|section(1)>|/ \\
\end{center}
are all acceptable and equivalent, but
\begin{center}
\verb/<section(1)|/ \ldots{} \verb/|section(2)>|/
\end{center}
is illegal.


In the above example,
`\TT{<p>}' is a higher precedence operator than `\TT{<section>}', and
`\TT{<s>}' is higher precedence than `\TT{<p>}'.  Also the sentence
terminator `\TT{.}' has the same precedence as `\TT{<s>}' and these
operators work together to form sentences.  The `\TT{<s>}' operator
is optional and is only given in the example in order to assign a \TT{.label}
attribute to the first sentence.  The second sentence has its `\TT{<s>}'
operator omitted.

Some text operators do \underline{not} set the \TT{.text-type} attribute,
but instead set only a \TT{.separator} attribute.  The `\TT{,}'
operator is an example.  Thus the text

\begin{indpar}\begin{verbatim}
this is, certainly, a phrase
\end{verbatim}\end{indpar}

is converted by the text parser to

\begin{indpar}\begin{verbatim}
@1 = @2 certainly @3 {| .separator = "," |}
@2 = this is
@3 = a phrase
\end{verbatim}\end{indpar}

Because the reformatted expression in this case is a list with
no \TT{.text-type} attribute, it can be assigned a \TT{.text-type}
attribute by a text operator of precedence lower than the
precedent of `\TT{,}'.  Thus the text

\begin{indpar}\begin{verbatim}
<p>
this is, certainly, a phrase
<p>
This is, certainly, a sentence.
\end{verbatim}\end{indpar}

is converted by the text parser to

\begin{indpar}\begin{verbatim}
@1 = @2 @6
@2 = @3 certainly @4 :|
    .separator = ","
    .text-type p
@4 = this is
@5 = a phrase
@6 = @7 {| .text-type p |}
@7 = @8 certainly @9 :|
    .separator = ","
    .initiator = capitalize
    .terminator = "."
    .text-type s
@8 = this is
@9 = a sentence
\end{verbatim}\end{indpar}

Unnamed brackets, namely
`\TT{(} \ldots{} \TT{)}',
`\TT{[} \ldots{} \TT{]}', and
`\TT{\{} \ldots{} \TT{\}}',
produce bracketed subexpressions just as they do for other
parsers.  Thus the text

\begin{indpar}\begin{verbatim}
the book (Bartholomew 2043) previously mentioned
\end{verbatim}\end{indpar}

is converted by the text parser to

\begin{indpar}\begin{verbatim}
@1 = the book @2 previously mentioned
@2 = Bartholomew 2043 :|
    .initiator = "("
    .terminator = ")"
\end{verbatim}\end{indpar}

If you want to eliminate spacing where it would normally occur,
you can use \skey{glue bracket}s, `\TT{<g|} \ldots{} \TT{|g>}',
which can also be implied by the absence of spacing in the input.
Thus

\begin{indpar}\begin{verbatim}
the book[Bartholomew 2043] previously mentioned
\end{verbatim}\end{indpar}

is equivalent to

\begin{indpar}\begin{verbatim}
the <g|book[Bartholomew 2043]|g> previously mentioned
\end{verbatim}\end{indpar}

and both are converted by the text parser to

\begin{indpar}\begin{verbatim}
@1 = the @2 previously mentioned
@2 = book @3 {| .text-type = g |}
@3 = Bartholomew 2043 :|
    .initiator = "["
    .terminator = "]"
\end{verbatim}\end{indpar}

\subsubsection{Standard Text Operators}
\label{STANDARD-TEXT-OPERATORS}

The following are the standard text operators

\begin{center}

\begin{tabular}{rl@{\hspace*{2em}}l@{\hspace*{2em}}l}

precedence & reformatter	& operator	& meaning 
\\[2ex]
-10000+100$n$
	& \ttkey{text-prefix}	& \tttkey{section($n$)}
						& section header \\
-1100	& \ttkey{text-prefix}	& \tttkey{tr}	& table row \\
-1000	& \ttkey{text-prefix}	& \tttkey{ti($m$,$n$)}	& table item \\
-500	& \ttkey{text-prefix}	& \tttkey{li}	& list item \\
0	& \ttkey{text-prefix}	& \tttkey{p($i$)}	& paragraph \\
100	& \ttkey{sentence}	& \tttkey{s}	& sentence \\
	&			& \ttkey{.}	& sentence terminator \\
	&			& \ttkey{!}	& sentence terminator \\
	&			& \ttkey{?}	& sentence terminator \\
200	& \ttkey{text-separator}
				& \ttkey{;}	& subsentence separator \\
	&			& \ttkey{:}	& subsentence separator \\
300	& \ttkey{text-separator}
				& \ttkey{--}	& phrase separator \\
	& 			& \ttkey{---}	& phrase separator \\
400	& \ttkey{text-separator}
				& \ttkey{,}	& phrase separator \\
\end{tabular}

\end{center}


\begin{indpar}[1em]

\newcommand{\OP}[1]{\tttmkey{#1}{reformatting}}

\bigskip

\ttmkey{text-prefix}{reformatter} \hfill \OP{section($n$)}
~~~ \OP{tr} ~~~ \OP{ti($m$,$n$)}
~~~ \OP{li} ~~~ \OP{p}

\begin{indpar}[0.5em]
These operators have different
precedences, and so cannot appear together in the same expression.

The expression must have the form
\begin{center}
\{ {\em operator} {\em subexpression} {\em subexpression}\STAR{} \}\STAR{}
\end{center}

That is, {\em operators}
(e.g., `\TT{<p>}') must begin the expression and may
not be consecutive or end the expression.  Each operator and the
{\em subexpressions} following it are reformatted into a list whose
\TT{.text-type} attribute is given by the operator.  If there is one
{\em operator}, this reformatted list becomes the reformatted expression.
If there is more than one, a list of these reformatted lists
becomes the reformatted expression.

The list of {\em subexpressions} following an {\em operator} is parsed as
an expression.  The result is then converted to a list with no
\TT{.text-type} attribute; if it is not already such, it is made
the sole element of a new list.  Then the \TT{.text-type} and \TT{.label}
attributes of this list are set from the {\em operator} and the result
is the reformatted list for that {\em operator}.

If the operator brackets text, that text becomes the \TT{.title} attribute
value of the reformatted list.

The `\TT{<section>}'
operator takes an additional argument $n$ (default \TT{0})
which becomes the \TT{.level} attribute of the reformated list.  Also,
$100n$ is added to the precedence of the operator.

The `\TT{<ti>}' table item
operator takes an additional arguments $m$ and $n$ (defaults \TT{1} and
\TT{1})
which become the \TT{.rows} and \TT{.columns} attributes, respectively,
of the reformated list.  These specify that the table item is to span
$m$ rows and $n$ columns.  $m$ can be omitted, as in \TT{<ti(}$n$\TT{)>}.

The `\TT{<p>}'
operator takes an additional argument $i$ (default \TT{0})
which becomes the \TT{.indent} attribute of the reformated list.  This
specifies that the entire paragraph is to be indented.

[TBD: maybe not the \TT{.indent} attribute.]

\end{indpar}

\bigskip

\ttmkey{sentence}{reformatter} \hfill \OP{s} ~~~ \ttmkey{.}{reformatting}
					     ~~~ \ttmkey{?}{reformatting}
					     ~~~ \ttmkey{!}{reformatting}

\begin{indpar}[0.5em]

The expression must have the form
\begin{center}
\{ \TT{<s>}{\em -option} {\em subexpression} {\em subexpression}\STAR{}
	{\em terminator} \}\STAR{}
\end{center}
where the {\em terminator} is one of `\ttmkey{.}{terminator}',
`\ttmkey{?}{terminator}', or `\ttmkey{!}{terminator}'.

That is, it must consist of a sequence of `\skey{sentence}s' each beginning
with an optional `\TT{<s>}', each ending with one of the {\em terminators},
and each being non-empty otherwise.  Each sentence is reformatted into
a list whose \TT{.text-type} is `\ttmkey{s}{\tt .text-type}', whose
\TT{.initiator} may be `\ttmkey{capitalize}{\tt .text-type}', and whose
\TT{.terminator} is the {\em terminator} at the end of the sentence.
If there is just one sentence, its reformatted list becomes the
reformatted expression.  If there
is more than one, a list of these reformatted sentence lists
becomes the reformatted expression.

The list of {\em subexpressions} in a sentence is parsed as
an expression.  The result is then converted to a list with no
\TT{.text-type}, \TT{.initiator}, or \TT{.terminator} attributes;
if it is not already such, it is made
the sole element of a new list.  Then the \TT{.text-type} attribute
of this list is set to `\TT{s}', the \TT{.label}
attribute of this list is set to any value provided by
an optional `\TT{<s:} {\em label\,}\TT{>}' {\em operator},
and the
\TT{.terminator} is set to the {\em terminator}.
If the first element of the list is a capitalized word, it is decapitalized
and the list \TT{.initiator} is set to `\TT{capitalize}'.
This list is then the reformatted list for the sentence.

\end{indpar}

\bigskip

\ttmkey{text-separator}{reformatter} \hfill \ttmkey{--}{reformatting}
				   ~~~ \ttmkey{---}{reformatting}
				   ~~~ \ttmkey{,}{reformatting}
				   ~~~ \ttmkey{;}{reformatting}
				   ~~~ \ttmkey{:}{reformatting}

\begin{indpar}[0.5em]
Here `\TT{--}' (or `\TT{---}'),
`\TT{,}', and `\TT{;}' (or `\TT{:}') have different
precedences, and so cannot appear together in the same expression.

The expression must have the form
\begin{center}
\{ {\em subexpression} {\em subexpression}\STAR{}
	{\em operator} \}\STAR{} {\em subexpression}\PLUS{}
\end{center}
where all the {\em operators} must be the same (i.e., if you
mix `\TT{;}' and `\TT{:}'
or `\TT{--}' and `\TT{---}' in the same expression, the expression
will be declared illegal by the reformatter).

That is, the expression
must consist of a sequence of non-empty {\em subexpression} lists
separated by {\em operators}.  The entire expression is reformatted as
a list whose
\TT{.separator} is the {\em operator}.  The elements of this list
are the lists that are the {\em subexpressions} between operators,
though if there
is only one {\em subexpression} between two operators, it becomes an
element of the final list.

\end{indpar}


\end{indpar}

\subsubsection{Standard Text Brackets}
\label{STANDARD-TEXT-BRACKETS}

\begin{center}

\begin{tabular}{l@{\hspace*{2em}}l}

bracket	& meaning 
\\[2ex]
\tttbkey{b} & boldface text (heavy weight) \\
\tttbkey{n} & normal text (normal weight) \\
\tttbkey{i} & italic text (TBD) \\
\tttbkey{r} & roman text (TBD) \\
\tttbkey{em} & emphasized text (TBD) \\
\tttbkey{table} & table (TBD) \\
\tttbkey{list} & list (TBD) \\
\tttbkey{g} & glued text (TBD) \\
\end{tabular}

\end{center}

\subsubsection{Text Mark Attributes}
\label{TEXT-MARK-ATTRIBUTES}

OBSOLETE - incorporate into above

\ikey{Text parsing}{text parsing} is performed by the \ttkey{-TEXT-PARSER-},
which is the parser for subexpressions of the
\TT{`}...\TT{'}, etc. matchfix operators.
The \TT{|} format separator and sentence and paragraph ends are
recognized by text processing, while
operators, qualifiers, qualifier shortcuts, and
the \TT{::?}, \TT{<:>}, \TT{::>}, \TT{@@}, and
\TT{??} marks are \underline{not} recognized.

Text parsing is normally done in the context of a pair of matched
{\em quotes}, and in this context {\em white-space} pre-lexemes
become lexemes.  Note that {\em white-space} lexemes all consist
of zero or more {\em vertical space} characters followed by zero or
more {\em single-space} characters (reference: TBD: make white space
lexemes sometimes?).
There are three kinds of {\em white-space} lexemes
used by text parsing:

\begin{list}{}{}

\item[{\bf Spacer Lexemes}.]
A \key{spacer} lexeme is a {\em white-space} lexeme containing
only single spaces.  Spacers are used in text parsing if they follow
a \TT{|} format separator on a line.

\item[{\bf Line Separator Lexemes}.]
A \key{line separator} lexeme is a {\em white-space}
lexeme that contains a single {\em line-feed} character and no other
{\em vertical-space} characters.  Such lexemes separate
non-blank lines, and are used by text parsing to end lines containing
a \TT{|} format separator.

\item[{\bf Blank Line Lexemes}.]
A \key{blank line} lexeme is a {\em white-space}
lexeme that contains either two or more {\em line-feed} characters or contains
a {\em vertical-space} character that is not a {\em line-feed} character.
Such lexemes
represent blank lines between non-blank lines, and are used by text parsing
both to end lines containing a \TT{|} format separator and
to separate paragraphs.

\end{list}

\subsubsection{Section, Paragraph, and Sentence Parsing}
\label{SECTION-PARAGRAPH-AND-SENTENCE-PARSING}

OBSOLETE - incorporate into above

If the text being parsed does not contain any format separators,
the text is parsed into phrases, sentences, and paragraphs.

First the text is divided by blank line lexemes into paragraphs.
The sequence of paragraphs comprises a section.

Then in each paragraph, sentence terminators are located.
White-space lexemes in the paragraph are deleted after sentence terminators
are located.
Each sequence
of lexemes or subexpressions ending in a sentence terminator
is made into a sentence, and any
non-empty sequence
of lexemes or subexpressions following the last sentence terminator
is made into a phrase.
The paragraph is then a sequence of zero or more sentences 
possibly followed by a phrase.  However, a paragraph cannot be empty.

The syntax of the result is:

\begin{indpar}
\emkey{section} ::= \TT{[-SECTION-} {\em paragraph}\PLUS{}
                  \TT{]} \\[1ex]
\emkey{paragraph}
	\begin{tabular}[t]{rl}
	::= &  \TT{[-PARAGRAPH-} {\em sentence}\PLUS{}
	       \TT{]} \\
	$|$ &  \TT{[-PARAGRAPH-} {\em sentence}\STAR{} {\em phrase}
	       \TT{]}
	\end{tabular} \\[1ex]
\emkey{sentence} ::= \TT{[-SENTENCE-} {\em sentence-non-terminator}\STAR{}
                                    {\em sentence-terminator}
                  \TT{]} \\[1ex]
\emkey{phrase}
	\begin{tabular}[t]{rl}
	::= &  \TT{[} \begin{tabular}[t]{@{}l@{}}
			{\em sentence-non-terminator}
			{\em sentence-non-terminator} \\
		        {\em sentence-non-terminator}\STAR{} \TT{]}
			\end{tabular} \\
	$|$ &  {\em sentence-non-terminator}
	\end{tabular} \\[1ex]
\emkey{sentence-terminator} ::= \TT{.} $|$
                              \TT{?} $|$
                              \TT{!} \\[1ex]
\emkey{sentence-non-terminator} ::= {\em symbol} $|$
                                  {\em subexpression}
\end{indpar}

Note that a {\em phrase} with more than one {\em sentence-non-terminator}
is a list, but a {\em phrase} with just one {\em sentence-non-terminator}
is not a list, but just the single {\em sentence-non-terminator} by itself.

There are several rules that modify the description just given:

{\bf Sentence Terminator Rule.}\index{Sentence Terminator Rule}
A \key{sentence-terminator} is any lexeme that is syntactically
a sentence terminator, that is not preceded by a {\em white-space}
lexeme, and that is followed by a {\em white-space} lexeme, a
{\em closing-mark} lexeme, or the
end of the lexeme sequence.  All other lexemes and all subexpressions are
\skey{sentence-non-terminator}s.

{\bf Initial Capitalization Rule.}\index{Initial Capitalization Rule}
A {\em word} consisting of an initial capital letter followed
by zero or more lower case letters is converted
to an all lower case word if it begins a sentence.
A {\em word} consisting of an initial
\ttkey{\^~} followed by an upper
case letter followed by zero or more lower case letters has the
initial \TT{\^~} removed.

{\bf Text Simplification Rule.}\index{Text Simplification Rule}
If the \TT{-TEXT-PARSER-} is to return a {\em section} with just
one {\em paragraph} and that {\em paragraph} contains nothing but
just one {\em sentence} or {\em phrase},
then just the {\em sentence} or {\em phrase} is returned.
Otherwise, if a {\em section} with just one {\em paragraph} is
to be returned, just the {\em paragraph} is returned.


Some examples follow:

\begin{center}
\begin{tabular}{lcl}

\verb|`the wife of Bob'|
& parses as &
\verb|[-PHRASE- the wife of Bob]|
\\[2ex]
\verb|`She hit the ball.'|
& parses as &
\verb|[-SENTENCE- she hit the ball .]|
\\[2ex]
\begin{tabular}{@{}l@{}}
\verb|`^Bill swung.| \\
\verb|  But he missed!'|
\end{tabular}
& parses as &
\begin{tabular}{@{}l@{}}
\verb|[-PARAGRAPH-| \\
\verb|    [-SENTENCE- Bill swung .]| \\
\verb|    [-SENTENCE- but he missed !]]|
\end{tabular}
\\[5ex]
\begin{tabular}{@{}l@{}}
\verb|`^I liked| \\
\verb|  the party.| \\
\verb|| \\
\verb|  Later, we caught| \\
\verb|  the bus.'|
\end{tabular}
& parses as &
\begin{tabular}{@{}l@{}}
\verb|[-SECTION-| \\
\verb|   [-PARAGRAPH-| \\
\verb|      [-SENTENCE-| \\
\verb|          I liked the party .]]| \\
\verb|   [-PARAGRAPH-| \\
\verb|      [-SENTENCE-| \\
\verb|          later , we caught| \\
\verb|                  the bus .]]]| \\
\end{tabular}

\end{tabular}
\end{center}

Note that capitalized words like proper names and `\TT{I}' need to be
prefixed by `\TT{\^~}' if they begin a sentence or phrase.


\subsubsection{Text with Format Separators}
\label{TEXT-WITH-FORMAT-SEPARATORS}

TBD

\subsection{The Parsing Algorithm}
\label{THE-PARSING-ALGORITHM}
Parsing is done by a recursive descent left-to-right algorithm.
A parser is called to parse each subexpression.  This parser is
given the following explicit arguments:

\begin{center}
\begin{tabular}{l}
a list of lexemes to parse \\
an optional (closing) bracket definition \\
an optional (terminating) operator precedence \\
\end{tabular}
\end{center}

The bracket definition, if given, specifies a closing bracket
which must appear in the list of lexemes.  When the parser
finds this bracket outside other brackets, the parser terminates
the parse.

The operator precedence, if given, specifies that infix or
nofix operators of this and lower precedence will terminate the parsing if
they are encountered in the list of lexemes.

In addition the parser is given the following implicit
arguments:

\begin{center}
\begin{tabular}{l}
the parsing definition stack \\
the parsing selector set stack
\end{tabular}
\end{center}

The parser returns

\begin{center}
\begin{tabular}{l}
the parsed expression \\
the unparsed final segment of the input lexeme list
\end{tabular}
\end{center}

When parsing is terminated by finding a closing bracket matching
the closing bracket definition argument, then the part of the
input lexeme list after this closing bracket is returned as the
unparsed final segment of the input lexeme list.  When parsing is
terminated by finding a terminating operator of precedence equal to or lower
than an operator precedence argument, the part of the input
lexeme list beginning with this terminating operator is returned as the
unparsed final segment of the input lexeme list.  Otherwise the
returned unparsed final segment of the input lexeme list is empty.

There are two standard kinds of parser: the operator parser
and the text parser.  These use somewhat different algorithms.

\subsubsection{The Text Parser}
\label{TEXT-PARSER}

The text parser divides the input into paragraphs that are separated by
blank lines.

Paragraphs are classified as tabular or free-form according
to whether their first line is a tabular format line.
A \key{tabular format line} contains optional whitespace characters,
followed by a `\ttmkey{+}{in tabular format line}', followed
by any number of `\TT{+}' or
`\ttmkey{-}{in tabular format line}' characters,
followed by a `\TT{+}' that ends the line, except that superfluous
whitespace characters are allowed after the `line ending' {\tt+}.
An example of a tabular paragraph is:


\begin{indpar}\begin{verbatim}
+------------------------+--------+------+
 ice melt                 40 lbs    $4.50
 2x4's, 8ft               10       $27.70
 16d nails                 2 lbs     3.21
\end{verbatim}\end{indpar}


A paragraph that is not tabular is \ikey{free-form}{paragraph}.
Each free-form paragraph is scanned for explicitly bracketed subexpressions,
phrase separators, and sentence terminators.  The paragraph is divided into
sentences using sentence terminators outside brackets, and each sentence
is given \TT{<* *>} implicit brackets.
Each sentence is then divided into
phrases if it has any phrase separators, and 



\section{Expression Evaluation}
\label{EXPRESSION-EVALUATION}

An expression is evaluated by first searching for an expression definition
that matches the expression.  Expression definitions have patterns that
are matched to the expression.  An expression definition may have
guards, which are expressions that must evaluate to true in order for
the expression definition match to succeed, and an expression definition
may have constraint equations, which match subexpressions to patterns or
to each other.
An expression definition may have an expression block that executes
in order to produce a value list for the expression if the definition
matches.  If a matching
expression definition has no expression block, the expression
evaluates to `\ttkey{true}'.  If no expression definition matches an
expression, the expression evaluates to `\ttkey{false}'.

Expression definitions are searched for in a context, which is a list
of expression definitions and pointers to other contexts.
Each point in the program has a lexical context, which is used by default
for expression evaluation. 
By default expressions are evaluated in the
lexical context of the place in the program code where the expression
appears.  In addition, there may be other
contexts in which expressions may be evaluated that effectively implement
either data bases or alternative programming languages.

When an expression definition is found whose pattern matches an expression,
a set of constraints are established that must be satisfied to
complete the match.  There are five kinds of constraints: syntax
equations, pattern equations, default equations, alternative
equations, and guards.
Syntax equations equate expressions that involve syntax variables,
which are names beginning with a \TT{\$} followed by a capital letter.
Pattern equations are like syntax equations but
involve a pattern which can represent one of many possible syntax
expressions.  Default equations assign values to syntax variables that are
discarded when a pattern is unfolded to become the syntax expression
it will actually represent.  Alternative equations specify alternatives
for simple atomic clauses that may be in a pattern.
Guards are just expressions that must evaluate to
\TT{true} in order for the match to succeed.

The syntax equations are solved during the matching process,
to produce values for the syntax variables.  Patterns are unfolded during
the matching process to become the syntax expressions they represent.
Guards are evaluated, and in some cases the value of a syntax variable
value is evaluated.
If the syntax equations or pattern equations are inconsistent and
cannot be solved, or if a guard or syntax variable value that must be
evaluated cannot be evaluated, or if a guard evaluates to \TT{false},
the match fails.  Evaluation of the guards or syntax variable values
may result in additional matches which generate more
constraints involving more syntax variables.

The matching process must consider all possible choices of which definitions
to match to an expression being evaluated.  If all choices fail, the
expression evaluates to \TT{false}.  If only one choice succeeds, that
choice is used to evaluate the expression.  If several choices succeed,
the situation becomes ambiguous, and the evaluation proceeds according
to the matching mode, as is described below
(\secref{MATCHING-ALGORITHM}).

A syntax variable name beginning with
\ttmkey{\$}{in syntax variable name} denotes an unevaluated
expression.  The same name without the \TT{\$} denotes the value
of this unevaluated expression when it is evaluated
in the context in which the unevaluated expression appears.
This last value is called the `\key{evaluation}' of the unevaluated
expression.  Thus, for example, \TT{\$X} denotes an unevaluated
expression and \TT{X} denotes the evaluation of that expression.

As an example, given the syntax equation
\begin{center}
\verb|foo(2+2) :=: foo($X)|
\end{center}
(where \TT{:=:} means `is syntactically equal to'), we get
the syntax equation
\begin{center}
\verb|2+2 :=: $X|
\end{center}
that defines \TT{\$X}.  If there is then a guard `\TT{number(X)}',
the expression \TT{\$X}, namely `\TT{2+2}',
will be evaluated in its context, the context in which `\TT{foo(2+2)}'
appeared, to produce the value \TT{4}, which will become the value of
\TT{X}, so the guard will become `\TT{number(4)}'.

An expression cannot be evaluated if it contains any undefined syntax
variables.  For example, if we began with the syntax equation
\begin{center}
\verb|foo(2+$Y) :=: foo($X)|
\end{center}
and guard `\TT{number(X)}', \TT{\$X} would be `\TT{2+\$Y}' which
could not be evaluated.  If at some later time in the matching process
the syntax equation
\begin{center}
\verb|$Y :=: 7|
\end{center}
is generated, then the value of \TT{\$X} becomes `\TT{2+7}'
which can now be evaluated to produce the value \TT{9} for \TT{X}
and allow the guard to become `\TT{number(9)}'.

In the above \TT{\$X} is an `unevaluated syntax variable' and
\TT{X} is its `associated' `evaluated syntax variable'.  It is
possible to use \TT{X} in a definition where \TT{\$X} is actually
meant, but if that is done once, then it must be done for every occurrence
of \TT{\$X} in the definition, and the only computation that may be
performed on the (unevaluated) value of \TT{\$X} is to evaluate it to
produce a value for \TT{X}.

Except for choices of which definitions to match to which expressions,
the entire matching process is monotonic.  This means the order in which
syntax equations are solved, patterns are unfolded, guards are evaluated,
and unevaluated syntax variable values are evaluated does not matter.

In order to make the matching process monotonic, pattern unfolding must
be monotonic.  This means that if undefined syntax variables in a pattern
equation whose pattern has been unfolded are given arbitrary values later,
the pattern unfolding must still be valid and unambiguous.

Similarly guard evaluations must not have side effects.  In other
words, evaluating a guard cannot affect any future valuations.
Side effects can only occur during block execution, so any blocks
executed during the guard evaluation process must not have side effects.

Lastly, required evaluations of unevaluated syntax variable values
must be monotonic.  For example, given the syntax variable \TT{\$X},
if the value of \TT{X} is required, the evaluation of the value of
\TT{\$X} must be monotonic.
In order to ensure this, an unevaluated expression is not evaluated until
all syntax variables it contains have been given values, so that
the expression to be evaluated does not contain any undefined syntax
variables.  Furthermore, evaluation of such an expression may not have
side effects.  Again this last means that any blocks executed during
the evaluation of the expression must not have side effects.
If an evaluation is needed, but the expression to be evaluated contains
a syntax variable that never becomes defined,
then the matching process fails for the expression definition, just as it
would if a guard evaluated to false.

\subsection{Expression Definitions}
\label{EXPRESSION-DEFINITION}

\ikey{Expression definitions}{expression definition} have the syntax:

\begin{indpar}
\emkey{expression-definition} ::=
	{\em pattern} \TT{<--} {\em constraint-list-option} {\em block-option}
	\\[1ex]
{\em pattern} ::= \TT{<--}{\em -subexpression}
	~~~ [see {\em O-subexpression}, \pagref{O-SUBEXPRESSION}] \\[1ex]
{\em pattern} ::= {\em pattern-object}
	~~~ [see \pagref{PATTERN-OBJECT}] \\[1ex]
\emkey{constraint-list-option} ::= {\em empty} $|$ {\em constraint-list} \\[1ex]
\emkey{constraint-list}
    ::= {\em constraint} \{ \TT{,} {\em constraint} \}\STAR{} \\[1ex]
\emkey{constraint} ::= \TT{,}{\em -subexpression}
	~~~ [see {\em O-subexpression}, \pagref{O-SUBEXPRESSION}] \\[1ex]
\emkey{constraint} ::= {\em syntax-equation}
		       \begin{tabular}[t]{@{}l@{}}
		       $|$ {\em pattern-equation} $|$ {\em default-equation} \\
		       $|$ {\em alternative-equation} $|$ {\em guard}
		       \end{tabular} \\[1ex]
\emkey{syntax-equation} ::= {\em syntax-expression}
		\TT{:=:} {\em syntax-expression}
	        ~~~ [see \pagref{SYNTAX-EQUATIONS}]
	 	\\[1ex]
\emkey{pattern-equation} ::= {\em syntax-expression}
		\TT{:=\~~} {\em constraint-pattern}
	        ~~~ [see \pagref{PATTERN-EQUATIONS}]
		\\[1ex]
{\em constraint-pattern} ::= {\em pattern-object}
	~~~ [see \pagref{PATTERN-OBJECT}] \\[1ex]
\emkey{default-equation} ::= {\em syntax-variable}
		\TT{:=?} {\em syntax-expression}
	        ~~~ [see \pagref{DEFAULT-EQUATIONS}]
		\\[1ex]
\emkey{alternative-equation} ::= \\
\hspace*{3em}{\em syntax-variable}
		\TT{:=:} {\em alternative}
		          \TT{|} {\em alternative}
			  \{ \TT{|} {\em alternative} \}\STAR{}
	                  ~~~ [see \pagref{ALTERNATIVE-EQUATIONS}]
		\\[1ex]
\emkey{alternative} ::= {\em atom}\PLUS{}
		\\[1ex]
\emkey{guard} ::= \TT{,}{\em -subexpression}
	~~~ [see {\em O-subexpression}, \pagref{O-SUBEXPRESSION}] \\[1ex]
\emkey{block-option} ::= {\em empty} $|$ \TT{\{ \}} $|$ {\em block} \\[1ex]
\emkey{block} ::= \TT{\{} {\em statement}
                           \{ \TT{;} {\em statement} \}\STAR{} \TT{\}}
	    \\[1ex]
{\em statement} ::= see \pagref{STATEMENT}
\end{indpar}

The \mkey{pattern}{in expression definition} of an expression definition
is the subexpression before the \TT{<--}.  If the expression definition
with pattern $p$ is being matched to the expression $e$,
the pattern equation $p$ \TT{:=\~~} $e$ is asserted, the
constraint syntax and pattern equations in the definition
are asserted, and the definition guards are required to evaluate
to \TT{true}.  Default equations are asserted as necessary.

Just before an expression definition is matched to an expression, the
definition is copied, and the act of copying 
creates a new set of variables that are distinct from any
previous variables.  Thus if \TT{\$X} appears in a definition, each
use of the definition will involve a \underline{different}
variable named \TT{\$X}.

\subsection{Syntax Equations}
\label{SYNTAX-EQUATIONS}

Although pattern equations are asserted before syntax equations are asserted,
a knowledge of syntax equations is required to understand pattern
equations.

A \key{syntax equation} asserts syntactic identity between two
\skey{syntax expression}s.  A syntax expression is a syntax variable,
an atom, or an object whose attribute values are syntax expressions.
The syntax of a syntax equation is:

\begin{indpar}
\emkey{syntax-equation} ::= {\em syntax-expression} \ttkey{:=:}
			    {\em syntax-expression}
			    \\[1ex]
\emkey{syntax-expression} ::= {\em syntax-variable}
			   $|$ {\em atom} $|$ {\em object}
			   \\[1ex]
\emkey{syntax-variable}\label{SYNTAX-VARIABLE}
			\begin{tabular}[t]{rl}
			::= & \TT{\$} {\em capitalized-word } \\
			$|$ & \TT{\$} \TT{(} {\em capitalized-word }
			      {\em name-component}\STAR{} \TT{)} \\
			$|$ & {\em place-holding-syntax-variable}
			    ~~~ [see \secref{PLACE-HOLDING-SYNTAX-VARIABLES}] \\
			$|$ & {\em evaluated-syntax-variable}
			    ~~~ [see \secref{EVALUATED-SYNTAX-VARIABLES}] \\
			\end{tabular} \\[1ex]
{\em name-component} ::= see \pagref{NAME-COMPONENT}
\end{indpar}

Syntax equations can be consistent or inconsistent according to the:

\begin{indpar}
\begin{list}{}{}
\item[\ikey{Consistency Rule}{consistency rule}:]
A syntax equation is \key{consistent} if it
\begin{enumerate}
\item asserts identity between a syntax variable and a syntax expression, or
\item asserts identity between two identical atoms, or
\item asserts identity between two objects each of which has the same
attribute labels as the other, and all the attributes in both objects
have exactly one value.
\end{enumerate}
However, this rule is applied after applying the Parentheses
and Atom Rules below.

Syntax equations that are not consistent are \key{inconsistent}.
\end{list}
\end{indpar}

The following rules amend the above process of consistency checking:

\begin{indpar}
\begin{list}{}{}
\item[\ikey{Parentheses Rule}{parentheses rule}:]\label{PARENTHESES-RULE}
An object whose \TT{.initiator} is \TT{"("} and whose
\TT{.terminator} is \TT{")"} is treated as if it had no
\TT{.initiator} or \TT{.terminator} attributes.
Also, a syntax variable name in \TT{( )} parentheses is treated
as if there were no parentheses.

\item[\ikey{Atom Rule}{atom rule}:]\label{ATOM-RULE}
In a syntax equation asserting the identity of an atom and an object,
the atom is treated as if it were an object that has
no attributes except one list element equal to the atom.
\end{list}
\end{indpar}

Thus the following identities are consistent:

\begin{center}
\begin{tabular}{r@\TT{~:=:~}l}
\verb/5 + 6/ & \verb/( 5 + 6 )/ \\
\verb/5/ & \verb/( 5 )/ \\
\verb/($X)/ & \verb/{ 5 + 6 }/ \\
\end{tabular}
\end{center}

From a consistent syntax equation asserting the syntax identity
of two objects new equations may be deduced for every attribute
label shared by the two objects.
Given such an attribute label, the values
of the attribute for the two objects are asserted to be syntactically
identical.  This is called \key{propagation}
of the syntax equation, and the rule that permits it is called
the \ikey{Propagation Rule}{propagation rule}\label{PROPAGATION-RULE}.
For example, from

\begin{center}
\verb/sort ($X) {| foo = 5 |} :=: sort ( 5 + 6 ) {| foo = 10 |}/
\end{center}

we can deduce by propagation that

\begin{center}
\begin{tabular}{r@\TT{~:=:~}l}
\verb/sort/ & \verb/sort/ \\
\verb/($X)/ & \verb/( 5 + 6 )/ \\
\verb/5/ & \verb/10/
\end{tabular}
\end{center}

The deduced equations need not be consistent in order to be deduced.
In this case the first two equations are consistent and the third is not.

In addition to the Propagation Rule, we apply the following, where
$v$ is a variable and $e_1$ and $e_2$ are subexpressions of the original
syntax equations:

\begin{indpar}
\begin{list}{}{}
\item [\ikey{Restricted Symmetry Rule}{restricted!symmetry rule}:]%
\label{RESTRICTED-SYMMETRY-RULE}
From $e_1$ \TT{:=:} $v$ we deduce $v$ \TT{:=:} $e_1$.

\item [\ikey{Restricted Transitivity Rule}{restricted!transitivity rule}:]%
\label{RESTRICTED-TRANSITIVITY-RULE}
From $v$ \TT{:=:} $e_1$ and $v$ \TT{:=:} $e_2$
we deduce $e_1$ \TT{:=:} $e_2$.
\end{list}
\end{indpar}

We have now given all the deduction rules used to solve syntax equations.
Note that these rules do \underline{not} create new syntax expressions:
all the syntax expressions in any deduced equation were subexpressions
in previous equations.  Because of this,
an algorithm that keeps making deductions until
no new deductions can be made will stop fairly quickly.

Note, however, that two different subexpressions
are not necessarily \TT{:=:} even if they are syntactically the same.
For example, given the original syntax equation:

\begin{center}
\verb/sort ($X, $Y) :=: sort ( 5, 5 )/
\end{center}

we derive by propagation that

\begin{center}
\begin{tabular}{r@\TT{~:=:~}l}
\verb/sort/ & \verb/sort/ \\
\verb/,/ & \verb/,/ \\
\verb/$X/ & \verb/5/$^1$ \\
\verb/$Y/ & \verb/5/$^2$ \\
\end{tabular}
\end{center}

where we have put superscripts $^1$ and $^2$ on the two \TT{5}'s to
indicate that they are different subexpressions of the original
syntax equation expressions.  But
but we are \underline{not} permitted to apply transitivity
to deduce \TT{\$X := \$Y},
because the two \TT{5}'s are not the \underline{same} subexpression of
the original syntax equation expressions.

However, we do make \TT{:=:} different subexpressions
that are variables with the same name.

\begin{quote}

As a technical matter we note that if we did use unrestricted rules
of symmetry, and transitivity, we would not get any essentially new results.
Specifically, the set of variables $v$ for which there is an equation of the
form $v$ \TT{:=:} $e$ where $e$ is not a variable would not expand.  Here
we assume that the original equations and all equations deduced from
these by Propagation, Restricted Symmetry, and Restricted Transitivity are
consistent.

Proof Sketch: Let $S$ be the original set of syntax equations.  Let $S'$ be
$S$ plus the equations deducible from equations in $S$ by using Propagation,
Restricted Symmetry, and Restricted Transitivity.

Let $S''$ be the set of equations $e_1$ \TT{:=:} $e_n$
such that there exists a sequence of expressions $e_2$, $e_3$,
\ldots, $e_{n-1}$ that are \underline{not} variables such that for $i<n$,
either $e_i$ \TT{:=:} $e_{i+1}$
or $e_{i+1}$ \TT{:=:} $e_i$ is in $S'$.  $n=2$ is allowed.

Let $S'''$ be $S$ plus
the equations deducible from $S$ by Propagation, Symmetry,
and Transitivity, without any restriction.

Then $S\subseteq S'\subseteq S''\subseteq S'''$.

If we can prove that
$S''=S'''$, the result will follow, since for a given $v$ an equation
of the form $v$ \TT{:=:} $e$ with $e$ a non-variable can exist in $S''$ only
if an equation of this form exists in $S'$.

So we need to prove $S'''\subseteq S''$.  We do this by mathematical
induction on the size of the deduction of an equation in $S'''$.
This amounts to applying the general rules, Symmetry, Transitivity,
and Propagation to equations in $S''$ and showing that the resulting
consequent must be an equation in $S''$, under the assumption that the
equations in $S'$ are consistent.

\end{quote}

\subsection{Patterns}
\label{PATTERNS}
\label{PATTERN-EQUATIONS}

A \emkey{pattern} is an object that represents one of
a set of syntax expressions.  Patterns are used in
{\em pattern-equations}, which identify a {\em syntax-expression} with
a {\em pattern}.  The syntax of a pattern equations and patterns is:

\begin{indpar}
\emkey{pattern-equation} ::= {\em syntax-expression} \ttkey{:=\~~}
			    {\em pattern}
			    \\[1ex]
\emkey{pattern} ::= {\em pattern-object}
\label{PATTERN}
\\[3ex]
\emkey{pattern-object} ::=
    \begin{tabular}[t]{l}
    {\em pattern-term-option}
        \{ {\em pattern-separator} {\em pattern-term} \}\STAR{} \\
    {\em pattern-attribute-representations}
    \end{tabular}
\label{PATTERN-OBJECT}
    \\[1ex]
\emkey{pattern-term-option} ::= {\em empty} $|$ {\em pattern-term} \\[1ex]
\emkey{pattern-separator} ::= \ttmkey{.}{pattern separator} \\[1ex]
\emkey{pattern-term} ::= {\em pattern-clause} {\em pattern-qualifier-option}
	\\[1ex]
\emkey{pattern-clause} ::= {\em pattern-factor}\PLUS{}
	\\[1ex]
\emkey{pattern-factor} ::= {\em pattern-object} $|$ {\em atom}
		       $|$ {\em syntax-variable} \\[1ex]
\emkey{pattern-qualifier-option} ::=
	{\em empty} $|$ {\em pattern qualifier} \\[1ex]
\emkey{pattern-qualifier} ::=
		           \ttmkey{?}{pattern qualifier}
		       $|$ \ttmkey{??}{pattern qualifier}
		       $|$ \ttmkey{...}{pattern qualifier}
		       $|$ \ttmkey{...?}{pattern qualifier}
	\\[1ex]
\emlkey{pattern-attribute-}{representations}
\\\hspace*{0.5in}
	\begin{tabular}[t]{rl}
        ::= & {\em empty} \\
	$|$ & \TT{\{| |\}} \\
	$|$ & \TT{\{|}
	      \begin{tabular}[t]{@{}l@{}}
	      {\em pattern-attribute-representation} \\
	      \{ \TT{;}
	              {\em pattern-attribute-representation} \}\STAR{}
	      \TT{|\}} \\
	      \end{tabular}
	\end{tabular}
\\[1ex]
\emlkey{pattern-attribute-}{representation} ::=
\\\hspace*{0.5in}
    {\em required-attribute-representation}
    $|$ {\em optional-attribute-representation}
\\[1ex]
\emlkey{required-pattern-attribute-}{representation} ::=
\\\hspace*{0.5in}
	{\em attribute-label} {\em attribute-label-flags-option} \TT{=}
	      {\em pattern}
\\[1ex]
\emlkey{optional-pattern-}{attribute-representation} ::=
\\\hspace*{0.5in}
	{\em attribute-label} {\em attribute-label-flags-option} \TT{=?}
	      {\em pattern}
\end{indpar}

A pattern represents one of many possible syntax expressions.  The
syntax expression it represents is made by concatenating the
{\em pattern-clauses} in different ways.  For example,

\begin{center}
\verb/replace ($X) . in ($Y) . by ($Z)/
\end{center}

represents one of the two syntax expressions:

\begin{center}
\verb/replace ($X) in ($Y) by ($Z)/ \\
or \\
\verb/replace ($X) by ($Z) in ($Y)/ 
\end{center}

The rules for pattern representation are:

\begin{enumerate}
\item The represented {\em syntax-expression} is a sequence of
{\em pattern-clauses} from the {\em pattern} taken in any order,
\underline{except}, if the first {\em pattern-clause} in the
{\em pattern} is not preceded by {\em pattern-separator} `\TT{.}',
it must be first in the {\em syntax-expression}.

\item A {\em pattern-clause} not followed by a {\em pattern-qualifier}
(\TT{?}, \TT{??}, \TT{...}, or \TT{...?})
in the {\em pattern} must appear exactly
once in the represented {\em syntax-expression}.

\item A {\em pattern-clause} followed by `\TT{?}'
in the {\em pattern} is an \key{optional pattern clause}
and must appear exactly once or not at all
in the represented {\em syntax-expression}.
See \secref{DEFAULT-EQUATIONS} for examples.

\item\label{OPTIONAL-TRUTH-VALUE-CLAUSE-RULE}
A {\em pattern-clause} followed by `\TT{??}'
in the {\em pattern} is an
\ikey{optional truth-value pattern clause}{optional truth-value!pattern clause}.
Like an optional pattern clause this must appear exactly once or not at all
in the represented {\em syntax-expression}.
In addition, the {\em pattern-clause} must end with a {\em syntax-variable},
and this may be omitted in the represented {\em syntax-expression}.
See \secref{OPTIONAL-TRUTH-VALUE-PATTERN-CLAUSES} for examples.

\item A {\em pattern-clause} followed by `\TT{...}'
in the {\em pattern} is a \key{repeated pattern clause}
and must appear one or more times
in the represented {\em syntax-expression}.
See \secref{REPEATED-PATTERN-CLAUSES} for examples.

\item A {\em pattern-clause} followed by `\TT{...?}'
in the {\em pattern} is an \lkey{optional repeated}{pattern clause}
and must appear one or more times or not at all
in the represented {\em syntax-expression}.
See \secref{REPEATED-PATTERN-CLAUSES} for examples.

\item A {\em syntax-variable} in a {\em pattern}
that appears in an {\em alternative-equation}
is called an \key{alternative-syntax-variable} and must be replaced
(along with any parentheses surrounding it)
in the represented {\em syntax-ex\-pres\-sion}
by one of the {\em alternatives} from the {\em alternative-equation}.
See \secref{ALTERNATIVE-EQUATIONS} for examples.

\item A {\em required-pattern-attribute-representation}
that has an `\TT{=}' sign
must appear exactly once in the represented {\em syntax-expression}.

\item An {\em optional-pattern-attribute-representation}
that has an `\TT{=?}' sign
and must appear exactly once or not at all
in the represented {\em syntax-expression}.

\end{enumerate}

Patterns appear in pattern equations, which are just
like syntax equations except their right sides are patterns and not
a syntax expressions.  If the syntax expression on the left side of
a pattern equation is an object, then the pattern on the right side
can be \key{unfolded} to match the syntax expression.  Unfolding
means removing the
\skey{pattern separator}s, `\TT{.}',
and \skey{pattern qualifier}s,
`\TT{?}', `\TT{??}', `\TT{...}', and `\TT{...?}',
arranging the pattern clauses in the correct order,
and removing {\em optional-attribute-representations}.
For example, given the pattern equation:

\begin{indpar}
\verb/replace {b} by {5 + c} in (exp 1) :=~/ \\
\verb/    replace ($X) . in ($Y) . by ($Z)/
\end{indpar}

The pattern may be unfolded so the equation becomes:

\begin{indpar}
\verb/replace {b} by {5 + c} in (exp 1) :=~/ \\
\verb/    replace ($X) by ($Z) in ($Y)/
\end{indpar}

The \key{Propagation Rule} (\pagref{PROPAGATION-RULE})
may be applied to a pattern
equation whose right side pattern has been unfolded.  Thus in the
example just given one may may deduce:

\begin{center}
\begin{tabular}{r@{\TT{~:=\~~~}}l}
\verb/{b}/ & \verb/($X)/ \\
\verb/{5 + c}/ & \verb/($Z)/ \\
\verb/(exp 1)/ & \verb/($Y)/ \\
\end{tabular}
\end{center}

Note that this results in pattern equations and \underline{not}
syntax equations.

A pattern that contains pattern separators or qualifiers
(`\TT{.}', `\TT{?}', `\TT{??}', `\TT{...}', or `\TT{...?}')
\underline{outside} subexpressions and {\em attribute-representations},
or that contains {\em optional-attribute-representations}
(with `\TT{=?}' sign),
is said to be `\key{folded}'.  Other patterns are said to be
\key{unfolded}.  Subexpressions of a pattern are also patterns.

A pattern that is unfolded and all of whose subexpressions
and attribute representation patterns are
unfolded, that is, a pattern that contains no pattern qualifiers or
optional attribute representations,
even in subexpressions or attribute representations,
is said to be \key{completely unfolded}.
Such patterns are \key{promoted} to be syntax expressions, and
any pattern equations containing them are promoted to be
syntax equations.  Thus in the above example the last four
pattern equations can be promoted and become the following
four syntax equations:

\begin{center}
\begin{tabular}{c}
\verb/replace {b} by {5 + c} in (exp 1)/ \\
\verb/:=:/ \\
\verb/replace ($X) by ($Z) in ($Y)/ \\
\end{tabular} \\[2ex]
\begin{tabular}{r@\TT{~:=:~}l}
\verb/{b}/ & \verb/($X)/ \\
\verb/{5 + c}/ & \verb/($Z)/ \\
\verb/(exp 1)/ & \verb/($Y)/ \\
\end{tabular}
\end{center}

The Restricted Symmetry Rule (\pagref{RESTRICTED-SYMMETRY-RULE})
and Restricted Transitivity Rule (\pagref{RESTRICTED-TRANSITIVITY-RULE})
cannot be applied to pattern equations, which are inherently asymmetric.
However the following can be applied, where $v$ is a syntax variable, $e$
a syntax expression, and $p$ a pattern:

\begin{indpar}
\begin{list}{}{}
\item [\ikey{Pattern Transitivity Rule}{pattern transitivity rule}:]%
\label{PATTERN-TRANSITIVITY-RULE}
From $v$ \TT{:=:} $e$ and $v$ \TT{:=\~~} $p$
we deduce $e$ \TT{:=\~~} $p$.
\end{list}
\end{indpar}

The Parentheses Rule (\pagref{PARENTHESES-RULE})
and Atom Rule (\pagref{ATOM-RULE}) do apply to pattern equations.
For example, a pattern that is an atom may be treated as if it were
a list whose only element is that atom, and a syntax variable in
\TT{( )} parentheses is treated as a syntax variable.

Finally, we need to state the following more carefully:

\begin{indpar}
\begin{list}{}{}
\item [\ikey{Pattern Unfolding Rule}{pattern unfolding rule}:]%
\label{PATTERN-UNFOLDING-RULE}
If a pattern equation asserts the identity of a syntax expression that
is an object with a pattern, and if the pattern can be unfolded unambiguously
so that the result would be consistent were the pattern equation
instead a syntax equation between
objects, then the pattern is unfolded.  Otherwise nothing is done.

When a pattern is unfolded, \underline{all instances} of the pattern
are unfolded, and this affects all equations containing the pattern.
\end{list}
\end{indpar}

The last sentence of the Pattern Unfolding Rule needs explanation.
Suppose we start with the pattern equation:

\begin{indpar}
\verb/replace {b} [by {5 + c} in (exp 1)] :=~/ \\
\verb/    replace ($X) [. in ($Y) . by ($Z)]/
\end{indpar}

which is similar to our previous equation except the clauses are
now in a subexpression.  At the top level there is only one clause,
so the pattern is already unfolded, and by the Propagation Rule
we get

\begin{center}
\begin{tabular}{r@{\TT{~:=\~~~}}l}
\verb/replace/ & \verb/replace/ \\
\verb/{b}/ & \verb/($X)/ \\
\verb/[by {5 + c} in (exp 1)]/ & \verb/[. in ($Y) . by ($Z)]/ \\
\end{tabular}
\end{center}

Now we have a total of 4 equations.
The pattern in the last of these equations can be unfolded and
when this is done, \underline{all} the equations containing the pattern are
affected, and we have the 4 equations

\begin{center}
\begin{tabular}{c}
\verb/replace {b} [by {5 + c} in (exp 1)]/ \\
\verb/:=~/ \\
\verb/replace ($X) [by ($Z) in ($Y)]/ \\
\end{tabular} \\[2ex]
\begin{tabular}{r@{\TT{~:=\~~~}}l}
\verb/replace/ & \verb/replace/ \\
\verb/{b}/ & \verb/($X)/ \\
\verb/[by {5 + c} in (exp 1)]/ & \verb/[by ($Z) in ($Y)]/ \\
\end{tabular}
\end{center}

In other words, because the pattern in the equation

\begin{center}
\begin{tabular}{r@{\TT{~:=\~~~}}l}
\verb/[by {5 + c} in (exp 1)]/ & \verb/[. in ($Y) . by ($Z)]/ \\
\end{tabular}
\end{center}

was a subexpression of the pattern in the equation

\begin{indpar}
\verb/replace {b} [by {5 + c} in (exp 1)] :=~/ \\
\verb/  replace ($X) [. in ($Y) . by ($Z)]/
\end{indpar}

then what appears to be two copies of the same pattern is in fact
only one copy, and unfolding either of these unfolds the other in
exactly the same way.

This is another aspect of the remark near the end of
Section~\secref{SYNTAX-EQUATIONS} that deduction does not create
new syntax expressions: it merely creates new equations between
existing syntax expressions.  This means the deduction process must
quickly terminate, since the supply of syntax expressions is limited to
those in the the initial equations.  Similarly new patterns are not
created by deduction, only new equations involving existing patterns.
And when a pattern unfolds, the folded pattern is replaced by the
unfolded pattern in all equations involving the pattern.

If after doing all possible deductions on a set of equations
all patterns are unfolded,
then all pattern equations will have been promoted to syntax equations.
If on the other hand, some patterns remain folded, then the pattern
equations involving them are said to be
`\mkey{unsolvable}{pattern equations}'.

A pattern equation between a syntax expression that is not a syntax
variable and a folded pattern is said to be
`\mkey{inconsistent}{pattern equation}' if there is \underline{no}
way to unfold the pattern so that the equation can be viewed as a
consistent syntax equation.  Clearly if a pattern equation is inconsistent
then the pattern equation will be unsolvable, or the pattern equation
will become inconsistent when some other equation causes the pattern
to be unfolded and the pattern equation to be promoted so it becomes
an inconsistent syntax equation.

However, if there is more than one way to unfold a pattern in a pattern
equation so that the equation can be viewed as a consistent syntax equation,
then the equation is said to be `\mkey{ambiguous}{pattern equation}'.
An ambiguous equation cannot be used to unfold a pattern, and may become
unsolvable, but, it is possible that another non-ambiguous pattern equation
may exist or be deduced which will allow the pattern to be unfolded, in
which case at the end of all deductions there may be no unfolded patterns
left and no unsolvable pattern equations.  In this case the
ambiguous pattern equation will have been promoted to be a syntax equation,
which may or may not be consistent.

\subsubsection{Default Equations}
\label{DEFAULT-EQUATIONS}

When a pattern is unfolded, syntax variables in optional pattern clauses
not included in the unfolded pattern are given default values
provided by default equations.  Default equations have the
syntax:

\begin{indpar}
\emkey{default-equation} ::= {\em syntax-variable} \ttkey{:=?}
			     {\em default-value}
\\[1ex]
\emkey{default-value} ::= {\em syntax-expression}
\end{indpar}

For example, given the equations:

\begin{center}
\begin{tabular}{rcl}
\verb/sort x/ & \TT{:=\~~} & \verb/sort ($X) . in direction ($Y) ?/ \\
\verb/$Y/ & \tt :=? & \verb|ascending|
\end{tabular}
\end{center}

the pattern in the first equation will be unfolded to give the equation:

\begin{center}
\begin{tabular}{rcl}
\verb/sort x/ & \TT{:=\~~} & \verb/sort ($X)/ \\
\end{tabular}
\end{center}

and because the variable \TT{\$Y} was dropped during the unfolding,
the default equation that defines it will promoted to become the syntax
equation:

\begin{center}
\begin{tabular}{rcl}
\verb/$Y/ & \tt :=: & \verb|ascending|
\end{tabular}
\end{center}

thereby establishing a value for \TT{\$Y}.  Default equations that
are not promoted to become syntax equations by this mechanism are
ignored.  This mechanism does \underline{not} apply to repeated pattern
clauses or optional repeated pattern clauses.

\subsubsection{Alternative Equations}
\label{ALTERNATIVE-EQUATIONS}

An {\em alternative-equation} specifies that a syntax variable must take
one of several alternative values.

\begin{indpar}
\emkey{alternative-equation} ::= \\
\hspace*{3em}{\em syntax-variable}
		\TT{:=:} {\em alternative}
		          \TT{|} {\em alternative}
			  \{ \TT{|} {\em alternative} \}\STAR{}
		\\[1ex]
\emkey{alternative} ::= {\em atom}\PLUS{}
\end{indpar}

For example,
\begin{center}
\verb/DIRECTION :=: ascending | descending/
\end{center}

Note that the {\em alternatives} are simple {\em atom} sequences,
and cannot include subexpressions or {\em syntax-variables}.

The {\em syntax-variable} in an alternative equation is called an
\key{alternative-syntax-variable}.  When such a variable appears
in a pattern it must be replaced by one of the {\em alternatives}
from the {\em alternative-equation} when the pattern is unfolded.
Any parentheses surrounding the variable in the pattern are removed.
The replacing {\em alternative} is integrated into the unfolded
pattern as if it had appeared in the pattern instead of the
{\em alternative-syntax-variable} and any parentheses surrounding it.

For example, given the above {\em alternative-equation} and the
{\em pattern-equation}
\begin{center}
\verb/sort ascending (3,2,7,8) :=~ sort DIRECTION (X)/
\end{center}
the pattern in thus equation can be unfolded to make the {\em syntax-equation}
\begin{center}
\verb/sort ascending (3,2,7,8) :=: sort ascending (X)/
\end{center}

However, given instead the pattern equation
\begin{center}
\verb/sort (SORT DIRECTION) (3,2,7,8) :=~ sort DIRECTION (X)/
\end{center}
the pattern in thus equation \underline{cannot} be unfolded because
there is ambiguity about which {\em alternative}
should replace \TT{DIRECTION}.

Whenever a pattern containing a {\em alternative-syntax-variable}
is unfolded, a particular {\em alternative} replaces the
variable in the pattern, and the syntax equation
\begin{center}
{\em alternative-syntax-variable} \TT{:=:} {\em alternative}
\end{center}
is asserted.  In this equation the unevaluated form of the
{\em alternative-syntax-variable} is used.  Thus in the above
example where the pattern was unfolded, the equation
\begin{center}
\verb/$DIRECTION :=: ascending/
\end{center}
is asserted.



\subsubsection{Optional Truth-Value Pattern Clauses}
\label{OPTIONAL-TRUTH-VALUE-PATTERN-CLAUSES}

An \ikey{optional truth-value pattern clause}%
{optional truth-value!pattern clause}%
\index{truth-value!pattern clause}%
\index{pattern clause!optional truth value}
(with `\TT{??}' {\em clause-qualifier}\,)
must end with a syntax variable $v$,
and this variable is treated specially in the following ways.
First, the guard:
\begin{center}
truth value ($v$)
\end{center}
is asserted.  Second, if the clause is omitted from the unfolded pattern,
the syntax equation
\begin{center}
$v$ \TT{:=:} \TT{false}
\end{center}
is asserted.  Third, the clause without its ending syntax variable
may appear in the unfolded pattern,
according to Rule \itemref{OPTIONAL-TRUTH-VALUE-CLAUSE-RULE},
in which case the syntax equation
\begin{center}
$v$ \TT{:=:} \TT{true}
\end{center}
is asserted.

Here $v$ is usually an evaluated syntax variable
(\pagref{EVALUATED-SYNTAX-VARIABLES}), but it may be
an unevaluated syntax variable.

For example, the pattern equation

\begin{center}
\begin{tabular}{rcl}
\verb/sort x/ & \TT{:=\~~} & \verb/sort ($X) . ascending ASCENDING ??/ \\
\end{tabular}
\end{center}

produces the guard and syntax equation:

\begin{center}
\verb/truth value (ASCENDING)/ \\
\begin{tabular}{rcl}
\verb/ASCENDING/ & \tt :=: & \verb/false/ \\
\end{tabular}
\end{center}

and the pattern equation

\begin{center}
\begin{tabular}{rcl}
\verb/sort x ascending/ & \TT{:=\~~} &
	\verb/sort ($X) . ascending ASCENDING ??/ \\
\end{tabular}
\end{center}

produces the guard and syntax equation:

\begin{center}
\verb/truth value (ASCENDING)/ \\
\begin{tabular}{rcl}
\verb/ASCENDING/ & \tt :=: & \verb/true/ \\
\end{tabular}
\end{center}



\subsubsection{Repeated Pattern Clauses}
\label{REPEATED-PATTERN-CLAUSES}

When a pattern is unfolded, a syntax variable in a
repeated or optional repeated pattern clause is replaced
in the unfolded pattern by new variables that represent elements of a list,
and a new syntax equation setting the original variable to this list
is created.  For example, when the pattern in the equation

\begin{center}
\begin{tabular}{rcl}
\verb/increment x by 5 by 10/ & \TT{:=\~~}
			      & \verb/increment ($X) . by ($Y) ...?/ \\
\end{tabular}
\end{center}

is unfolded, the following equations result:

\begin{center}
\begin{tabular}{rcl}
\verb/increment x by 5 by 10/ & \TT{:=\~~}
			      & \verb/increment ($X) by ($Y$1) by ($Y$2)/ \\
\verb/$Y/ & \tt :=: & \verb|($Y$1, $Y$2)|
\end{tabular}
\end{center}

Note that here `\TT{\$Y\$1}' and `\TT{\$Y\$2\$}' are each a single syntax
variable name, each with two \TT{\$}'s in it.  Users of RECKON should
not use \TT{\$} two or more times in
a syntax variable name in order to avoid conflicting
with this usage.

With an optional repeated pattern clause it is also possible for the
resulting list to be empty.  Thus

\begin{center}
\begin{tabular}{rcl}
\verb/increment x/ & \TT{:=\~~}
			      & \verb/increment ($X) . by ($Y) ...?/ \\
\end{tabular}
\end{center}

yields

\begin{center}
\begin{tabular}{rcl}
\verb/increment x/ & \TT{:=\~~}
			      & \verb/increment ($X)/ \\
\verb/$Y/ & \tt :=: & \verb|()|
\end{tabular}
\end{center}

\subsubsection{Place Holding Syntax Variables}
\label{PLACE-HOLDING-SYNTAX-VARIABLES}

A `\TT{\$}' by itself can be used as a syntax variable called
a \lkey{place holding}{syntax variable} that has the special
property that each of its original equation occurrences
is treated as if it were a \underline{different} variable.  The syntax is:

\begin{indpar}
\emlkey{place-holding}{-syntax-variable} ::= \ttkey{\$}
\end{indpar}

More specifically, whenever \TT{\$} appears in an original
equation, it is replaced by a unique new syntax variable name. 
For example, the pattern equation:

\begin{indpar}
\verb/replace {b} by {5 + c} in (exp 1) :=:/ \\
\verb/    replace ($X) . by $ . in $/
\end{indpar}

is treated as if it were

\begin{indpar}
\verb/replace {b} by {5 + c} in (exp 1) :=:/ \\
\verb/    replace ($X) . by ($1$) . in ($2$)/
\end{indpar}

where `\TT{\$1\$}' and `\TT{\$2\$}' are unique new
syntax variable names created by the RECKON system.




\subsubsection{Evaluated Syntax Variables}
\label{EVALUATED-SYNTAX-VARIABLES}

Syntax variables whose names begin with \TT{\$}
take values that are syntax expressions
which are \underline{not} evaluated.  Such syntax variables are called
\lkey{unevaluated}{syntax variables}.  With every unevaluated syntax
variable there can be associated an \key{evaluated syntax variable}
whose name is made by omitting the \TT{\$} from the beginning of the
unevaluated syntax variable name.  Thus \TT{X} is associated with
\TT{\$X}.  The syntax is:

\begin{indpar}
\emlkey{unevaluated-syntax-}{variable}
			\begin{tabular}[t]{rl}
			::= & \TT{\$} {\em capitalized-word } \\
			$|$ & \TT{\$} \TT{(} {\em capitalized-word }
			      {\em name-component}\STAR{} \TT{)} \\
			\end{tabular}
\\[1ex]
\emkey{evaluated-syntax-variable} 
			::= {\em capitalized-word }
			{\em name-component}\STAR{}
\\[1ex]
{\em name-component} ::= {\em non-special-symbol} $|$ {\em decimal-natural}
			 ~~~ [as per \pagref{NAME-COMPONENT}]
\end{indpar}

Informally, an evaluated syntax variable is assigned the value obtained by
evaluating its associated unevaluated syntax variable's value.  In order
for this to happen, the unevaluated syntax variable must be evaluatable.
This means that its value, a syntax expression, must not contain any
unevaluatable syntax variables.

More formally:

\begin{indpar}
\begin{list}{}{}
\item [\ikey{Evaluatable Definition}{evaluatable definition}:]%
\label{EVALUATABLE-DEFINITION}
A syntax variable $v$ is evaluatable if a syntax equation $v$ \TT{:=:} $e$
has been deduced and every syntax variable in $e$ is evaluatable.
In this case $e$ is called the \key{unevaluated value} of $v$, and
the \key{complete unevaluated value} of $v$ is $e$ with all the
syntax variables it contains replaced by their complete unevaluated values.
\item [\ikey{Evaluation Rule}{evaluation rule}:]%
\label{EVALUATION-RULE}
If an evaluated syntax variable $v$ appears in a syntax equation and
its associated unevaluated syntax variable \TT{\$}$v$ is evaluatable,
then the syntax equation $v$ \TT{:=:} $E$ is deduced, where $E$
is the value obtained by evaluating the unevaluated value of
\TT{\$}$v$ in the context
in which the unevaluated value of \TT{\$}$v$ appears.
It is an error if this evaluation has side effects (\pagref{SIDE-EFFECTS}).
\end{list}
\end{indpar}

For example, given the code

\begin{indpar}\begin{verbatim}
sum ($X) and ($Y) <-- number(X), number(Y) { value = X + Y }
. . . . .
z = sum (1+1) and (5+5)
\end{verbatim}\end{indpar}

the call to `\TT{sum}' in the last line is matched with the definition
of `\TT{sum}' in the first line giving rise to a number of deduced
equations, among which are:

\begin{center}
\begin{tabular}{rcl}
\verb/sum (1+1) and (5+5)/ & \TT{:=\~~}
			      & \verb/sum ($X) and ($Y)/ \\
\verb/$X/ & \tt :=: & \verb/(1+1)/ \\
\verb/$Y/ & \TT{:=:\~~} & \verb/(5+5)/ \\
\verb/X/ & \tt :=: & \verb/2/ \\
\verb/Y/ & \TT{:=:\~~} & \verb/10/ \\
\end{tabular}
\end{center}

The last two equations are required to deduce the value of the evaluated
variables \TT{X} and \TT{Y} that are needed for the guards
\TT{number(X)} and \TT{number(Y)} and the block code statement
`\TT{value = X + Y}'.  These last two equations are obtained by
the Evaluation Rule.  For example, to obtain the value \TT{2} for the
evaluated variable \TT{X}, the value `\TT{(1+1)}' of the a associated
unevaluated variable \TT{\$X} is evaluated.  `\TT{(1+1)}' is
evaluatable because it contains no syntax variables and for this reason is
also its own `complete unevaluated value'.

Semantically, evaluated syntax variables are not permitted in patterns.
However, syntactically they can be placed in patterns according to the
following:

\begin{indpar}
\begin{list}{}{}
\item [\ikey{Evaluated Variable Pattern Rule}%
{evaluated variable!pattern rule}:]%
\label{EVALUATED-VARIABLE-PROMOTION-RULE}
If an evaluated syntax variable $v$ appears in a pattern, it is 
replaced in the pattern by its associated unevaluated variable
\TT{\$}$v$, and in addition
any occurrences of \TT{\$}$v$ in the containing expression definition
are treated as errors (i.e., $v$ and not \TT{\$}$v$ must be used
throughout the expression definition).
\end{list}
\end{indpar}

For example, the definition

\begin{indpar}\begin{verbatim}
for every counter:
    on increment THIS . by Y ? <-- number(Y), Y :=? 1:
        next count = count + Y
\end{verbatim}\end{indpar}

is treated as if it were

\begin{indpar}\begin{verbatim}
for every counter:
    on increment $THIS . by $Y ? <-- number(Y), Y :=? 1:
        next count = count + Y
\end{verbatim}\end{indpar}

while the definition

\begin{indpar}\begin{verbatim}
for every counter:
    on increment THIS . by Y ? <-- number(Y), $Y :=? 1:
        next count = count + Y
\end{verbatim}\end{indpar}

would be in error because \TT{Y} is used in the pattern but
\TT{\$Y} is used in the default equation.

\subsection{The Matching Algorithm}
\label{MATCHING-ALGORITHM}

The \key{evaluation algorithm} inputs an expression to be evaluated
and a context.  The context (\secref{CONTEXTS}) provides a list of expression
definitions that may match the expression.

An expression to be evaluated may contain syntax variables that are assigned
values during matching.  The result of matching is both a list of values for
the expression and an assignment of values for these variables.

More than one definition may match an expression.
More than one definition may match a guard,
and different guard definitions may lead to different
values of variables in the original expression being evaluated.
So expression matching is a search process to find a choice
of expression definitions that
leads to success, and more than one choice may succeed.

Note that evaluations of guards and evaluations
used to find values of evaluated syntax variables are required to have
no side effects, so the order of these evaluations does not matter.
Given the choices of which definitions are matched to which expressions,
the outcome of the matching process is uniquely determined, and does not
depend on the order of syntax equation deductions, guard evaluations, etc.,
or on the order in which the choices are tried.

Matching may be done in any of the following \skey{matching mode}s:

\begin{list}{}{}

\item[\ttkey{first-value}]~\\
The first definitions tried that lead to successful matches are the only ones
used.  Definitions are tried in the order they are given in the contexts
used in evaluation.

\item[\ttkey{all-values}]~\\
All possible choices are tried and the
successful results are collected in a set of results.  Each result
in this set consists of a value list for the expression being evaluated
and values for each syntax variable in that expression.

\item[\ttkey{consistent-values}]~\\
All possible choices are tried and the
successful results are collected in a set of results.  Then these results
are tested to see if they are pairwise equal.
All the value lists of the expression
being evaluated must be equal, and all the values of each syntax variable
contained in the expression must be equal.  If all expression value lists or
values of a syntax variable are equal, one of these expression value lists
is returned as the value list of the expression, and one syntax variable value
is returned as the value of the syntax variable.
If some of the expression value lists or syntax variable values are unequal, an
error value giving the context of the evaluation and the unequal value lists
or values is returned as the value of the expression or syntax variable.

\end{list}

If the expression match search process yields no matches at all,
the expression is given the value `\TT{false}', and variables in the
expression are not given any values.

\subsection{Contexts}
\label{CONTEXTS}

An expression is evaluated in a context.  The context is searched
for an expression definition whose pattern matches the expression being
evaluated, and that definition is then used to evaluate the expression.

A \key{context} is either a list or a set of expression definitions and
other contexts.  Context elements that are expression definitions are
matched to the expression being evaluated.  Context elements that are
themselves contexts are searched recursively.

\ikey{Context lists}{list!context} are searched in order if the
matching mode is \TT{first-value}, and are searched exhaustively
otherwise.
\ikey{Context sets}{set!context} are always searched exhaustively.

An expression definition is an object (\secref{OBJECTS})
that consists of a pattern, an optional list of constraints,
an optional block, and an optional context.  An
{\em expression-definition} (\pagref{EXPRESSION-DEFINITION})
computes an expression definition that has no context.
A context can be added to the expression definition later by executing:

\begin{indpar}
\TT{set} {\em expression-definition} \TT{context} {\em context}
\end{indpar}

Once a context has been added to an expression definition, the context
cannot be changed.

A new expression definition can be made from an old one by
the expression:

\begin{indpar}
	\verb|an| \ttkey{expression-definition}
	      {\em expression-definition}
	      {\em context}
\end{indpar}

The new expression definition has a different context, given by
the second argument, than the first argument does.  The special
value \ttmkey{UNDEFINED}{argument of an!expression-definition@{\tt
expression-definition}} can be given as the {\em context} argument
to create a new expression definition whose pattern, constraints, and block
are the same as those of {\em expression-definition} argument
but whose context part is missing and can be set later.

There are two kinds of contexts: \mkey{immutable}{context} and
\mkey{mutable}{context}.
An immutable context cannot be modified.  A mutable context can have
its list (or set) modified.
Each kind can be either a set or a list.

A context can be created by:

\begin{indpar}
\verb|a| \ttkey{context}
    \begin{tabular}[t]{@{}l@{}}
    \verb|(| {\em context-element} \{ \verb|,| {\em context-element} \}
	\verb|)| \\
    \ttmkey{is list}{of context!of \TT{context}} {\em list} \\
    \ttmkey{is mutable}{of context!of \TT{context}}
           {\em mutable} \\
    \ttmkey{with contexts missing}{of context!of \TT{context}}
           {\em contexts-missing}
    \end{tabular}
\end{indpar}

in which each {\em context-element} is either an expression definition or
a context, and {\em list}, {\em mutable}, and {\em contexts-missing}
are either `\TT{false}' (the default) or `\TT{true}'.
If {\em contexts-missing} is \TT{false} (the default), any expression
definition {\em context-elements} that do not have their
contexts set will have them set equal to the context being created.

Thus given expression definitions that do not have their contexts set,
the default is to create an immutable context set whose expression definitions
have the new context and therefore can reference each other.  Blocks
containing {\em expression-definitions} perform exactly this kind of
context creation.

The {\em context-item} list of a context object is a list object
(\pagref{LIST}) which can be extracted from the context object by

\begin{indpar}
\verb|the| \ttmkey{list}{of context} \verb|of| {\em context}
\end{indpar}

This list object is a list or set according to whether or not the
context is a list or set, and the list object is immutable or mutable
according to whether or not the context object is immutable or mutable.
If mutable, altering the list object will alter its containing context
object, and this is in fact the only way to mutate a mutable context.

\section{Blocks}
\label{BLOCKS}

A block is a set of variables, values for some of the variables, and
code for computing these values.  Blocks are optional parts of
{\em expression-definitions} (\secref{EXPRESSION-DEFINITION}).

\subsection{Block Syntax}
\label{BLOCK-SYNTAX}

The code of a block has the following syntax:

\begin{indpar}
\emkey{block} ::= \TT{\{} {\em group}
                         \{ {\em sequence-break} {\em group} \}\STAR{}
			 \TT{\}} \\[1ex]
\emkey{sequence-break} ::= \ttkey{-----}\TT{-}\STAR{}
	(1 word consisting of 5 or more \TT{-}'s) \\[1ex]
\emkey{group} ::= {\em declaration-group} $|$ {\em statement-group}
			 \\[1ex]
\emkey{declaration-group}\label{DECLARATION-GROUP} ::= {\em declaration}
    \{ \TT{;} {\em declaration} \}\STAR{} \\[1ex]
\emkey{statement-group} ::= {\em statement}
	\{ \TT{;} {\em statement} \}\STAR{} \\[1ex]
\emkey{declaration} ::= {\em expression-definition} $|$ {\em empty} \\[1ex]
\emkey{expression-definition} ::= see \pagref{EXPRESSION-DEFINITION} \\[1ex]
\emkey{statement}
    \begin{tabular}[t]{rl}
    ::= & {\em unqualified-statement} \\
    $|$ & {\em statement-qualifier} {\em unqualified-statement} \\
    $|$ & {\em empty }
    \end{tabular}
\label{STATEMENT}\\[1ex]
\emkey{statement-qualifier} ::= \ttkey{first}
			    $|$ \ttkey{always}
			    $|$ \ttkey{default}
			    \\[1ex]
\emkey{unqualified-statement}
    \begin{tabular}[t]{rl}
    ::= & {\em assignment-statement} \\
    $|$ & {\em unguarded-subblock} \\
    $|$ & {\em guarded-statement}
    \end{tabular} \\[1ex]
\emkey{assignment-statement}
	\begin{tabular}[t]{rl}
	::= & {\em variable-assignment-statement} \\
	$|$ & {\em pattern-assignment-statement}
	\end{tabular} \\[1ex]
\emlkey{variable}{-assignment-statement} ::=
	{\em output-variable} \ttkey{=} {\em right-side} \\[1ex]
\emkey{right-side} \
    \begin{tabular}[t]{rl}
    ::= & {\em operator-expression} \\
    $|$ & {\em operator-expression} \ttkey{=>} {\em output-variable}
		\{ \TT{,} {\em output-variable} \}\STAR{}
    \end{tabular} \\[1ex]
{\em operator-expression} ::= see \pagref{OPERATOR-EXPRESSION} \\[1ex]
\emkey{output-variable} ::= {\em variable-name} $|$ {\em next-variable} \\[1ex]
\emkey{next-variable} ::= \ttkey{next} {\em variable-name} \\[1ex]
\emkey{variable-name} ::= {\em name} ~~~~~ [see \pagref{NAME}] \\[1ex]
\emlkey{pattern}{-assignment-statement} ::=
	{\em pattern} \TT{\~~=\~~}\index{~=~@{\TT{\~~=\~~}}}
	{\em right-side} \\[1ex]
{\em pattern} ::= see \pagref{PATTERN} \\[1ex]
\emkey{unguarded-subblock} ::= \TT{\{} {\em statement-group} \TT{\}} \\[1ex]
\emkey{guarded-statement} ::=
      {\em if-statement} $|$ {\em when-statement} \\[1ex]
\emkey{if-statement} ::=
      \begin{tabular}[t]{l}
      \ttkey{if} {\em guard} {\em unguarded-subblock} \\
      {\em else-if-continuation}\STAR{} \\
      {\em else-continuation-option}
      \end{tabular} \\[1ex]
\emkey{else-if-continuation} ::=
      \TT{;} \ttkey{else if} {\em guard} {\em unguarded-subblock} \\[1ex]
\emkey{else-continuation-option} ::= {\em empty} $|$
      \TT{;} \ttkey{else} {\em unguarded-subblock} \\[1ex]
\emkey{when-statement} ::=
      \ttkey{when} {\em guard} {\em unguarded-subblock} \\[1ex]
\emkey{guard} ::= {\em right-side}
\end{indpar}

\subsection{Block Variable Names}
\label{BLOCK-VARIABLE-NAMES}

In order to evaluate a block, the 
{\em variable-names} in the block must be identified.
Some {\em variable-names} may be \mkey{inherited}{variable-name}
from a {\em expression-definition} containing the block.
Some are {\em output-variables} in {\em assignment-statements}
or {\em right-sides}.
Some are variables in the {\em patterns} of {\em assign\-ment-patterns}.
All the {\em variable-names}
in the block are inherited or can be identified by looking at the left
sides of {\em variable-assignments}, at the {\em output-variables}
following \TT{=>} in {\em right-sides}, or {\em patterns} in
{\em pattern-assignments}.

When identifying {\em variable-names} in a {\em block}, {\em statements} in a
{\em subblock} of the {\em block} are treated as if they
were in the {\em block} proper.  Thus variables named in the
{\em subblock} are variables named in the {\em block}.\footnote{
RECKON does not have the notion of name space nesting, because the
\TT{\{ \}} brackets that would
indicate nesting can be implied by the \TT{:} construction.}

For example, in

\begin{indpar}[1in]
\verb|sum from X through Y <-- integer X, integer Y| {\em block}
\end{indpar}

the variable names \TT{X} and \TT{Y} are inherited by the {\em block}.

As another example, if the {\em pattern-assignment}

\begin{indpar}[1in]
\verb|$X + $Y ~=~ `5 + ( 7 * y )'|
\end{indpar}

appears in a block,
the variable names \TT{\$X} and \TT{\$Y} are pattern variable names
that are {\em variable-names} of the {\em block}.

The {\em output-variable} names in {\em variable-assignments}
and {\em right-sides} are {\em variable-names}.  For example, in

\begin{indpar}[1in]\begin{verbatim}
when sort x to y => y:
    z = first 
\end{verbatim}\end{indpar}

\TT{y} and \TT{z} are {\em output-variables} and therefore
{\em variable-names}.

Both evaluated and unevaluated pattern variables may be used in
the {\em operator-expressions} that appear in {\em right-sides}.
For example,
\begin{indpar}[1in]\begin{verbatim}
x = $X
\end{verbatim}\end{indpar}

sets the variable \TT{x} to the unevaluated expression stored in
\TT{\$X}.

[TBD: Arrays and array element names]

\subsection{Block Evaluation}
\label{BLOCK-EVALUATION}

\ikey{Blocks}{block!evaluation}
are divided into \ikey{groups}{group!evaluation} by \skey{sequence-break}s.
The {\em groups} are evaluated in order: each group being completely
evaluated before the next group is evaluated.  However,
evaluation within a \mkey{statement-group}{evaluation}
is driven by availability of variable values,
and not by the order of the {\em statements} in the group.

Each variable in a block can be assigned at most one value: it is
an error if the variable is assigned a value more than once during
a block evaluation, even if all the values assigned are the same.

The variables in an {\em operator-expression}
are called \skey{input-variable}s.
Each {\em operator-expres\-sion} in a {\em statement-group}
is evaluated only when \underline{all} its input variables have values.
When the {\em operator-expression} of an {\em assignment-statement} or
{\em right-side}
is evaluated, the {\em output-variables} and pattern variables in the
{\em assignment-statement} or {\em right-side} are given values.

None of the statements in an {\em if-statement}
{\em unguarded-block} are
evaluated until the block's {\em guard} has been evaluated to true.
If the guard evaluates to false, no statement in the
{\em unguarded-block} is ever evaluated.  An {\em else-if-continuation}
{\em guard} is not evaluated until all {\em guards}
in any preceding {\em if-statement}
or {\em else-if-continuations} in the same {\em guard-statement}
have been evaluated to false.  The {\em unguarded-block} of an
{\em else-continuation} is evaluated if and only if
all {\em guards} in any preceding {\em if-statement}
or {\em else-if-continuation} in the same {\em if-statement}
have been evaluated to false.

An example application of these rules is:

\begin{indpar}\begin{verbatim}
{
  z = y1
  z = y2
  if X > 5:
    y1 = 9
  else:
    y2 = 10
}
\end{verbatim}\end{indpar}

where \TT{X} is an inherited variable name.  If \TT{X > 5} is true,
the variable \TT{y1} is given the value \TT{9} and then
\TT{z} is given this value, while the variable \TT{y2}
is never given a value.  If \TT{X > 5} is false,
the variable \TT{y2}
is given the value \TT{10} and then \TT{z} is given this
value, while the variable \TT{y1} is never given a value.

A {\em when-statement} is just like an {\em if-statement} that has
no {\em else-if-continuation} or {\em else-continu\-a\-tion}.
[TBD: what about making a variable true if it has ANY value, for the
purposes of a {\em when-statement}?]

A {\em statement-group} terminates when all the
{\em right-side-expressions} in it have either been evaluated or
cannot be evaluated because of lack of an input variable value or
because of {\em guards}.
Once a {\em statement-group}
terminates, no part of the group can be evaluated, even if another group
later in the block defines that part's input variables.

However, group evaluation is additionally modified by {\em statement-qualifiers}
(\secref{DEFAULT-STATEMENTS}, \secref{ITERATION}).

The \ikey{declarations}{declaration!evaluation} of a
\mkey{declaration-group}{evaluation} are evaluated in order.  Evaluation of a
{\em declaration} just adds its definition to the current context.
The {\em declaration-group} terminates when its last {\em declaration}
has evaluated.  There are no {\em guards} or block variables in a declaration
group (the variables of a definition are not variables of the block).

\ikey{Empty-statements}{empty-statement!evaluation} and
\ikey{empty-declarations}{empty-declaration!evaluation} do nothing
when they evaluate.

The {\em groups} of a {\em block} are evaluated in order.  No part of
a {\em group}
can evaluate until all previous {\em groups} of the block have completely
finished evaluating.  Once a {\em group} starts to evaluate, no part of
a previous {\em group} can evaluate.

A {\em block} terminates when its last group terminates.

When a block terminates, the \mkey{value}{of block} of the block is the
value of its \TT{value} variable\index{value variable@\TT{value} variable},
if any.  Thus the block

\begin{center}
\verb|{ value = X + Y }|
\end{center}

which inherits the variables \TT{X} and \TT{Y} will return
the sum of its inherited variables as the value of the block.

If a block finishes without producing a value for a variable named
\TT{value}, the value of the block is \ttmkey{true}{block value}.

Block evaluation is additionally modified by {\em statement-qualifiers}
and {\em next-variables}
(\secref{DEFAULT-STATEMENTS} and \secref{ITERATION}).

\subsection{Default Statements}
\label{DEFAULT-STATEMENTS}

The \ttkey{default} {\em statement-qualifier} modifies group execution.
A statement qualified by \TT{default}
is called a \key{default statement}.  Default statements in a {\em group}
are initially inactive, meaning that they are treated as if they do not exist,

After the {\em group} without its default statements finishes executing,
any default statement in the {\em group} that has
\underline{no} output or pattern variable with a value
is made active.  All default statements that can be made active in this
way are made active at the same time.  Then the {\em group}, which now
consists of all non-default statements and all active default statements,
continues executing, until no more non-default or active default statement
can be executed.

Since all default statements that become active in a group become active
at the same time, it is possible for an error to occur if two such
statements assign values the same variable.

An example application of these rules is:

\begin{indpar}\begin{verbatim}
{
  if X > 5:
    value = `true'
  default value = `false'
}
\end{verbatim}\end{indpar}

where \TT{X} is an inherited variable name.  If \TT{X > 5} is true,
the value of the block is `\TT{true}' and the \TT{default}
{\em assignment-statement} remains inactive, but if \TT{X > 5} is false,
the \TT{default} {\em assignment-statement} becomes active and
the value of the block is `\TT{false}'.

\subsection{Iteration}
\label{ITERATION}

A block can \key{iterate}, meaning that it generates another block
that is the next block in a sequence of blocks.  A block
iterates if it does \underline{not} produce a value of a \TT{value}
variable and if it does produce a value for a {\em next-variable}.
The sequence of blocks are called the
\skey{iteration}s of the sequence.  Evaluation of a block can always
be thought of as producing a sequence of iterations, though this
sequence might include only one block which does not iterate.

A {\em next-variable} is named by a {\em variable-name} preceded by
the `\ttkey{next}' keyword.  A {\em next-variable}
is effectively a new variable with a name derived from the
{\em variable-name}.  We will used the notation `\TT{next }$V$'
to denote the {\em next-variable} made from the variable name $V$.
The value of \TT{next }$V$ at the end of execution of the
current block iteration becomes the value of $V$ at the beginning
of execution of the next block iteration.  In order for there to be
a next iteration, the current iteration must compute the value of
some {\em next-variable}, and the current iteration must not compute
the value of the \TT{value} variable.

{\em Next-variables} can be both output and input variables.
When used as input variables they are just like other input variables.
The \TT{next} unary operator can be applied to an expression that does not
consist solely of a {\em variable-name}.  When this is done, it is
as if the \TT{next} keyword had instead been prefaced to every
{\em variable-name} in the expression.  Thus `\TT{next(x+y)}' is
the equivalent of `\TT{next x + next y}'.

If a default statement outputs a {\em next-variable}, the statement
cannot become active unless some other {\em next-variable} has already
been given a value.  Thus the decision to iterate cannot be made inside
a default statement.

A statement of the form

\begin{center}
\verb|default next |$V$\verb| = |$V$
\end{center}

is implied in the last group of a block
for every inherited {\em variable-name} $V$ provided
no other default statement in the last group of the block
outputs \TT{next }$V$.
Thus inherited variables are normally propagated unchanged from
one iteration to the next.

If a {\em next-variable} is given the value of
the expression `\ttkey{UNDEFINED}',\label{UNDEFINED}
the variable will become undefined
at the beginning of the next iteration.  Thus the statement

\begin{center}
\verb|default next |$V$\verb| = UNDEFINED|
\end{center}

for an inherited {\em variable-name} $V$ will keep the inherited
variable from being propagated from one iteration to the next.
The expression `\TT{UNDEFINED}' cannot be used to set a
non-{\em next-variable}.

A \ttkey{first} qualified {\em statement} is only visible in the
first iteration of a block sequence.

An \ttkey{always} qualified {\em statement} is equivalent to the {\em statement}
qualified by \TT{first} plus additional {\em statements} of the form

\begin{center}
\verb|default next |$V$\verb| = |$V$
\end{center}

for every {\em variable-name} $V$ that can be assigned by the
\TT{always} qualified {\em statement}.  Thus the
\TT{always} qualified {\em statement} will assign values on the first
iteration, and these values will then be propagated to subsequent iterations.


\section{Objects}
\label{OBJECTS}

An object is a typed block that can be used as a value.
A typed block, or object, has a type and inherits code from its type.

An \key{object} can be created by an {\em object-expression}:


\begin{indpar}
\emkey{object-expression} ::= \{ \ttkey{a} $|$ \ttkey{an} \} {\em type-name}
		              {\em block-option} \\[1ex]
\emkey{type-name} ::= {\em name} ~~~~~ [see \pagref{NAME}]
\end{indpar}

The code in the {\em block} becomes a permanent part of the object.
The variable values defined by this code become \skey{component}s of the object.
These components can be retrieved by expressions of the form:

\begin{center}
\ttmkey{the}{the of@\TT{the} \ldots \TT{of}}
{\em variable-name}
\ttmkey{of}{the of@\TT{the} \ldots \TT{of}}
{\em object}
\end{center}

where {\em variable-name} names a variable whose value is the location
of the object.

Objects are updated by adding code to them either permanently or temporarily.
Whenever code is added to an object, the code executes as much as it
can to define variable values that are then components of the object.
When the code can execute no further (\secref{BLOCK-EVALUATION},
\secref{DEFAULT-STATEMENTS}, \secref{ITERATION}), any
variables that do not have values become undefined components.  If some of
undefined components are given values later, any code that is a permanent
part of the object may restart and produce additional variable values that
define additional components.

Recall that the concept of being a variable of a block
of code is defined syntactically and independently of which variable values
the block actually computes (\secref{BLOCK-VARIABLE-NAMES}).
The components of an object are more precisely the variables
of the code added permanently to the object, whether or not these
variables have values defined by code added permanently or temporarily
to the object.  Variables of code added temporarily that are not
also variables of code added permanently are
\underline{not} components of the object,
and are not visible outside the temporarily added code.

[TBD: We need a better way to declare an object component
without giving it a value in permanent code.]

The permanent code of an object all belongs to two groups: a
{\em declaration-group} and a {\em statement-group} in that
order (i.e., with declarations first).
When code is added to the block, the added code can also
have two groups: a {\em declaration-group} that is appended to the
permanent {\em declaration-group} and a following {\em statement-group} that
is appended to the permanent {\em statement-group}.  This is true whether
the code is being added permanently or temporarily.  Of course either
group can be empty.

A statement of the form:

\begin{indpar}
\ttkey{for every} {\em type-name} {\em block} 
\end{indpar}

adds the code in its block permanently to every object of the given type,
including both existing objects and objects that are
created in the future.  The code in the block is associated with the
type and is said to be `\skey{inherit}{ed}' by every object of that type.

A statement of the form:

\begin{indpar}
\ttkey{update} {\em variable-name} {\em block} 
\end{indpar}\label{UPDATE}

where {\em variable-name} evaluates to the location of an
object adds the code in the
{\em block} temporarily to the object.  The code is added and all
code in the object executes until it can do nothing more.  Then
the temporary code is removed from the object.

When code is added to an object and executes, the statement qualifier
\TT{default} acts when execution stops to enable execution of \TT{default}
statements, as per \secref{DEFAULT-STATEMENTS}.  Similarly
`\TT{next}' variables can be used to create iterations of the
object.  Each iteration replaces the previous iteration of the object
wherever the object is referenced.  Thus if two variables equal
the object, and one is used to cause the object to iterate, both variable
values will become the new iterated object.

A statement of the form

\begin{center}
\verb|default| \verb|next |$C$\verb| = |$C$
\end{center}

is implied in the permanent code
for every component name $C$ of an object, provided
no other default statement in the permanent code
outputs `\TT{next }$C$'.
Thus components are normally propagated unchanged from
one object iteration to the next.  A statement of the form

\begin{center}
\verb|default| \verb|next |$C$\verb| = UNDEFINED|
\end{center}

can be used to override this behavior to
make $C$ have no value at the beginning of the next object
iteration.

When an iteration of an object is created by temporary code, the
sequence of actions is:

\begin{center}
\begin{tabular}{lp{5.5in}}
(1) & Add the temporary code to the object. \\
(2) & Execute all object code until it terminates. \\
(3) & If any \TT{next} component values were defined by the
      execution in step (2), create
      the next iteration of the object, giving this
      iteration only the permanent code of the object. \\
(4) & In the next iteration of the object execute all
      code until it terminates.
\end{tabular}
\end{center}

Code can be temporarily added to an object by invoking methods.
A \key{method} is defined by a \key{method definition}
that is an expression definition which is part of the {\em declaration-group}
of the object code (it can be either permanent or temporary).
The method is callable from code inside or outside the object code block.
The syntax for a method definition is:

\begin{center}
\emkey{method-definition} ::= \ttkey{on} {\em expression-definition}
\end{center}

When the method definition is called, the method code block
is added temporarily to the code that contained
the method definition.  The object whose code this is
may be referred to within its
code by the name \ttkey{SELF}, which may or may not also be an argument
of the method definition.  If it is an argument, the method definition
has an implicit guard that requires the \TT{SELF} argument value to be
equal to the object whose code contains the method definition.

If there is no \TT{SELF} argument, a new object
is created when the method is called, and the permanent code plus
method code is executed for that object.  The permanent code must
contain the method definition in this case.  Such a method is
called a \TT{constructor}, and the object created is said to be
constructed by the method execution.  Constructor executions usually return
the object they construct, but this is not required by the language.
Constructors usually
have patterns that begin with `\{ \TT{a} $|$ \TT{an} \} {\em type-name}',
where {\em type-name} names the type of object they construct, but
this is not required by the language either.

TBD: protection; protection zones.


\section{Side Effects}
\label{SIDE-EFFECTS}

A \key{side effect} is an action that changes memory, inputs information from
the outside world, or outputs information to the outside world.
When an expression is evaluated, it may or may not have side effects.

The order in which side effects are executed is determined by
{\em sequence-breaks} that divide a {\em block} into {\em groups}
further (\secref{BLOCK-EVALUATION}).  A programmer typically writes code
so there is at most one side effect per {\em group}, in order to
ensure side effects execute in the desired order.

TBD: could this last rule be enforced.

The \key{side effect mode} controls the execution of side effects.
It has three settings: \TT{execute}, \TT{delay}, and \TT{error}.
In \ttkey{execute mode} a side effect simply executes.  In
\ttkey{error mode} an attempt to execute a side effect raises an error,
and the side effect is not executed.

In \ttkey{delay mode} input and memory change side effects execute,
but put operations on an \TT{undo} list that can undo their effects,
while output side effects do not execute, but are instead put on a
\TT{todo} list.

There are two lists maintained that permit side effects to be delayed
or undone.  The \ttmkey{todo}{list} list is a list of delayed output
actions that have been delayed.  The \ttmkey{undo}{list} list is
a list of input and memory change actions that can be undone.
The position of these lists can be recorded and an undo
operation can be performed that backs up to previously recorded positions
by deleting actions from the end of the \TT{todo} list and undoing
actions on the end of the \TT{undo} list.

To control the side effect mode there is a \key{side effect mode stack}.
This contains items each of which contains a side effect mode and
positions in the \TT{todo} and \TT{undo} stacks.  The side effect mode
of the top item on the side effect mode stack is the effective side
effect mode for current execution.
Whenever an item is pushed to the side effect mode stack, the current
positions of the \TT{todo} and \TT{undo} lists are recorded in the
item.

The following statements operate on the side effect mode stack:

\begin{list}{}{}
\item[\ttlkey{begin executing}{side effects}]~~~Push a new item with side effect
execute mode onto the side effect mode stack.  Before the push the
stack must be empty or the top item in the stack must have execute or
error mode.

\item[\ttlkey{end executing}{side effects}]~~~Pop the top item from
the side effect mode stack.  This top item must have
execute mode.

\item[\ttlkey{begin forbidding}{side effects}]~~~Push
a new item with side effect
error mode onto the side effect mode stack.  Before the push the
stack must be empty or the top item in the stack must have execute or
error mode.

\item[\ttlkey{end forbidding}{side effects}]~~~Pop the top item from the
side effect mode stack.  This top item must have
error mode.

\item[\ttlkey{delay}{side effects}]~~~Push a new item with side effect
delay mode onto the side effect mode stack.

\item[\ttlkey{commit}{side effects}]~~~Pop the top item from the
side effect mode stack.  This top item must have
delay mode.  It the resulting stack has a new top item that is not
delay mode, discard the contents of the \TT{undo} stack, and execute
and then discard the contents of the \TT{todo} stack.

\item[\ttlkey{abort side}{effects}]~~~Pop the item from the
the side effect mode stack.  This top item must have
delay mode.  Consider the \TT{todo} and \TT{undo} list positions
of the new item at the top of the stack, or take these positions to be
the beginning of the lists if the stack has become empty.  Remove
elements from ends of the lists until these considered positions become
the current list positions.  When removing an element from the end of the
\TT{undo} list, perform the undo action specified by the element.

\end{list}

\section{Debugging}

Design:

Debugging is based on the notion that almost all
RECKON programs will run quickly.
Input checkpointing is used to record all inputs to a computation
so the computation can be deterministically rerun.  Detailed
traces can be generated which explain for each value how it was generated.
Values have a sequence number that identifies the point in the execution
where they were generated.  It is therefore possible to ask for a detailed
accounting of how any value was generated, provided the run is short enough
to be repeated once or a few times so the computer can turn the history
tracing on appropriately.

\section{Design Notes}

These are some detailed design rules to be incorporated in the language
definition later.

\begin{list}{}{}

\item
{\bf Blank Algebraic Operators}.
The blank, or missing operator, denotes \TT{*} when it precedes a word,
as in \TT{5x} being equivalent to \TT{5*x}.  When it is between a
preceding integer and a following ratio, it adds the ratio to the integer,
as in \TT{41 1/3}.

\end{list}

\section{To Do}

Describe matrix expression scanning that has no separators.
Maybe it should not recognize operators outside parentheses?

Describe blank lines as paragraph operators in text parsing.

Should temporaries be full-fledged names.

Describe the quote evaluator.\label{QUOTE-EVALUATOR}

Why doesn't `\TT{define qualifier xxx}' mean define expressions equal
to `{qual\-i\-fier\EOL{} xxx}'.

\TT{missing(\#X)} is true if \TT{\#X} is a null node.
\TT{integer(\#X)} is true if \TT{\#X} is an integer.

Qualifier shortcuts should be conditioned on the first words of
the expression being qualified.  E.g., if these words are
`\TT{define operator}' the shortcut `\TT{left => }\TT{with
associativity [left]}' would be defined.

Expressions to be evaluated can have sets of possible values.

Imaginary Units\label{IMAGINARY-UNITS}

Visible Side Effects\label{VISIBLE-SIDE-EFFECTS}

List Objects\label{LIST}

Qualifier Definition\label{QUALIFIER-DEFINITION}

Qualifier Shortcut Definition\label{QUALIFIER-SHORTCUT-DEFINITION}

Automatic Optional Marks\label{AUTOMATIC-OPTIONAL-MARKS}

Describe Garbage Collection\label{GARBAGE-COLLECTION}

Manual Deletion\label{MANUAL-DELETION}, the stub is marked deleted,
and gc's make pointers to the stub either NULL or point them at
a standard deleted object so the deleted stub can be collected.

\bibliographystyle{plain}
\bibliography{reckon}

\printindex

\end{document}

