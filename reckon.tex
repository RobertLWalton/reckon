% Personal Calculation and Simulation Langauge (PCASL)
%
% File:         pcasl.tex
% Author:       Bob Walton (walton@deas.harvard.edu)
% Date:		See \date below.
  
\documentclass[12pt]{article}

\usepackage{makeidx}

\makeindex

\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}
\raggedbottom

\setlength{\unitlength}{1in}

\pagestyle{headings}
\setlength{\parindent}{0.0in}
\setlength{\parskip}{1ex}

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}
\newcommand{\subsubsubsection}[1]{\paragraph[#1]{#1.}}
\newcommand{\subsubsubsubsection}[1]{\subparagraph[#1]{#1.}}

% Begin \tableofcontents surgery.

\newcount\AtCatcode
\AtCatcode=\catcode`@
\catcode `@=11	% @ is now a letter

\renewcommand{\contentsname}{}
\renewcommand\l@section{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\l@table{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\tableofcontents{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}}%
    \item\@starttoc{toc}%
    \end{list}}
\renewcommand\listoftables{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}%
	      }%
    \item\@starttoc{lot}%
    \end{list}}

\catcode `@=\AtCatcode	% @ is now restored

% End \tableofcontents surgery.

\newcommand{\CN}[2]%	Change Notice.
    {\hspace*{0in}\marginpar{\sloppy \raggedright \it \footnotesize
     $^{\mbox{#1}}$#2}}
    % Change notice.

\newcommand{\key}[1]{{\em #1}\index{#1}}
\newcommand{\mkey}[2]{{\em #1}\index{#1!#2}}
\newcommand{\skey}[2]{{\em #1#2}\index{#1}}
\newcommand{\ikey}[2]{{\em #1}\index{#2}}
\newcommand{\ttkey}[1]{{\tt #1}\index{#1@{\tt #1}}}
\newcommand{\ttmkey}[2]{{\tt #1}\index{#1@{\tt #1}!#2}}
\newcommand{\ttfkey}[2]{{\tt #1}\index{#1@{\tt #1}!for #2@for {\tt #2}}}
\newcommand{\ttakey}[2]{{\tt #1}\index{#2@{\tt #1}}}
\newcommand{\ttamkey}[3]{{\tt #1}\index{#2@{\tt #1}!#3}}
\newcommand{\ttindex}[1]{\index{#1@{\tt #1}}}
\newcommand{\ttmindex}[2]{\index{#1@{\tt #1}!#2}}
\newcommand{\emkey}[1]{{\em #1}\index{#1@{\em #1}}}
\newcommand{\emindex}[1]{\index{#1@{\em #1}}}

\newcommand{\EOL}{\penalty \exhyphenpenalty}

\newcount\TildeCatcode
\TildeCatcode=\catcode`\~
\catcode`~=12
\newcommand{\Tilde}{~}
\catcode`~=\TildeCatcode

\newcount\CurlyBraCatcode
\newcount\CurlyKetCatcode
\newcount\SquareBraCatcode
\newcount\SquareKetCatcode
\CurlyBraCatcode=\catcode`{
\CurlyKetCatcode=\catcode`}
\SquareBraCatcode=\catcode`[
\SquareKetCatcode=\catcode`]

\catcode`{=\SquareBraCatcode
\catcode`}=\SquareKetCatcode
\catcode`[=\CurlyBraCatcode
\catcode`]=\CurlyKetCatcode

\newcommand[\CurlyBra][{]
\newcommand[\CurlyKet][}]

\catcode`{=\CurlyBraCatcode
\catcode`}=\CurlyKetCatcode
\catcode`[=\SquareBraCatcode
\catcode`]=\SquareKetCatcode

\newcommand{\ttbrackets}{
    \renewcommand{\{}{\CurlyBra}
    \renewcommand{\}}{\CurlyKet}}

\newlength{\figurewidth}
\setlength{\figurewidth}{\textwidth}
\addtolength{\figurewidth}{-0.40in}

\newsavebox{\figurebox}

\newenvironment{boxedfigure}[1][!btp]%
	{\begin{figure*}[#1]
	 \begin{lrbox}{\figurebox}
	 \begin{minipage}{\figurewidth}

	 \vspace*{1ex}}%
	{
	 \vspace*{1ex}

	 \end{minipage}
	 \end{lrbox}
	 \begin{center}
	 \fbox{\hspace*{0.1in}\usebox{\figurebox}\hspace*{0.1in}}
	 \end{center}
	 \end{figure*}}

\newenvironment{indpar}[1][0.3in]%
	{\begin{list}{}%
		     {\setlength{\itemsep}{0in}%
		      \setlength{\topsep}{0in}%
		      \setlength{\parsep}{1ex}%
		      \setlength{\labelwidth}{#1}%
		      \setlength{\leftmargin}{#1}%
		      \addtolength{\leftmargin}{\labelsep}}%
	 \item}%
	{\end{list}}

\begin{document}
        
\title{Personal\\Calculation and Simulation\\Language\\[2ex]PCASL\\[2ex]
       (Draft 1a)}

\author{Robert L. Walton\thanks{This document was partly inspired
by teaching courses at Suffolk University.}}

\date{December 12, 2003}
 
\maketitle

\tableofcontents 

\newpage

\section{Introduction}

This document describes PCASL, the Personal Calculation and Simulation
Language, that is informally referred to as P-Castle, Personal Castle, or just
Castle.

PCASL is designed for naive programmers: that is, for people who may never
be able to program computers well.  It is a simple language that has
powerful data types which make it easier to write small programs
that do a variety of tasks that a person might want to do.  Generally
the tasks fall into the categories of calculating things (taxes,
probabilities, statistics) or simulating things
(computer games, construction designs, mathematics demonstrations).
Included are:

\begin{center}
\begin{tabular}{l}
Calculations that might be done with a spreadsheet. \\
Drawing pictures. \\
Simulating popular board games and creating new ones. \\
Creating simple computer games, including dialog games. \\
Computing and analysing documents. \\
Doing elementary algebra and calculus problems. \\
Calculating basic probabilities and statistics. \\
Simulating two and three dimensional objects. \\
Simulating simple electrical, mechanical, chemical, and biological systems.\\
Solving problems in elementary logic. \\
\end{tabular}
\end{center}

There are many computer languages that have some powerful data type that adapts
them for a specific kind of computation.  PCASL tries to combine these.
Some previous computer languages that have influenced PCASL, and
the data types they particularly support, are:

\begin{center}
\begin{tabular}{l@{\hspace{0.5in}}l}
Various Spreadsheets		& Spreadsheets \\
Various Data Base Languages	& Data Bases \\
Matlab				& Matrices \\
Mathematica			& Expressions \\
TCL				& Character Strings and Lists \\
Lisp				& Words and Phrases \\
Prolog				& Logical Expressions \\
\end{tabular}
\end{center}

PCASL is \underline{not} designed to be a computer-efficient language.
It is designed to be person-efficient, and to do small calculations
rapidly enough with inexpensive modern computers.

\section{Remarks}

PCASL was created as an answer to the question: what programming language
should you teach beginning programming students who do not have the talent
or inclination to become good programmers?  The inital answer, that it does
not matter provided you implement some powerful types of data in the
language you choose, has a flaw.  The flaw is that without the right powerful
data types, the language will be useless to the students after the course
is over.  So what is needed is a programming language that will be useful
to students after a first course in programming, and the essence of
such a language is the integration within it of many powerful and useful
data types.

The current version of PCASL is not stable, because it has not been
implemented, and because, unlike most programming languages, PCASL
has lots of subtle interactions between its various features.  The
hope is that with implementation and experimentation, a stable sensible
version of PCASL integrating all its data types can be achieved.

\section{Data}

PCASL has two major kinds of data: expressions and blocks.  Numbers are
the simplest expressions.  More complex expressions are math
expressions or document expressions.  Blocks are sets of variables
each of which can have a value, which is an expression, and also
a definition, which is another expression that is used to compute the
value when the value is needed.  The definitions of a block, taken all
together, are called the `code' of the block.

You can use PCASL as a calculator by typing into it expressions to
be evaluated and assignments of values and definitions to variables.
Some examples involving numbers are:

\begin{indpar}\begin{verbatim}
> 9
9
> 9 + 8
17
> x = 9
9
> y = 9 + 8
17
> x + y
26
\end{verbatim}\end{indpar}

Here the `\verb|> |' at the beginning of some lines is the PCASL \key{prompt}
that tells you its OK to input an expression to be evaluated.

At somewhat the opposite extreme from numbers are words, phrases, sentences,
and paragraphs.  You can calculate with these `\skey{document expression}s'.

\begin{indpar}
\verb|> g = `hello'| \\
\verb|`|hello\verb|'| \\
\verb|> `<<g>> there'| \\
\verb|`|hello there\verb|'| \\
\verb|> z = ``I thought he said `<<g>>'.''| \\
\verb|``|I thought he said `hello'.\verb|''| \\
\verb/> notice = ``|This document is meant to be read./ \\
\verb/+            |Reading this document is good, but.../ \\
\verb/+            |<<z>>.''/ \\
\verb|``|This document is meant to be read. \\
\verb|  |Reading this document is good, but\ldots \\
\verb|  |I thought he said `hello'.\verb|''| \\
\verb|> `When you add <<x>> and <<y>> you get <<x+y>>.'| \\
\verb|`|When you add 9 and 17 you get 26.\verb|'|
\end{indpar}

Modern math computes with expressions, and not just numbers.
You can compute with \skey{math expression}s in PCASL.

\begin{indpar}
\verb|> f = {10x^2 - 3.67x - 0.04}| \\
\verb|{|$10x^2-3.67x-0.04$\verb|}| \\
\verb|> h = (- 0.96 + 0.67x) in x| \\
\verb|{|$-0.96+0.67x$\verb|}| \\
\verb|> (f + h) in x| \\
\verb|{|$10x^2-3x-1$\verb|}| \\
\verb|> solve (f + h = 0) for x| \\
\verb|{|$x = (-0.2, 0.5)$\verb|}| \\
\verb|> (f + h) at (x = (3, 4, 5))| \\
\verb|(78.95, 145.28, 231.61)| \\
\verb|> g = {integral (x^2 dx)}| \\
\verb|{|$\int x^2 dx$\verb|}| \\
\verb|> simplify g| \\
\verb|{|$\frac{1}{3} x^3$\verb|}| \\
\verb|> v = g from (x=1) to (x=5)| \\
\verb|41 1/3| \\
\verb|> out = `The value of {<<g>> from (x=1) to (x=5)} is <<v>>.'| \\
\verb|`|The value of $\int_{x=1}^{x=5} x^2 dx$ is $41\frac{1}{3}$.\verb|'| \\
\verb|> raw out| \\
\verb|[sentence the value of {(integral (x^2*dx)) from (x=1) to (x=5)}| \\
\verb|          is 124/3]|
\end{indpar}

Another kind of datum you can compute with in PCASL is
the \key{block}:

\begin{indpar}
\verb|> a person {| \\
\verb|+     name = `Jack'| \\
\verb|+     weight = 123 lb| \\
\verb|+     height = 5'9"| \\
\verb|+     age = 23 yr 2 mo }| \\
\begin{tabular}{|r|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000000 & Jack & \tt 123 lb & \tt 5'9" & \tt 23 yr 2 mo \\
\hline
\end{tabular} \\
\verb|> a person {| \\
\verb|+     name = `Jill'| \\
\verb|+     weight = 110 lb| \\
\verb|+     height = 5'7"| \\
\verb|+     age = 21 yr 8 mo }| \\
\begin{tabular}{|r|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000001 & Jill & \tt 110 lb & \tt 5'7" & \tt 21 yr 8 mo \\
\hline
\end{tabular} \\
\verb|> all persons| \\
\begin{tabular}{|r|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000000 & Jack & \tt 123 lb & \tt 5'9" & \tt 23 yr 2 mo \\
\tt @1000001 & Jill & \tt 110 lb & \tt 5'7" & \tt 21 yr 8 mo \\
\hline
\end{tabular} \\
\verb|> the person Jack| \\
\begin{tabular}{|r|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000000 & Jack & \tt 123 lb & \tt 5'9" & \tt 23 yr 2 mo \\
\hline
\end{tabular} \\
\verb|> the person named Jack's height| \\
\verb|5'9"| \\
\verb|> the weight of the person named Jack| \\
\verb|123 lb| \\
\verb|> @1000001| \\
\begin{tabular}{|r|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000001 & Jill & \tt 110 lb & \tt 5'7" & \tt 21 yr 8 mo \\
\hline
\end{tabular} \\
\verb|> the weight of @1000001| \\
\verb|110 lb|
\end{indpar}

It is possible to add code to a type such as `{\tt person}':

\begin{indpar}
\verb|> a person <-- {| \\
\verb|+     body-mass-index = 703.06958 * weight in lbs| \\
\verb|+                     / (height in inches)^2 }| \\
\verb|> all persons| \\
\begin{tabular}{|r|l|r|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} &
\multicolumn{1}{|c|}{\bf \shortstack{body-mass-\\index}} \\
\hline
\tt @1000000 & Jack & \tt 123 lb & \tt 5'9" & \tt 23 yr 2 mo & \tt 18.163738 \\
\tt @1000001 & Jill & \tt 110 lb & \tt 5'7" & \tt 21 yr 8 mo & \tt 17.228258 \\
\hline
\end{tabular}
\end{indpar}

One can use definitions to define expressions that compute values:

\begin{indpar}
\verb|> sum from X through Y <-- integer X, integer Y {| \\
\verb|+     `Sum of integers from X through Y.'| \\
\verb|+     if ( X > Y ):| \\
\verb|+         value = 0| \\
\verb|+     else:| \\
\verb|+         value = X + sum (X+1) through Y }| \\
\verb|> sum from 5 through 10| \\
\verb|45| \\
\verb|> all (sums from X through Y)| \\
\begin{tabular}{|r|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf X} &
\multicolumn{1}{|c}{\bf Y} &
\multicolumn{1}{|c|}{\bf value} \\
\hline
\tt @1000002 & \tt 5	& \tt	10	& \tt 45 \\
\tt @1000003 & \tt 6	& \tt	10	& \tt 40 \\
\tt @1000004 & \tt 7	& \tt	10	& \tt 34 \\
\tt @1000005 & \tt 8	& \tt	10	& \tt 27 \\
\tt @1000006 & \tt 9	& \tt	10	& \tt 19 \\
\tt @1000007 & \tt 10	& \tt	10	& \tt 10 \\
\tt @1000008 & \tt 11	& \tt	10	& \tt 0 \\
\hline
\end{tabular} \\
\verb|> sum from 1 through 2| \\
\verb|3| \\
\verb|> all (sums from X through Y)| \\
\begin{tabular}{|r|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf X} &
\multicolumn{1}{|c}{\bf Y} &
\multicolumn{1}{|c|}{\bf value} \\
\hline
\tt @1000002 & \tt 5	& \tt	10	& \tt 45 \\
\tt @1000003 & \tt 6	& \tt	10	& \tt 40 \\
\tt @1000004 & \tt 7	& \tt	10	& \tt 34 \\
\tt @1000005 & \tt 8	& \tt	10	& \tt 27 \\
\tt @1000006 & \tt 9	& \tt	10	& \tt 19 \\
\tt @1000007 & \tt 10	& \tt	10	& \tt 10 \\
\tt @1000008 & \tt 11	& \tt	10	& \tt 0 \\
\tt @1000009 & \tt 1	& \tt	2	& \tt 3 \\
\tt @1000010 & \tt 2	& \tt	2	& \tt 2 \\
\tt @1000011 & \tt 3	& \tt	2	& \tt 0 \\
\hline
\end{tabular}
\end{indpar}

Executions can be examined in detail because
when an expression is computed, the block that computes it is remembered
for some time.  However, as memory is finite, eventually these
computations are forgotten as they can always be regenerated if
needed.

The sum above was computed by recursion: to compute the sum of 5 through 10
one computes the sum of 6 through 10.  One can also compute sums by
iteration.

\begin{indpar}
\verb|> sum from X through Y <-- integer X, integer Y {| \\
\verb|+     `Sum of integers from X through Y.'| \\
\verb|+     first sum = 0| \\
\verb|+     if ( X <= Y ):| \\
\verb|+         next sum = sum + X| \\
\verb|+         next X = X + 1| \\
\verb|+     else:| \\
\verb|+         value = sum }| \\
\verb|> sum from 5 through 10| \\
\verb|45| \\
\verb|> all (sums from 5 through 10)| \\
\begin{tabular}{|r|r|r|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf previous} &
\multicolumn{1}{|c}{\bf X} &
\multicolumn{1}{|c}{\bf Y} &
\multicolumn{1}{|c}{\bf sum} &
\multicolumn{1}{|c|}{\bf value} \\
\hline
\tt @1000012 &              & \tt 5	& \tt 10   & \tt 0	& \\
\tt @1000013 & \tt @1000012 & \tt 6	& \tt 10   & \tt 5	& \\
\tt @1000014 & \tt @1000013 & \tt 7	& \tt 10   & \tt 11	& \\
\tt @1000015 & \tt @1000014 & \tt 8	& \tt 10   & \tt 18	& \\
\tt @1000016 & \tt @1000015 & \tt 9	& \tt 10   & \tt 26	& \\
\tt @1000017 & \tt @1000016 & \tt 10	& \tt 10   & \tt 35	& \\
\tt @1000018 & \tt @1000017 & \tt 11	& \tt 10   & \tt 45	& \tt 45 \\
\hline
\end{tabular}
\end{indpar}

One can also iterate over data.

\begin{indpar}
\verb|> average weight of X <-- tuple X of persons {| \\
\verb|+     first count = 0| \\
\verb|+     first sum = 0| \\
\verb|+     if X = ():| \\
\verb|+         if count = 0:| \\
\verb|+             value = error `Cannot average 0 things.'| \\
\verb|+         else:| \\
\verb|+             value = sum / count| \\
\verb|+     else:| \\
\verb|+         next count = count + 1| \\
\verb|+         next sum = sum + the weight of (first X)| \\
\verb|+         next X = rest X }| \\
\verb|> average weight of (all persons)| \\
\verb|116.5 lbs|
\end{indpar}

In case you wonder how some of the above works, here are some hints.

PCASL tends to ignore word endings: thus `{\tt person}' and
`{\tt persons}' are to PCASL the same word.
PCASL can even be told that `{\tt person}'
and `{\tt people}' are the same word.
`{\tt Jack's}', on the other hand, is treated an abbreviation
of two separate words `{\tt Jack 's}', where `{\tt 's}' is
a separate word by itself.

Expressions are just strings of words and subexpressions.  Subexpressions
must be parenthesized unless they consist of a single word, or unless
they are delimited by operators.

Lists of values can be stored in tuples, which are computed by comma
separted lists in parentheses.  Thus

\begin{indpar}
\verb|> (the person named Jill, the person named Jack)| \\
\begin{tabular}{|r|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000001 & Jill & \tt 110 lb & \tt 5'7" & \tt 21 yr 8 mo \\
\tt @1000000 & Jack & \tt 123 lb & \tt 5'9" & \tt 23 yr 2 mo \\
\hline
\end{tabular} \\
\verb|> (the person named Jack, the person named Jill)| \\
\begin{tabular}{|r|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000000 & Jack & \tt 123 lb & \tt 5'9" & \tt 23 yr 2 mo \\
\tt @1000001 & Jill & \tt 110 lb & \tt 5'7" & \tt 21 yr 8 mo \\
\hline
\end{tabular} \\
\verb|> raw (all persons)| \\
\verb|(the person named Jack, the person named Jill)|
\end{indpar}

The `{\tt raw}' form of a value is a form that prints as you could
input it in a way that reveals its internal structure.  Thus
`{\tt all persons}' denotes the tuple of all persons.

`{\tt the person named Jack}' is a printed representation of the
internal name of a block.  Such printed representations are chosen
automatically from the set of all possible representations, which
in this case include `{\tt the person weighing 123}' and
`{\tt the person named Jack weighing 123}'.

A single non-tuple value is equivalent to a tuple with one element.
Tuples cannot have other tuples as elements; instead attempts to
compute such tuples are \key{flattened}:

\begin{indpar}
\verb|> x = (1,(2,3),4)| \\
\verb|(1,2,3,4)| \\
\verb|> first x| \\
\verb|1| \\
\verb|> rest x| \\
\verb|(2,3,4)| \\
\verb|> rest (rest x)| \\
\verb|(3,4)| \\
\verb|> rest (rest (rest x))| \\
\verb|3| \\
\verb|> rest 9| \\
\verb|()|
\end{indpar}

PCASL has many different kinds of quotes or brackets.  Some of these,
\verb|{...}|, \verb|`...'|, and \verb|[...]|, turn evalution off,
while \verb|<<...>>| turns evaluation on.  Some,
\verb|`...'| and \verb|[...]|, turn recognition of operators (e.g., \verb|+|
and \verb|=|) off, while others,
\verb|{...}| and \verb|<<...>>|, turn recognition of operators on.
\verb|`...'| (and \verb|``...''|, \verb|```...'''|, etc.), also do other
things, like insert implicit operations (e.g., \verb|sentence|).

PCASL stores information as expressions.  For example:

\begin{indpar}
\verb|> (a person named `Jack') is husband of (a person named `Jill') <--| \\
\verb|> Y is wife of X <-- X is husband of Y| \\
\verb|> (a person named `Jill') is wife of (a person named `Jack') ?| \\
\verb|true| \\
\verb|> (a person named `Jack') is wife of (a person named `Jill') ?| \\
\verb|false| \\
\verb|> (a person named X) is wife of (a person named `Jack') ?| \\
\verb|X = `|Jill\verb|'| \\
\verb|> X is wife of (a person named `Jack') ?| \\
\verb|X = (a person named `Jill')| \\
\verb|> @1000001 is wife of (a person named `Jack') ?| \\
\verb|true| \\
\verb|> @1000001 = (a person named `Jill') ?| \\
\verb|true| \\
\verb|> @1000001 = (a person named `Jack') ?| \\
\verb|false|
\end{indpar}

PCASL also supports pictorial data
that are computed like expressions.

\begin{indpar}
\verb|> x = {circle 0.4}| \\
\begin{picture}(0.4,0.4)
\put(0.2,0.2){\circle{0.4}}
\end{picture} \\
\verb|> y = {rectangle (0.4,0.2)}| \\
\begin{picture}(0.4,0.2)
\put(0,0){\framebox(0.4,0.2){}}
\end{picture} \\
\verb|> z = {(circle 0.4) labeled `Jack'}| \\
\begin{picture}(0.4,0.4)
\put(0.2,0.2){\circle{0.4}}
\put(0.0,0.0){\makebox(0.4,0.4){Jack}}
\end{picture} \\
\verb|> {(<<x>> right of <<y>>) above <<z>>}| \\
\begin{picture}(0.8,0.8)
\put(0.6,0.6){\circle{0.4}}
\put(0.0,0.5){\framebox(0.4,0.2){}}
\put(0.4,0.2){\circle{0.4}}
\put(0.2,0.0){\makebox(0.4,0.4){Jack}}
\end{picture} \\
\verb|> {row(<<x>>,<<y>>,<<z>>)}| \\
\begin{picture}(1.4,0.4)
\put(0.2,0.2){\circle{0.4}}
\put(0.5,0.1){\framebox(0.4,0.2){}}
\put(1.2,0.2){\circle{0.4}}
\put(1.0,0.0){\makebox(0.4,0.4){Jack}}
\end{picture} \\
\verb|> p = {column (row(<<x>>,<<y>>,<<z>>), row(<<z>>,<<y>>,<<x>>))}| \\
\begin{picture}(1.4,0.9)
\put(0.2,0.7){\circle{0.4}}
\put(0.5,0.6){\framebox(0.4,0.2){}}
\put(1.2,0.7){\circle{0.4}}
\put(1.0,0.5){\makebox(0.4,0.4){Jack}}
\put(1.2,0.2){\circle{0.4}}
\put(0.5,0.1){\framebox(0.4,0.2){}}
\put(0.2,0.2){\circle{0.4}}
\put(0.0,0.0){\makebox(0.4,0.4){Jack}}
\end{picture} \\
\verb|> raw x| \\
\verb|{circle 0.4}| \\
\verb|> raw p| \\
\verb|{column (row (circle 0.4,| \\
\verb|              rectangle (0.4,0.2),| \\
\verb|              (circle 0.4) labeled `Jack'),| \\
\verb|         row ((circle 0.4) labeled `Jack',| \\
\verb|              rectangle (0.4,0.2),| \\
\verb|              circle 0.4))}|
\end{indpar}

You can also change how an expression is displayed.

\begin{indpar}
\newlength{\ovalraise}
\setlength{\ovalraise}{-0.1in}
\addtolength{\ovalraise}{0.8ex}
\verb|> display (a person named X) as ((oval (0.4,0.2)) labelled X) <--| \\
\verb|> (a person named `Jack')| \\
\begin{picture}(0.4,0.2)
\put(0.2,0.1){\oval(0.4,0.2)}
\put(0.0,0.0){\makebox(0.4,0.2){Jack}}
\end{picture} \\
\verb|> ``(a person named `Jill') is wife of (a person named `Jack')''| \\
\verb|``|
\raisebox{\ovalraise}{\begin{picture}(0.4,0.2)
\put(0.2,0.1){\oval(0.4,0.2)}
\put(0.0,0.0){\makebox(0.4,0.2){Jill}}
\end{picture}}
{is the wife of}
\raisebox{\ovalraise}{\begin{picture}(0.4,0.2)
\put(0.2,0.1){\oval(0.4,0.2)}
\put(0.0,0.0){\makebox(0.4,0.2){Jack}}
\end{picture}}
\verb|''|
\end{indpar}

TBD: example of a simple game.


\section{Lexemes}

A PCASL program is a sequence of characters which is scanned from
left to right to produce a sequence of pre-lexemes.  The sequence
of pre-lexemes is then scanned from left to right to produce
a sequence of lexemes.

\subsection{Pre-Lexemes}

Pre-lexemes are defined as follows:

\begin{indpar}
\key{pre-lexeme}
	\begin{tabular}[t]{rl}
	::= & \key{pre-word} \\
	$|$ & \key{opening-mark} \\
	$|$ & \key{closing-mark} \\
	$|$ & \key{format-separator} \\
	$|$ & \key{white-space}
	\end{tabular}
	\\[1ex]
\key{pre-word} ::= {\em word-character} {\em word-character}$^\star$ \\[1ex]
\key{word-character} \begin{tabular}[t]{rl}
                       ::= & {\em letter} $|$ {\em digit} \\
		       $|$ &    \verb|+|%
		             $|$\verb|-|%
		             $|$\verb|*|%
		             $|$\verb|/|%
		             $|$\verb|\|%
		             $|$\verb|~|%
		             $|$\verb|@|%
		             $|$\verb|#|%
		             $|$\verb|$|%
		             $|$\verb|%|%
		             $|$\verb|^|%
		             $|$\verb|&|%
		             $|$\verb|=|%
		             $|$\verb/|/%
		             $|$\verb|<|%
		             $|$\verb|>|%
		             $|$\verb|_|%
		             $|$\verb|"|%
		             $|$\verb|`|%
		             $|$\verb|'|%
		             $|$\verb|!|%
		             $|$\verb|?|%
			     $|$\verb|;|%
			     $|$\verb|:|%
			     $|$\verb|,|%
		             $|$\verb|.|
			\end{tabular}\\[1ex]
\key{letter} ::= {\em lower-case-letter} $|$ {\em upper-case-letter} \\[1ex]
\key{lower-case-letter} ::=    \verb|a|%
			    $|$\verb|b|%
			    $|$\verb|c|%
			    $|$\verb|d|%
			    $|$\verb|e|%
			    $|$\verb|f|%
			    $|$\verb|g|%
			    $|$\verb|h|%
			    $|$\verb|i|%
			    $|$\verb|j|%
			    $|$\verb|k|%
			    $|$\verb|l|%
			    $|$\verb|m|%
			    $|$\verb|n|%
			    $|$\verb|o|%
			    $|$\verb|p|%
			    $|$\verb|q|%
			    $|$\verb|r|%
			    $|$\verb|s|%
			    $|$\verb|t|%
			    $|$\verb|u|%
			    $|$\verb|v|%
			    $|$\verb|w|%
			    $|$\verb|x|%
			    $|$\verb|y|%
			    $|$\verb|z|
			    \\[1ex]
\key{upper-case-letter} ::=    \verb|A|%
			    $|$\verb|B|%
			    $|$\verb|C|%
			    $|$\verb|D|%
			    $|$\verb|E|%
			    $|$\verb|F|%
			    $|$\verb|G|%
			    $|$\verb|H|%
			    $|$\verb|I|%
			    $|$\verb|J|%
			    $|$\verb|K|%
			    $|$\verb|L|%
			    $|$\verb|M|%
			    $|$\verb|N|%
			    $|$\verb|O|%
			    $|$\verb|p|%
			    $|$\verb|Q|%
			    $|$\verb|R|%
			    $|$\verb|S|%
			    $|$\verb|T|%
			    $|$\verb|U|%
			    $|$\verb|V|%
			    $|$\verb|W|%
			    $|$\verb|X|%
			    $|$\verb|Y|%
			    $|$\verb|Z|
			    \\[1ex]
\key{digit} ::=    \verb|0|%
		$|$\verb|1|%
		$|$\verb|2|%
		$|$\verb|3|%
		$|$\verb|4|%
		$|$\verb|5|%
		$|$\verb|6|%
		$|$\verb|7|%
		$|$\verb|8|%
		$|$\verb|9|
		\\[1ex]
\key{opening-mark} ::=     \verb|(|
	       	       $|$ \verb|[|
	       	       $|$ \verb|{|
	       	       $|$ {\em opening-quote}
	       	       $|$ {\em opening-angle}
	       	       \\[1ex]
\key{closing-mark} ::=     \verb|)|
	       	       $|$ \verb|]|
	       	       $|$ \verb|}|
	       	       $|$ {\em closing-quote}
	       	       $|$ {\em closing-angle}
	       	       \\[1ex]
\key{opening-quote} \begin{tabular}[t]{rl}
		     ::= & {\em opening-quote-character}
		           {\em opening-quote-character}$^\star$ \\
		     \end{tabular}
		     \\[1ex]
\key{opening-quote-character} ::= \verb|`| \\[1ex]
\key{closing-quote} \begin{tabular}[t]{rl}
		     ::= & {\em closing-quote-character}
		           {\em closing-quote-character}$^\star$ \\
		     \end{tabular}
		     \\[1ex]
\key{closing-quote-character} ::= \verb|'| \\[1ex]
\key{quote} ::= {\em opening-quote} $|$ {\em closing-quote} \\[1ex]
\key{opening-angle} \begin{tabular}[t]{rl}
		     ::= & {\em opening-angle-character}
		           {\em opening-angle-character} \\
		         & {\em opening-angle-character}$^\star$ \\
		     \end{tabular}
		     \\[1ex]
\key{opening-angle-character} ::= \verb|<| \\[1ex]
\key{closing-angle} \begin{tabular}[t]{rl}
		     ::= & {\em closing-angle-character}
		           {\em closing-angle-character} \\
		         & {\em closing-angle-character}$^\star$ \\
		     \end{tabular}
		     \\[1ex]
\key{closing-angle-character} ::= \verb|>| \\[1ex]
\key{angle-character} ::= \verb|<| $|$ \verb|>| \\[1ex]
\key{opening-character} ::=     \verb|(|
		            $|$ \verb|[|
		            $|$ \verb|{|
		            $|$ \verb|`|
		            $|$ \verb|<|
			    \\[1ex]
\key{closing-character} ::=     \verb|)|
		            $|$ \verb|]|
		            $|$ \verb|}|
		            $|$ \verb|'|
		            $|$ \verb|>|
			    \\[1ex]
\key{format-separator} ::= {\em format-separator-character}
			   {\em format-separator-character}$^\star$ \\[1ex]
\key{format-separator-character} ::=    \verb\|\
				        \\[1ex]
\key{white-space} ::= {\em white-space-character}
                     {\em white-space-character}$^\star$ \\[1ex]
\key{white-space-character} ::=
    \key{horizontal-space-character} $|$ \key{vertical-space-character} \\[1ex]
\key{horizontal-space-character} ::=
    \key{space} $|$ \key{horizontal-tab} $|$ \key{carriage-return} \\[1ex]
\key{vertical-space-character} ::=
    \key{line-feed} $|$ \key{vertical-tab} $|$ \key{form-feed}
\end{indpar}


The following sections give rules involving pre-lexemes.

\subsubsection{Lexical Matching and Pre-Lexical Context}
\label{LEXICAL-MATCHING}

{\em Opening-marks} and {\em closing-marks} are both pre-lexemes
and also lexemes.  Rules for matching pre-lexemes in a pre-lexeme
sequence are the same as rules for matching lexemes in a lexeme sequence.
Here we will state the rules for lexemes, and leave it to the reader
to reformulate them for pre-lexemes.

{\bf Lexeme Matching Rule.}\index{Lexeme Matching Rule}
An {\em opening-mark} with $N$ characters $C$
must have a matching {\em closing-mark} with $N$ characters each the
mirror of $C$.  Each {\em closing-mark} must match exactly one
{\em opening-mark} and the {\em opening-mark} must precede the
{\em closing-mark}.

Two lexemes are said to be \mkey{matched}{lexemes} if and only if
they are matched opening and closing marks.

{\bf Matched Lexeme Nesting Rule.}\index{Matched Lexeme Nesting Rule}
If one lexeme in a pair $P_2$ of matched lexemes is in between the
lexemes of another pair $P_1$ of matched lexemes, then both lexemes
in $P_2$ must be in between the lexemes of $P_1$.  In this case
$P_2$ is said to be \mkey{nested}{lexemes} inside of $P_1$.

During the scan a character $C$ is said to be in the
\key{lexical context} of a pair $P$ of matched lexemes
if and only if $C$ is between the matched lexemes of $P$,
and $C$ is neither part of or between any other pair of matched
lexemes that is nested inside of $P$.

For a sequence of pre-lexemes, \mkey{matched}{pre-lexemes} pre-lexemes
and \key{pre-lexical context} are defined as for a sequence of lexemes.

\subsubsection{Character Disambiguation Rules}

Several characters in pre-lexemes are ambiguous in the
pre-lexeme syntax equations.  The following rules disambiguate these
characters.

{\bf Opening Quote Rule.}\index{Opening Quote Rule}
An \key{opening-quote-character} must be preceeded by a
{\em white-space-character},
an {\em opening-character}, or a {\em format-separator-character}.
Otherwise it is a {\em word-character}.

{\bf Closing Quote Rule.}\index{Closing Quote Rule}
A \key{closing-quote-character} must be part of a sequence of
{\em closing-quote-characters} that is of exactly the right length to be the
matching pre-lexeme for the last previous unmatched {\em opening-mark},
which must be an {\em opening-quote}.
Otherwise the potential {\em closing-quote-character}
is a {\em word-character}.

{\bf Format Separator Rule.}\index{Format Separator Rule}
A {\em format-separator-character} must be in the pre-lexical context of
a pair of matched {\em quotes}.  Otherwise it is a {\em word-character}.

{\bf Angle Rule.}\index{Angle Rule}
An {\em angle-character} must be either preceded by or followed by a copy
of itself.  Otherwise it is a {\em word-character}.

Quote Examples:

\begin{indpar}[0.1in]
\begin{tabular}{@{}l@{\hspace*{0.3in}}l}
			& Pre-Lexeme Sequence		\\
Input String		& with {\em spaces} represented by \verb|_|'s \\[1ex]
\verb|I said `Hello'.|	& \tt I~~\verb|_|~~said~~\verb|_|~~`~~Hello~~'~~.	\\
\verb|Re`op 'tis.  But!|
			& \tt Re`op~~\verb|_|~~'tis.%
			  ~~\verb|__|~~But! \\
\verb|`Like 'tis'|	& \tt `~~Like~~\verb|_|~~'~~tis'	\\
\verb|``Like 'tis''|	& \tt ``~~Like~~\verb|_|~~'tis~~''	\\
\verb|`Like me''|	& \tt `~~Like~~\verb|_|~~me''		\\
\verb|`` `Hello' is a word.''|
			& \tt ``~~\verb|_|~~`~~Hello~~'~~\verb|_|~~is%
			  ~~\verb|_|~~a~~\verb|_|~~word.~~'' \\
\end{tabular}
\end{indpar}

Other rules of PCASL (\ref{LEXEMES})
limit the semantic content
of {\em white-space}, so that there is no problem putting
space between the \verb|``| and \verb|`| in the last example.

Angle and Format Separator Examples:

\begin{indpar}[0.1in]
\begin{tabular}{@{}l@{\hspace*{0.6in}}l}
			& Pre-Lexeme Sequence		\\
Input String		& with {\em spaces} represented by \verb|_|'s \\[1ex]
\verb|x <= y |		& \tt x \verb|_| \verb|<=| \verb|_| y	\\
\verb|x <<= y |		& \tt x \verb|_| \verb|<<| = \verb|_| y	\\
\verb/x = y|z/		& \tt x \verb|_| = \verb|_| \verb/y|z/ \\
\verb/x = `y|z'/	& \tt x \verb|_| = \verb|_|
                              \verb|`| y \verb/|/ z \verb|'| \\
\end{tabular}
\end{indpar}

\subsubsection{White Space Conversion}

A \key{white-space} lexeme does not have exactly the same characters
that were input to create it, unlike other pre-lexemes.  The
sequence of {\em white-space-characters} input to create a
{\em white-space} lexeme is modified as follows to create the lexeme:

{\bf Line End Spaces Rule.}\index{Line End Spaces Rule}
All {\em horizontal-space} characters preceeding a {\em vertical-space}
character are deleted.  Thus spaces at line ends are ignored.

{\bf Carriage Return Rule.}\index{Carriage Return Rule}
Each {\em carriage-return} and all {\em horizontal-spaces} preceding
it are deleted.  Thus the lexeme has no {\em carriage-returns}.

{\bf Horizontal Tab Rule.}\index{Horizontal Tab Rule}
Each {\em horizontal-tab} is replace by {\em spaces} assuming that
horizontal tab stops are set every 8 columns.
Thus the lexeme has no {\em horizontal-tabs}.

Note that these rules do \underline{not} alter the printed appearance
of the {\em white-space} lexeme.

After these rules are applied, a {\em white-space} lexeme consists of
only of {\em vertical-space-characters} followed by {\em space} characters.
{\em White-space} lexemes are only pre-lexemes; they are deleted
when pre-lexemes are converted to lexemes.  The rules that
form the lexeme sequence ensure that all
{\em vertical-space} characters are equivalent
(\ref{INDENTATION-LEXEMES}).


\subsection{Lexemes}
\label{LEXEMES}

The sequence of pre-lexemes is converted to a sequence of lexemes
according to the following rules, which we will describe in the
order given:

\begin{indpar}[1in]
Numbers \\
Post Separators \\
Indentation Lexemes
\end{indpar}

The syntax equations defining a lexeme are:

\begin{indpar}
\key{lexeme} ::= {\em word} $|$ {\em separator}
		$|$ {\em opening-mark}
		$|$ {\em closing-mark} \\[1ex]
\key{separator} ::= {\em format-separator}
		$|$ {\em post-separator} \\[1ex]
\key{indentation-lexeme} ::= \verb|;|
			 $|$ \verb|{|
			 $|$ \verb|}|
\end{indpar}

{\em Post-separators} are single characters removed from the
ends of {\em pre-words}.  A {\em Word} is what is left of
a {\em pre-word} after any {\em post-separators}
are removed from its end.
{\em Words} and {\em post-separators} are defined
below in \ref{POST-SEPARATORS}.


The {\em indentation-lexemes} are lexemes implied by indentation, and
are not distinguishable from explicit lexemes, namely the post-separator
\verb|;|, the {\em opening-mark} \verb|{|, and the {\em closing-mark}
\verb|}|.  They are defined below in
\ref{INDENTATION-LEXEMES}.

{\em White-space} pre-lexemes are used only to define indentation and
create {\em indentation-lexemes}.
Then {\em white-space} pre-lexemes are
discarded: they are not {\em lexemes}.

[TBD: what about use of whitespace in text.]

{\em Format-separators}, {\em opening-marks}, and {\em closing-marks}
are both pre-lexemes and lexemes.

\subsubsection{Number Lexemes}
\label{NUMBER-LEXEMES}

The rule for spliting a {\em pre-word} into a {\em word}
and a {\em separator} makes reference to {\em words} that are
{\em numbers}, saying that splitting is preferred if the {\em word}
resulting from the split is a {\em number}.  Some of the syntax equations
defining {\em numbers} are as follows.

\begin{indpar}
\key{number} ::= {\em real-number} $|$ {\em unit-number}
				   $|$ {\em complex-number} \\[1ex]
\key{real-number} ::= {\em unsigned-real-number}
                  $|$ {\em sign} {\em unsigned-real-number}
		      \\[1ex]
\key{sign} ::= \verb|+| $|$ \verb|-| \\[1ex]
\key{unsigned-real-number} ::= {\em unexponented-number}
		$|$ {\em unexponented-number} {\em exponent} \\[1ex]
\key{unexponented-number} ::= {\em decimal-number}
			  $|$ {\em decimal-ratio}
			  $|$ {\em radixed-number} \\[1ex]
\key{decimal-number} \begin{tabular}[t]{rl}
                     ::= & {\em decimal-natural} \\
		     $|$ & {\em decimal-natural} \verb|.|
		           {\em decimal-natural} \\
		     $|$ & \verb|.| {\em decimal-natural}
		     \end{tabular} \\[1ex]
\key{decimal-natural} ::= {\em decimal-digits}
		     $|$ {\em decimal-natural} \verb|,| {\em decimal-digits}
		     \\[1ex]
\key{decimal-digits} ::= {\em digit} {\em digit}$^\star$ \\[1ex]
\key{decimal-ratio} ::= {\em decimal-natural} \verb|/|
			{\em decimal-natural} \\[1ex]
\key{exponent} ::= {\em exponent-indicator}
		   {\em exponent-sign-and-digits} \\[1ex]
\key{exponent-indicator} ::= \verb|e| $|$ \verb|E| $|$ \verb|^| \\[1ex]
\key{exponent-sign-and-digits} ::= {\em decimal-digits}
			    $|$ {\em sign} {\em decimal-digits}
\end{indpar}

Real Decimal Number Examples:

\begin{indpar}[0.1in]
\tt
\begin{tabular}{l@{~~~~~}l@{~~~~~}l@{~~~~~}l@{~~~~~}l}
123	& -123		& +123		& 1,234		& -1,234,567 \\
123.0	& -.123		& +0.0		& +.000		& 1,234.987,654 \\
123e0	& -123e+2	& +123e-321	& 1,234e9	& -0.123,456e-3 \\
123E0	& -123E+2	& +123E-321	& -0.123,456e-3	& -1,234.567890	\\
1/2	& -3/4		& +1,234/5	& 1,234/5,432	& -53/000 \\
1,2	& 1.86,54	& .123,45,6	& 1,2345678	& 1.2345678,92
\end{tabular}
\end{indpar}

In a {\em decimal-number} the decimal point
must be followed by a digit.  Commas must be surrounded by digits,
and should be
every 3 digits from the decimal point, or every three digits
from the end if there is no decimal point.  If there is any comma at all,
there must be commas
every 3 digits, except that commas may be used in the integer part 
without any being used in the faction part.
Incorrect numbers of digits between commas will result in an
error when the lexeme is converted to a number,
but is \underline{not} an error of lexeme formation.  The last line of
examples above are therefore legal lexemes that will give errors when
converted to numbers.

Similarly there will be an error converting a {\em decimal-ratio} to a
number if the denominator equals zero, but the ratio will still be a legal
lexeme.  \verb|-53/000| is an example.

\ikey{Radixed-numbers}{radixed-number} permit binary, octal, or hexadecimal
radices to the used instead of decimal.  In fact, other number representation
schemes are permitted.

\begin{indpar}
\key{radixed-number}::= {\em radix-indicator}
		        \verb|`| {\em radixed-number-mark}
		        {\em radix-number-mark}$^\star$ \verb|'|
		        \\[1ex]
\key{radix-indicator} ::= {\em letter} {\em letter}$^\star$ \\[1ex]
\key{radixed-number-mark} ::= {\em digit} $|$ {\em letter}
                      $|$ \verb|.| $|$ \verb|,| $|$ {\em sign}
\end{indpar}

Radixed Number Examples:

\begin{indpar}[0.1in]
\tt
\begin{tabular}{l@{~~~~~}l@{~~~~~}l@{~~~~~}l}

B'10110100'	& O'77534201'	& D'19758'	& X'FE8A932B' \\
B'101101'e+2	& O'0.7753'e-5	& D'197.58'	& X'0.FE8A932B' \\
B'10,1101'	& O'12,3456'e-5	& D'0.123,5'	& X'FE8A,932B.7CCD,83' \\
\end{tabular}
\end{indpar}


The following {\em radix-indicators} are standard.

\begin{center}
\begin{tabular}{l@{~~~~~}l@{~~~~~}l@{~~~~~}l}
Radix	& Radix		 &			& Allowed Digits \\
Name	& Indicators     & Allowed Digits	& Between Commas \\[1ex]
binary	& \tt b~~~B	 & \tt 0 1		& 4 or 8 \\
octal	& \tt o~~~O	 & \tt 0 1 2 3 4 5 6 7	& 3 \\
decimal	& \tt d~~~D	 & \tt 0 1 2 3 4 5 6 7 8 9
						& 3 \\
hexadecimal
	& \tt x~~~X	 & \tt 0 1 2 3 4 5 6 7 8 9
						& 4 or 8 \\
	&		 & \tt a b c d e f A B C D E F
\end{tabular}
\end{center}

{\em Radixed-numbers} can be legal lexemes and still be unconvertable to
numbers because their {\em radix-indicators} are undefined, they
have digits not defined for the given {\em radix-indicator}, they
have too many decimal points, and so forth.  These errors are detected
when the lexemes are converted to numbers.  On the other hand, it
is possible to define non-standard converters for converting
{\em radixed-number} lexemes to numbers, and thereby increase the
space of number representations.


\ikey{Unit-numbers}{unit-number} are just {\em real-numbers} with a
{\em unit-indicator} prefixed or postfixed.

\begin{indpar}
\key{unit-number} ::= {\em pre-unit-indicator} {\em real-number}
		  $|$ {\em real-number} {\em post-unit-indicator} \\[1ex]
\key{pre-unit-indicator} ::= \verb|$| $|$ {\tt \pounds} \\[1ex]
\key{post-unit-indicator} ::= \verb|'| $|$ \verb|"| $|$ $^\circ$ \\[1ex]
\key{unit-indicator} ::= {\em pre-unit-indicator}
		     $|$ {\em post-unit-indicator}
\end{indpar}

However, unit numbers are not lexemes.

{\bf Unit Number Rule.}\index{Unit Number Rule}
If a {\em unit-number} is to be output as a {\em word} lexeme, then instead
the {\em unit-number} is split into two {\em word} lexemes, one of which
is the {\em real-number} part and the other of which is a 1-character
{\em word} consisting of the {\em unit-indicator}.

Unit Number Examples:

\begin{indpar}[0.1in]
\begin{tabular}{@{}l@{\hspace*{0.3in}}l}
Unit Number		& Lexeme Sequence	\\[1ex]
\tt \$5.71		& \tt \$~~5.71 \\
\tt \pounds -5.71	& \tt \pounds ~~-5.71 \\
\tt 15'			& \tt 15~~' \\
\tt -2.543e3"		& \tt -2.543e3~~" \\
\tt 72$^\circ$		& \tt 72~~$^\circ$ \\
\tt X'BE63'e-2$^\circ$	& \tt X'BE63'e-2~~$^\circ$
\end{tabular}
\end{indpar}

An {\em imaginary-number} is just a {\em real-number} with an
{\em imaginary-indicator}, e.g.~\verb|i|, post-fixed.  A
{\em complex-number} is just an {\em imaginary-number}
or a {\em real-number} followed by
a {\em sign} followed by an {\em imaginary-number}.

\begin{indpar}
\key{complex-number} ::= {\em imaginary-number}
		$|$ {\em real-number} {\em signed-imaginary-number} \\[1ex]
\key{imaginary-number} ::= {\em unsigned-imaginary-number}
		$|$ {\em signed-imaginary-number} \\[1ex]
\key{signed-imaginary-number} ::=
		{\em sign} {\em unsigned-imaginary-number} \\[1ex]
\key{unsigned-imaginary-number} ::=
		{\em unsigned-real-number} {\em imaginary-indicator} \\[1ex]
\key{imaginary-indicator} ::=     \verb|I|
			      $|$ \verb|i|
			      $|$ \verb|J|
			      $|$ \verb|j|
\end{indpar}

Complex Number Examples:

\begin{indpar}[0.1in]
\tt
\begin{tabular}{l@{~~~~~}l@{~~~~~}l}

3i		& +3j		& -X'FE90.34D2'I		\\
2+3i		& -3+3.345e10j	& 35-X'FE90.34D2'J		\\
\end{tabular}
\end{indpar}

\subsubsection{Post Separators}
\label{POST-SEPARATORS}

Informally, a post-separator is a 1-character separator that immediately
follows a word and could be part of that word.  Examples are the comma, period,
and the exclamation point.  There are two kinds of post separators:
weak and strong.  The Post Separator Rule
given below tells when a {\em pre-word} ending
in a {\em post-separator-character}
must be split into smaller {\em pre-word} and a 1-character
{\em separator}.  This rule makes reference to {\em words} that are
{\em numbers}, saying that splitting is preferred when the
{\em post-separator-character} is weak if the {\em word}
resulting from the split is a {\em number}.

The syntax equations required are:

\begin{indpar}
\key{separator} ::= {\em format-separator}
		$|$ {\em post-separator} \\[1ex]
\key{post-separator} ::= {\em post-separator-character} \\[1ex]
\key{post-separator-character} \begin{tabular}[t]{rl}
                     ::= & {\em strong-post-separator-character} \\
		     $|$ & {\em weak-post-separator-character}
		     \end{tabular} \\[1ex]
\key{strong-post-separator-character} ::=     \verb|,|
			                $|$ \verb|;|
					\\[1ex]
\key{weak-post-separator-character} ::=     \verb|!|
				        $|$ \verb|?|
			                $|$ \verb|:|
			                $|$ \verb|.|
					\\[1ex]
\key{pre-word} ::= {\em word}
		$|$ {\em pre-word} {\em post-separator-character}
\end{indpar}

{\bf Post Separator Rule.}\index{Post Separator Rule}
A {\em pre-word} of 2 or more characters
that ends with a {\em post-separator-character}
is split into a smaller {\em pre-word} and a {\em post-separator}
if (1) the {\em post-separator-character} is strong, or if
(2) the smaller {\em pre-word} is a {\em number}, or if
(3) the smaller {\em pre-word} does 
\underline{not} contain a copy of the {\em post-separator-character}.
If the {\em pre-word} is not split, it becomes a {\em word} lexeme.

The following rule handles the case of 1-character {\em pre-words}.

{\bf Isolated Post Separator Rule.}\index{Isolated Post Separator Rule}
A {\em pre-word} that consists of a single {\em post-separator-character}
is a {\em post-separator} lexeme.


Examples:

\begin{indpar}[0.1in]
\begin{tabular}{@{}l@{\hspace*{0.3in}}l@{~~~}l@{\hspace*{0.6in}}l}
Pre-Word		& \multicolumn{2}{@{}l@{}}{Lexeme Sequence}
							& Splits?	\\[1ex]
\verb|hello.|		& \tt hello 		& \tt .	& yes		\\
\verb|X,|		& \tt X 		& \tt ,	& yes		\\
\verb|h.e.l.l.o.|	& \tt h.e.l.l.o.	&	& no		\\
\verb|e.g.|		& \tt e.g.		&	& no		\\
\verb|5.0.|		& \tt 5.0		& \tt .	& yes		\\
\verb|1,234.5,|		& \tt 1,234.5		& \tt ,	& yes		\\
\verb|1,234.5,,|	& \tt 1,234.5		& \tt ,~~,
							& yes, twice	\\
\verb|1,234.5.,|	& \tt 1,234.5		& \tt .~~,
							& yes, twice	\\
\verb|help!|		& \tt help		& \tt !	& yes		\\
\verb|!help!|		& \tt !help!		&	& no		\\
\verb|help.!|		& \tt help		& \tt .~~!
							& yes, twice	\\
\verb|.help.!|		& \tt .help.		& \tt !
							& yes, once	\\
\verb|!.help.!|		& \tt !.help.!		&	& no		\\
\end{tabular}
\end{indpar}

\subsubsection{Indentation Lexemes}
\label{INDENTATION-LEXEMES}

{\em Indentation-lexemes} are implied by indentation.  The
\mkey{indentation}{of line} of a line is the
the number of {\em space} characters in the {\em white-space}
pre-lexeme just before the first non-{\em white-space} pre-lexeme
of the line.  Note that lines cannot be empty; empty lines are
merged into {\em white-space} pre-lexemes.

At any given point in the scan of pre-lexemes, there is a
stack of indentation records, called the \key{indentation stack}.
An \key{indentation record} is a number of
columns, a pre-lexical context, and a flag.
The number of columns is called the \key{indentation}.
The flag is called the \key{implicit bracket flag}, and indicates whether
or not an implied \verb|{| lexeme was inserted at the same time the
indentation record was pushed onto the indentation stack.

Initially the indentation stack contains a single indentation record with
0 indentation, the outermost pre-lexical context,
and an off implicit bracket flag.
The stack cannot become empty; any operation that would
pop the last indentation off the stack announces an error and leaves the
stack alone.  Thus the bottommost indentation on the stack is always
the same.

The indentation in the indentation record at the top of the indentation
stack is called the \key{current indentation}, and the pre-lexical
context in that record is called the \key{current pre-lexical context}.

{\bf Semi-Colon Rule.}\index{Semi-Colon Rule}
If the first non-{\em white-space} pre-lexeme of a line is neither
\verb|{| nor \verb|}|, if that pre-lexeme is in
the current pre-lexical context, and if the indentation of the line
is the current indentation, and if the last lexeme output was not
a \verb|;| {\em separator} lexeme or a \verb|{| {\em opening-mark}
lexeme (including an implied {\em opening-mark} as in the
Implicit-Bracket Rule below), then a \verb|;| implied {\em separator}
lexeme is output
before any lexemes generated by the line are output.

{\bf Explicit-Bracket Rule.}\index{Explicit-Bracket Rule}
If the last pre-lexeme of a line is \verb|{|, then an indentation record
is pushed into the indentation stack just after the \verb|{| lexeme
is output.  The indentation in the record is the indentation of the next
line, the pre-lexical context is that in effect just after the \verb|{|,
and the implicit bracket flag is off.
The pushed indentation record is popped just after its pre-lexical context
ends; that is, just after reading the \verb|}| pre-lexeme that matches the
\verb|{| pre-lexeme that pushed the indentation record.

{\bf Implicit-Bracket Rule.}\index{Implicit-Bracket Rule}
If the last lexeme output for a line would be a post-separator \verb|:|,
then a \verb|{| implied {\em opening-mark} lexeme
is output instead of the \verb|:|, and an indentation
record is pushed into the indentation stack.  The indentation of the
record is the indentation of the next line, the implicit bracket flag
of the record is on, and the
pre-lexical context of the record is that of the \verb|:|.
The pushed record is popped (1) just before the first line such that
the line beginning pre-lexeme is in the record's pre-lexical context
and the line's indentation is less than the record's indentation,
or (2) at the end of the input pre-lexeme stream.
When the record is popped, a \verb|}| implied {\em closing-mark}
lexeme is output.

In order to avoid subtle errors created by indentation, there
is a {\tt minimum-indentation} parameter and the following rule.

{\bf Minimum-Indentation Rule.}\index{Minimum-Indentation Rule}
The indentation of any line must equal the current indentation
or differ from it by at least the value of the
\ttkey{minimum-indentation} parameter.  The {\tt minimum-indentation}
parameter defaults to {\tt 4}.


Indentation Lexeme Examples:

\begin{indpar}[0.1in]
\tt \ttbrackets
\begin{tabular}{@{}l@{~~~~~~~~~~}l}
{\rm Input String}		& {\rm Output Lexemes} \\[1ex]
hi \{ x; y z; w \}		& \tt hi \{ x ; y z ; w \} \\[1ex]
hi \{				& hi \{ \\
~~~~x				& x \\
~~~~y z				& ; y z \\
~~~~w \}			& ; w \} \\[1ex]
hi				& hi \\
\{				& \{ \\
~~~~x				& x \\
~~~~y z				& ; y z \\
~~~~w				& ; w \\
\}				& \} \\[1ex]
hi:				& hi \{ \\
~~~~x				& x \\
~~~~y z				& ; y z \\
~~~~w				& ; w \\
				& \} \\[1ex]
hi \{				& hi \{ \\
~~~~x				& x \\
~~~~y `this			& ; y ` this \\
is another pre-lexical		& is another pre-lexical \\
context.			& context . \\
' foo bar			& ' foo bar \\
~~~~w \}			& ; w \} \\[1ex]
hi \{				& hi \{ \\
~~~~x				& x \\
~~~~y \{			& ; y \{ \\
ho				& ho \\
hum \} z			& ; hum \} z \\
~~~~w \}			& ; w \}
\end{tabular}
\end{indpar}


\section{Expression Parsing}\index{parsing}
\label{EXPRESSION-PARSING}

An expression is a sequence of words, separators, and subexpressions.
A subexpression is a pair of matched lexemes and all the lexemes in
between.

Expressions and subexpressions can contain operators.  When they do,
matched implied parentheses are inserted into the expressions or subexpressions
according to rules of operator precedence and associativity, and these
implied parentheses create new subexpressions.

Expressions and subexpressions that do not contain operators may contain
argument lists and qualifying phrases.  The order in which qualifying
phrases appear does not matter, and sometimes the order of arguments
in an argument list does not matter.

Expressions containing operators are restructured, both by inserting
implied parentheses and in other ways.  Subexpressions surrounded by
particular matching lexemes, such as \verb|`'|, are restructured.

The process of restructuring expressions is called \key{parsing}.
Parsing takes an expression as input, and produces as output a raw
expression that contains nothing that will trigger further restructuring.

\subsection{Subexpressions}
\label{SUBEXPRESSIONS}

The first step in parsing is to identify \skey{subexpression}s within
an expression, without restructuring the expression, by applying
the following syntax equations.

\begin{indpar}
\key{expression} ::= {\em expression-item}$^\star$ \\[1ex]
\key{expression-item} ::= {\em word} $|$ {\em separator}
				     $|$ {\em subexpression} \\[1ex]
\key{subexpression} ::= {\em opening-mark} {\em expression}
			{\em closing-mark}
\end{indpar}

{\bf Subexpression Rule.}\index{Subexpression Rule}
The {\em opening-mark} lexeme that begins a subexpression
must match (\ref{LEXICAL-MATCHING}) the {\em closing-mark} lexeme that
ends a subexpression.

\subsection{Expression Structure}
\label{EXPRESSION-STRUCTURE}

Expression structure is affected by three special marks.
The \key{reorder mark} (\ttkey{<:>}) separates arguments that can be
reordered, as in the expression `\verb|element LIST <:> INDEX|', and is used in
expression definitions.
The \key{remainder mark} (\ttkey{::>}) preceeds a final argument in an
expression definition that represents the list of remainding arguments in a use
of the definition, as in the expression `\verb|max ::> ARGS|'
where \verb|ARGS| represents
the list of all the arguments given to \verb|max|.
The \key{qualifier mark} (\ttkey{@@}) signals that the following
expression item is a qualifier, as in the expression
`\verb|sort x @@ ascending|',
and is implied by qualifiers (e.g. \verb|with|, \verb|has|,
\verb|ascending|) in an expression.

Expressions are restructured if they contain operators (e.g.,
\verb|+|,
\verb|-|,
\verb|*|,
\verb|/|),
qualifiers (e.g.,
\verb|with|,
\verb|has|,
\verb|ascending|),
or certain matching lexemes.  A \key{raw expression}
(\ref{RAW-EXPRESSIONS})
is a particular kind of expression that will not be
restructured.  The only special marks that may be in a raw expression
are the reorder mark (\verb|<:>|), the remainder mark (\verb|::>|),
and the qualifier mark (\verb|@@|).
Translating
an expression into a raw expression is called \key{parsing}.

Matching lexemes may affect parsing.
An informal summary of some of these is:

\begin{center}
\begin{tabular}{lll}
Brackets   & Turns Off			& Turns On \\[1ex]

\verb|[]|  & operators, qualifiers, \verb/|/, text
					& \verb|<:>|, \verb|::>|, \verb|@@| \\
\verb|[< >]|  & \verb/|/, text		& operators, qualifiers,
					  \verb|<:>|, \verb|::>|, \verb|@@| \\
\verb|()|  & nothing			& nothing \\
\verb|{}|  & eval, \verb/|/, text	& operators, qualifiers,
					  \verb|<:>|, \verb|::>|, \verb|@@| \\
\verb|<<>>|  & \verb/|/, text		& eval, operators, qualifiers,
					  \verb|<:>|, \verb|::>|, \verb|@@| \\
\verb|`'|  & eval, operators, qualifiers,
					& \verb/|/, text \\
	   & \verb|<:>|, \verb|::>|, \verb|@@|
\end{tabular}
\end{center}

Other matching lexemes may be made to affect parsing by introducing
operator definitions (\ref{OPERATOR-DEFINITIONS}).

Parsing is controlled by the \key{parsing context}, which consists
of a \key{parsing parser stack} and a \key{parsing definition stack}.

There are three standard \ikey{parsers}{parser!standard}:
the \key{marks parser} \ttkey{-MARKS-PARSER-},
where only the reorder mark (\verb|<:>|),
remainder mark (\verb|::>|), and the qualifier mark (\verb|@@|) are recognized,
the \key{operators parser} \ttkey{-OPERATORS-PARSER-},
where these marks
are recognized along with operators and qualifiers,
and the \key{text parser} \ttkey{-TEXT-PARSER-},
where only the format-separator (\verb/|/)
is recognized.
An opening mark may change the parser by
pushing a new parser into the parsing
parser stack whose top member is the effective parser for subexpressions.
The corresponding closing mark will pop the parsing parser
stack.

From the parsing point of view there are several types of
expression restructuring that can occur.  One, text restructuring,
is done by the text parser, which is invoked by
\verb|`'| quotes, and does things like turn
\verb|`I am!'| into \verb|[sentence I am !]|.  A second kind of
restructuring, which is done by all standard parsers,
enforces the rule that the first item of an expression with no
operators cannot be a subexpression or qualifier,
by inserting the word \verb|-EMPTY-| at the
beginning of the expression if necessary, as when
\verb|((integral x) from 0)| is restructured as
\verb|(-EMPTY- (integral x) from 0)|.  Lastly, operators (\ref{OPERATORS}),
as recognized by the operators parser,
can cause major restructuring of an expression,
as when \verb|x + y - 5 * z| is restructured as \verb|[- [+ x y] [* 5 z]]|,
and qualifiers, also recognized by the operators parser,
can cause qualifier marks (\verb|@@|) to be inserted, as when
\verb|sort x| \verb|ascending|
is restructured as
\verb|[sort x @@ ascending]|.

In expressions that cannot contain operators
or qualifiers, words and separators that would be recognized as operators
or qualifiers elsewhere are not recognized as such.  Thus in
\verb|[word +]| the \verb|+| is not recognized as an operator, and
in \verb|[item ascending]| \verb|ascending| is not recognized as
a qualifier.

Some matching lexemes above affect evaluation (eval).
Evaluation differs from parsing context in that it is managed by a
counter and not a stack; if evaluation is
turned off twice, it must be turned on twice to be in effect.
Thus in a context in which evaluation is on, the \verb|X| in
\verb|{ <<X>> = 5 }| and \verb|{ y = `<< <<X>> >>' }| will be evaluated
but the \verb|X| in \verb|{ y = `<<X>>' }| will not be.  There is
an \key{evaluation counter} value that is
incremented (decremented) by an opening mark
that turns evaluation on (off), and decremented (incremented) by the
corresponding closing mark.  This counter sticks at +1: matching
lexemes that would increment the counter have no affect if the counter
is at +1.

Evaluation is also not part of parsing; the evaluation counter is
used during expression evaluation, which occurs after expression parsing.
Parsing does insert the wrappers (\ref{OPERATOR-WRAPPER})
\ttkey{-EVAL-ON-} and \ttkey{-EVAL-OFF-} around expressions to inform
the evaluator when to increment or decrement the evaluation counter.

\subsection{Raw Expressions}
\label{RAW-EXPRESSIONS}

A raw expression is an expression that contains no operators,
qualifiers, or text parsing contexts that induce restructuring.
Also, all raw expressions must begin with a word or separator.
Raw expressions can be directly represented using the \verb|[]|
matching lexemes and the \verb|<:>| reorder, \verb|::>| remainder, and 
\verb|@@| qualifier marks.

When an expression is parsed, the output is a raw expression.
The following are examples, all of which are assumed to
appear in the context of \verb|{}| matching lexemes (so
operators and qualifiers are turned on and text parsing is turned off):

\begin{center}
\begin{tabular}{ll}
Input Expression	& Raw Expression Equivalent \\[1ex]
\verb|3*x*x + 5|	& \verb|[+ [* [* 3 x] x] 5]| \\
\verb|x = y = 10|	& \verb|[= x [= y 10]]| \\
\verb|0 < x <= 5 |	& \verb|[-COMPARE- 0 < x <= 5]| \\
\verb|x = `Hello <<y>>.' |
			& \begin{tabular}[t]{@{}l}
	    \verb|[= x [-EVAL-OFF-| \\
	    \verb|      [sentence Hello| \\
	    \verb|                [-EVAL-ON- y]| \\
	    \verb|                .]]]| \\
	    \end{tabular}
\end{tabular}
\end{center}

The syntax of raw expressions is defined as follows:

\begin{indpar}
\key{raw-expression} ::= {\em word} $|$ {\em separator}
				     $|$ {\em raw-subexpression} \\[1ex]
\key{raw-subexpression} ::=
	\begin{tabular}[t]{@{}ll}
	\verb|[| & {\em raw-expression-head} \\
		 & {\em raw-argument-list} \\
		 & {\em raw-qualifier-phrase}$^\star$ \verb|]| \\
	\end{tabular} \\[1ex]
\key{raw-expression-head} ::= {\em word} $|$ {\em separator} \\[1ex]
\key{raw-argument-list} ::=
	    {\em raw-base-argument-list}
	    {\em raw-argument-remainder-option} \\[1ex]
\key{raw-base-argument-list}
        \begin{tabular}[t]{@{}rl}
	::= & {\em empty} \\
	$|$ & {\em raw-argument}
	    \{ {\em reorder-mark-option} {\em raw-argument} \}$^\star$
	\end{tabular} \\[1ex]
\key{reorder-mark-option} ::= {\em empty} $|$ \verb|<:>| \\[1ex]
\key{reorder-argument-remainder-option} ::=
	{\em empty} $|$ \verb|::>| {\em raw-argument} \\[1ex]
\key{raw-argument} ::= {\em raw-expression} \\[1ex]
\key{raw-qualifier-phrase} ::=
	\verb|@@| {\em raw-qualifier-head} {\em raw-argument-list} \\[1ex]
\key{raw-qualifier-head} ::= {\em word} $|$ {\em separator}
\end{indpar}

The order of {\em raw-qualifier-phrases}
in a {\em raw-expression} does not matter.
The order of arguments separated by {\em reorder-marks} (\verb|<:>|) does
not matter.  Both {\em reorder-marks} (\verb|<:>|) and {\em remainder-marks}
(\verb|::>|) can only occur in the head of an inference rule
(\ref{INFERENCE-RULE}).

\subsection{Operators}
\label{OPERATORS}

Operators restructure expressions in which they occur.  Operators
are defined by operator definitions that can be added to the current
operator context by some operators.

\subsubsection{Operator Definitions}
\label{OPERATOR-DEFINITIONS}

The parsing definitions stack
contains \skey{operator definition}s and qualifier definitions.
An operator definition specifies for each operator the following:

\begin{indpar}[1in]
Fixity \\
Name \\
Precedence \\
Associativity \\
Parser \\
Control Flags \\
Wrapper \\
Subdefinitions
\end{indpar}


\subsubsubsection{Operator Fixity}\ttmindex{fixity}{of operator}
\label{OPERATOR-FIXITY}
An operator has one of the following fixities:

\begin{indpar}
\begin{tabular}{@{}p{1in}@{~~~}p{4in}@{}}
\ttkey{infix}		& E.g., \verb|+| in \verb|x + 5|.\\
\ttkey{prefix}		& E.g., \verb|-| in \verb|- 5|.\\
\ttkey{postfix}		& E.g., \verb|!| in \verb|x!|.\\
\ttkey{matchfix}	& E.g., \verb/[| |]/ in \verb/[| x - 5 |]/.
\end{tabular}
\end{indpar}

An infix operator is placed between its two operands;
a prefix operator is placed before its one operand;
a postfix operator is placed after its one operand;
and a matchfix operator surrounds its one operand.
Operands of prefix, infix, and postfix
operators may not be empty; but the operand of a matchfix operator
may be empty.
An infix operator may not begin or end an expression;
a prefix operator must begin an expression;
a postfix operator must end an expression;
and a matchfix operator has two parts: an opening operator
that must begin an expression and a closing operator that must end
the same expression.

\subsubsubsection{Operator Name}\ttmindex{name}{of operator}
\label{OPERATOR-NAME}
An operator definition has a sequence of lexemes that is the
{\em name} of the operator.  The operator
inside a subexpression is just this sequence of lexemes, except for
matchfix operators, which have two sequences of lexemes, an
\key{opening operator name} that must begin the subexpression and
a \key{closing operator name} that must end the subexpression.

By abuse of language, the term `\key{operator}' is often used
as a synonym for `operator name'.  Similarly `\key{opening operator}'
is used as a synonym for `opening operator name' and `\key{closing operator}'
is used as a synonym for `closing operator name'.

The opening and closing names of a matchfix
operator are bundled into a single operator name that is
sequence of lexemes consisting of
the opening operator name followed by a `\verb/.../' lexeme
followed by the closing operator name.
For example, the
matchfix operator named `\verb/[ | ... | ]/' permits subexpressions
like `\verb/[| x - 5 |]/'.  Here the opening operator name
is `\verb/[|/' and the closing operator name is `\verb/|]/'.

Opening and closing marks cannot be part of an operator name
unless the operator is a matchfix operator.
If opening and closing marks are part of a matchfix operator
name, they must begin and end the name, and they must not be
parentheses \verb|()|.

When a subexpression is tested
for matchfix operators, any opening and closing marks that begin and
end the subexpression are included in the subexpression, unless they are
parentheses \verb|()|, which are always removed (recursively) when they
begin and end a subexpression, and are thus invisible.  Thus
the matchfix operator `\verb/| ... |/' could be invoked by
the expression `\verb/x + (| y |)/'.  Operator names are not permitted
to include parentheses \verb|()|, so names such as `\verb/|( ... )|/'
are erroneous.
Generally, including extra pairs of parentheses
\verb|()| has no affect on expression parsing or expression meaning,
though the explicit parentheses in `\verb/[(|x|)]/' will prevent 
a matchfix operator named `\verb/[| ... |]/' from being recognized.

\subsubsubsection{Operator Precedence}\ttmindex{precedence}{of operator}
\label{OPERATOR-PRECEDENCE}
The precedence of an operator is an integer.  Precedence is used in
selecting which infix operators in an expression to consider
(\ref{OPERATOR-SELECTION}).
Only infix operators have precedence.

\subsubsubsection{Operator Associativity}\ttmindex{associativity}{of operator}
\label{OPERATOR-ASSOCIATIVITY}
An infix operator has an {\em associativity} that is
a sequence of lexemes.
Three associativities, {\tt left}, {\tt right}, and
{\tt none}, have special meaning.  If an infix operator has some
other associativity, it is said to have \key{named associativity}.
Only infix operators have associativity.

If more than one infix operator is selected in an expression by the operator
selection algorithm\EOL (\ref{OPERATOR-SELECTION}),
all the infix operators that are selected
must have the identical operator definitions except for operator names,
and the associativity in these definitions
must not be {\tt none}\ttmindex{none}{associativity}.

If all operators are {\tt left} associative%
\index{left associative@{\tt left} associative},
all the infix operators but the rightmost are deselected,
so it is as if operators to the left had
higher precedence than those to the right.

If all operators are {\tt right} associative%
\index{right associative@{\tt right} associative},
all the infix operators but the leftmost are deselected,
so it is as if operators to the right had
higher precedence than those to the left.

If all operators are of \key{named associativity}, all remain selected, and 
implicitly parenthesized subexpressions will be created between the
operators as well as between the beginning of the expression and the
first operator and between the last operator and the end of the expression.
Then the associativity, as a lexeme sequence, is prepended to the expression.
Thus if the infix operators \verb|<| and \verb|<=| have associativity
\verb|-COMPARE-|, the expression \verb|0 < x - 3 <= 5| will
be rewritten as \verb|[-COMPARE- 0 < (x - 3) <= 5]|.

\subsubsubsection{Operator Parser}\ttmindex{parser}{of operator}
\label{OPERATOR-PARSER}

A parser is the name of the function that is called with a expression
as its single argument in order to parse the expression.

The parser used for subexpressions of an expression is the parser
at the top of the \key{parsing parser stack}.

The \verb|parser| of an operator definition is an optional word that
names a parser.  If present, the word is pushed into the parsing parser
stack before subexpressions are parsed, and then the parsing parser stack
is popped after subexpressions have been parsed.

The following are standard parsers:

\begin{indpar}

The \key{operators parser} \ttkey{-OPERATORS-PARSER-}.
Operators, qualifiers, and the
\verb|<:>| reorder, \verb|::>| remainder, and
\verb|@@| qualifier marks are recognized.  The special constructs
of text parsing, e.g., the \verb/|/ format separator,
are \underline{not} recognized.

The \key{marks parser} \ttkey{-MARKS-PARSER-}.
The \verb|<:>| reorder, \verb|::>| remainder, and
\verb|@@| qualifier marks are recognized.  Operators, qualifiers,
and the special constructs
of text parsing, e.g., the \verb/|/ format separator,
are \underline{not} recognized.

The \key{text parser} \ttkey{-TEXT-PARSER-}.
The special constructs of text parsing (\ref{TEXT-PARSING}) are
recognized.  Operators, qualifiers, and
the \verb|<:>| reorder, \verb|::>| remainder, and
\verb|@@| qualifier marks are \underline{not} recognized.

\end{indpar}

\subsubsubsection{Operator Control Flags}\ttmindex{control flag}{of operator}
\label{OPERATOR-CONTROL-FLAGS}
Operators can be associated with \skey{operator control flag}s that
affect parsing of subexpressions of the operator.

\begin{indpar}

{\bf definitions}\index{definitions flag@{\tt definitions} flag}\\
This flag may only be given for a right associative infix operator.
It causes the
left operand of the operator to be inspected to see if it is an
operator or qualifier definition.  If no, nothing special is done.
If yes, the expression containing
the infix operator is replaced by just its right operand, the definition
in the left operand
is pushed onto the parsing definitions stack, the right operand is
parsed, and then the definition is popped off the parsing definitions stack.

\end{indpar}

\subsubsubsection{Operator Wrapper}\ttmindex{wrapper}{of operator}
\label{OPERATOR-WRAPPER}

An operator wrapper is a raw expression containing the lexeme `\verb|...|'.
If operator selection for an expression selects a single operator with a
wrapper, the expression is restructured to be a copy of the wrapper
with its `\verb|...|' lexeme replaced by the parse of the expression
being restructured.

For example, if the matchfix operator `\verb|<< ... >>|' has the
wrapper `\verb|-EVAL-ON- ...|', then the expression `\verb|<<x>>|'
will be restructured to be `\verb|-EVAL-ON- x|'.

\subsubsubsection{Operator Subdefinitions}\ttmindex{definition}{of operator}
\label{OPERATOR-SUBDEFINITIONS}

An operator definition can contain a list of definitions
that are pushed into the parsing definition stack before the subexpressions
of the operator are parsed, and are popped from the stack after the
subexpressions are parsed.  To avoid name confusion, these definitions
are called \skey{subdefinition}s.

Note that subdefinitions can include operator definitions, operator
undefinitions, qualifier definitions, and qualifier undefinitions.

\subsubsection{Operator Definition Syntax}
\label{OPERATOR-DEFINITION-SYNTAX}

\subsubsection{Operator Selection}
\label{OPERATOR-SELECTION}

The operator selection algorithm is run by the
the \mkey{operators parser}{operator selection}
\ttmkey{-OPERATORS-PARSER-}{operator selection} to check an expression
for operators.
This algorithm selects operators whose name appears in the expression,
and then applies rules to deselect some selected operators.  If at the end
of the algorithm there is exactly one operator selected, the definition
of that operator is used to restructure the expression.  If there is more
than one operator selected, it is a parse error unless the definitions of
all selected operators are identical except for operator names.

The operator selection algorithm uses the current parsing definition stack
to determine which operators are defined.  The most important parts of each
definition are the operator name and operator fixity.

In the algorithm the concepts of prefix sequence and postfix sequence
are used.  A \key{prefix sequence} is a sequence of defined prefix operator
names.  A \key{postfix sequence} is a sequence of defined postfix operator
names.

In the \key{operator selection algorithm}, which is defined as follows,
the steps are executed in the order given, and
each step is repeated until it does nothing.

\begin{enumerate}

\item
Select any defined matchfix operator whose opening name
begins the expression and whose closing name ends the expression.

\item
If two matchfix operators are selected, the opening operator name
of the first is longer than the opening operator name of the second,
and the closing operator name
of the first is longer than the closing operator name of the second,
then the second operator is deselected.

Thus if `\verb/[| ... |]/' and `\verb/[ ... ]/' are two selected
matchfix operators, the second will be deselected.

\item
If more than one matchfix operator is still selected, the parse is in error.

\item
If a matchfix operator is selected, and the expression begins with
a prefix sequence that is not shorter than the opening name of the
matchfix operator, the parse is in error.
Similarly if a matchfix operator is selected, and the expression ends with
a postfix sequence that is not shorter than the closing name of the
matchfix operator, the parse is in error.

Thus if `\verb|- < ... > -|' is a defined matchfix operator and
`\verb|-|' is a defined prefix operator, but there is no defined
prefix operator whose name begins with the lexeme `\verb|<|',
parses of expressions containing the matchfix operator
will \underline{not} be in error.
But if there is another defined prefix operator named `\verb|<|',
parses of these expressions will be in error.

\item
If a matchfix operator is selected, the algorithm terminates successfully
at this point, without selecting any other operators.
The part of the expression between the opening operator name and closing
operator name is the sole operand of the matchfix operator.  This operand
is implicitly parenthesized, and may be empty.

\item
Select all defined infix operators that occur in the expression.

\item
Deselect any selected infix operator that overlaps or abuts
a prefix sequence that begins the expression.
Deselect any selected infix operator that overlaps or abuts
a postfix sequence that ends the expression.

Note that the empty sequence is both a prefix and a postfix sequence,
so infix operators that begin or end the expression are deselected.
For example, in the expression `\verb|+ x * y|' the prefix operator
`\verb|+|' is
deselected, and in the expression `\verb|+ + + x * y|' all the `\verb|+|'s are
deselected.

\item
On the set of selected infix operators define the \key{infix conflict relation}
to be the smallest equivalence relation such that two selected infix operators
conflict if they overlap or abut.

\item
Deselect any infix operator if it is not followed by a prefix sequence that
contains all other infix operators that conflict with the infix operator.
Deselect any infix operator if it is not preceded by a postfix sequence that
contains all other infix operators that conflict with the infix operator.
In checking for conflicting operators, check any infix operator selected
at the end of the previous step, whether or not it has been deselected
in this step.

Since the empty sequence is a prefix and postfix sequence, any infix operator
that does not conflict with any other infix operator will still be selected
at the end of this step.

The parse is in error if there is an equivalence class of
conflicting operators all
of whose members are deselected by this step.

\item
The parse is in error if two conflicting infix operators are still selected at
this point.

\item
If two infix operators are selected, and the first has strictly lower
precedence than the second, deselect the second.

\item
If several infix operators are still selected at this point, all these
operators must have the same associativity, which must not be `\verb|none|'.
Otherwise the parse is in error.

\item
If several infix operators are selected at this point and their common
associativity is `\verb|left|', all but the rightmost infix operator
are deselected.
Similarly if several infix operators are selected at this point and their common
associativity is `\verb|right|', all but the leftmost infix operator
are deselected.

\item
If several infix operators are still selected at this point, all these
operators must have the same definitions except for operator names.
Otherwise the parse is in error.

\item
If any infix operators are still selected at this point, the algorithm
terminates successfully.
The parts of the expression between the operators, before the first
operator, and after the last operator are the operands, and are
implicitly parenthesized.  No operand is empty.
If the common associativity of the infix operators is not
`\verb|left|',
`\verb|right|', or
`\verb|none|', this associativity as a lexeme sequence is prepended to the
expression, before the first operator.

\item
Select all prefix operators that begin the expression, and all postfix
operators that end the expression.

\item
If two prefix operators are selected, and one is longer than the other,
deselect the shorter.
Similarly, if two postfix operators are selected,
and one is longer than the other,
deselect the shorter.

\item
If more than one operator is selected at this point, the parse is in error.

\item
If one operator is selected at this point, and the operator name
is the entire expression, deselect the operator.  Thus
in the expression `\verb|x = (+)|', `\verb|+|' will be deselected
when the subexpression `\verb|(+)|' is parsed.

\item
The algorithm terminates successfully
at this point with zero operators selected,
or with one prefix or postfix operator selected.
If there is one selected operator, the part of the expression
that is not the operator name is the sole operand, and is implicitly
parenthesized.  Note this operand cannot be empty.

\end{enumerate}


The rules just given produce a result that is often the same as the
more common context free grammar rules for parsing expressions.  However,
there is a difference: in PCASL an operator can change the parsing context
used to parse its operand subexpressions.  See the sections on
operator parsers (\ref{OPERATOR-PARSER}),
operator control flags (\ref{OPERATOR-CONTROL-FLAGS}),
and operator subdefinitions (\ref{OPERATOR-SUBDEFINITIONS})
above.

\subsubsection{Post Operator Selection Processing}
\label{POST-OPERATOR-SELECTION-PROCESSING}

Post operator selection processing is done after operator selection by
the \mkey{operators parser}{post operator selection}
\ttmkey{-OPERATORS-PARSER-}{post operator selection},
whether or not any operators are selected.
After operators are selected without a parse error, all the selected
operators have identical definitions except for operator name.
The common part of these definitions, which we will refer to as
`the opertor definition', is used to control post operator selection
processing of the expression containing the operators.  If no operators are
selected, a definition containing no optional parts (no named associativity,
no parser, no control flags, no wrapper, no subdefinitions) is used
to control post operator selection processing.

Post operator selection processing is done in the following steps.

\begin{enumerate}

\item
If the operator definition has a parser, this is pushed into the
parsing parser stack.

\item
If the operator definition has subdefinitions, these are pushed into the
parsing definition stack.


\item
Subexpressions are parsed left to right by calling the parser at the
top of the parsing parser stack.  If the operator definition has the
\ttmkey{definitions}{control flag} control flag (note the operator must
be right associative), after the first subexpression is parsed,
it is checked to see if it is an operator definition
(\ref{OPERATOR-DEFINITION-SYNTAX}).  If yes, this operator definition is pushed
into the parsing definition stack before the second subexpression is parsed.

\item
If an operator definition in the first subexpression was pushed into
the parsing definition stack, the expression is replaced by its parsed
second subexpression.  Otherwise all subexpressions in the expression
are replaced by their parsed versions.

\item
If the operator definition has a named associativity, this is prefixed
to the expression.

\item
If the operator definition has a wrapper, the expression is
replaced by its wrapper with the word \verb|...| in the wrapper
replaced by the expression.

\item
If anything was pushed into the parsing stacks above, these things
are popped from the stacks.

\item
The expression is returned as the result of parsing the expression.

\end{enumerate}

\subsection{Text Parsing}
\label{TEXT-PARSING}


\section{Expression Graphs}
\label{EXPRESSION-GRAPHS}

Expression graphs store expressions.  An \key{expression graph}
is a directed possibly cyclic graph with labels on all arrows and on some
nodes, plus a set of graph node valued variables.

Expression graph arrow and node labels 
must be single words or separators.  Labelled nodes cannot be the source
of any arrow.  Several arrows with the same source node may have the same
arrow label.

An expression graph variable has a name, a value, and a default.
Variable names must be single words or separators.
Both the value and the default are graph nodes.  The default may be
missing.

All graph nodes are reachable from from either the value or the default
of some variable.

There is always a variable named \ttkey{-ROOT-} whose value
is a graph node called the \mkey{root}{of expression graph}
of the expression graph.  The \verb|-ROOT-| variable does not have a default.

If there is only one variable, \verb|-ROOT-|, and no node is the destination
of more than one arrow, the graph is a tree.  In this case it is called
an \key{expression tree}.

There is a correspondence between raw expressions and expression trees
that is one-to-one, except that two raw expressions differing only
in the order of their qualifier clauses correspond to the same expression
tree.

There are several operations that convert expression trees into general
expression graphs.  All these use a designated operator, which defaults
to \ttkey{//}, to identify expression graph variables and their values.
The most commonly used conversion operation also uses the convention that
words beginning with a capital letter designate
expression graph variables.

\subsection{Expression Graph Notation}
\label{EXPRESSION-GRAPH-NOTATION}

The following is an example of the notation we will use to represent
expression graphs:%
\footnote{This notation is standard for feature structures:
e.g., see Bob Carpenter, {\em The Logic of Typed Feature Structures},
1992, Cambridge University Press}

\newcommand{\Glabel}[1]{\mbox{\tt #1}}
\newcommand{\Gvariable}[1]{\fbox{\tt #1}}
\newsavebox{\Gfbox}
\newcommand{\Gdefault}[1]{%
    \sbox{\Gfbox}{\fbox{\tt #1}}%
    {\setlength{\fboxsep}{0.01in}%
     \fbox{\usebox{\Gfbox}}%
    }}
\newenvironment{Graph}%
    { \( \left[ \begin{array}{l}}%
    {\end{array} \right] \) }
\newenvironment{Gchild}[1]%
    {\mbox{\tt #1}:
     \begin{array}{l}
     \rule{0in}{0in} \vspace{-0.15in} \\
     \left[ \begin{array}{l}}%
    {\end{array} \right] \\
     \rule{0in}{0in} \vspace{-0.15in}
     \end{array}}

\begin{center}
\ttbrackets

\begin{Graph}
    \Gvariable{-ROOT-} \\
    \begin{Gchild}{fee}
	\Gvariable{X} \\
	\Glabel{\$5} \\
    \end{Gchild} \\
    \begin{Gchild}{fie}
	\Gvariable{X} \\
    \end{Gchild} \\
\end{Graph}
\hspace{0.3in}
\begin{Graph}
    \Gdefault{X} \\
    \begin{Gchild}{1}
	\Glabel{foe} \\
    \end{Gchild} \\
    \begin{Gchild}{2}
	\Glabel{fum} \\
    \end{Gchild} \\
\end{Graph}
\hspace{0.3in}
\begin{Graph}
    \Gvariable{Y} \\
    \Gdefault{Y} \\
    \begin{Gchild}{1}
	\Gvariable{\{1\}} \\
    \end{Gchild} \\
    \begin{Gchild}{2}
	\begin{Gchild}{*}
	    \Gvariable{\{1\}} \\
	\end{Gchild} \\
    \end{Gchild} \\
\end{Graph}


\end{center}

In this notation, the representation of a graph node is a set of lines
enclosed in [] brackets.

If the node is the value or default of some variables,
the names of those variables, each enclosed in a box or double box, are the top
lines of the representation of the node.
A variable name is boxed if the node is the value of
a variable, and double boxed if the node is the default of the
variable.
In our example \Gvariable{-ROOT-}, \Gvariable{X}, and \Gvariable{Y}
designate nodes that are variable values and
\Gdefault{X} and \Gdefault{Y} designate nodes that are variable defaults.
A single node can be the value or default of several variables: in the
example one node is both the value and the default of \verb|Y|.

The example expression graph has three variables, \verb|-ROOT-|, \verb|X|,
and \verb|Y|.  While all nodes in the expression graph must be reachable
from the value or default of some variable in the graph, all nodes
need not be reachable from the value of \verb|-ROOT-|.  The above example
is a single expression graph with three variables, and \underline{not}
three expression graphs.

Two nodes with the same boxed variable name in their representation
are actually the same node in the graph, and
similarly two nodes with the same doubly boxed variable name in their
representation are actually the same node in the graph.  When several
nodes are the same in this sense, all but one of these must have only
boxed or doubly boxed variable names in its representation.

Sometimes it is necessary to indicate that two nodes are the same for
a node that is not the value or default of any variable.
This is done by creating an
\key{expression graph pseudo-variable}\index{pseudo-variable!expression graph}
whose name is a word or separator in curly brackets.  In the example,
\verb|{1}| is such a pseudo-variable name.  Such pseudo-variable names
are always boxed, and never double boxed.

If a node has a label, that is the last line in the node's representation,
and is
immediately below any boxed or doubly boxed variable names.
There are no other lines in the representation.
In the above example, \Glabel{\$5} labels
the node that is the value of the variable \verb|X|.

If a node is the source of arrows in the directed graph,
representations of each arrow appear below any boxed or doubly
boxed variable names in the
representation of the node.  Each arrow representation consists of the
label of the arrow followed by a colon (:) followed by
a representation of the target node of the arrow.  This later
is of course surrounded by [] brackets.

\subsection{Expression Graph Unification}
\label{UNIFICATION}

Informally, expression graphs may be thought of
as expressions of information, and the unification of
two expression graphs is then an expression graph whose information content
is the least upper bound of the information content of each of
the two graphs taken separately.

PCASL uses expression graph unification to represent expression
graphs (\ref{EXPRESSION-GRAPH-REPRESENTATION}).
PCASL also employs a modification of the unification operation
called the matching operation (\ref{MATCHING}).

Unification of two expression graphs
either succeeds and produces a unique expression
graph as its result, or fails and produces no result.  Unification
fails if any graph being unified has a node that is the source of
two or more arrows with the same arrow label.

If X and Y are expression graphs then their unification, Z,
is computed by the following \key{unification algorithm}.
This algorithm assumes that all expression graphs are stored in
a common graph memory that contains nodes and arrows, but
each expression graph has its own distinct set of variables.

\begin{enumerate}

\item
X is replaced by a copy of X, and Y is replaced by a copy
of Y.  Each copy has nodes,
arrows, and variables that are distinct from those
of any other expression graph.  

\item
The set of nodes and arrows of Z is initialized to the union
of the sets of nodes and arrows of X and Y.  Note that since
X and Y are now copies of the original, the nodes and arrows
of X and Y are all now distinct.

\item
There is a set called the \key{merge set}
of node pairs called \skey{merge pair}s that is
used by the algorithm.  This is initialized to the empty set.

\item
The set of variables of Z is initialized to the set of
variables in X.

\item
Each variable V in Y is added to the variable set of Z using
the following method.  If V is not already in the variable set of Z,
it is simply added to that set.  If V is already in the set,
let V in the variable set of Z have value XV and default XD
(because V must have come from X),
and let V in the variable set of Y have value YV and default YD,
where XD and/or YD may be missing.  Then add the merge pair (XV,YV)
to the merge set.  If YD is not missing but XD is missing,
set the default of V in the variable set of Z to equal YD.  If
neither YD or XD is missing, add the merge pair (XD,YD) to the merge set.

\item
For each merge pair (M,N) in the merge set,
perform the following \key{pair merge algorithm}.
Do this recursively until the merge set is empty.

\begin{enumerate}

\item
Remove (M,N) from the merge set.

\item
If M and N are the same node, terminate the pair merge algorithm.

\item
If M and N are labeled nodes with different labels, the merge
algorithm fails.

\item
If either M or N is a labeled node and the other node is the
source of some arrows, the merge algorithm fails.

\item
If either M or N is a node that is the source of two or more arrows
with the same label, the merge algorithm fails.

\item
Replace M by a forwarding pointer that points at N.
This means that henceforth any attempt to reference M will be forwarded
to N, so M is effectively merged with N.

\item
If M is a labeled node with label L, and N is unlabeled, label N with L.

\item
For every arrow sourced at M do the following.
Let the arrow be labeled L and point at target node MT.
If N is not the source of an arrow labeled L,
make a new arrow labeled L pointing from N to MT.
But if N is the source of an arrow labelled L with target NT, add the
merge pair (MT,NT) to the merge set.

\end{enumerate}

\end{enumerate}

Note that the running time of the unification algorithm is bounded by

\[
\begin{array}{c}
T_1(\mbox{number of variables in X} + \mbox{number of variables in Y}) \\
+ \\
T_2(\mbox{number of nodes in X} + \mbox{number of nodes in Y}) \\
\times \\
(\mbox{number of distinct arrow labels in either X or Y})^2
\end{array}
\]

where $T_1$ and $T_2$ are small constant times (typically a few microseconds).
The total number of nodes in X and Y bounds the number of pair merge
operations, and the
last factor bounds the time to form the union of the arrow labels of
any two nodes that are being merged.  The bound just given is typically
a substantial overestimate, and can be improved to:

\[
\begin{array}{c}
T_1(\mbox{number of variables in X} + \mbox{number of variables in Y}) \\
+ \\
T_2(\mbox{number of nodes in X} + \mbox{number of nodes in Y}
				- \mbox{number of nodes in Z}) \\
\times \\
(\mbox{maximum number of arrows sourced at any one node in Z})^2
\end{array}
\]

\subsection{Raw Expression Trees}
\label{RAW-EXPRESSION-TREES}

Raw expressions represent expression trees.  For example, the expression

\begin{center}
\verb|[max x y z]|
\end{center}

represents the expression tree

\begin{center}
\begin{Graph}
    \Gvariable{-ROOT-} \\
    \begin{Gchild}{-ARITY-}
	\Glabel{3} \\
    \end{Gchild} \\
    \begin{Gchild}{0}
	\Glabel{max} \\
    \end{Gchild} \\
    \begin{Gchild}{1}
	\Glabel{x} \\
    \end{Gchild} \\
    \begin{Gchild}{2}
	\Glabel{y} \\
    \end{Gchild} \\
    \begin{Gchild}{3}
	\Glabel{z} \\
    \end{Gchild} \\
\end{Graph}
\end{center}

The raw expression is represented by the root node of an expression tree.
The raw expression head, `\verb|max|', is represented by a node labeled
`\verb|max|' that is the target of an arrow labeled `\verb|0|' from the root.
Here `\verb|0|' is called the \key{head index} of the root node, and is
always the label on an arrow leading to a raw expression head.
The three arguments become targets of arrows from the root labeled
with the \ikey{argument indices}{argument index}
`\verb|1|', `\verb|2|', `\verb|3|'.  Each argument in this case is a single
word, and is represented by a node labeled with that word.
An arrow labeled `\ttkey{-ARITY-}' is added to the root node to point
at a node labeled with the number of arguments in the raw expression.

A second example is the expression

\begin{center}
\verb|[sort x @@ with key weight @@ with comparator <]|
\end{center}

is represented by the expression tree

\begin{center}
\begin{Graph}
    \Gvariable{-ROOT-} \\
    \begin{Gchild}{-ARITY-}
	\Glabel{1} \\
    \end{Gchild} \\
    \begin{Gchild}{0}
	\Glabel{sort} \\
    \end{Gchild} \\
    \begin{Gchild}{1}
	\Glabel{x} \\
    \end{Gchild} \\
    \begin{Gchild}{-QUALIFIER-}
	\begin{Gchild}{-ARITY-}
	    \Glabel{2}
	\end{Gchild} \\
	\begin{Gchild}{0}
	    \Glabel{with}
	\end{Gchild} \\
	\begin{Gchild}{1}
	    \Glabel{key}
	\end{Gchild} \\
	\begin{Gchild}{2}
	    \Glabel{weight}
	\end{Gchild} \\
    \end{Gchild} \\
    \begin{Gchild}{-QUALIFITER-}
	\begin{Gchild}{-ARITY-}
	    \Glabel{2}
	\end{Gchild} \\
	\begin{Gchild}{0}
	    \Glabel{with}
	\end{Gchild} \\
	\begin{Gchild}{1}
	    \Glabel{comparator}
	\end{Gchild} \\
	\begin{Gchild}{2}
	    \Glabel{<}
	\end{Gchild} \\
    \end{Gchild} \\
\end{Graph}
\end{center}

Here each qualifier becomes node that is the target of an arrow labeled
`\ttkey{-QUALIFIER-}'.  The qualifier node has the arrows with the same
labels as the root node: an arrow labeled `\verb|0|' for the
qualifier head, arrows labeled `\verb|1|', `\verb|2|', etc. for the
arguments, and an arrow labeled `\verb|-ARITY-|' for the number of arguments.

Another example is the expression

\begin{center}
\verb|[fill Prefix Matrix <:> Value Postfix ::> Runs]|
\end{center}

is represented by the expression tree

\begin{center}
\begin{Graph}
    \Gvariable{-ROOT-} \\
    \begin{Gchild}{-ARITY-}
	\Glabel{4} \\
    \end{Gchild} \\
    \begin{Gchild}{0}
	\Glabel{fill} \\
    \end{Gchild} \\
    \begin{Gchild}{1}
	\Glabel{Prefix} \\
    \end{Gchild} \\
    \begin{Gchild}{2-3}
	\Glabel{Matrix} \\
    \end{Gchild} \\
    \begin{Gchild}{2-3}
	\Glabel{Value}
    \end{Gchild} \\
    \begin{Gchild}{4}
	\Glabel{Postfix}
    \end{Gchild} \\
    \begin{Gchild}{-REST-}
	\Glabel{Runs}
    \end{Gchild} \\
\end{Graph}
\end{center}

Consecutive arguments separated by the \key{reorder mark} \ttkey{<:>} are
given the an argument index that is actually a range of the form
`$m$\verb|-|$n$', where $m$ is the number of the first of the consecutive
arguments and $n$ is the number of the last.  Thus in our example, arguments
2 and 3 are consecutive arguments separated by \verb|<:>|, so
they both get the argument index `\verb|2-3|'.

The argument after a \key{remainder mark} \ttkey{::>} is
given the special argument index `\ttkey{-REST-}'.  This argument
is not counted in the `\verb|-ARITY-|'.

\subsection{Expression Graph Representation}
\label{EXPRESSION-GRAPH-REPRESENTATION}

Raw expressions can be used to represent expression graphs.  This is
done by defining conversions between expression trees that correspond
directly to raw expressions and arbitrary expression graphs.

There are two kinds of such conversions: explicit and implicit.
In explicit conversion, all graph variable names in the expression trees
are indicated by particular graph variable operations which
by default are `\verb|//|' and `\verb|~~|'.
In implicit conversion, graph variable
operations are used as in explicit conversion,
but in addition all expression tree
leaves that are words beginning with an upper case letter are treated
as graph variable names, as if they were implicitly the single
argument of a `\verb|//|' operation.  Thus `\verb|Fie|' is
treated as if it were `\verb|[// Fee]|'.

In this section we consider conversions between expression trees represented
by raw expressions and expression graphs.  There are two
\skey{graph variable operation}s
involved: the \key{graph variable value operation},%
\index{value operation!graph variable}
which defaults to
\ttkey{//}, and the \key{graph variable default operation},%
\index{default operation!graph variable}
which defaults to \verb|~~|%
\index{~~@{\tt \protect\Tilde\protect\Tilde}}.
In this section we will consider these
two operations in the context of raw expressions, but in non-raw expresssions
these operations are usually the postfix operator \verb|//|
and high precedence infix operators \verb|//| and \verb|~~|.

In addition to the graph variable operations, there are two other
\skey{graph operation}s.  The \key{graph parent operation},%
\index{parent operation!graph}
which defaults to \ttkey{\#\#\#\#},
is used to specify graph nodes that are the source of arrows
with labels that are not head or argument indices.
The \key{graph concatenation operation},%
\index{concatenation operation!graph}
which defaults to \ttkey{++++},
is used to combine graphs by removing the \verb|-ROOT-| variable
from all but the first and unifying (\ref{UNIFICATION}) the resulting
graphs.  This operation may be needed to produce graphs that have disjoint
components.

We have given default names for the three graph operations, but
conversions can optionally be done using different names for these
operations.  In the rest of this document we use the default names.

Using raw expression notation, the following subexpressions are used
to represent single nodes of an expression graph:

\begin{indpar}
\begin{list}{}{}

\item[{\tt [//} {\em variable-name} {\em variable-value}{\tt]}]~\\
Represents the node represented by {\em variable-value} and specifies that
this node is the value of the named expression graph variable.

\item[{\tt [//} {\em variable-name}{\tt]}]~\\
Represents a node with no label that is not the source of any arrow,
and specifies that
this node is the value of the named expression graph variable.

\item[{\em variable-name}]~\\
Ditto, in the case that implicit conversion is being used and
{\em variable-name} is a word beginning with a capital letter.

\item[{\tt [\Tilde\Tilde} {\em variable-name} {\em variable-default} {\tt]}]~\\
Represents a node with no label that is not the source of any arrow,
specifies that this node is the value of the named expression graph variable,
and specifies that the default of the expression graph variable is
the node represented by {\em variable-default}.

\item[{\tt [\#\#\#\#}
      \{ {\em arrow-label} {\em target-value} \}$^\star${\tt]}]~\\
Represents an unlabeled node that is the source of arrows labeled with
the {\em arrow-labels}.  The target of each arrow is represented by
the {\em target-value} raw expression that follows the arrow's
{\em arrow-label}.

\item[{\tt [++++}
      {\em expression-graph} {\em expression-graph}$^\star${\tt]}]~\\
Represents the combination of the {\em expression-graphs}.  The
\verb|-ROOT-| variable is deleted from all {\em expression-graphs} but the
first, and the resulting expression graphs are unified: (\ref{UNIFICATION}).
It is an error if the unification does not produce a unique result.

\end{list}
\end{indpar}

It is possible for several subexpressions of the above form to mention the
same graph variable.  If this happens, all these subexpressions represent the
same node, and the graph variable may be given several values or several
defaults.  If a variable is given several values, these values
are unified (\ref{UNIFICATION} to produce a single variable value, and if 
a variable is given several defaults, these are unified to produce a
single default.  It is an error if any of these value or default
unifications produces does
not produce a single unified value or default.

Some examples of expression trees represented by raw expressions and the
expression graphs they convert to are as follows:

\begin{indpar}
\begin{tabular}{p{2.5in}@{~~~~~}l}

\verb|[z [// x] [// x]]|
&
\begin{Graph}
    \Gvariable{-ROOT-} \\
    \begin{Gchild}{0}
	\Glabel{z} \\
    \end{Gchild} \\
    \begin{Gchild}{1}
	\Gvariable{x} \\
    \end{Gchild} \\
    \begin{Gchild}{2}
	\Gvariable{x} \\
    \end{Gchild} \\
\end{Graph}
\end{tabular}

\medskip

\begin{tabular}{p{2.5in}@{~~~~~}l}
\verb|[z [// x [+ 9 8]] [// x]]|
&
\begin{Graph}
    \Gvariable{-ROOT-} \\
    \begin{Gchild}{0}
	\Glabel{z} \\
    \end{Gchild} \\
    \begin{Gchild}{1}
	\Gvariable{x} \\
	\begin{Gchild}{0}
	    \Glabel{+} \\
	\end{Gchild} \\
	\begin{Gchild}{1}
	    \Glabel{9} \\
	\end{Gchild} \\
	\begin{Gchild}{2}
	    \Glabel{8} \\
	\end{Gchild} \\
    \end{Gchild} \\
    \begin{Gchild}{2}
	\Gvariable{x} \\
    \end{Gchild} \\
\end{Graph}
\end{tabular}

\medskip

\begin{tabular}{p{2.5in}@{~~~~~}l}
\begin{tabular}{l}
\verb|[z [// X foo] X]| \\
implicit conversion
\end{tabular}
&
\begin{Graph}
    \Gvariable{-ROOT-} \\
    \begin{Gchild}{0}
	\Glabel{z} \\
    \end{Gchild} \\
    \begin{Gchild}{1}
	\Gvariable{X} \\
	\Glabel{foo}
    \end{Gchild} \\
    \begin{Gchild}{2}
	\Gvariable{X} \\
    \end{Gchild} \\
\end{Graph}
\end{tabular}

\medskip

\begin{tabular}{p{2.5in}@{~~~~~}l}
\begin{tabular}{l}
\verb|[z [// X foo] X]| \\
explicit conversion
\end{tabular}
&
\begin{Graph}
    \Gvariable{-ROOT-} \\
    \begin{Gchild}{0}
	\Glabel{z} \\
    \end{Gchild} \\
    \begin{Gchild}{1}
	\Gvariable{X} \\
	\Glabel{foo}
    \end{Gchild} \\
    \begin{Gchild}{2}
	\Glabel{X} \\
    \end{Gchild} \\
\end{Graph}
\end{tabular}

\medskip

\begin{tabular}{p{2.5in}@{~~~~~}l}
\begin{tabular}{l}
\verb|[z [~~ X foo] X]| \\
implicit conversion
\end{tabular}
&
\begin{Graph}
    \Gvariable{-ROOT-} \\
    \begin{Gchild}{0}
	\Glabel{z} \\
    \end{Gchild} \\
    \begin{Gchild}{1}
	\Gvariable{X} \\
    \end{Gchild} \\
    \begin{Gchild}{2}
	\Gvariable{X} \\
    \end{Gchild} \\
\end{Graph}
~~~
\begin{tabular}{l}
defaults: \\
~\\
\begin{Graph}
    \Gdefault{X} \\
    \Glabel{foo} \\
\end{Graph}
\end{tabular}

\end{tabular}
\end{indpar}

Here we have represented the default for a variable by putting
the variable name in a double box, as in \Gdefault{X}, on the node
that is the default for the variable.  Note that the
default of a variable must be an expression graph not connected to
the main expression graph or other default graphs.  Note also that
a variable with a default cannot have a regular value that is
anything but an unlabeled node that is not the source of any arrows.


\section{Expression Inference}
\label{EXPRESSION-INFERENCE}

Expression inference is done for three reasons:

\begin{indpar}

{\bf Logic Inference}.\index{logic inference}The expression is
inferred to discover whether the expression is true or false.

{\bf Evaluation Inference}.\index{evaluation inference}The expression is
inferred to discover a code block that is to be used to evaluate the expression.

{\bf Reduction Inference}.\index{reduction inference}The expression is
inferred to discover a reduction of the expression, which is another
expression that is substituted for the original expression.

\end{indpar}

All three forms of inference run an inference algorithm on the
expression and a set of inference rules.  This algorithm matches
the expression to an inference rule, and then generates a new set of
expressions that must be logically inferred in order for the matching
to be a success.

There are four differences between the three kinds of inference.
The first is in which inference rules are checked against the expression
to be inferred.  There are logic rules, evaluation rules, and reduction
rules.  An expression to be logically inferred is matched only against
logic rules; an expression to be evaluated is matched only against
evaluation rules; and an expression to be reduced is matched only
against reduction rules.  Note that if a matching is successful and a new set
expressions is generated to be logically inferred, these secondary
expressions must be logically inferred using only logic rules.

The second difference lies in what is done after inferrence succeeds.
For logic inference, true is returned.  For evaluation inference, a code
block assoicated with the matching rule is evaluated.  For reduction
inference, a reduced expression associated with the reduction rule replaces
the original expression.

The third difference lies in what is done should inferrence fail.
For logic inference, false is returned.  For evaluation inferrence,
the expression evaluates to an error value.
For reduction inference, the original expression is left alone and not
replaced, as if it reduced to itself.

The fourth difference is in what is done should an expression be inferrable
in more than one way.  In logic inference, true is returned.  In evaluation
inference, the code blocks of the separate inferences must be the same
indentical code block, else the expression evaluates to an error value.
For reduction inference, the reduced expressions, an arbitrary
one of the several reduced expressions is used to replace the original
expression; it is up to PCASL programmers to code confluent%
\footnote{`Confluent' means that all ways of recursively reducing
an expression lead to the same final result.}
reduction rules.

\subsection{The Inference Algorithm}
\label{INFERENCE-ALGORITHM}
\label{INFERENCE-RULE}

The \key{inference algorithm} inputs an expression to be inferred
and a set of inference rules.

Rules are collected into contexts.  An expression is
usually inferred in the context in which the expression occurs,
though it is possible to explicitly designate the context in which an
expression is to be inferred.

An \key{inference rule} consists of single head and a possibly empty
set of goals, in the format

\begin{center}
{\em head} \verb|<===| {\em goal}\verb|,| {\em goal}\verb|,|
			\ldots\verb|,| {\em goal}
\end{center}

The head is
an expression that is matched against the expression to be inferred.
A goal is an expression that must be logically inferred to make
inference involving the rule a success.  The intuition is that
the head is true when all the goals are true, and if the head
can be matched against the expression to be inferred, then
the expression to be inferred is true if all the goals can be
logically inferred.

The head may contain variables that receive values during matching.
The goals may contain these same variables which are replaced by
their values before the goals are logically inferred.

Expression inference consists of the following steps.

\begin{enumerate}

\item Reduce the expression.  Initially, all subexpressions of the
expression are marked as reducible.  For logic and evaluation inferences,
the expression itself is considered to be a subexpression, but this is
not done for reduction inferences.  The reduction algorithm
selects a reducible subexpression S that does not contain any reducible
subexpression, and reduces S using reduction inference.  If S is successfully
reduced, it is replace in the original expression by its reduction, and
the reduction and all its subexpressions are marked reducible.  If S is
not successfully reduced, its `reducible mark' is removed, so it becomes
irreducible.  This step is repeated until there are no reducible subexpressions
left (including the entire expression itself).

\item

Match the expression to the head of some inference rule of suitable type
(logic, evaluation, or reduction).  Matching assigns values to variables
in the expression being inferred and to variables in the head of the
inference rule.

\item
Expand the goal expressions of the inference rule whose head matched,
by replacing variables in these expressions that were assigned values
by the matching with their values.

\item
Logically infer each expanded goal.

\end{enumerate}


\subsection{Inference Matching}
\label{INFERENCE-MATCHING}

TBD

Expressions are externally represented as sequences of lexemes and
subexpressions, but internally they are represented as directed graphs whose
arrows are labelled by lexemes from the expression, and
whose nodes are unlabelled.  For example, the expression

\begin{center}
\verb|sort x ascending with key weight with comparator <|
\end{center}

represents the tree

\[
    \verb|sort| \left[
	\begin{array}{l}
        \verb|1| \left[ \verb|x| \right. \\
        \verb|2| \left[ \verb|ascending| \right. \\
        \verb|3| \left[ \verb|with| \left[
	    \begin{array}{l}
	    \verb|1| \left[ \verb|key| \right. \\
	    \verb|2| \left[ \verb|weight| \right. \\
           \end{array} \right. \right. \\
        \verb|4| \left[ \verb|with| \left[
	    \begin{array}{l}
	    \verb|1| \left[ \verb|comparator| \right. \\
	    \verb|2| \left[ \verb|<| \right. \\
           \end{array} \right. \right. \\
       \end{array} \right.
\]

while

\begin{center}
\verb|x = 7 * y + 5|
\end{center}

represents the tree

\[
    \verb|=| \left[
        \begin{array}{l}
	\verb|1| \left[ \verb|x| \right. \\
        \verb|2| \left[ \verb|+| \left[
	    \begin{array}{l}
	    \verb|1| \left[ \verb|*| \left[
	        \begin{array}{l}
		\verb|1| \left[ \verb|7| \right. \\
		\verb|2| \left[ \verb|y| \right. \\
		\end{array} \right. \right. \\
	    \verb|2| \left[ \verb|5| \right. \\
	    \end{array} \right. \right. \\
	\end{array} \right.
\]

and

\begin{center}
\verb|0 < x <= y <= 100|
\end{center}

represents the tree

\[
    \verb|<| \left[
        \begin{array}{l}
	\verb|1| \left[ \verb|0| \right. \\
        \verb|-REST-| \left[ \verb|<=| \left[
	    \begin{array}{l}
	    \verb|1| \left[ \verb|x| \right. \\
	    \verb|-REST-| \left[ \verb|<=| \left[
		\begin{array}{l}
		\verb|1| \left[ \verb|y| \right. \\
		\verb|2| \left[ \verb|100| \right. \\
		\end{array} \right. \right. \\
	    \end{array} \right. \right. \\
	\end{array} \right.
\]

\subsection{Inference Rules}
\label{INFERENCE-RULES}

An \key{inference rule} has the form:

\begin{center}
\key{consequent-expression} \verb|<--|
    \key{condition-expression} \{ \verb|,| {\em condition-expression} \}
\end{center}

An \key{inference step} takes as input one of the reduced goal-expressions
in the goal set and one inference rule,
such that the reduced goal-expression unifies with the
consequent-expression of the inference rule.  The unification variables in the
goal-set and inference-rule are replaced by their values computed
by this unification.  The goal-expression is removed the goal set, and
all the condition-expressions of the inference rule are added to the goal
set.

\subsection{Reduction Rules}
\label{REDUCTION-RULES}

A \key{reduction rule} has the form:

\begin{center}
\key{result-expression} \verb|<==|
\key{consequent-expression} \verb|<--|
    \key{condition-expression} \{ \verb|,| {\em condition-expression} \}
\end{center}

A reduction rule contains within it the equivalent of an inference rule,
which is obtained by removing the result-expression and following \verb|<==|
from the reduction rule.

A subexpression is \key{reduced} by finding for it inferences in which
the first rule applied to the original expression is a reduction rule.
If the result-expressions of all such inferences found unify, their
unification replaces the expression being reduced.  If no inferences
are found, the expression is not replaced.  It is an error
if several inferences are found but their result-expressions fail to unify.

An expression is \key{reduced} by reducing all its subexpressions, smallest
first, until lastly the whole expression is reduced as a subexpression of
itself.

\section{Expression Evaluation}
\label{EXPRESSION-EVALUATION}

\section{Design Notes}

These are some detailed design rules to be incorporated in the language
definition later.

\begin{list}{}{}

\item
{\bf Quotes}.  \verb|`'| are word, phrase, sentence, paragraph quotes.
\verb|[]| are math expression quotes.   Quotes are in left-right pairs
and can be nested.

\item
{\bf Multiple Quotes}.  Quotes can be multiplied $N$ times: e.g.,
\verb|[[...]]|, \verb|[[[...]]]|, etc.  It is possible to begin a quoted
phrase with a quoted phrase by following the initial $N$-left-quote by
space.  E.g., \verb|`` `Hello' 'tis a good word.''|.

\item
{\bf Algebraic Expressions}.
An expression may or may not be algebraic.  Algebraic expressions have
operators that determine structure.  Atoms in these are sequences of
words, numbers, and parenthesized or bracketted subexpressions.

\item
{\bf N-tuples and Flatening}.
The comma operator forms N-tuples, e.g., \verb|(x,y,z)| is a 3-tuple.

Tuples flatten.  It is not possible for a tuple to be a component of
a tuple: instead the tuples are flattened.  E.g., \verb|(x,(y,z),w)|
is the same value as \verb|(x,y,z,w)|.  There is no such thing as a
1-tuple, but any non-tuple behaves like a 1-tuple.

\item
{\bf Blank Algebraic Operators}.
The blank, or missing operator, denotes \verb|*| when it precedes a word,
as in \verb|5x| being equivalent to \verb|5*x|.  When it is between a
preceding integer and a following ratio, it adds the ratio to the integer,
as in \verb|41 1/3|.

\end{list}



\bibliographystyle{plain}
\bibliography{pcasl}

\printindex

\end{document}

