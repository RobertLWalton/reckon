% Calculation and Simulation Total Language Environment (CASTLE)
%
% File:         castle.tex
% Author:       Bob Walton (walton@deas.harvard.edu)
% Date:		See \date below.
  
\documentclass[12pt]{article}

\usepackage{makeidx}
\usepackage{pictex}

\makeindex

\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}
\raggedbottom

\setlength{\unitlength}{1in}

\pagestyle{headings}
\setlength{\parindent}{0.0in}
\setlength{\parskip}{1ex}

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}
\newcommand{\subsubsubsection}[1]{\paragraph[#1]{#1.}}
\newcommand{\subsubsubsubsection}[1]{\subparagraph[#1]{#1.}}

% Begin \tableofcontents surgery.

\newcount\AtCatcode
\AtCatcode=\catcode`@
\catcode `@=11	% @ is now a letter

\renewcommand{\contentsname}{}
\renewcommand\l@section{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\l@table{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\tableofcontents{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}}%
    \item\@starttoc{toc}%
    \end{list}}
\renewcommand\listoftables{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}%
	      }%
    \item\@starttoc{lot}%
    \end{list}}

\catcode `@=\AtCatcode	% @ is now restored

% End \tableofcontents surgery.

\newcommand{\CN}[2]%	Change Notice.
    {\hspace*{0in}\marginpar{\sloppy \raggedright \it \footnotesize
     $^{\mbox{#1}}$#2}}
    % Change notice.

\newcommand{\key}[1]{{\bf \em #1}\index{#1}}
\newcommand{\mkey}[2]{{\bf \em #1}\index{#1!#2}}
\newcommand{\skey}[2]{{\bf \em #1#2}\index{#1}}
\newcommand{\ikey}[2]{{\bf \em #1}\index{#2}}
\newcommand{\ttkey}[1]{{\tt \bf #1}\index{#1@{\tt #1}}}
% < and > do not work for \tt \bf, hence:
\newcommand{\ttnbkey}[1]{{\tt #1}\index{#1@{\tt #1}}}
\newcommand{\ttmkey}[2]{{\tt \bf #1}\index{#1@{\tt #1}!#2}}
\newcommand{\ttfkey}[2]{{\tt \bf #1}\index{#1@{\tt #1}!for #2@for {\tt #2}}}
\newcommand{\ttakey}[2]{{\tt \bf #1}\index{#2@{\tt #1}}}
\newcommand{\ttamkey}[3]{{\tt \bf #1}\index{#2@{\tt #1}!#3}}
\newcommand{\ttindex}[1]{\index{#1@{\tt #1}}}
\newcommand{\ttmindex}[2]{\index{#1@{\tt #1}!#2}}
\newcommand{\emkey}[1]{{\bf \em #1}\index{#1@{\em #1}}}
\newcommand{\emindex}[1]{\index{#1@{\em #1}}}

\newcommand{\opt}{$^!$}

\newcommand{\secref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\stepref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\appref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\pagref}[1]{p\pageref{#1}}

\newcommand{\EOL}{\penalty \exhyphenpenalty}

\newcount\TildeCatcode
\TildeCatcode=\catcode`\~
\catcode`~=12
\newcommand{\Tilde}{~}
\catcode`~=\TildeCatcode

\newcount\CircumflexCatcode
\CircumflexCatcode=\catcode`\^
\catcode`^=12
\newcommand{\Circumflex}{^}
\catcode`^=\CircumflexCatcode

\newcount\BraCatcode
\BraCatcode=\catcode`\<
\catcode`<=12
\newcommand{\Bra}{<}
\catcode`<=\BraCatcode

\newcount\KetCatcode
\KetCatcode=\catcode`\>
\catcode`>=12
\newcommand{\Ket}{>}
\catcode`>=\KetCatcode

\newcount\CurlyBraCatcode
\newcount\CurlyKetCatcode
\newcount\SquareBraCatcode
\newcount\SquareKetCatcode
\CurlyBraCatcode=\catcode`{
\CurlyKetCatcode=\catcode`}
\SquareBraCatcode=\catcode`[
\SquareKetCatcode=\catcode`]

\catcode`{=\SquareBraCatcode
\catcode`}=\SquareKetCatcode
\catcode`[=\CurlyBraCatcode
\catcode`]=\CurlyKetCatcode

\newcommand[\CurlyBra][{]
\newcommand[\CurlyKet][}]

\catcode`{=\CurlyBraCatcode
\catcode`}=\CurlyKetCatcode
\catcode`[=\SquareBraCatcode
\catcode`]=\SquareKetCatcode

\newcommand{\ttbrackets}{%
    \renewcommand{\{}{\CurlyBra}%
    \renewcommand{\}}{\CurlyKet}}

\newlength{\figurewidth}
\setlength{\figurewidth}{\textwidth}
\addtolength{\figurewidth}{-0.40in}

\newsavebox{\figurebox}

\newenvironment{boxedfigure}[1][!btp]%
	{\begin{figure*}[#1]
	 \begin{lrbox}{\figurebox}
	 \begin{minipage}{\figurewidth}

	 \vspace*{1ex}}%
	{
	 \vspace*{1ex}

	 \end{minipage}
	 \end{lrbox}
	 \begin{center}
	 \fbox{\hspace*{0.1in}\usebox{\figurebox}\hspace*{0.1in}}
	 \end{center}
	 \end{figure*}}

\newenvironment{indpar}[1][0.3in]%
	{\begin{list}{}%
		     {\setlength{\itemsep}{0in}%
		      \setlength{\topsep}{0in}%
		      \setlength{\parsep}{1ex}%
		      \setlength{\labelwidth}{#1}%
		      \setlength{\leftmargin}{#1}%
		      \addtolength{\leftmargin}{\labelsep}}%
	 \item}%
	{\end{list}}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{lemma}[theorem]{Lemma}

\begin{document}
        
\title{Calculation and Simulation\\
       Total Language Environment\\[2ex]
       CASTLE\\[2ex]
       (Draft 1a)}

\author{Robert L. Walton\thanks{Copyright 2004 Robert L. Walton.
Permission to copy this document verbatim is granted by the author
to the public.  This document was partly inspired
by teaching courses at Suffolk University, and by the work of Thomas
Cheatham and Stuart Shieber.}}

\date{June 22, 2005}
 
\maketitle

\newpage
\begin{center}
\large \bf Table of Contents
\end{center}

\bigskip

\tableofcontents 

\newpage

\section{Introduction}

This document describes the programming language CASTLE.  CASTLE,
for what its worth, stands for `Calculation and Simulation Total Language
Environment', which hints at its purpose.

CASTLE is designed for naive programmers: that is, for people who may never
be able to program computers well.  It is a simple language with
powerful data types that make it easier to write small programs
that do a variety of tasks a person might want to do.  Generally
the tasks fall into the categories of calculating things (taxes,
probabilities, statistics) or simulating things
(computer games, construction designs, mathematics demonstrations).
Included are:

\begin{center}
\begin{tabular}{l}
Calculations that might be done with a spreadsheet. \\
Drawing pictures. \\
Simulating popular board games and creating new ones. \\
Creating simple computer games, including dialog games. \\
Computing and analyzing documents. \\
Doing elementary algebra and calculus problems. \\
Calculating basic probabilities and statistics. \\
Simulating two and three dimensional objects. \\
Simulating simple electrical, mechanical, chemical, and biological systems.\\
Solving problems in elementary logic. \\
\end{tabular}
\end{center}

There are many computer languages that have some powerful data type that adapts
them for a specific kind of computation.  CASTLE tries to combine these.
Some previous computer languages that have influenced CASTLE, and
the data types they particularly support, are:

\begin{center}
\begin{tabular}{l@{\hspace{0.5in}}l}
Various Spreadsheets		& Spreadsheets \\
Various Data Base Languages	& Data Bases \\
Various Script Languages	& Documents \\
MATLAB				& Matrices \\
Mathematica			& Expressions \\
TCL				& Character Strings and Lists \\
Lisp				& Words and Phrases \\
PROLOG				& Logical Expressions \\
\end{tabular}
\end{center}

CASTLE is \underline{not} designed to be a computer-efficient language.
It is designed to be person-efficient, and to do small calculations
rapidly enough with inexpensive modern computers.

\section{Remarks}

CASTLE was created as an answer to the question: what programming language
should you teach beginning programming students who do not have the talent
or inclination to become good programmers?  The initial answer, that it does
not matter provided you implement some powerful types of data in the
language you choose, has a flaw.  The flaw is that without the right powerful
data types, the language will be useless to the students after the course
is over.  So what is needed is a programming language that will be useful
to students after a first course in programming, and the essence of
such a language is the integration within it of many powerful and useful
data types.

The basic principles of the CASTLE design were developed
by the author while teaching the intended customers of
CASTLE.\footnote{Specifically, while teaching CS121 at Suffolk University
using the C programming language.}
The language should have as few parts as possible, to cut down
on the amount of detail that must be remembered to use the language, but
conversely, there is no limit to the conceptual complexity of any well-used
part.\footnote{There was no problem teaching recursion, but it was better
not to each many different looping constructs.}
The language should have powerful data types, well integrated into
the syntax of the language.  As much as possible, statement executions
in the language should have visible effect.

The current version of CASTLE is not stable, because it has not been
implemented, and because, unlike most programming languages, CASTLE
has lots of subtle important interactions between its various features.  The
hope is that with implementation and experimentation, a stable sensible
version of CASTLE, integrating all its data types, can be achieved.

\section{Overview}

CASTLE has two major kinds of data: expressions and blocks.  Numbers are
the simplest expressions.  More complex expressions are math
expressions or document expressions.  A block is a set of variables
and an piece of code.  Each variable can have a value, which is an expression.
The code contains expressions that can be evaluated under appropriate
circumstances to produce values for variables.

In CASTLE an `object' is a block that has an associated `type'.  For
example, there may be an object `george' with type `person'.  All blocks
of the same type have the same code, and many of the same variables,
but typically have different variable values.

You can use CASTLE as a calculator by typing into it expressions to
be evaluated, assignments of values to variables, and definitions
of functions and predicates.  Some examples involving numbers are:

\begin{indpar}\begin{verbatim}
> 9
9
> 9 + 8
17
> x = 9
9
> y = 9 + 8
17
> x + y
26
\end{verbatim}\end{indpar}

Here the `\verb|> |' at the beginning of some lines is the CASTLE \key{prompt}
that tells you its OK to input an expression to be evaluated.

At somewhat the opposite extreme from numbers are words, phrases, sentences,
and paragraphs.  You can calculate with these `\skey{document expression}s'.

\begin{indpar}
\verb|> g = `hello'| \\
\verb|`|hello\verb|'| \\
\verb|> `<<g>> there'| \\
\verb|`|hello there\verb|'| \\
\verb|> z = ``I thought he said `<<<g>>>'.''| \\
\verb|``|I thought he said `hello'.\verb|''| \\
\verb/> notice = ``|This document is meant to be read./ \\
\verb/+            |Reading this document is good, but.../ \\
\verb/+            |<<z>>.''/ \\
\verb|``|This document is meant to be read. \\
\verb|  |Reading this document is good, but\ldots \\
\verb|  |I thought he said `hello'.\verb|''| \\
\verb|> `When you add <<x>> and <<y>> you get <<x+y>>.'| \\
\verb|`|When you add 9 and 17 you get 26.\verb|'|
\end{indpar}

Modern math computes with expressions, and not just numbers.
You can compute with \skey{math expression}s in CASTLE.

\begin{indpar}
\verb|> f = {10x^2 - 3.67x - 0.04}| \\
\verb|{|$10x^2-3.67x-0.04$\verb|}| \\
\verb|> h = (- 0.96 + 0.67x) in x| \\
\verb|{|$-0.96+0.67x$\verb|}| \\
\verb|> (f + h) in x| \\
\verb|{|$10x^2-3x-1$\verb|}| \\
\verb|> solve (f + h = 0) for x| \\
\verb|{|$x = (-0.2, 0.5)$\verb|}| \\
\verb|> (f + h) at (x = (3, 4, 5))| \\
\verb|(78.95, 145.28, 231.61)| \\
\verb|> g = {integral (x ^ 2 dx)}| \\
\verb|{|$\int x^2 dx$\verb|}| \\
\verb|> simplify g| \\
\verb|{|$\frac{1}{3} x^3$\verb|}| \\
\verb|> v = g from (x = 1) to (x = 5)| \\
\verb|41 1/3| \\
\verb|> out = `The value of {<<<g>>> from (x = 1) to (x = 5)} is <<v>>.'| \\
\verb|`|The value of $\int_{x = 1}^{x = 5} x^2 dx$ is $41\frac{1}{3}$.\verb|'| \\
\verb|> raw out| \\
\verb|[-SENTENCE- the value of| \\
\verb|            {(integral (x ^ 2 * dx)) from (x = 1) to (x = 5)}| \\
\verb|            is 124/3 .]|
\end{indpar}

[TBD: Can you overload \verb|{}| as both math expression brackets
and code brackets?]

Another kind of datum you can compute with in CASTLE is
the block.  A \key{block} contains a set of variables, each of which
can have a value which is an expression.  A block can also
have code, which contains expressions that are evaluated under appropriate
circumstances to produce values for the block's variables.

In CASTLE an \key{object} is a block that has an associated \key{type}.  For
example, there may be an object named `Jack' with type `person'.  All objects
of the same type have the same code, and many of the same variables,
but typically have different variable values.  For example:

\begin{indpar}
\verb|> a person {| \\
\verb|+     name = `Jack'| \\
\verb|+     weight = 123 lb| \\
\verb|+     height = 5' 9"| \\
\verb|+     age = 23 yr 2 mo }| \\
\begin{tabular}{|r|l|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf type} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000000 & person & Jack & \tt 123 lb & \tt 5' 9" & \tt 23 yr 2 mo \\
\hline
\end{tabular} \\
\verb|> a person {| \\
\verb|+     name = `Jill'| \\
\verb|+     weight = 110 lb| \\
\verb|+     height = 5' 7"| \\
\verb|+     age = 21 yr 8 mo }| \\
\begin{tabular}{|r|l|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf type} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000001 & person & Jill & \tt 110 lb & \tt 5' 7" & \tt 21 yr 8 mo \\
\hline
\end{tabular} \\
\verb|> all persons| \\
\begin{tabular}{|r|l|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf type} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000000 & person & Jack & \tt 123 lb & \tt 5' 9" & \tt 23 yr 2 mo \\
\tt @1000001 & person & Jill & \tt 110 lb & \tt 5' 7" & \tt 21 yr 8 mo \\
\hline
\end{tabular} \\
\verb|> the person Jack| \\
\begin{tabular}{|r|l|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf type} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000000 & person & Jack & \tt 123 lb & \tt 5' 9" & \tt 23 yr 2 mo \\
\hline
\end{tabular} \\
\verb|> the person named Jack's height| \\
\verb|5' 9"| \\
\verb|> the weight of the person named Jack| \\
\verb|123 lb| \\
\verb|> @1000001| \\
\begin{tabular}{|r|l|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf type} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000001 & person & Jill & \tt 110 lb & \tt 5' 7" & \tt 21 yr 8 mo \\
\hline
\end{tabular} \\
\verb|> the weight of @1000001| \\
\verb|110 lb|
\end{indpar}

It is possible to add code to a type such as `{\tt person}'.  This has
the affect of adding the code to all blocks that are objects of that type.
For example:

\begin{indpar}
\verb|> for every person <-- {| \\
\verb|+     body-mass-index = 703.06958 * weight in lbs| \\
\verb|+                     / (height in inches)^2 }| \\
\verb|> all persons| \\
\begin{tabular}{|r|l|l|r|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf type} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} &
\multicolumn{1}{|c|}{\bf \shortstack{body-mass-\\index}} \\
\hline
\tt @1000000 & person & Jack
	     & \tt 123 lb & \tt 5' 9" & \tt 23 yr 2 mo & \tt 18.163738 \\
\tt @1000001 & person & Jill
	     & \tt 110 lb & \tt 5' 7" & \tt 21 yr 8 mo & \tt 17.228258 \\
\hline
\end{tabular}
\end{indpar}

One can use definitions to define expressions that compute values:

\begin{indpar}
\verb|> sum from X through Y <-- integer X, integer Y {| \\
\verb|+     `Sum of integers from X through Y.'| \\
\verb|+     if ( X > Y ):| \\
\verb|+         value = 0| \\
\verb|+     else:| \\
\verb|+         value = X + sum (X+1) through Y }| \\
\verb|> sum from 5 through 10| \\
\verb|45| \\
\verb|> all (sums from X through Y)| \\
\begin{tabular}{|r|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf X} &
\multicolumn{1}{|c}{\bf Y} &
\multicolumn{1}{|c|}{\bf value} \\
\hline
\tt @1000002 & \tt 5	& \tt	10	& \tt 45 \\
\tt @1000003 & \tt 6	& \tt	10	& \tt 40 \\
\tt @1000004 & \tt 7	& \tt	10	& \tt 34 \\
\tt @1000005 & \tt 8	& \tt	10	& \tt 27 \\
\tt @1000006 & \tt 9	& \tt	10	& \tt 19 \\
\tt @1000007 & \tt 10	& \tt	10	& \tt 10 \\
\tt @1000008 & \tt 11	& \tt	10	& \tt 0 \\
\hline
\end{tabular} \\
\verb|> sum from 1 through 2| \\
\verb|3| \\
\verb|> all (sums from X through Y)| \\
\begin{tabular}{|r|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf X} &
\multicolumn{1}{|c}{\bf Y} &
\multicolumn{1}{|c|}{\bf value} \\
\hline
\tt @1000002 & \tt 5	& \tt	10	& \tt 45 \\
\tt @1000003 & \tt 6	& \tt	10	& \tt 40 \\
\tt @1000004 & \tt 7	& \tt	10	& \tt 34 \\
\tt @1000005 & \tt 8	& \tt	10	& \tt 27 \\
\tt @1000006 & \tt 9	& \tt	10	& \tt 19 \\
\tt @1000007 & \tt 10	& \tt	10	& \tt 10 \\
\tt @1000008 & \tt 11	& \tt	10	& \tt 0 \\
\tt @1000009 & \tt 1	& \tt	2	& \tt 3 \\
\tt @1000010 & \tt 2	& \tt	2	& \tt 2 \\
\tt @1000011 & \tt 3	& \tt	2	& \tt 0 \\
\hline
\end{tabular}
\end{indpar}

Executions can be examined in detail, because
when an expression is computed, the block that computes it is remembered
for some time.  However, as memory is finite, eventually these
computations are forgotten as they can always be regenerated if
needed.

The sum above was computed by recursion: to compute the sum of 5 through 10
one adds 5 to the sum of 6 through 10.  One can also compute sums by
iteration.

\begin{indpar}
\verb|> sum from X through Y <-- integer X, integer Y {| \\
\verb|+     `Sum of integers from X through Y.'| \\
\verb|+     first sum = 0| \\
\verb|+     if ( X <= Y ):| \\
\verb|+         next sum = sum + X| \\
\verb|+         next X = X + 1| \\
\verb|+     else:| \\
\verb|+         value = sum }| \\
\verb|> sum from 5 through 10| \\
\verb|45| \\
\verb|> all (sums from X through Y)| \\
\begin{tabular}{|r|r|r|r|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf previous} &
\multicolumn{1}{|c}{\bf next} &
\multicolumn{1}{|c}{\bf X} &
\multicolumn{1}{|c}{\bf Y} &
\multicolumn{1}{|c}{\bf sum} &
\multicolumn{1}{|c|}{\bf value} \\
\hline
\tt @1000012 &              & \tt @1000013
	     & \tt 5	& \tt 10   & \tt 0	& \\
\tt @1000013 & \tt @1000012 & \tt @1000014
	     & \tt 6	& \tt 10   & \tt 5	& \\
\tt @1000014 & \tt @1000013 & \tt @1000015
	     & \tt 7	& \tt 10   & \tt 11	& \\
\tt @1000015 & \tt @1000014 & \tt @1000016
	     & \tt 8	& \tt 10   & \tt 18	& \\
\tt @1000016 & \tt @1000015 & \tt @1000017
	     & \tt 9	& \tt 10   & \tt 26	& \\
\tt @1000017 & \tt @1000016 & \tt @1000018
	     & \tt 10	& \tt 10   & \tt 35	& \\
\tt @1000018 & \tt @1000017 &
	     & \tt 11	& \tt 10   & \tt 45	& \tt 45 \\
\hline
\end{tabular}
\end{indpar}

One can also iterate over data.

\begin{indpar}
\verb|> average weight of X <-- list X of persons {| \\
\verb|+     first count = 0| \\
\verb|+     first sum = 0| \\
\verb|+     if X = ():| \\
\verb|+         if count = 0:| \\
\verb|+             value = error `Cannot average 0 things.'| \\
\verb|+         else:| \\
\verb|+             value = sum / count| \\
\verb|+     else:| \\
\verb|+         next count = count + 1| \\
\verb|+         next sum = sum + the weight of (first X)| \\
\verb|+         next X = rest X }| \\
\verb|> average weight of (all persons)| \\
\verb|116.5 lbs|
\end{indpar}

In case you wonder how some of the above works, here are some hints.

CASTLE tends to ignore word endings: thus `{\tt person}' and
`{\tt persons}' are to CASTLE the same word.
CASTLE can even be told that `{\tt person}'
and `{\tt people}' are the same word.
`{\tt Jack's}', on the other hand, is treated an abbreviation
of two separate words `{\tt Jack}' and `{\tt 's}', where `{\tt 's}' is
a separate word by itself.

Expressions are just strings of words and subexpressions.  Subexpressions
must be parenthesized unless they consist of a single word, or unless
they are delimited by operators.

Lists of values can be stored in \skey{list}s, which are computed by comma
separated lists in parentheses.  Thus

\begin{indpar}
\verb|> (the person named Jill, the person named Jack)| \\
\begin{tabular}{|r|l|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf type} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000001 & person & Jill & \tt 110 lb & \tt 5' 7" & \tt 21 yr 8 mo \\
\tt @1000000 & person & Jack & \tt 123 lb & \tt 5' 9" & \tt 23 yr 2 mo \\
\hline
\end{tabular} \\
\verb|> (the person named Jack, the person named Jill)| \\
\begin{tabular}{|r|l|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf type} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000000 & person & Jack & \tt 123 lb & \tt 5' 9" & \tt 23 yr 2 mo \\
\tt @1000001 & person & Jill & \tt 110 lb & \tt 5' 7" & \tt 21 yr 8 mo \\
\hline
\end{tabular} \\
\verb|> raw (all persons)| \\
\verb|(the person named Jack, the person named Jill)| \\
\verb|> really raw (all persons)| \\
\verb|(@1000000, @1000001)|
\end{indpar}

The `{\tt raw}' form of a value represents the value
as you could input it in a way that reveals its internal structure.  Thus
`{\tt all persons}' denotes the list of all persons, and it is the list
structure that is revealed, not the structure of the elements of the list.

`{\tt the person named Jack}' is a printed representation of the
internal name of an object.  Such printed representations are chosen
automatically from the set of all possible representations, which
in this case include `{\tt the person weighing 123 lbs}' and
`{\tt the person named Jack weighing 123 lbs}'.

The `{\tt really raw}' form of a value identifies objects by their IDs.

A single non-list value is equivalent to a list with one element.
Lists cannot have other lists as elements; instead attempts to
compute such lists are \key{flattened}:

\begin{indpar}
\verb|> x = (1,(2,3),4)| \\
\verb|(1,2,3,4)| \\
\verb|> first x| \\
\verb|1| \\
\verb|> rest x| \\
\verb|(2,3,4)| \\
\verb|> rest (rest x)| \\
\verb|(3,4)| \\
\verb|> rest (rest (rest x))| \\
\verb|4| \\
\verb|> rest 4| \\
\verb|()|
\end{indpar}

For this reason CASTLE lists are sometimes called `\skey{flat list}s'.

CASTLE has many different kinds of quotes or brackets.  Some of these,
\verb|{|\ldots\verb|}|, \verb|`|\ldots\verb|'|, and \verb|{{|\ldots\verb|}}|,
turn evaluation off, while \verb|<<|\ldots\verb|>>|,
\verb|<<<|\ldots\verb|>>>|, \verb|<<<<|\ldots\verb|>>>>|, etc.
turn evaluation on.
Some,
\verb|`|\ldots\verb|'| and \verb|{{|\ldots\verb|}}|,
turn recognition of operators (e.g., \verb|+| and \verb|=|) off, while others,
\verb|<<|\ldots\verb|>>| and \verb|{|\ldots\verb|}|,
turn recognition of operators on.  Quotes --
\verb|`|\ldots\verb|'|,
\verb|``|\ldots\verb|''|, \verb|```|\ldots\verb|'''|, etc.~--
also do other things, like insert implicit operations
(e.g., \verb|-SENTENCE-|).

CASTLE can store information as expressions.  For example:

\begin{indpar}
\verb|> (a person named `Jack') is husband of (a person named `Jill') <--| \\
\verb|> Y is wife of X <-- X is husband of Y|
\end{indpar}

Here `\verb|<--|' means `is asserted' or `is asserted if'.
All the assertions that have been made can be queried:

\begin{indpar}
\verb|> (a person named `Jill') is wife of (a person named `Jack') ?| \\
\verb|true| \\
\verb|> (a person named `Jack') is wife of (a person named `Jill') ?| \\
\verb|false| \\
\verb|> (a person named X) is wife of (a person named `Jack') ?| \\
\verb|X = `|Jill\verb|'| \\
\verb|> X is wife of (a person named `Jack') ?| \\
\verb|X = (a person named `Jill')| \\
\verb|> @1000001 is wife of (a person named `Jack') ?| \\
\verb|true| \\
\verb|> @1000001 = (a person named `Jill') ?| \\
\verb|true| \\
\verb|> @1000001 = (a person named `Jack') ?| \\
\verb|false|
\end{indpar}

CASTLE supports pictorial data
that are expressions displayed as pictures:

\begin{indpar}
\verb|> x = {circle 0.4}| \\
\begin{picture}(0.4,0.4)
\put(0.2,0.2){\circle{0.4}}
\end{picture} \\
\verb|> y = {rectangle (0.4,0.2)}| \\
\begin{picture}(0.4,0.2)
\put(0,0){\framebox(0.4,0.2){}}
\end{picture} \\
\verb|> z = {(circle 0.4) labeled `Jack'}| \\
\begin{picture}(0.4,0.4)
\put(0.2,0.2){\circle{0.4}}
\put(0.0,0.0){\makebox(0.4,0.4){Jack}}
\end{picture} \\
\verb|> {(<<x>> right of <<y>>) above <<z>>}| \\
\begin{picture}(0.8,0.8)
\put(0.6,0.6){\circle{0.4}}
\put(0.0,0.5){\framebox(0.4,0.2){}}
\put(0.4,0.2){\circle{0.4}}
\put(0.2,0.0){\makebox(0.4,0.4){Jack}}
\end{picture} \\
\verb|> {row(<<x>>,<<y>>,<<z>>)}| \\
\begin{picture}(1.4,0.4)
\put(0.2,0.2){\circle{0.4}}
\put(0.5,0.1){\framebox(0.4,0.2){}}
\put(1.2,0.2){\circle{0.4}}
\put(1.0,0.0){\makebox(0.4,0.4){Jack}}
\end{picture} \\
\verb|> p = {column (row(<<x>>,<<y>>,<<z>>), row(<<z>>,<<y>>,<<x>>))}| \\
\begin{picture}(1.4,0.9)
\put(0.2,0.7){\circle{0.4}}
\put(0.5,0.6){\framebox(0.4,0.2){}}
\put(1.2,0.7){\circle{0.4}}
\put(1.0,0.5){\makebox(0.4,0.4){Jack}}
\put(1.2,0.2){\circle{0.4}}
\put(0.5,0.1){\framebox(0.4,0.2){}}
\put(0.2,0.2){\circle{0.4}}
\put(0.0,0.0){\makebox(0.4,0.4){Jack}}
\end{picture} \\
\verb|> raw x| \\
\verb|{circle 0.4}| \\
\verb|> raw p| \\
\verb|{column (row (circle 0.4,| \\
\verb|              rectangle (0.4,0.2),| \\
\verb|              (circle 0.4) labeled `Jack'),| \\
\verb|         row ((circle 0.4) labeled `Jack',| \\
\verb|              rectangle (0.4,0.2),| \\
\verb|              circle 0.4))}|
\end{indpar}

You can also change how an expression is displayed.

\begin{indpar}
\newlength{\ovalraise}
\setlength{\ovalraise}{-0.1in}
\addtolength{\ovalraise}{0.8ex}
\verb|> display ( P ) <-- person ( P ) has name ( X ) {| \\
\verb|>     value = {oval (0.4,0.2) labeled <<X>>} }| \\
\verb|> (a person named `Jack')| \\
\begin{picture}(0.4,0.2)
\put(0.2,0.1){\oval(0.4,0.2)}
\put(0.0,0.0){\makebox(0.4,0.2){Jack}}
\end{picture} \\
\verb|> ``(a person named `Jill') is wife of (a person named `Jack')''| \\
\verb|``|
\raisebox{\ovalraise}{\begin{picture}(0.4,0.2)
\put(0.2,0.1){\oval(0.4,0.2)}
\put(0.0,0.0){\makebox(0.4,0.2){Jill}}
\end{picture}}
{is the wife of}
\raisebox{\ovalraise}{\begin{picture}(0.4,0.2)
\put(0.2,0.1){\oval(0.4,0.2)}
\put(0.0,0.0){\makebox(0.4,0.2){Jack}}
\end{picture}}
\verb|''|
\end{indpar}

Displays can be used to make demonstrations:

\begin{indpar}
\verb|> for every demo {| \\
\verb|>     on a demo with angle X <-- {| \\
\verb|+         angle = X } }| \\
\verb|> x = a demo with angle 30 degrees| \\
\begin{tabular}{|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf type} &
\multicolumn{1}{|c|}{\bf angle} \\
\hline
\tt @1000043 & demo & 30 degrees \\
\hline
\end{tabular} \\
\verb|> for every demo {| \\
\verb|+     on update THIS to X <-- {| \\
\verb|+         next angle = X }| \\
\verb|+     on increment THIS by X <-- {| \\
\verb|+         next angle = angle + X } }| \\
\verb|> update x to 40 degrees| \\
\begin{tabular}{|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf type} &
\multicolumn{1}{|c|}{\bf angle} \\
\hline
\tt @1000044 & demo & 40 degrees \\
\hline
\end{tabular} \\
\verb|> increment x by 5 degrees| \\
\begin{tabular}{|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf type} &
\multicolumn{1}{|c|}{\bf angle} \\
\hline
\tt @1000045 & demo & 45 degrees \\
\hline
\end{tabular} \\
\verb|> display ( D ) <-- demo ( D ) with angle ( X ) {| \\
\verb|+     c = {circle 1.0 dotted center (0.0,0.0)}| \\
\verb|+     x-axis = {arrow from (-0.75,0.0) to (0.75,0.0)}| \\
\verb|+     y-axis = {arrow from (0.0,-0.75) to (0.0,0.75)}| \\
\verb|+     line = {line from (0.0,0.0) to <<(0.5*cos X, 0.5*sin X)>>}| \\
\verb|+     arc = {arc-arrow from (0.7,0.0) to <<(0.3*cos X, 0.3*sin X)>>}| \\
\verb|+     theta = {Greek th}| \\
\verb|+     value = {column (| \\
\verb|+                overlap (| \\
\verb|+                  <<c>>,| \\
\verb|+                  <<x-axis>> labeled `X Axis',| \\
\verb|+                  <<y-axis>> labeled `Y Axis',| \\
\verb|+                  <<line>>,| \\
\verb|+                  <<arc>> labeled `<<theta>>' ),| \\
\verb|+                label `Depiction of Angle <<theta>>' ) } } | \\
\verb|> x| \\
\begin{picture}(4.0,1.9)
\put(1.0,0.95){\qbezier[40](0.5,0.0)(0.46,0.46)(0.0,0.5)}
\put(1.0,0.95){\qbezier[40](0.0,0.5)(-0.46,0.46)(-0.5,0.0)}
\put(1.0,0.95){\qbezier[40](-0.5,0.0)(-0.46,-0.46)(0.0,-0.5)}
\put(1.0,0.95){\qbezier[40](0.0,-0.5)(0.46,-0.46)(0.5,0.0)}
\put(1.0,0.95){
    \qbezier[250](0.3,0.0)(0.3,0.124264)(0.212132,0.212132)
    \put(0.212132,0.212132){\vector(-1,1){0.00}}
    \put(0.31,0.1){$\theta$}}
\put(1.0,0.2){\vector(0,1){1.5}}
\put(0.0,1.7){\makebox(2.0,0.2){Y Axis}}
\put(0.25,0.95){\vector(1,0){1.5}}
\put(1.80,0.85){\makebox(2.0,0.2)[l]{X Axis}}
\put(1.0,0.95){\line(1,1){0.353553}}
\put(0.0,0.0){\makebox(2.0,0.2){Depiction of Angle $\theta$}}
\end{picture} \\
\verb|> show x label {Greek th}| \\
See $\theta$ \\
\verb|> update x to 40 degrees| \\
See $\theta$ \\
\verb|> increment x by -5 degrees| \\
See $\theta$
\end{indpar} 

In this example we first define a `constructor'
of the form `{\tt a demo with angle X}' to make new {\tt demo} objects,
and then we define two `methods', namely `{\tt update THIS to X}' and
`{\tt in\-cre\-ment THIS by X}', to change a {\tt demo} object.  Changing
a {\tt demo} object is like iterating a loop to make a new object.

Next we define how to display a {\tt demo} object.  Then we use the
`{\tt show x label {\ttbrackets \{Greek th\}}}' command
to cause the {\tt demo} object value of {\tt x}
to be displayed in a separate window labeled `$\theta$'.
Every time this {\tt demo} object
changes, the $\theta$ window is updated, and every time the object
is to be printed, `See $\theta$' is printed instead.


TBD: example of a simple game.

\begin{boxedfigure}

\begin{verbatim}
for every board:
    on a board of dimension S <--:
        `make a board of size SxS'
        size = S
        array square size (S,S) initially `empty'
        `allowed vessels have lengths 2 (destroyer), 3 (cruiser),
         4 (battleship); vessels(L) is number of length L'
        array vessels size 5 initially 0
        `maximum-vessels(L) is maximum number of vessels of
         length L'
        array maximum-vessels size 5 initially 0
        maximum-vessels(2) = 5
        maximum-vessels(3) = 2
        maximum-vessels(1) = 1
	`hit(I,J) is true iff shell has hit square (I,J)'
        array hit size (S,S) initially `false'
\end{verbatim}

\caption{Code for the Battleship Game, Part I}
\label{CODE-FOR-BATTLESHIP-1}
\end{boxedfigure}

\begin{boxedfigure}

\begin{verbatim}
    on vessel from (I1,J1) to (I2,J2) <--:
        `draw a vessel with endpoints (I1,J1) and (I2,J2)'
        dI = I1 - I2
        dJ = J1 - J2
        if (     abs(dI) != abs(dJ)
             AND dI != 0 AND dJ != 0 ):
            value = error `illegal vessel, not horizontal or vertical
                           or diagonal'

        length = max ( abs(dI), abs(dJ) )
        if ( length < 2 ):
            value = error `illegal vessel, too short'
        else if ( length > 4 ):
            value = error `illegal vessel, too long'
        if ( vessels(length) >= maximum-vessels(length) ):
            value = error `illegal vessel, too many of that type'

	`set squares occupied by vessel to length of vessel'
        sI = sign dI
        sJ = sign dJ
        for (I,J) = (I1,J1) to (I2,J2) step (sI,sJ):
            if ( square (I,J) != `empty' ):
                value = error `illegal vessel, overlaps an
                               existing vessel'
        for (I,J) = (I1,J1) to (I2,J2) step (sI,sJ):
            square (I,J) = length
\end{verbatim}

\caption{Code for the Battleship Game, Part II}
\label{CODE-FOR-BATTLESHIP-2}
\end{boxedfigure}

The rest of this document is a reference manual for CASTLE.


\section{Lexical Scans}

A CASTLE program is a sequence of characters which is scanned from
left to right to produce a sequence of \skey{pre-lexeme}s.  The sequence
of pre-lexemes is then scanned from left to right to produce
a sequence of \skey{lexeme}s.  The sequence of lexemes may then be subject to
a left to right \key{lexical parsing} scan to produce a final set of lexemes
that is input for expression parsing.  Lexical parsing is suppressed in
certain contexts, e.g., within quotes.

For example, the input `{\tt x = 7' 5.5";}' (here the `' quotes are
\underline{not} part of the input) contains the pre-lexeme
`{\tt 5.5";}', which is split into 3 lexemes `{\tt 5.5 " ;}', and
then during lexical parsing `{\tt *}' operators are inserted before
or after units, and `{\tt +}' operators are inserted
between consecutive numbers with different units, and parentheses
are inserted around sequences of consecutive numbers with different units,
to produce from the input the following string of 12 lexemes:

\begin{center}
\tt x = ( 7 * ' + 5.5 * " ) ;
\end{center}

\subsection{Pre-Lexemes}

\ikey{Pre-lexemes}{pre-lexeme} are defined as follows:

\begin{indpar}
\key{pre-lexeme}
	\begin{tabular}[t]{rl}
	::= & \key{pre-word} \\
	$|$ & \key{opening-mark} \\
	$|$ & \key{closing-mark} \\
	$|$ & \key{format-separator} \\
	$|$ & \key{white-space}
	\end{tabular}
	\\[1ex]
\key{pre-word} ::= {\em word-character} {\em word-character}\,$^\star$ \\[1ex]
\key{word-character} \begin{tabular}[t]{rl}
                       ::= & {\em letter} $|$ {\em digit} \\
		       $|$ &    \verb|+|%
		             $|$\verb|-|%
		             $|$\verb|*|%
		             $|$\verb|/|%
		             $|$\verb|\|%
		             $|$\verb|~|%
		             $|$\verb|@|%
		             $|$\verb|#|%
		             $|$\verb|$|%
		             $|$\verb|%|%
		             $|$\verb|^|%
		             $|$\verb|&|%
		             $|$\verb|=|%
		             $|$\verb/|/%
		             $|$\verb|<|%
		             $|$\verb|>|%
		             $|$\verb|_|%
		             $|$\verb|"|%
		             $|$\verb|`|%
		             $|$\verb|'|%
		             $|$\verb|!|%
		             $|$\verb|?|%
			     $|$\verb|;|%
			     $|$\verb|:|%
			     $|$\verb|,|%
		             $|$\verb|.|
			\end{tabular}\\[1ex]
\key{letter} ::= {\em lower-case-letter} $|$ {\em upper-case-letter} \\[1ex]
\key{lower-case-letter} ::=    \verb|a|%
			    $|$\verb|b|%
			    $|$\verb|c|%
			    $|$\verb|d|%
			    $|$\verb|e|%
			    $|$\verb|f|%
			    $|$\verb|g|%
			    $|$\verb|h|%
			    $|$\verb|i|%
			    $|$\verb|j|%
			    $|$\verb|k|%
			    $|$\verb|l|%
			    $|$\verb|m|%
			    $|$\verb|n|%
			    $|$\verb|o|%
			    $|$\verb|p|%
			    $|$\verb|q|%
			    $|$\verb|r|%
			    $|$\verb|s|%
			    $|$\verb|t|%
			    $|$\verb|u|%
			    $|$\verb|v|%
			    $|$\verb|w|%
			    $|$\verb|x|%
			    $|$\verb|y|%
			    $|$\verb|z|
			    \\[1ex]
\key{upper-case-letter} ::=    \verb|A|%
			    $|$\verb|B|%
			    $|$\verb|C|%
			    $|$\verb|D|%
			    $|$\verb|E|%
			    $|$\verb|F|%
			    $|$\verb|G|%
			    $|$\verb|H|%
			    $|$\verb|I|%
			    $|$\verb|J|%
			    $|$\verb|K|%
			    $|$\verb|L|%
			    $|$\verb|M|%
			    $|$\verb|N|%
			    $|$\verb|O|%
			    $|$\verb|p|%
			    $|$\verb|Q|%
			    $|$\verb|R|%
			    $|$\verb|S|%
			    $|$\verb|T|%
			    $|$\verb|U|%
			    $|$\verb|V|%
			    $|$\verb|W|%
			    $|$\verb|X|%
			    $|$\verb|Y|%
			    $|$\verb|Z|
			    \\[1ex]
\key{digit} ::=    \verb|0|%
		$|$\verb|1|%
		$|$\verb|2|%
		$|$\verb|3|%
		$|$\verb|4|%
		$|$\verb|5|%
		$|$\verb|6|%
		$|$\verb|7|%
		$|$\verb|8|%
		$|$\verb|9|
		\\[1ex]
\key{opening-mark} ::=     \verb|(|
	       	       $|$ \verb|[|
	       	       $|$ \verb|{|
	       	       $|$ {\em opening-quote}
	       	       $|$ {\em opening-angle}
	       	       \\[1ex]
\key{closing-mark} ::=     \verb|)|
	       	       $|$ \verb|]|
	       	       $|$ \verb|}|
	       	       $|$ {\em closing-quote}
	       	       $|$ {\em closing-angle}
	       	       \\[1ex]
\key{opening-quote} \begin{tabular}[t]{rl}
		     ::= & {\em opening-quote-character}
		           {\em opening-quote-character}\,$^\star$ \\
		     \end{tabular}
		     \\[1ex]
\key{opening-quote-character} ::= \verb|`| \\[1ex]
\key{closing-quote} \begin{tabular}[t]{rl}
		     ::= & {\em closing-quote-character}
		           {\em closing-quote-character}\,$^\star$ \\
		     \end{tabular}
		     \\[1ex]
\key{closing-quote-character} ::= \verb|'| \\[1ex]
\key{quote} ::= {\em opening-quote} $|$ {\em closing-quote} \\[1ex]
\key{opening-angle} \begin{tabular}[t]{rl}
		     ::= & {\em opening-angle-character}
		           {\em opening-angle-character} \\
		         & {\em opening-angle-character}\,$^\star$ \\
		     \end{tabular}
		     \\[1ex]
\key{opening-angle-character} ::= \verb|<| \\[1ex]
\key{closing-angle} \begin{tabular}[t]{rl}
		     ::= & {\em closing-angle-character}
		           {\em closing-angle-character} \\
		         & {\em closing-angle-character}\,$^\star$ \\
		     \end{tabular}
		     \\[1ex]
\key{closing-angle-character} ::= \verb|>| \\[1ex]
\key{angle-character} ::= \verb|<| $|$ \verb|>| \\[1ex]
\key{opening-character} ::=     \verb|(|
		            $|$ \verb|[|
		            $|$ \verb|{|
		            $|$ \verb|`|
		            $|$ \verb|<|
			    \\[1ex]
\key{closing-character} ::=     \verb|)|
		            $|$ \verb|]|
		            $|$ \verb|}|
		            $|$ \verb|'|
		            $|$ \verb|>|
			    \\[1ex]
\key{format-separator} ::= {\em format-separator-character}
			   {\em format-separator-character}\,$^\star$ \\[1ex]
\key{format-separator-character} ::=    \verb\|\
				        \\[1ex]
\key{white-space} ::= {\em white-space-character}
                     {\em white-space-character}\,$^\star$ \\[1ex]
\key{white-space-character}
    \begin{tabular}[t]{rl}
    ::= & {\em horizontal-space-character} \\
    $|$ & {\em vertical-space-character}
    \end{tabular}
    \\[1ex]
\key{horizontal-space-character} ::=
    \key{space} $|$ \key{horizontal-tab} $|$ \key{carriage-return} \\[1ex]
\key{vertical-space-character} ::=
    \key{line-feed} $|$ \key{vertical-tab} $|$ \key{form-feed}
\end{indpar}


The following sections give rules involving pre-lexemes.

\subsubsection{Lexical Matching and Pre-Lexical Context}
\label{LEXICAL-MATCHING}

{\em Opening-marks} and {\em closing-marks} are both pre-lexemes
and also lexemes.  Rules for matching pre-lexemes in a pre-lexeme
sequence are the same as rules for matching lexemes in a lexeme sequence.
Here we will state the rules for lexemes, and leave it to the reader
to reformulate them for pre-lexemes.

{\bf Lexeme Matching Rule.}\index{Lexeme Matching Rule}\index{matching!lexemes}
An {\em opening-mark} with $N$ characters $C$
must have a matching {\em closing-mark} with $N$ characters each the
mirror of $C$.  Here
the mirror of \verb|`| is \verb|'|,
the mirror of \verb|{| is \verb|}|,
the mirror of \verb|[| is \verb|]|,
the mirror of \verb|(| is \verb|)|,
and the mirror of \verb|<| is \verb|>|.
Each {\em closing-mark} must match exactly one {\em opening-mark},
each {\em opening-mark} must match exactly one {\em closing-mark},
and an {\em opening-mark} must precede its matching {\em closing-mark}.

Two lexemes are said to be \mkey{matched}{lexemes} if and only if
they are matched opening and closing marks.

{\bf Matched Lexeme Nesting Rule.}\index{Matched Lexeme Nesting Rule}
If one lexeme in a pair $P_2$ of matched lexemes is in between the
lexemes of another pair $P_1$ of matched lexemes, then both lexemes
in $P_2$ must be in between the lexemes of $P_1$.  In this case
$P_2$ is said to be \mkey{nested}{lexemes} inside of $P_1$.

During the scan a character $C$ is said to be in the
\key{lexical context} of a pair $P$ of matched lexemes
if and only if $C$ is between the matched lexemes of $P$,
and $C$ is not between any other pair of matched
lexemes that is nested inside of $P$.  For example,
in \verb|{ x [ y ] z }|, \verb|{ }| are in the outermost lexical
context, \verb|x [ ] z| are in the middle lexical context whose
matched lexemes are \verb|{ }|, and
\verb|y| is in the innermost lexical context whose matched lexemes
are \verb|[ ]|.\label{LEXICAL-CONTEXT}

For a sequence of pre-lexemes, \mkey{matched}{pre-lexemes} pre-lexemes
and \key{pre-lexical context} are defined as for a sequence of lexemes.

\subsubsection{Character Disambiguation Rules}

Several characters in pre-lexemes are ambiguous in the
pre-lexeme syntax equations.  The following rules disambiguate these
characters.

{\bf Opening Quote Rule.}\index{Opening Quote Rule}
An \key{opening-quote-character} must be preceded by a
{\em white-space-character},
an {\em opening-character}, or a {\em format-separator-character}.
Otherwise it is a {\em word-character}.

{\bf Closing Quote Rule.}\index{Closing Quote Rule}
A \key{closing-quote-character} must be part of a sequence of
{\em closing-quote-characters} that is of exactly the right length to be the
matching pre-lexeme for the last previous unmatched {\em opening-mark},
which must be an {\em opening-quote}.
Otherwise the potential {\em closing-quote-character}
is a {\em word-character}.

{\bf Format Separator Rule.}\index{Format Separator Rule}
A {\em format-separator-character} must be in the pre-lexical context of
a pair of matched {\em quotes}.  Otherwise it is a {\em word-character}.

{\bf Angle Rule.}\index{Angle Rule}
An {\em angle-character} must be either preceded by or followed by a copy
of itself.  Otherwise it is a {\em word-character}.

\subsubsection{Pre-Lexeme Examples}

Quote Examples:

\begin{indpar}[0.1in]
\begin{tabular}{@{}l@{\hspace*{0.3in}}l}
			& Pre-Lexeme Sequence		\\
Input String		& with {\em spaces} represented by \verb|_|'s \\[1ex]
\verb|I said `Hello'.|	& \tt I~~\verb|_|~~said~~\verb|_|~~`~~Hello~~'~~.	\\
\verb|Re`op 'tis.  But!|
			& \tt Re`op~~\verb|_|~~'tis.%
			  ~~\verb|__|~~But! \\
\verb|`Like 'tis'.|	& \tt `~~Like~~\verb|_|~~'~~tis'.	\\
\verb|``Like 'tis''.|	& \tt ``~~Like~~\verb|_|~~'tis~~''~~.	\\
\verb|`Like me''.|	& \tt `~~Like~~\verb|_|~~me''.		\\
\verb|`` `Hello' is a word.''|
			& \tt ``~~\verb|_|~~`~~Hello~~'~~\verb|_|~~is%
			  ~~\verb|_|~~a~~\verb|_|~~word.~~'' \\
\end{tabular}
\end{indpar}

Other rules of CASTLE
limit the semantic content of {\em white-space}.
In particular, there is no problem putting
space between the \verb|``| and \verb|`| in the last example
(\secref{SECTION-PARAGRAPH-AND-SENTENCE-PARSING}).

Angle and Format Separator Examples:

\begin{indpar}[0.1in]
\begin{tabular}{@{}l@{\hspace*{0.6in}}l}
			& Pre-Lexeme Sequence		\\
Input String		& with {\em spaces} represented by \verb|_|'s \\[1ex]
\verb|x <= y |		& \tt x~~\verb|_|~~\verb|<=|~~\verb|_|~~y	\\
\verb|x <<= y |		& \tt x~~\verb|_|~~\verb|<<|~~=~~\verb|_|~~y
			~~ Note \verb|<<| is unmatched {\em opening-mark}. \\
\verb/x = y|z/		& \tt x~~\verb|_|~~=~~\verb|_|~~\verb/y|z/ \\
\verb/x = `y|z'/	& \tt x~~\verb|_|~~=~~\verb|_|~~%
                              \verb|`|~~y~~\verb/|/~~z~~\verb|'|~~\\
\end{tabular}
\end{indpar}

\subsubsection{White Space Conversion}
\label{WHITE-SPACE-CONVERSION}

A \key{white-space} pre-lexeme does not have exactly the same characters
that were input to create it, unlike other pre-lexemes.  The
sequence of {\em white-space-characters} input to create a
{\em white-space} pre-lexeme is modified as follows to create the pre-lexeme:

{\bf Line End Spaces Rule.}\index{Line End Spaces Rule}
All {\em horizontal-space} characters preceding a {\em vertical-space}
character are deleted.  Thus spaces at line ends are ignored.

{\bf Carriage Return Rule.}\index{Carriage Return Rule}%
\label{CARRIAGE-RETURN-RULE}
If the pre-lexeme contains a {\em carriage-return} but no
{\em vertical-space-character}, it is in error.
Each {\em carriage-return} and all {\em horizontal-spaces} preceding
it are deleted.  Thus the pre-lexeme has no {\em carriage-returns}.

{\bf Horizontal Tab Rule.}\index{Horizontal Tab Rule}
Each {\em horizontal-tab} is replaced by {\em spaces} assuming that
horizontal tab stops are set every 8 columns after applying the
Carriage Return Rule (\pagref{CARRIAGE-RETURN-RULE}).
Thus the pre-lexeme has no {\em horizontal-tabs}.

Note that these rules do \underline{not} alter the printed appearance
of the {\em white-space} pre-lexeme, assuming that each
{\em vertical-space-character} causes printing to return to the beginning
of the line after the vertical space is executed.  The input may or may not
contain {\em carriage-returns} immediately before or after
{\em vertical-space-characters} with no effect.

After these rules are applied, a {\em white-space} pre-lexeme consists
of zero or more {\em vertical-space-characters} followed by
zero or more {\em space} characters.\label{WHITE-SPACE-PRE-LEXEMES}
It is not possible to have an
empty {\em white-space} pre-lexeme; the pre-lexeme either has a
{\em vertical-space-character}, which none of the above rules can delete,
or it has a {\em space} character which cannot be deleted, because,
in the absence of a {\em vertical-space-character}, the input
to the pre-lexeme cannot have a {\em carriage-return},
and therefore {\em horizontal-space-characters} cannot be deleted by the rules.

{\em White-space} pre-lexemes in the pre-lexical context of
a pair of matched {\em quotes} become lexemes.
{\em White-space} pre-lexemes
that are not in the pre-lexical context of a pair of matched {\em quotes}
are discarded, and do not become lexemes, but in certain pre-lexical contexts
they may be used to create indentation lexemes (\secref{INDENTATION-LEXEMES}).

The rules for forming lexemes from pre-lexemes ensure that all
non-empty sequences of {\em vertical-space} characters are equivalent outside
the pre-lexical context of a pair of matched {\em quotes}.

Inside matched
{\em quotes} that have no {\em format-separator} the only distinction made
between non-empty sequences of {\em vertical-space} characters concerns
whether or not they represent blank lines.
A {\em white-space} lexeme whose only {\em vertical-space} character is
a single {\em line-feed} represents just the end of a non-blank line,
with no following blank lines.
A {\em white-space} lexeme with some other sequence of {\em vertical-space}
characters represents the end of a non-blank line that is followed by one
or more blank lines.  Thus all sequences of {\em vertical-space} characters
that consist of other than just a single {\em line-feed} are equivalent,
inside matched quotes without a {\em format-separator}.

Inside matched {\em quotes} {\em white-space} lexemes
after a {\em format-separator} are retained literally.


\subsection{Lexemes}
\label{LEXEMES}

The sequence of pre-lexemes is converted to a sequence of \skey{lexeme}s
according to the following rules, which we will describe in order:

\begin{indpar}[1in]
Numbers \\
Post Separators \\
Indentation Lexemes
\end{indpar}

The syntax equations defining a lexeme are:

\begin{indpar}
\key{lexeme} ::= {\em word} $|$ {\em separator}
		$|$ {\em opening-mark}
		$|$ {\em closing-mark}
		$|$ {\em white-space} \\[1ex]
\key{separator} ::= {\em format-separator}
		$|$ {\em post-separator} \\[1ex]
\key{indentation-lexeme} ::= \verb|;|
			 $|$ \verb|{|
			 $|$ \verb|}|
\end{indpar}

{\em Post-separators} are single characters removed from the
ends of {\em pre-words}.  A {\em word} is what is left of
a {\em pre-word} after any {\em post-separators}
are removed from its end.
{\em Words} and {\em post-separators} are defined
below in \secref{POST-SEPARATORS}.


The {\em indentation-lexemes} are lexemes implied by indentation, and
are not distinguishable from explicit lexemes.  They are defined below in
\secref{INDENTATION-LEXEMES}.

{\em White-space} pre-lexemes become lexemes if they appear
in the pre-lexical context of a pair of matched {\em quotes}.
All other {\em white-space} pre-lexemes are discarded when pre-lexemes
are scanned to lexemes.

{\em Format-separators}, {\em opening-marks}, and {\em closing-marks}
are both pre-lexemes and lexemes.

\subsubsection{Number Lexemes}
\label{NUMBER-LEXEMES}

The rule for splitting a {\em pre-word} into a {\em word}
and a {\em separator} makes reference to {\em words} that are
{\em numbers}, saying that splitting is preferred if the {\em word}
resulting from the split is a {\em number}.  Some of the syntax equations
defining \skey{number}s are as follows.

\begin{indpar}
\key{number} ::= {\em real-number} $|$ {\em unit-number} \\[1ex]
\key{real-number} ::= {\em decimal-number} $|$ {\em radix-number}
				           $|$ {\em ratio}
				           $|$ {\em scientific-number}
\end{indpar}%
\label{REAL-NUMBER}

\subsubsubsection{Decimal Numbers}
\label{DECIMAL-NUMBERS}

\ikey{Decimal numbers}{decimal number}
are sequences of digits with optional commas,
an optional decimal point, and an optional sign.

\begin{indpar}
\key{decimal-number} ::= {\em unsigned-decimal-number}
                     $|$ {\em sign} {\em unsigned-decimal-number} \\[1ex]
\key{sign} ::= \verb|+| $|$ \verb|-| \\[1ex]
\key{unsigned-decimal-number} \begin{tabular}[t]{rl}
                              ::= & {\em decimal-natural} \\
		              $|$ & {\em decimal-natural} \verb|.|
		                    {\em decimal-natural} \\
		              $|$ & \verb|.| {\em decimal-natural}
		              \end{tabular} \\[1ex]
\key{decimal-natural} ::= {\em decimal-digits}
		     $|$ {\em decimal-natural} \verb|,| {\em decimal-digits}
		     \\[1ex]
\key{decimal-digits} ::= {\em digit} {\em digit}\,$^\star$
\end{indpar}

Decimal Number Examples:

\begin{indpar}[0.1in]
\tt
\begin{tabular}{l@{~~~~~}l@{~~~~~}l@{~~~~~}l@{~~~~~}l}
123	& -123		& +123		& 1,234		& -1,234,567 \\
123.0	& -.123		& +0.0		& 1,234.987654	& 1,234.987,654 \\
1,2	& -1.86,54	& 1,234567.89	& 12345.678,9	& +1.234567,892 \\[1ex]
\multicolumn{5}{l}{\normalfont (Lexemes in
the last line give errors when converted to numbers.)}
\end{tabular}
\end{indpar}

In a {\em decimal-number} lexeme, the decimal point must be followed by
a digit, and commas must be surrounded by digits.

In addition, commas must be located
every 3 digits from the decimal point, or every 3 digits
from the right end if there is no decimal point.
If there are any commas at all, there must be commas every 3 digits
in the integer part, while the fraction part may be comma free,
or may contain commas every 3 digits.
Failure to follow the rules of this paragraph will result in an
error when the lexeme is converted to a number,
but is \underline{not} an error of lexeme formation.  The last line of
examples above are therefore legal lexemes that will give errors when
converted to numbers.

\subsubsubsection{Radix Numbers}
\label{RADIXED-NUMBERS}

\ikey{Radix-numbers}{radix-number} permit binary, octal, or hexadecimal
radi\-ces to the used instead of decimal.  In fact, other number representation
schemes are permitted.

\begin{indpar}
\key{radix-number} ::= {\em unsigned-radix-number}
		   $|$ {\em sign} {\em unsigned-radix-number} \\[1ex]
\key{unsigned-radix-number} \\
	\hspace*{0.5in}::= {\em radix-indicator}
		        \verb|#| {\em radix-number-mark}
		        {\em radix-number-mark}\,$^\star$ \verb|#|
		        \\[1ex]
\key{radix-indicator} ::= {\em letter} {\em letter-or-digit}\,$^\star$ \\[1ex]
\key{letter-or-digit} ::= {\em letter} $|$ {\em digit} \\[1ex]
\key{radix-number-mark} ::= {\em word-character} except
	\{ \verb|#| $|$ \verb/|/ $|$ \verb|<| $|$ \verb|>|
	            $|$ \verb|`| $|$ \verb|'| \}
\end{indpar}

Radix Number Examples:

\begin{indpar}[0.1in]
\tt
\begin{tabular}{l@{~~~~~}l@{~~~~~}l@{~~~~~}l}

B\#10110100\#	& O\#77534201\# & D\#19758\#	& X\#FE8A932B\# \\
B\#101101\#	& O\#0.7753\#	& D\#197.58\#	& X\#0.fe8a932b\# \\
B\#10,1101\#	& O\#12,3456\#  & D\#0.123,5\#	& X\#FE8A,932B.7CCD,83\# \\
B\#a5,7b63\#	& O\#12/3456\#	& D\#+0.1\#	& X\#F.E8A932B.7CCD\# \\[1ex]
\multicolumn{4}{l}{\normalfont (Lexemes in
the last line give errors when converted to numbers.)}
\end{tabular}
\end{indpar}


The following {\em radix-indicators} are standard.

\begin{center}
\begin{tabular}{l@{~~~~~}l@{~~~~~}l@{~~~~~}l}
Radix	& Radix		 &			& Allowed Digits \\
Name	& Indicators     & Allowed Digits	& Between Commas \\[1ex]
binary	& \tt b~~~B	 & \tt 0 1		& 4 or 8 \\
octal	& \tt o~~~O	 & \tt 0 1 2 3 4 5 6 7	& 3 \\
decimal	& \tt d~~~D	 & \tt 0 1 2 3 4 5 6 7 8 9
						& 3 \\
hexadecimal
	& \tt x~~~X	 & \tt 0 1 2 3 4 5 6 7 8 9
						& 4 or 8 \\
	&		 & \tt a b c d e f A B C D E F
\end{tabular}
\end{center}

Standard {\em radix-indicators} permit a single decimal point, which must
be followed by a digit.
Standard {\em radix-indicator}
rules for comma location are the same as for {\em decimal-numbers}
(\secref{DECIMAL-NUMBERS}), except the number of digits between commas may
be 4 or 8 instead of 3.

{\em Radix-numbers} can be legal lexemes and still be unconvertible to
numbers because their {\em radix-indicators} are undefined, they
have {\em radix-number-marks} (e.g., digits)
not defined for the given {\em radix-indicator}, they
have too many decimal points, and so forth.
These errors are detected when the lexemes are converted to numbers.
The last line of {\em radix-number} examples above are legal lexemes that
will give errors when converted to numbers.
Note that standard radix indicators only allow commas, a decimal point,
digits, and letters that are hexadecimal digits
as {\em radix-number-marks}.

On the other hand, it
is possible to define non-standard converters for converting
{\em radix-number} lexemes to numbers, and thereby increase the
set of legal number representations.

\subsubsubsection{Ratios}
\label{RATIOS}

A \key{ratio} consists of two strings of decimal digits, the numerator
and denominator, separated by a slash (`\verb|/|'),
with an optional sign.

\begin{indpar}
\key{ratio} ::= {\em unsigned-ratio}
	    $|$ {\em sign} {\em unsigned-ratio} \\[1ex]
\key{unsigned-ratio} ::= {\em numerator} \verb|/| {\em denominator} \\[1ex]
\key{numerator} ::= {\em decimal-natural} \\[1ex]
\key{denominator} ::= {\em decimal-natural}
\end{indpar}

Ratio Examples:

\begin{indpar}[0.1in]
\tt
\begin{tabular}{l@{~~~~~}l@{~~~~~}l@{~~~~~}l@{~~~~~}l}
1/2	& -3/4		& +1,234/5	& 1,234/5,432	& -53/000 \\[1ex]
\multicolumn{5}{l}{\normalfont (The last lexeme
gives an error when converted to a number.)}
\end{tabular}
\end{indpar}

If the denominator equals zero, the ratio is still a legal lexeme, but
will cause an error when it is interpreted as a number.
\verb|-53/000| is an example.

\subsubsubsection{Scientific Numbers}
\label{SCIENTIFIC-NUMBERS}

A {\em scientific-number} is a {\em decimal-number} or a {\em radix-number}
followed by an exponent.

\begin{indpar}
\key{scientific-number} \begin{tabular}[t]{rl}
                        ::= & {\em decimal-number} {\em exponent} \\
			$|$ & {\em radix-number} {\em exponent}
		        \end{tabular} \\[1ex]
\key{exponent} ::= {\em exponent-indicator}
		   {\em exponent-sign-and-digits} \\[1ex]
\key{exponent-indicator} ::= \verb|e| $|$ \verb|E| \\[1ex]
\key{exponent-sign-and-digits} ::= {\em decimal-digits}
			    $|$ {\em sign} {\em decimal-digits}
\end{indpar}

Scientific Number Examples:

\begin{indpar}[0.1in]
\tt
\begin{tabular}{l@{~~~~~}l@{~~~~~}l@{~~~~~}l@{~~~~~}l}
123e0		& -123e+2	& +123e-321	& 1,234e9 \\
123E0		& -123E+2	& +123E-321	& -0.123,456e-3	\\
.123\verb|e|0	& -.123\verb|e|+2
				& -0.123,456e-3 & -1,234.567890\verb|e|6 \\
X\#a9\#e0	& B\#1011\#e-3	& O\#0.7753\#e-5
					    & X\#0.FE8A,932B,E\#\verb|e|+5 \\
\end{tabular}
\end{indpar}

Note that exponents cannot contain commas.

The digits in an exponent are always decimal, even when the number has
a radix indicator such as {\tt B} or {\tt X} that indicates a different
radix.  However, the interpretation of the exponent depends upon the
radix indicator.  Standard radix indicators interpret the exponent as
multiplication by their radix to the exponent power.  Thus
{\tt B\#1101\#e-2} and {\tt B\#11.01\#} are both equal to {\tt 3.25}.

\subsubsubsection{Unit Numbers}
\label{UNIT-NUMBERS}

\ikey{Unit-numbers}{unit-number} are just {\em decimal-numbers}
with a {\em unit-indica\-tor} prefixed or postfixed.  A {\em sign} may be before
or after a prefix {\em unit-indicator}.

\begin{indpar}
\key{unit-number} \begin{tabular}[t]{rl}
		  ::= & {\em pre-unit-indicator} {\em unit-base-number} \\
		  $|$ & {\em sign} {\em pre-unit-indicator}
		  		   {\em unsigned-unit-base-number} \\
		  $|$ & {\em unit-base-number} {\em post-unit-indicator}
		  \end{tabular} \\[1ex]
\key{unit-base-number} ::= {\em decimal-number} \\[1ex]
\key{unsigned-unit-base-number} ::= {\em unsigned-decimal-number} \\[1ex]
\key{pre-unit-indicator} ::= \verb|$| $|$ {\tt \pounds} \\[1ex]
\key{post-unit-indicator} ::= \verb|'| $|$ \verb|"| $|$ \verb|%| $|$ $^\circ$
			  $|$ \verb|i| $|$ \verb|j| $|$ \verb|k|
			      \\[1ex]
\key{unit-indicator} ::= {\em pre-unit-indicator}
		     $|$ {\em post-unit-indicator}
\end{indpar}

However, unit numbers are not lexemes.

{\bf Unit Number Rule.}\index{Unit Number Rule}
If a {\em unit-number} is to be output as a {\em word} lexeme, then instead
the {\em unit-number} is split into two {\em word} lexemes, one of which
is the {\em real-number} part and the other of which is a 1-character
{\em word} consisting of the {\em unit-indicator}.

Unit Number Examples:

\begin{indpar}[0.1in]
\begin{tabular}{@{}l@{\hspace*{0.3in}}l}
Unit Number		& Lexeme Sequence	\\[1ex]
\tt \$5.71		& \tt \$~~5.71 \\
\tt \pounds -5.71	& \tt \pounds ~~-5.71 \\
\tt -\$2.20		& \tt \$ -2.20 \\
\tt 15'			& \tt 15~~' \\
\tt -2.543"		& \tt -2.543~~" \\
\tt 72\%		& \tt 72~~\% \\
\tt 0.5i		& \tt 72~~i \\
\end{tabular}
\end{indpar}

Here \verb|15'| splits to produce \verb|'| as a 1-character
\underline{word} lexeme, and not as a closing quote lexeme.

A sign immediately before a {\em pre-unit-indicator} is moved to
the {\em real-number} part; \verb|-$2.20| becomes \verb|$ -2.20|.
The units `\ttmkey{i}{as unit}', `\ttmkey{j}{as unit}', and
`\ttmkey{k}{as unit}' are used to specify complex imaginary or quaternion
numbers: see \pagref{IMAGINARY-UNITS}.

Note that {\em radix-numbers}, {\em ratios}, and {\em scientific-numbers}
cannot have units as part of their pre-lexeme.  This is to reduce confusion:
the units can always be given separated by a space from the number,
as in `{\tt \pounds~}\verb|O#7601#|', `\verb|$ 3/4|', and `\verb|5e3 i|'.

\subsubsection{Post Separators}
\label{POST-SEPARATORS}

Informally, a \key{post-separator} is a 1-character separator that immediately
follows a word without intervening space.  Examples are the comma, period,
and the exclamation point.  A word and any following post-separators
are all part of a single pre-word.  For example, `\verb|Hello!|' is a
pre-word containing the word `\verb|Hello|' and the post-separator `\verb|!|'.

There are two kinds of post separators:
\ttmkey{weak}{post-separator} and \ttmkey{strong}{post-separator}.
The Post Separator Rule
given below tells when a {\em pre-word} ending
in a {\em post-separator-character}
must be split into a smaller {\em pre-word} and a 1-character
{\em separator}.  This rule makes reference to {\em words} that are
{\em numbers}, saying that splitting is preferred when the
{\em post-separator-character} is weak if the {\em pre-word}
resulting from the split is a {\em number}.

The syntax equations required are:

\begin{indpar}
\key{separator} ::= {\em format-separator}
		$|$ {\em post-separator} \\[1ex]
\key{post-separator} ::= {\em post-separator-character} \\[1ex]
\key{post-separator-character} \begin{tabular}[t]{rl}
                     ::= & {\em strong-post-separator-character} \\
		     $|$ & {\em weak-post-separator-character}
		     \end{tabular} \\[1ex]
\key{strong-post-separator-character} ::=     \verb|,|
			                $|$ \verb|;|
					\\[1ex]
\key{weak-post-separator-character} ::=     \verb|!|
				        $|$ \verb|?|
			                $|$ \verb|:|
			                $|$ \verb|.|
					\\[1ex]
\key{pre-word} ::= {\em word}
		$|$ {\em pre-word} {\em post-separator-character}
\end{indpar}

{\bf Post Separator Rule.}\index{Post Separator Rule}
A {\em pre-word} of 2 or more characters
that ends with a {\em post-separator-character}
is split into a smaller {\em pre-word} and a {\em post-separator}
if (1) the {\em post-separator-character} is strong, or if
(2) the smaller {\em pre-word} ends with a
{\em strong-post-separator-character}, or if
(3) the smaller {\em pre-word} is a {\em number}, or if
(4) the smaller {\em pre-word} does 
\underline{not} contain a copy of the {\em post-separator-character}.
If the {\em pre-word} is not split, it becomes a {\em word} lexeme.

The following rule handles the case of 1-character {\em pre-words}.

{\bf Isolated Post Separator Rule.}\index{Isolated Post Separator Rule}
A {\em pre-word} that consists of a single {\em post-separator-character}
is a {\em post-separator} lexeme.


Examples:

\begin{indpar}[0.1in]
\begin{tabular}{@{}l@{\hspace*{0.3in}}l@{~~~}l@{\hspace*{0.6in}}l}
Pre-Word		& \multicolumn{2}{@{}l@{}}{Lexeme Sequence}
							& Splits?	\\[1ex]
\verb|hello.|		& \tt hello 		& \tt .	& yes		\\
\verb|X,|		& \tt X 		& \tt ,	& yes		\\
\verb|h.e.l.l.o.|	& \tt h.e.l.l.o.	&	& no		\\
\verb|e.g.|		& \tt e.g.		&	& no		\\
\verb|5.0.|		& \tt 5.0		& \tt .	& yes		\\
\verb|1,234.5,|		& \tt 1,234.5		& \tt ,	& yes		\\
\verb|1,234.5,,|	& \tt 1,234.5		& \tt ,~~,
							& yes, twice	\\
\verb|1,234.5.,|	& \tt 1,234.5		& \tt .~~,
							& yes, twice	\\
\verb|1,234.5,.|	& \tt 1,234.5		& \tt ,~~.
							& yes, twice	\\
\verb|help!|		& \tt help		& \tt !	& yes		\\
\verb|!help!|		& \tt !help!		&	& no		\\
\verb|help.!|		& \tt help		& \tt .~~!
							& yes, twice	\\
\verb|.help.!|		& \tt .help.		& \tt !
							& yes, once	\\
\verb|!.help.!|		& \tt !.help.!		&	& no		\\
\end{tabular}
\end{indpar}

\subsubsection{Indentation Lexemes}
\label{INDENTATION-LEXEMES}

{\em Indentation-lexemes} are implied by indentation.  The
\mkey{indentation}{of line} of a line is the
the number of {\em space} characters in the {\em white-space}
pre-lexeme just before the first non-{\em white-space} pre-lexeme
of the line.  Note that lines cannot be empty; empty lines are
merged into {\em white-space} pre-lexemes.  Recall that
{\em white-space} pre-lexemes each consist
of zero or more {\em vertical-space-characters} followed by
zero or more {\em space} characters (\pagref{WHITE-SPACE-PRE-LEXEMES}).

At any given point in the scan converting pre-lexemes to lexemes, there is a
stack of indentation records, called the \key{indentation stack}.
An \key{indentation record} is a number of
columns, a pre-lexical context (\pagref{LEXICAL-CONTEXT}), and a flag.
The number of columns is called the \key{indentation}.
The flag is called the \key{implicit bracket flag}, and indicates whether
or not an implied \verb|{| lexeme was inserted at the same time the
indentation record was pushed onto the indentation stack.

Initially the indentation stack contains a single indentation record with
0 indentation, the outermost pre-lexical context,
and an off implicit bracket flag.
The stack cannot become empty; any operation that would
pop the last indentation off the stack announces an error and leaves the
stack alone.  Thus the bottommost indentation on the stack is always
the same.

The indentation in the indentation record at the top of the indentation
stack is called the \key{current indentation}, and the pre-lexical
context in that record is called the \key{current indentation context}.

The rules for creating indentation records are such that the pre-lexical
contexts in such records are either pre-lexical contexts of some \verb|{ }|
bracket pair, or are the outermost pre-lexical context, which therefore behaves
like the context of a \verb|{ }| bracket pair as far as indentation is
concerned.  A line beginning is said to be in a particular pre-lexical
context if the first lexeme on the line, were it not a {\em closing-mark},
would be in that pre-lexical context.  One may think of a \key{line beginning}
as being a position on a line just before the first pre-lexeme on the line.

{\bf Semi-Colon Rule.}\index{Semi-Colon Rule}
If the beginning of the line is in the current indentation context,
and if the indentation of the line is the current indentation,
then a \verb|;| implied {\em separator} lexeme is output
before any lexemes generated by the line are output, unless
(1) the last lexeme output before the line
was a \verb|;| {\em separator} lexeme,
(2) the last lexeme output was a \verb|{| {\em opening-mark}
lexeme (including an implied {\em opening-mark} as in the
Implicit-Bracket Rule below), or
(3) the first non-{\em white-space} pre-lexeme of a line is \verb|}|.

{\bf Explicit-Bracket Rule.}\index{Explicit-Bracket Rule}
If the last pre-lexeme of a line is \verb|{|, then an indentation record
is pushed onto the indentation stack just after the \verb|{| lexeme
is output.  The indentation in the record is the indentation of the next
line, the pre-lexical context is that in effect just after the \verb|{|,
and the implicit bracket flag is off.
The pushed indentation record is popped just after its pre-lexical context
ends; that is, just before reading the \verb|}| pre-lexeme that matches the
\verb|{| pre-lexeme that pushed the indentation record.

{\bf Implicit-Bracket Rule.}\index{Implicit-Bracket Rule}
If the last lexeme output for a line would be a separator \verb|:| in
the current indentation context,
then a \verb|{| implied {\em opening-mark} lexeme
is output instead of the \verb|:|, and an indentation
record is pushed onto the indentation stack.  The indentation of the
record is the indentation of the next line, the implicit bracket flag
of the record is on, and the
pre-lexical context of the record is that of the \verb|:|.
The pushed record is popped (1) just before the first line such that
the line beginning is in the record's pre-lexical context
and the line's indentation is less than the record's indentation,
or (2) at the end of the input pre-lexeme stream.
When the record is popped, a \verb|}| implied {\em closing-mark}
lexeme is output.  It is an error if this implied {\em closing-mark}
does not match the implied {\em opening-mark} associated with the popped
record, because of intervening explicit opening and closing marks.

In order to avoid subtle errors created by indentation, there
is a {\tt minimum-indentation} parameter and the following rule.

{\bf Minimum-Indentation Rule.}\index{Minimum-Indentation Rule}
The indentation of any line whose beginning is in the current indentation
context (the first pre-lexeme of the line would be in the current indentation
context if it did not end a sub-context) must equal the current indentation
or differ from it by at least the value of the
\ttkey{minimum-indentation} parameter.  The {\tt minimum-indentation}
parameter defaults to {\tt 4}.


Indentation Lexeme Examples:

\begin{indpar}[0.1in]
\tt \ttbrackets
\begin{tabular}{@{}p{2in}@{~~~~~~~~~~}l}
{\rm Input String}		& {\rm Output Lexemes} \\[1ex]
hi \{ x; y z; w \}		& \tt hi \{ x ; y z ; w \} \\[1ex]
hi \{				& hi \{ \\
~~~~x				& x \\
~~~~y z				& ; y z \\
~~~~w \}			& ; w \}
\end{tabular}
\end{indpar}
\begin{indpar}[0.1in]
\tt \ttbrackets
\begin{tabular}{@{}p{2in}@{~~~~~~~~~~}l}
hi				& hi \\
\{				& ; \{ \\
~~~~x				& x \\
~~~~y z				& ; y z \\
~~~~w				& ; w \\
\}				& \}
\end{tabular}
\end{indpar}
\begin{indpar}[0.1in]
\tt \ttbrackets
\begin{tabular}{@{}p{2in}@{~~~~~~~~~~}l}
hi:				& hi \{ \\
~~~~x				& x \\
~~~~y z				& ; y z \\
~~~~w				& ; w \\
				& \}
\end{tabular}
\end{indpar}
\begin{indpar}[0.1in]
\tt \ttbrackets
\begin{tabular}{@{}p{2in}@{~~~~~~~~~~}l}
hi \{				& hi \{ \\
~~~~x				& x \\
~~~~y `this			& ; y ` this \\
is another pre-lexical		& is another pre-lexical \\
context.			& context . \\
' foo bar			& ' foo bar \\
~~~~w \}			& ; w \}
\end{tabular}
\end{indpar}
\begin{indpar}[0.1in]
\tt \ttbrackets
\begin{tabular}{@{}p{2in}@{~~~~~~~~~~}l}
hi \{				& hi \{ \\
~~~~x				& x \\
~~~~\{				& ; \{ \\
ho				& ho \\
hum \} y			& ; hum \} y \\
~~~~z \}			& ; z \}
\end{tabular}
\end{indpar}


\subsection{Lexical Parsing}
\label{LEXICAL-PARSING}

After pre-lexemes are scanned to produce lexemes, lexemes may be
scanned to perform the following:

\begin{indpar}[1in]
Lexeme Replacement (Spelling Regularization, Possessive Splitting)
    (\secref{LEXEME-REPLACEMENT}) \\
Number Unit Grouping (\secref{NUMBER-UNIT-GROUPING}) \\
Unit Multiplier Insertion (\secref{UNIT-MULTIPLIER-INSERTION})
\end{indpar}

We describe these below in order.

The scan that performs the above actions is called
\key{lexical parsing}\index{parsing!lexical},
because it does initial parse steps
at the level of individual lexemes and short sequences of lexemes, and
because it is controlled by definitions in the parsing stack
(\pagref{PARSING-STACK}).

Lexical parsing is \underline{not} performed in certain
contexts, such as in the lexical context of a pair of matched {\em quotes}
(see the table on \pagref{CONTEXT-SWITCHES}).

\subsubsection{Lexeme Replacement}
\label{LEXEME-REPLACEMENT}

The lexeme replacement process replaces one lexeme by a string of zero or
more lexemes.  Replacement may be done by either a dictionary or a function.
Replacement is controlled by \skey{lexeme replacement definition}s
in the parsing stack (\pagref{PARSING-STACK}).

There are two kinds of lexeme replacement definitions:
dictionary and function.  These have the syntax:

\begin{indpar}
\ikey{LEXEME-DEFINITION}{lexeme-definition}\,\footnote{Capitalized syntactic
categories represent CASTLE expressions (\secref{EXPRESSION-PARSING}).}
		     \begin{tabular}[t]{rl}
                     ::= & {\em LEXEME-DICTIONARY-DEFINITION} \\
		     $|$ & {\em LEXEME-FUNCTION-DEFINITION}
		     \end{tabular} \\[1ex]
\ikey{LEXEME-DICTIONARY-DEFINITION}{lexeme-dictionary-definition} \\
	\hspace*{0.5in}::= \begin{tabular}[t]{@{}l@{}l@{}}
	                   \verb|define | & \verb|lexeme dictionary|
                                            {\em DICTIONARY-NAME} \\
				& {\em LEXEME-DICTIONARY-ENTRIES}
		     \end{tabular} \\[1ex]
\ikey{DICTIONARY-NAME}{dictionary-name} ::=
	\verb|[|
	\{ {\em word} $|$ {\em separator} \}
	\{ {\em word} $|$ {\em separator} \}\,$^\star$
	\verb|]| \\[1ex]
\ikey{LEXEME-DICTIONARY-ENTRIES}{lexeme-dictionary-entries}
                    ::= \verb|(| {\em lexeme-dictionary-entry-list} \verb|)|
		    \\[1ex]
\key{lexeme-dictionary-entry-list} \\
		     \hspace*{0.5in}\begin{tabular}[t]{@{}rl@{}}
                     ::= & {\em LEXEME-DICTIONARY-ENTRY} \\
		     $|$ & {\em lexeme-dictionary-entry-list} \verb|,|
		           {\em LEXEME-DICTIONARY-ENTRY}
		     \end{tabular} \\[1ex]
\ikey{LEXEME-DICTIONARY-ENTRY}{lexeme-dictionary-entry} \\
    \hspace*{0.5in}::=
	\verb|[| {\em replaced-lexeme} \verb|==>| {\em replacing-lexemes}
	\verb|]| \\[1ex]
\key{replaced-lexeme} ::=
	\{ {\em word} $|$ {\em separator} \} \\[1ex]
\key{replacing-lexemes} ::=
	\{ {\em word} $|$ {\em separator} \}\,$^\star$ \\[1ex]
\ikey{LEXEME-FUNCTION-DEFINITION}{lexeme-function-definition} \\
	\hspace*{0.5in}::= \verb|define lexeme function|
				{\em FUNCTION-NAME} \\[1ex]
\ikey{FUNCTION-NAME}{function-name} ::=
	\verb|[|
	\{ {\em word} $|$ {\em separator} \}
	\{ {\em word} $|$ {\em separator} \}\,$^\star$
	\verb|]|
\end{indpar}%
\label{LEXEME-REPLACEMENT-DEFINITION}

which correspond to the expression definitions
(\secref{EXPRESSION-DEFINITIONS}):\footnote{These particular dictionary
entries tell us that {\tt NAME} and {\tt ENTIRES} are \underline{evaluated}
arguments (\secref{EXPRESSION-EVALUATION}).}

\begin{indpar}
\begin{verbatim}
define lexeme dictionary NAME ENTRIES <-- list ENTRIES

define lexeme function NAME <--
\end{verbatim}
\end{indpar}

A \key{lexeme dictionary entry} gives a lexeme that is to be replaced
and a sequence of lexemes that replace it.  For example, the entry

\begin{center}
\verb|[ people ==> person ]|
\end{center}

causes the word `\verb|people|' to be replaced by the word `\verb|person|'.

A \key{lexeme function} is a function that is called with a lexeme as its
single argument and which returns either `\verb|false|' if the lexeme is
not to be replaced or returns an expression consisting of a sequence of
lexemes that are to replace the lexeme otherwise.  For example, given the
lexeme function definition

\begin{indpar}
\begin{verbatim}
define lexeme function [replace people]
\end{verbatim}
\end{indpar}

and the expression definition

\begin{indpar}
\begin{verbatim}
replace people X <-- {
    if X == [people]:
        value = [person]
    else:
        value = false }
\end{verbatim}
\end{indpar}

an appearance of the lexeme `\verb|fie|' will evaluate the
expression `\verb|replace people fie|' which will return `\verb|false|'
to avoid replacing the lexeme `\verb|fie|'.

It is possible to temporarily void lexeme replacement definitions by
placing canceling undefinitions in the parsing stack.  These have the
syntax:

\begin{indpar}
\ikey{LEXEME-UNDEFINITION}{lexeme-undefinition}
		     \begin{tabular}[t]{rl}
                     ::= & {\em LEXEME-DICTIONARY-UNDEFINITION} \\
		     $|$ & {\em LEXEME-FUNCTION-UNDEFINITION}
		     \end{tabular} \\[1ex]
\ikey{LEXEME-DICTIONARY-UNDEFINITION}{lexeme-dictionary-undefinition} \\
	\hspace*{0.5in}::= \verb|undefine lexeme dictionary|
                                            {\em DICTIONARY-NAME} \\[1ex]
\ikey{LEXEME-FUNCTION-UNDEFINITION}{lexeme-function-undefinition} \\
	\hspace*{0.5in}::= \verb|undefine lexeme function|
				{\em FUNCTION-NAME}
\end{indpar}

which correspond to the expression definitions
(\secref{EXPRESSION-DEFINITIONS}):

\begin{indpar}
\begin{verbatim}
undefine lexeme dictionary NAME <--

undefine lexeme function NAME <--
\end{verbatim}
\end{indpar}

Lexeme replacement is \underline{not} recursive: the replacement lexemes are
not themselves subject to replacement.

The following lexeme dictionaries and functions are
defined in the initial parsing stack.  Their definitions are ordered in the
stack so the first given below is at the top of the stack and is the
first that replaces lexemes.

\begin{list}{}{}

\item
\verb|define lexeme dictionary [english lexeme dictionary]|~~
This dictionary translates common English irregular plurals,
to their singular form, and decomposes
irregular possessives to their singular decomposed form.
This dictionary also protects irregular singular forms that might be
mistaken for regular plural forms (e.g., `\verb|news|').
Some example translations are:

\begin{center}
\begin{tabular}{l}
\verb|people| $\longrightarrow$ \verb|[person]| \\
\verb|women| $\longrightarrow$ \verb|[woman]| \\
\verb|geese| $\longrightarrow$ \verb|[goose]| \\
\verb|fungi| $\longrightarrow$ \verb|[fungus]| \\
\verb|news| $\longrightarrow$ \verb|[news]| \\
\end{tabular}
\end{center}

\item
\verb|define lexeme function [english lexeme function]|~~
This function translates common English standard plurals
to their singular form, and decomposes
standard possessives to their singular decomposed form.
Some example translations are:

\begin{center}
\begin{tabular}{l}
\verb|boys| $\longrightarrow$ \verb|[boy]| \\
\verb|boy's| $\longrightarrow$ \verb|[boy 's]| \\
\verb|boys'| $\longrightarrow$ \verb|[boy 's]| \\
\verb|boxes| $\longrightarrow$ \verb|[box]| \\
\end{tabular}
\end{center}

\end{list}

Because CASTLE, outside the context of quotes,
insists on mapping different forms of a word to a single
word, some subtleties of language are lost.  For example, `\verb|people|'
can be a singular word referring to a group of people, but CASTLE will
standardly confuse it with `\verb|person|'.

\subsubsection{Number Unit Grouping}
\label{NUMBER-UNIT-GROUPING}

A {\em number-unit-group} is a sequence of one or more {\em number-unit-pairs}
each of which consists of two lexemes: a {\em real-number} (number
without {\em unit-indicator}, \pagref{REAL-NUMBER}),
and a {\em unit-specifier}.
The syntax equations are:

\begin{indpar}
\key{number-unit-group} ::= {\em number-unit-pair}
			    {\em number-unit-pair}\,$^\star$ \\[1ex]
\key{number-unit-pair} \begin{tabular}[t]{rl}
                     ::= & {\em prefix-unit-specifier} {\em real-number} \\
                     $|$ & {\em real-number} {\em postfix-unit-specifier} \\
		     \end{tabular} \\[1ex]
\key{prefix-unit-specifier} ::= {\em word} {\em word}\,$^\star$ \\[1ex]
\key{postfix-unit-specifier} ::= {\em word} {\em word}\,$^\star$ \\[1ex]
\key{unit-specifier} ::= {\em prefix-unit-specifier} $|$
                         {\em postfix-unit-specifier}
\end{indpar}

In order to be recognized as a {\em unit-specifier} a {\em word} sequence
must be defined as a {\em UNIT-SPECIFIER-NAME} by the following:

\begin{indpar}
\ikey{UNIT-SPECIFIER-DEFINITION}{unit-specifier-definition} \\
	\hspace*{0.5in}::= \verb|define unit specifier|
	    \begin{tabular}[t]{l}
	    {\em UNIT-SPECIFIER-FIXITY} \\
	    {\em UNIT-SPECIFIER-NAME}
	    \end{tabular} \\[1ex]
\ikey{UNIT-SPECIFIER-FIXITY}{unit-specifier-fixity} ::=
	\verb|[| \ttkey{prefix} \verb|]|
	$|$ \verb|[| \ttkey{postfix} \verb|]| \\[1ex]
\ikey{UNIT-SPECIFIER-NAME}{unit-specifier-name} ::=
	\verb|[| {\em word} {\em word}\,$^\star$ \verb|]|
\end{indpar}%
\label{UNIT-SPECIFIER-DEFINITION}

It is possible to temporarily void unit specifier definitions by
placing canceling undefinitions in the parsing stack.  These have the
syntax:

\begin{indpar}
\ikey{UNIT-SPECIFIER-UNDEFINITION}{unit-specifier-undefinition} \\
	\hspace*{0.5in}::= \verb|undefine unit specifier|
	    {\em UNIT-SPECIFIER-NAME}
\end{indpar}

The \key{number unit grouping} phase of lexical
parsing recognizes {\em number-unit-groups} containing more than
one {\em number-unit-pair}, places
implied parentheses around them, and places implied `\verb|+|' operators
between their {\em number-unit-pairs}.  This is done after lexeme replacement
(\secref{LEXEME-REPLACEMENT}).

For example, `\verb|7 ' 30 "|' is a {\em number-unit-group} containing
2 {\em number-unit-pairs} that number unit grouping transforms into
`\verb|( 7 ' + 30 " )|'.

\subsubsection{Unit Multiplier Insertion}
\label{UNIT-MULTIPLIER-INSERTION}

The \key{unit multiplier insertion} phase of lexical
parsing inserts a multiplication operator lexeme, `\verb|*|',
before a {\em postfix-unit-specifier}, and
after a {\em prefix-unit-specifier}, unless the point at which the
`\verb|*|' is to be inserted is already occupied by a
`\verb|*|' or `\verb|/|' lexeme.  This is done after number unit
grouping (\secref{NUMBER-UNIT-GROUPING}).

For example, if `\verb|sec|', `\verb|ft|', and `\verb|lb|'
are {\em postfix-unit-specifiers},
then
\begin{center}
\verb|some function ( 3 ft / sec, 9 ft ^ 2 lb / sec )|
\end{center}
becomes
\begin{center}
\verb|some function ( 3 * ft / sec, 9 * ft ^ 2 * lb / sec )|
\end{center}


\section{Expression Parsing}\index{parsing!expression}
\label{EXPRESSION-PARSING}

An expression is a sequence of words, separators, and subexpressions.
A subexpression is a pair of matched lexemes and all the lexemes in
between.

Expressions and subexpressions can contain operators.  When they do,
matched implied parentheses are inserted into the expressions or subexpressions
according to rules of operator precedence and associativity, and these
implied parentheses create new subexpressions.

Expressions and subexpressions that do not contain operators may contain
argument lists and qualifying phrases.  The order in which qualifying
phrases appear does not matter, and sometimes the order of arguments
in an argument list does not matter.

Expressions containing operators are restructured, both by inserting
implied parentheses and in other ways.  Subexpressions surrounded by
particular matching lexemes, such as \verb|`'|, are restructured in
special ways.

The process of restructuring expressions is called
\key{expression parsing}\index{parsing!expression}.
Expression parsing takes an expression as input, and produces as output a raw
expression that contains nothing that will trigger further restructuring.

\subsection{Subexpressions}
\label{SUBEXPRESSIONS}

The first step in expression parsing is to identify \skey{subexpression}s within
an expression, without restructuring the expression, by applying
the following syntax equations.

\begin{indpar}
\key{EXPRESSION} ::= {\em expression-item}\,$^\star$ \\[1ex]
\key{expression-item} ::= {\em word} $|$ {\em separator}
				     $|$ {\em subexpression} \\[1ex]
\key{subexpression} ::= {\em opening-mark} {\em EXPRESSION}
			{\em closing-mark}
\end{indpar}

{\bf Subexpression Rule.}\index{Subexpression Rule}
The {\em opening-mark} lexeme that begins a subexpression must lexically match
(\secref{LEXICAL-MATCHING}) the {\em closing-mark} lexeme that
ends a subexpression.

The subexpressions identified by this rule have explicit opening and closing
marks.  Below we introduce subexpressions with operators that have implicit
parentheses as their opening and closing marks.

The syntactic category name {\em EXPRESSION} is capitalized because in
this document syntactic categories representing CASTLE expressions
are given completely capitalized names.

\subsection{Expression Structure Overview}
\label{EXPRESSION-STRUCTURE-OVERVIEW}

Expression structure is affected by five special marks.
The \key{optional argument mark} `\ttnbkey{::?}' is used in expression
definitions
to separate arguments that are required from those that can be optional,
as in the expression `\verb|find-max LIST ::? COMPARATOR|', in which the
the `\verb|LIST|' argument is required but the `\verb|COMPARATOR|' argument
is optional.
The \key{reorder mark} `\ttnbkey{<:>}' is used in expression definitions
to separate arguments whose order can be switched,
as in the expression `\verb|element LIST <:> INDEX|' in which the
`\verb|LIST|' and `\verb|INDEX|' argument can be switched.
The \key{remainder mark} `\ttnbkey{::>}' precedes a final argument in an
expression definition that represents the list of remaining arguments in a use
of the definition, as in the expression `\verb|max ::> ARGS|',
where \verb|ARGS| represents
the list of all the arguments given to \verb|max|.
The \key{required qualifier mark}\index{qualifier mark!required}
`\ttkey{@@}' in an expression signals that the following
expression item is a required qualifier, as in the expression
`\verb|sort x @@ with order ascending |',
and is implied by qualifiers (e.g. \verb|with|, \verb|has|)
in an expression.
The \key{optional qualifier mark}\index{qualifier mark!optional}
`\ttnbkey{??}' in an expression signals that the following
expression item is an optional qualifier, as in the expression
`\verb|sort X ?? with order O|'.  When default values are provided in
definitions, required qualifier marks may be converted automatically to
optional qualifier marks and an optional argument mark may be inserted into an
argument list automatically (\secref{AUTOMATIC-OPTIONAL-MARKS}).

Expressions are restructured if they contain operators (e.g.,
\verb|+|,
\verb|-|,
\verb|*|,
\verb|/|),
qualifiers (e.g.,
\verb|with|,
\verb|has|),
or qualifier shortcuts (e.g., \verb|ascending|, which is a shortcut for
`{\tt with order ascending}').
A \key{raw expression} (\secref{RAW-EXPRESSIONS})
is a particular kind of expression that will not be
restructured.  The only special marks that may be in a raw expression
are the five special marks:
the optional argument mark (\verb|::?|), the reorder mark (\verb|<:>|),
the remainder mark (\verb|::>|),
and the qualifier marks (\verb|@@|, \verb|??|).
Translating an expression into a raw expression is called
\key{expression parsing}\index{parsing!expression}.

Some operators are matchfix operators, which surround their single
argument like parentheses.  Some matchfix operators have special
affects on parsing.  An informal summary of the standard matchfix
operators is:

\begin{center}
\begin{tabular}{l@{~~~~~~}l@{~~~~~~}l@{~~~~~~}l@{~~~~~~}l@{~~~~~~}l}
		& \multicolumn{5}{c}{Turns} \\ \cline{2-6} \\
		& operators
				& lexical
					& \verb/|/
						& \verb|<:> ::> ::?| \\
Brackets	& and qualifiers
				& parsing
					& text	& \verb|@@  ??|
							& evaluation \\[1ex]

\verb|(|\ldots\verb|)|
		& --		& --    & --	& --	& -- \\
\verb|{|\ldots\verb|}|
		& on		& on	& off	& on	& off \\
\verb|[|\ldots\verb|]|
		& off		& off	& off	& on	& off \\
\verb|{{|\ldots\verb|}}|
		& on		& on	& off	& on	& -- \\
\verb|[[|\ldots\verb|]]|
		& off		& off	& off	& on	& -- \\
\verb|<<|\ldots\verb|>>|
		& on		& on	& off	& on	& on \\
\verb|<<<|\ldots\verb|>>>|
		& on		& on	& off	& on	& on twice \\
\verb|<<<<|\ldots\verb|>>>>|
		& on		& on	& off	& on	& on thrice \\
\verb|`|\ldots\verb|'|
		& off		& off	& on	& off	& off \\
\verb|``|\ldots\verb|''|
		& off		& off	& on	& off	& off \\
\verb|```|\ldots\verb|'''|
		& off		& off	& on	& off	& off \\
\end{tabular}\label{CONTEXT-SWITCHES}
\end{center}

Other matching lexemes may be made to affect parsing by introducing
operator definitions (\secref{OPERATOR-DEFINITIONS}).

Parsing is controlled by the \key{parsing stack},\label{PARSING-STACK}
which contains definitions of parsers, operators, qualifiers, and
qualifier shortcuts, as well as definitions related to
lexical parsing.
An definitional operator (\pagref{DEFINITIONAL})
may push definitions onto the parsing
stack.  After the expression containing the operator has been parsed,
these definitions will be popped from the parsing stack.

The following is a list of the kinds of
\ikey{definitions}{definition!in parsing stack} that may be in
the \mkey{parsing stack}{kinds of definition in}:%
\label{PARSING-STACK-DEFINITION-KINDS}

\begin{center}
\begin{tabular}{ll}
parser & \secref{PARSER-DEFINITION} \\
operator & \secref{OPERATOR-DEFINITIONS} \\
qualifier & \secref{QUALIFIER-DEFINITION} \\
qualifier shortcut & \secref{QUALIFIER-SHORTCUT-DEFINITION} \\
lexeme replacement & \secref{LEXEME-REPLACEMENT-DEFINITION} \\
unit specifier & \secref{UNIT-SPECIFIER-DEFINITION}
\end{tabular}
\end{center}

A \key{parser definition}\label{PARSER-DEFINITION}
just names a parser.  The most recent parser
definition in the parsing stack names the parser used to parse expressions.
Parser definitions have the syntax:

\begin{indpar}
\ikey{PARSER-DEFINITION}{parser-definition} \\
	\hspace*{0.5in}::= \verb|define parser| {\em PARSER-NAME} \\
\ikey{PARSER-NAME}{parser-name} ::=
	\verb|[| {\em word} {\em word}\,$^\star$ \verb|]|
\end{indpar}

It is possible to temporarily void parser definitions by
placing canceling undefinitions in the parsing stack.  These have the
syntax:

\begin{indpar}
\ikey{PARSER-UNDEFINITION}{parser-undefinition} ::= \verb|undefine parser|
\end{indpar}

This undefinition, as long as it is in the stack, cancels the effect 
of the parser definition that would be used if the undefinition were not
in the stack.

There are three standard \ikey{parsers}{parser!standard}:
the \key{marks parser} \ttkey{-MARKS-PARSER-},
where only the optional argument mark (\verb|::?|), reorder mark (\verb|<:>|),
remainder mark (\verb|::>|), required qualifier mark (\verb|@@|),
and optional qualifier mark (\verb|??|), are recognized;
the \key{operators parser} \ttkey{-OPERATORS-PARSER-},
where these marks
are recognized along with operators, qualifiers, and qualifier shortcuts,
and where lexical parsing (\secref{LEXICAL-PARSING}) is performed;
and the \key{text parser} \ttkey{-TEXT-PARSER-},
where only the format-separator (\verb/|/) and punctuation are recognized.

From the parsing point of view there are several types of
expression restructuring that can occur.  One, text restructuring,
is done by the text parser (\secref{TEXT-PARSING}), which is invoked by
\verb|`'| quotes, and does things like turn
\verb|`I am!'| into \verb|[-SENTENCE- I am !]|.  Other kinds of
restructuring are done by the operators parser (\secref{OPERATORS}).
The operators `\verb|+|', `\verb|-|', and `\verb|*|' in the expression
\verb|x + y - 5 * z| cause this expression to be restructured as
\verb|[- [+ x y] [* 5 z]]|.  The qualifier `\verb|with|' in the
expression \verb|sort x with order ascending| causes this expression
to be restructured as \verb|[sort x @@ with order ascending]|.
The qualifier shortcut `\verb|ascending|' in the expression
\verb|sort x| \verb|ascending| causes this expression to be
restructured as \verb|[sort x @@ with order ascending]|.
In addition, lexical parsing (\secref{LEXICAL-PARSING}) is performed
by the operators parser.

In expressions that cannot contain operators,
words and separators that would be recognized elsewhere as operators,
qualifiers, or qualifier shortcuts are not recognized as such.  Thus in
\verb|[word +]| the \verb|+| is not recognized as an operator, and
in \verb|[item ascending]| \verb|ascending| is not recognized as
a qualifier shortcut.

Some of the matchfix operators above affect evaluation.
Evaluation differs from parsing in that it is managed by a
counter and not a stack; if evaluation is
turned off twice, it must be turned on twice to be in effect.
Thus in a context in which evaluation is on, the \verb|X| in
\verb|{ <<X>> = 5 }| and \verb|{ y = `<< <<X>> >>' }| will be evaluated
but the \verb|X| in \verb|{ y = `<<X>>' }| will not be.  There is
an \key{evaluation counter} value that is
incremented (decremented) by an opening mark
that turns evaluation on (off), and decremented (incremented) by the
corresponding closing mark.  This counter sticks at +1: matching
lexemes that would increment the counter have no affect if the counter
is at +1.

The brackets `\verb|<<<|\ldots\verb|>>>|' are equivalent to
`\verb|<< <<|\ldots\verb|>> >>|' and thus turn evaluation on twice.
Thus \verb|{ y = `<< <<X>> >>' }| is equivalent to \verb|{ y = `<<<X>>>' }|.
Similarly the brackets `\verb|<<<<|\ldots\verb|>>>>|'
are equivalent to `\verb|<< << <<|\ldots\verb|>> >> >>|' and
turn evaluation on thrice.

Evaluation is not part of parsing; the evaluation counter is
used during expression evaluation, which occurs after expression parsing.
Parsing does insert the wrappers (\secref{OPERATOR-WRAPPER})
\ttkey{-EVAL-OFF-} and \ttkey{-EVAL-ON-} around expressions to inform
the evaluator when to decrement or increment the evaluation counter.

\subsection{Raw Expressions}
\label{RAW-EXPRESSIONS}

A raw expression is an expression that contains no operators,
qualifiers, qualifier shortcuts, or text parsing contexts that
induce restructuring.
Raw expressions can be directly represented using the \verb|[]|
matching lexemes and the \verb|::?| optional argument,
\verb|<:>| reorder, \verb|::>| remainder,
\verb|@@| required qualifier, and \verb|??| optional qualifier marks.

When an expression is parsed, the output is a raw expression.
The following are examples, in which the input expressions are assumed to
appear in the context of \verb|{}| matching lexemes (so
operators, qualifiers, and qualifier shortcuts
are turned on and text parsing is turned off):

\begin{center}
\begin{tabular}{ll}
Input Expression	& Raw Expression Equivalent \\[1ex]
\verb|x|		& \verb|x| \\
\verb|(+)|		& \verb|+| \\
\verb|3 * x * x + 5|	& \verb|[+ [* [* 3 x] x] 5]| \\
\verb|x = y = 10|	& \verb|[= x [= y 10]]| \\
\verb|0 < x <= 5 |	& \verb|[-COMPARE- 0 < x <= 5]| \\
\verb|x = `Hello <<y>>.' |
			& \begin{tabular}[t]{@{}l}
	    \verb|[= x [-EVAL-OFF-| \\
	    \verb|      [-SENTENCE- Hello| \\
	    \verb|                  [-EVAL-ON- y]| \\
	    \verb|                  .]]]| \\
	    \end{tabular}
\end{tabular}
\end{center}

The syntax of raw expressions is defined as follows:

\begin{indpar}
\key{RAW-EXPRESSION} ::= {\em word} $|$ {\em separator}
				     $|$ {\em raw-subexpression} \\[1ex]
\key{raw-subexpression} ::=
	\begin{tabular}[t]{@{}ll}
	\verb|[| & {\em raw-expression-head} \\
		 & {\em raw-argument-list} \\
		 & {\em raw-qualifier-phrase}\,$^\star$ \verb|]| \\
	\end{tabular} \\[1ex]
\key{raw-expression-head} ::= {\em RAW-EXPRESSION} \\[1ex]
\key{raw-argument-list}
        \begin{tabular}[t]{@{}rl}
	::= & {\em raw-base-argument-list}
	      {\em raw-argument-remainder-option} \\
	$|$ & \begin{tabular}[t]{@{}l}
	      {\em raw-base-argument-list}
	      {\em optional-argument-mark} \\
	      {\em non-empty-raw-base-argument-list} \\
	      {\em raw-argument-remainder-option}
	      \end{tabular}
	\end{tabular} \\[1ex]
\key{optional-argument-mark} ::= \verb|::?| \\[1ex]
\key{raw-base-argument-list}
	::= {\em empty} $|$ {\em non-empty-raw-base-argument-list} \\[1ex]
\key{raw-non-empty-base-argument-list} \\
	\hspace*{0.5in}\begin{tabular}[t]{rl}
	::= & {\em raw-argument} \\
	    & \{ {\em reorder-mark-option} {\em raw-argument} \}\,$^\star$
	\end{tabular} \\[1ex]
\key{reorder-mark-option} ::= {\em empty} $|$ \verb|<:>| \\[1ex]
\key{raw-argument-remainder-option} ::=
	{\em empty} $|$ \verb|::>| {\em raw-argument} \\[1ex]
\key{raw-argument} ::= {\em RAW-EXPRESSION} \\[1ex]
\key{raw-qualifier-phrase} ::=
	{\em qualifier-mark} {\em raw-qualifier-head}
			     {\em raw-argument-list} \\[1ex]
\key{qualifier-mark} ::= {\em required-qualifier-mark}
			 $|$ {\em optional-qualifier-mark} \\[1ex]
\key{required-qualifier-mark} ::= \ttkey{@@} \\[1ex]
\key{optional-qualifier-mark} ::= \ttnbkey{??} \\[1ex]
\key{raw-qualifier-head} ::= {\em RAW-EXPRESSION}
\end{indpar}

The order of {\em raw-qualifier-phrases}
in a {\em RAW-EXPRESSION} does not matter.
The order of arguments separated by {\em reorder-marks} (\verb|<:>|) does
not matter.  The {\em optional-argument-mark} (\verb|::?|),
{\em reorder-mark} (\verb|<:>|), {\em remain\-der-mark}
(\verb|::>|), and {\em optional-qualifier-mark} (\verb|??|)
appear in patterns (\secref{PATTERN}), but not in evaluatable expressions.

\subsection{Operators}
\label{OPERATORS}

Operators restructure expressions in which they occur.  Operators
are defined by operator definitions that can be added to the
parsing stack.  Certain operators are `definitional'
(\pagref{DEFINITIONAL}), and it is just these operators which accept
definitions to be pushed into the parsing stack.

\subsubsection{Operator Definitions}
\label{OPERATOR-DEFINITIONS}

\ikey{Operator definitions}{operator definition} can be pushed onto
the parsing stack, and are used by the operators parser.
An operator definition specifies for each operator the following:

\begin{indpar}[1in]
Fixity \\
Name \\
Precedence \\
Associativity \\
Parser \\
Control Flags \\
Wrapper \\
Subdefinitions
\end{indpar}


\subsubsubsection{Operator Fixity}\ttmindex{fixity}{of operator}
\label{OPERATOR-FIXITY}
An operator has one of the following fixities:

\begin{indpar}
\begin{tabular}{@{}p{1in}@{~~~}p{4in}@{}}
\ttkey{infix}		& E.g., \verb|+| in \verb|x + 5|.\\
\ttkey{prefix}		& E.g., \verb|-| in \verb|- 5|.\\
\ttkey{postfix}		& E.g., \verb|!| in \verb|x!|.\\
\ttkey{matchfix}	& E.g., \verb/[| |]/ in \verb/[| x - 5 |]/.
\end{tabular}
\end{indpar}

An infix operator is placed between its two operands;
a prefix operator is placed before its one operand;
a postfix operator is placed after its one operand;
and a matchfix operator surrounds its one operand.
Operands of prefix, infix, and postfix
operators may not be empty; but the operand of a matchfix operator
may be empty.
An infix operator may not begin or end an expression;
a prefix operator must begin an expression;
a postfix operator must end an expression;
and a matchfix operator has two parts: an opening operator
that must begin an expression and a closing operator that must end
the same expression.

\subsubsubsection{Operator Name}\ttmindex{name}{of operator}
\label{OPERATOR-NAME}
An operator definition has a sequence of lexemes that is the
{\em name} of the operator.  The operator
inside a subexpression is just this sequence of lexemes, except for
matchfix operators, which have two sequences of lexemes, an
\key{opening operator name} that must begin the subexpression and
a \key{closing operator name} that must end the subexpression.

By abuse of language, the term `\key{operator}' is often used
as a synonym for `operator name'.  Similarly `\key{opening operator}'
is used as a synonym for `opening operator name' and `\key{closing operator}'
is used as a synonym for `closing operator name'.

The opening and closing names of a matchfix
operator are bundled into a single operator name that is
sequence of lexemes consisting of
the opening operator name followed by a `\verb/.../' lexeme
followed by the closing operator name.
For example, the
matchfix operator named `\verb/[ | ... | ]/' permits subexpressions
like `\verb/[| x - 5 |]/'.  Here the opening operator name
is `\verb/[|/' and the closing operator name is `\verb/|]/'.

A matchfix operator name must begin with an opening mark and end with
a matching closing mark.  Non-matchfix
operator names cannot contain opening or closing marks.

When a subexpression is tested
for matchfix operators, any explicit opening and closing marks that begin and
end the subexpression are included in the subexpression.  Implicit
parentheses, are not included.  Thus a matchfix operator
such as `\verb/(| ... |)/' can only be invoked with explicit parentheses,
and not with implicit parentheses.

\subsubsubsection{Operator Precedence}\ttmindex{precedence}{of operator}
\label{OPERATOR-PRECEDENCE}
The precedence of an operator is an integer.  Precedence is used in
selecting which infix operators in an expression to consider
(\secref{OPERATOR-SELECTION}).
Only infix operators have precedence.

\subsubsubsection{Operator Associativity}\ttmindex{associativity}{of operator}
\label{OPERATOR-ASSOCIATIVITY}
An infix operator has an {\em associativity} that is
a sequence of lexemes.
Three associativities, {\tt left}, {\tt right}, and
{\tt none}, have special meaning.  If an infix operator has some
other associativity, it is said to have \key{named associativity}.
Only infix operators have associativity.

If more than one infix operator of lowest precedence
is selected in an expression by the operator
selection algorithm\EOL (\secref{OPERATOR-SELECTION}),
all the infix operators that are selected
must have the identical operator definitions except for operator names,
and the associativity in these definitions
must not be {\tt none}\ttmindex{none}{associativity}.

In this situation we consider the following subcases.

If all operators are {\tt left} associative%
\index{left associative@{\tt left} associative},
all the infix operators but the rightmost are deselected,
so it is as if operators to the left had
higher precedence than those to the right.

If all operators are {\tt right} associative%
\index{right associative@{\tt right} associative},
all the infix operators but the leftmost are deselected,
so it is as if operators to the right had
higher precedence than those to the left.

If all operators are of \key{named associativity}, all remain selected, and 
implicitly parenthesized subexpressions will be created between the
operators as well as between the beginning of the expression and the
first operator and between the last operator and the end of the expression.
Then the associativity, as a lexeme sequence, is prepended to the expression.
Thus if the infix operators \verb|<| and \verb|<=| have associativity
\verb|-COMPARE-|, the expression \verb|0 < x - 3 <= 5| will
be rewritten first as \verb|[-COMPARE- 0 < (x - 3) <= 5]|,
and then finally as \verb|[-COMPARE- 0 < [- x 3] <= 5]|.

\subsubsubsection{Operator Parser}\ttmindex{parser}{of operator}
\label{OPERATOR-PARSER}

A parser is the name of the function that is called with an expression
as its single argument in order to parse the expression.

Parsers can be pushed onto the parsing stack.
The parser used for subexpressions of an expression is the parser
nearest the top of the parsing stack.

The \verb|parser| of an operator definition is an optional word that
names a parser.  If present, a {\em PARSER-DEFINITION}
(\pagref{PARSER-DEFINITION}) naming the parser is pushed onto the parsing
stack before subexpressions are parsed, and popped from the parsing stack
after subexpressions have been parsed.

The following are standard parsers:

\begin{indpar}

The \key{operators parser}, \ttkey{-OPERATORS-PARSER-}.
Lexical parsing is done.
Then operators, qualifiers, qualifier shortcuts,
and the \verb|::?| optional argument,
\verb|<:>| reorder, \verb|::>| remainder,
\verb|@@| required qualifier, and
\verb|??| optional qualifier marks are recognized.
The special constructs of text parsing, e.g., the \verb/|/ format separator,
are \underline{not} recognized.

The \key{marks parser}, \ttkey{-MARKS-PARSER-}.
Lexical parsing is \underline{not} done.
The \verb|::?| optional argument,
\verb|<:>| reorder, \verb|::>| remainder,
\verb|@@| required qualifier, and
\verb|??| optional qualifier marks are recognized.
Operators, qualifiers, qualifier shortcuts, and the special constructs
of text parsing, e.g., the \verb/|/ format separator,
are \underline{not} recognized.

The \key{text parser}, \ttkey{-TEXT-PARSER-}.
Lexical parsing is \underline{not} done.
The special constructs of text parsing (\secref{TEXT-PARSING}) are
recognized.
Operators, qualifiers, qualifier shortcuts, and the \verb|::?| optional
argument, \verb|<:>| reorder, \verb|::>| remainder,
\verb|@@| required qualifier, and
\verb|??| optional qualifier marks are \underline{not} recognized.

\end{indpar}

\subsubsubsection{Operator Control Flags}\ttmindex{control flag}{of operator}
\label{OPERATOR-CONTROL-FLAGS}
Operators can be associated with \skey{operator control flag}s that
affect parsing of subexpressions of the operator.

\begin{indpar}

{\bf definitional}\index{definitional flag@{\tt definitional} flag}%
\label{DEFINITIONAL}~~~~~
This flag may only be given for a right associative infix operator.
It causes the left operand of the operator to be inspected to see if it is
an expression beginning with the word `\ttkey{define}' or `\ttkey{undefine}'.
Such an expression
is called a \key{definition}, and is assumed to push a definition into
the parsing stack.
See \pagref{PARSING-STACK-DEFINITION-KINDS} for a list of the kinds of
definition that may be pushed into the parsing stack.

If its left operand is not a definition, nothing special is done by
a definitional operator.

If its left operand is a definition,
the left operand is executed by the parser and
may push definitions into the parsing stack, the expression containing
the infix operator is replaced by just its right operand,
the right operand is parsed, and then any definitions pushed while
executing the left operand are popped off the parsing stack.

\end{indpar}

\subsubsubsection{Operator Wrapper}\ttmindex{wrapper}{of operator}
\label{OPERATOR-WRAPPER}

An operator wrapper is a raw expression containing the lexeme `\verb|...|'.
If operator selection for an expression selects a single operator with a
wrapper, the expression is restructured to be a copy of the wrapper
with its `\verb|...|' lexeme replaced by the parse of the expression
being restructured.

For example, if the matchfix operator `\verb|<< ... >>|' has the
wrapper `\verb|[-EVAL-ON- ...]|', then the expression `\verb|<<x>>|'
will be restructured to be `\verb|[-EVAL-ON- x]|'.
See \pagref{WRAPPER-PROCESSING}.

\subsubsubsection{Operator Subdefinitions}\ttmindex{definition}{of operator}
\label{OPERATOR-SUBDEFINITIONS}

An operator definition can contain a list of definitions
that are pushed onto the parsing stack before the subexpressions
of the operator are parsed, and are popped from the stack after the
subexpressions are parsed.  To avoid confusion, these definitions
are called \skey{subdefinition}s.

Note that subdefinitions can include any definitions that can be 
pushed onto the parsing stack, and can also include undefinitions, that
inactivate all definitions with particular names in the stack.
See \pagref{PARSING-STACK-DEFINITION-KINDS} for a list of the kinds of
definition that may be pushed into the parsing stack.


\subsubsection{Operator Definition Syntax}
\label{OPERATOR-DEFINITION-SYNTAX}

The syntax of operator definitions is:

\begin{indpar}
\key{OPERATOR-DEFINITION} \\
	\hspace*{0.5in}::= \ttkey{define operator}
	    {\em OPERATOR-LABEL}
	    {\em operator-definition-qualifier}\,$^\star$
	    \\[1ex]
\key{OPERATOR-LABEL} ::=
	\verb|[|
	{\em operator-fixity} {\em operator-name}
	\verb|]| \\[1ex]
\key{operator-fixity} ::=
	\ttkey{prefix} $|$ \ttkey{infix} $|$ \ttkey{postfix}
	$|$ \ttkey{matchfix} \\[1ex]
\key{operator-name} ::=
	\{ {\em word} $|$ {\em separator} \}
	\{ {\em word} $|$ {\em separator} \}\,$^\star$
	\\[1ex]
\key{operator-definition-qualifier} \begin{tabular}[t]{rl}
                     ::= &  {\em operator-precedence-qualifier} \\
                     $|$ &  {\em operator-associativity-qualifier} \\
                     $|$ &  {\em operator-parser-qualifier} \\
                     $|$ &  {\em operator-flags-qualifier} \\
                     $|$ &  {\em operator-wrapper-qualifier} \\
                     $|$ &  {\em operator-subdefinition-qualifier} \\
		     \end{tabular} \\[1ex]
\key{operator-precedence-qualifier} ::=
	\ttkey{with precedence} {\em INTEGER} \\[1ex]
\key{operator-associativity-qualifier} \\
	\hspace*{0.5in}\begin{tabular}[t]{rl}
	::= &  \ttkey{with associativity} {\em OPERATOR-ASSOCIATIVITY} \\
	$|$ &  \ttkey{left} \\
	$|$ &  \ttkey{right}
	\end{tabular} \\[1ex]
\key{OPERATOR-ASSOCIATIVITY} \\
        \hspace*{0.5in}::=
	\verb|[|
	\{ {\em word} $|$ {\em separator} \}
	\{ {\em word} $|$ {\em separator} \}\,$^\star$
	\verb|]| \\[1ex]
\key{operator-parser-qualifier} ::=
	\ttkey{with parser} {\em PARSER-NAME} \\[1ex]
\ikey{PARSER-NAME}{parser-name} ::=
	\verb|[|
	\{ {\em word} $|$ {\em separator} \}
	\{ {\em word} $|$ {\em separator} \}\,$^\star$
	\verb|]| \\[1ex]
\key{operator-flags-qualifier} \\
	\hspace*{0.5in}\begin{tabular}[t]{rl}
	::= &  \ttkey{with flags} {\em OPERATOR-FLAGS} \\
	$|$ &  \ttkey{definitional}
	\end{tabular} \\[1ex]
\key{OPERATOR-FLAGS} ::=
	\verb|[|
	\{ {\em word} $|$ {\em separator} \}
	\{ {\em word} $|$ {\em separator} \}\,$^\star$
	\verb|]| \\[1ex]
\key{operator-wrapper-qualifier} ::=
	\ttkey{with wrapper} {\em OPERATOR-WRAPPER} \\[1ex]
\key{OPERATOR-WRAPPER} ::=
	\verb|[|
	\{ {\em word} $|$ {\em separator} \}
	\{ {\em word} $|$ {\em separator} \}\,$^\star$
	\verb|]| \\[1ex]
\key{operator-subdefinitions-qualifier} ::=
	\ttkey{with subdefinitions} {\em subdefinitions-block} \\[1ex]
\key{subdefinitions-block} ::=
	\verb|{| {\em declaration-group} \verb|}| \\[1ex]
\key{declaration-group} ::= see \pagref{DECLARATION-GROUP}
\end{indpar}

which correspond to the definitions
(\secref{EXPRESSION-DEFINITIONS}):

\begin{indpar}
\begin{verbatim}
define qualifier with

define qualifier shortcuts
       ( [left => with associativity [left]],
         [right => with associativity [right]],
         [definitional => with flags [definitional]] )

define define operator LABEL
       ?? with precedence PRECEDENCE
       ?? with associativity ASSOCIATIVITY
       ?? with parser PARSER
       ?? with flags FLAGS
       ?? with wrapper WRAPPER
       ?? with subdefinitions SUBDEFINITIONS
       <--
\end{verbatim}
\end{indpar}

It is possible to temporarily void an operator definition by
placing a canceling undefinition in the parsing stack.  This has the
syntax:

\begin{indpar}
\ikey{OPERATOR-UNDEFINITION}{operator-undefinition} \\
	\hspace*{0.5in}::= \verb|undefine operator|
	~ {\em OPERATOR-FIXITY} ~ {\em OPERATOR-NAME}
\end{indpar}

\subsubsection{Operator Selection}
\label{OPERATOR-SELECTION}

The operator selection algorithm is run by the
the \mkey{operators parser}{operator selection},
\ttmkey{-OPERATORS-PARSER-}{operator selection}, to check an expression
for operators.
This algorithm selects operators whose name appears in the expression,
and then applies rules to de-select some selected operators.  If at the end
of the algorithm there is exactly one operator selected, the definition
of that operator is used to restructure the expression.  If there is more
than one operator selected, it is a parse error unless the definitions of
all selected operators are identical except for operator names, in which
case the common part of these definitions is used to restructure the expression.

The operator selection algorithm uses the current parsing definition stack
to determine which operators are defined.  For this algorithm,
the most important parts of each
operator definition are the operator name and operator fixity.

The operator selection algorithm produces a result that is often
the same as the more common operator precedence rules for parsing expressions.
However, in CASTLE an operator can change the parsing stack
used to parse its operand subexpressions, and this allows CASTLE to
to use various grammars for subexpressions.\footnote{In practice
we expect this may be equivalent to using an operator precedence grammar
to parse everything outside explicit opening and closing marks, and only
permitting matchfix operators to change grammars.  But CASTLE currently
has more capabilities than this, and it is a matter or experiment to
see whether these extra capabilities are useful.}

In the operator selection algorithm the concepts of prefix sequence and
postfix sequence are used.
A \key{prefix sequence} is a sequence of defined prefix operator names.
A \key{postfix sequence} is a sequence of defined postfix operator names.

The \key{operator selection algorithm} executes the following
steps in the order given, repeating each step until it does nothing new
before proceeding to the next step.

\begin{enumerate}

\item
If the expression begins with an implicit `\verb|(|' and ends with an
implicit `\verb|)|', then
discard the beginning `\verb|(|' and ending `\verb|)|'.

Similarly if the expression begins with an explicit
`\verb|(|' and ends with an explicit `\verb|)|', and if
there is \underline{no} defined matchfix operator whose opening name
begins the expression and whose closing name ends the expression, then
discard the beginning `\verb|(|' and ending `\verb|)|'.

\item
Select any defined matchfix operator whose opening name
begins the expression and whose closing name ends the expression.

\item
If two matchfix operators are selected, the opening operator name
of the first is longer than the opening operator name of the second,
and the closing operator name
of the first is longer than the closing operator name of the second,
then the second operator is deselected.

Thus if `\verb/[| ... |]/' and `\verb/[ ... ]/' are two selected
matchfix operators, the second will be deselected.

\item
If more than one matchfix operator is still selected, the parse is in error.

\item
If a matchfix operator is selected, the algorithm terminates successfully
at this point, without selecting any other operators.
The part of the expression between the opening operator name and closing
operator name is the sole operand of the matchfix operator.  This operand
is implicitly parenthesized, and may be empty.

\item
Select all defined infix operators that occur in the expression.

\item
If two selected infix operators overlap, and one includes and is longer
than the other, deselect the shorter included operator.

\item\label{INFIX-DESELECTION-STEP}
De-select any infix operator that is included in a prefix sequence
and not preceded by a non-empty postfix sequence if the infix operator is
preceded by the beginning of the expression, by an infix operator selected
by the last step,
or by a non-empty part of a prefix sequence that includes the infix operator.

De-select any infix operator that is included in a postfix sequence
and not followed by a non-empty prefix sequence if the infix operator is
followed by the end of the expression, by an infix operator selected by the
last step,
or by a non-empty part of a postfix sequence that includes
the infix operator.

Thus in the expression `\verb|x + - y|', `\verb|-|' would be deselected
as an infix operator by this step, as it is a prefix operator not
preceded by an postfix operator that is proceeded by an infix operator.
However `\verb|+|' would not be deselected, as it is not preceded by
an operator or expression beginning.

\item The parse is in error if two consecutive or overlapping
infix operators are still selected at this point, or if a still
selected infix operator begins or ends the expression.

\item\label{LOWER-PRECEDENCE-STEP}
If two infix operators are selected, and one has strictly lower
precedence than another, de-select the operator with higher precedence.

\item
If several infix operators are still selected at this point, all these
operators must have the same associativity, which must not be `\verb|none|'.
Otherwise the parse is in error.

\item
If several infix operators are selected at this point and their common
associativity is `\verb|left|', all but the rightmost infix operator
are deselected.
Similarly if several infix operators are selected at this point and their common
associativity is `\verb|right|', all but the leftmost infix operator
are deselected.

\item
If several infix operators are still selected at this point, all these
operators must have the same definitions except for operator names.
Otherwise the parse is in error.

\item
If any infix operators are still selected at this point, the algorithm
terminates successfully.
The parts of the expression between the operators, before the first
operator, and after the last operator are the operands, and are
implicitly parenthesized.  No operand is empty.

\item
Select all prefix operators that begin the expression, and all postfix
operators that end the expression.

\item
If two prefix operators are selected, and one is longer than the other,
de-select the shorter.
Similarly, if two postfix operators are selected,
and one is longer than the other,
de-select the shorter.

\item
If both prefix and postfix operators are selected at this point, the postfix
operators are deselected.  Thus postfix operators are in effect
given precedence over prefix operators.

\item
If more than one operator is selected at this point, the parse is in error.
This would be the result of ambiguity among prefix operators, or ambiguity
among postfix operators.

\item
If one operator is selected at this point, and the operator name
is the entire expression, de-select the operator.  Thus
in the expression `\verb|x = (+)|', `\verb|+|' will be deselected
when the subexpression `\verb|(+)|' is parsed.

\item
The algorithm terminates successfully
at this point with zero operators selected,
or with one prefix or postfix operator selected.
If there is one selected operator, the part of the expression
that is not the operator name is the sole operand, and is implicitly
parenthesized.  Note this operand cannot be empty.

\end{enumerate}

As noted above, the parsing stack can be changed before subexpressions
are parsed, but the definitions of prefix, postfix, and infix operators
before the change affect operator selection.  It is possible for
parsing stack changes to produce anomalous seeming results.  For
example, if a parsing stack change introduced by the infix operator
\verb|+*+| defines a new prefix operator named \verb|*|,
where \verb|*| was previously as just an infix operator,
then the expression `\verb|x +*+ * y|' would be illegal, because
\verb|*| would not be defined as a prefix operator soon enough.
In this case one would have to write
`\verb|x +*+ (* y)|' to get a legal parse.


\subsubsection{Post Operator Selection Processing}
\label{POST-OPERATOR-SELECTION-PROCESSING}

Post operator selection processing is done after operator selection by
the \mkey{operators parser}{post operator selection}
\ttmkey{-OPERATORS-PARSER-}{post operator selection},
whether or not any operators are selected.
After operators are selected without a parse error, all the selected
operators have identical definitions except for operator name.
The common part of these definitions, which we will refer to as
`the operator definition', is used to control post operator selection
processing of the expression containing the operators.  If no operators are
selected, a definition containing no optional parts (no named associativity,
no parser, no control flags, no wrapper, no subdefinitions) is used
to control post operator selection processing.

Post operator selection processing is done in the following steps.

\begin{enumerate}

\item\label{PARSER-PUSH}
If the operator definition has a parser, this is pushed onto the
parsing parser stack.

\item\label{SUBDEFINITION-PUSH}
If the operator definition has subdefinitions, these are pushed onto the
parsing definition stack.

\item
\label{PARSE-SUBEXPRESSIONS}
Subexpressions are parsed left to right by calling the parser at the
top of the parsing parser stack, and subexpressions are replaced by
their parsed versions.

An exception is made if the operator definition has the
\ttmkey{definitional}{control flag} control flag (note the operator must
be {\tt right} associative) and if the first
subexpression, after being parsed, is a definition that can be pushed onto the
parsing stack.  In this case, this definition
is pushed onto the parsing stack, the second subexpression is parsed,
the current expression is replaced by the parsed second expression,
and parsing continues at step~\stepref{POP-PARSING-STACK} below.

\item
If the operator definition has no wrapper, it is processed as follows:

\begin{enumerate}

\item
If the operator definition has named associativity,
this associativity is prepended to the expression.

\item
Otherwise if the operator definition is not {\tt matchfix},
any selected operator (there can be at most one) is moved to the
beginning of the expression.

\item
Otherwise if the operator definition is {\tt matchfix}, the
parse is in error.

\end{enumerate}

\item
If the operator definition has a wrapper,\label{WRAPPER-PROCESSING}
it is processed as follows:

\begin{enumerate}

\item If the operator definition does not have named associativity,
all selected operators are removed from the expression.

\item
The expression is
replaced by its wrapper with the word \verb|...| in the wrapper
replaced by the expression.

\end{enumerate}

\item
\label{POP-PARSING-STACK}
If anything was pushed onto the parsing stack
by steps~\ref{PARSER-PUSH} and \ref{SUBDEFINITION-PUSH}
above, these things
are popped from the stack.

\item
The expression is returned as the result of parsing the expression.

\end{enumerate}

\subsubsection{Equivalence to Classical Parsing}
\label{EQUIVALENCE-TO-CLASSICAL-PARSING}

In this section we prove that the operator selection algorithm of
\secref{OPERATOR-SELECTION} is equivalent to the classical expression
parsing algorithm in typical circumstances.

First we define classical parsing.  A \key{classical parse}
is a parse according to the syntax equations:

\begin{indpar}
{\em expression} ::= {\em expression$_0$} \\[1ex]
{\em expression$_n$} ::= {\em expression$_{n+1}$}
	\{ {\em infix-operator$_n$} {\em expression$_{n+1}$} \}$^\star$
	~~~ ( $0\leq n\leq M$ ) \\[1ex]
{\em expression$_{M+1}$} ::=
	{\em prefix-operator}$^\star$
	{\em expression$_{M+2}$} \\[1ex]
{\em expression$_{M+2}$} ::=
	{\em expression$_{M+3}$}
	{\em postfix-operator}$^\star$
	\\[1ex]
{\em expression$_{M+3}$} ::= {\em non-operator} {\em non-operator}$^\star$ $|$
	\verb|(| {\em expression} \verb|)| \\[1ex]
{\em infix-operator$_n$} ::= infix operator of precedence $n$
	~~~ ( $0\leq n\leq M$ ) \\[1ex]
{\em infix-operator} ::= {\em infix-operator$_0$} $|$ \ldots $|$
	{\em infix-operator$_M$} \\[1ex]
{\em operator} ::= {\em prefix-operator} $|$ {\em postfix-operator}
	$|$ {\em infix-operator} \\[1ex]
{\em non-operator} ::= lexeme that is not an {\em operator} or parenthesis
\end{indpar}

We want to show that the parse of any expression which has an unambiguous
classical parse is obtained by the operator selection algorithm of
\secref{OPERATOR-SELECTION}, and conversely, that if the operator selection
algorithm obtains a parse, that parse is an unambiguous classical parse.
In order to show these things we must assume:

\begin{list}{}{}

\item[A1.] All operators are defined in the parsing stack, and the parsing
stack does not change during the expression parse.

\item[A2.] There are no matchfix operators (these behave just like
parentheses except for overlap situations).

\item[A3.] No two operators can overlap.  (This is trivial if
all operators are just a single lexeme).

\item[A4.] No operator can overlap a non-operator.

\item[A5.] No operator is both prefix and postfix.

%% Warning: A1-A5 and A5 are referenced below.

\end{list}

Here we mean by `operator' the lexemes that represent an operator, so
one operator can be both infix and prefix.  However no operator can
be infix with two different precedences.

The last assumption reflects a minor distinction between
the operator selection algorithm and classical parsing.

It will be convenient to use the following alternative parsing.
A \key{semi-classical parse} is a parse according to the syntax
equations:

\begin{indpar}
{\em expression} ::= {\em primitive-expression}
	\{ {\em infix-operator} {\em primitive-expression} \}$^\star$ \\[1ex]
{\em primitive-expression} ::= {\em prefix-operator}$^\star$
	{\em atomic-expression} {\em postfix-operator}$^\star$ \\[1ex]
{\em atomic-expression} ::= {\em non-operator} {\em non-operator}$^\star$ $|$
	\verb|(| {\em expression} \verb|)|
\end{indpar}

One can then prove the following:

\begin{lemma}
There is a 1-1 correspondence between classical and semi-classical
parses of an expression such that corresponding parses have exactly the same
{\em infix-operators}, {\em prefix-operators}, and {\em postfix-operators}.
\end{lemma}

Proof: By induction on the size of the parse trees.

\begin{corollary}
If an expression has two different classical parses, some operator in the
expression must have different fixities in the two parses.
\end{corollary}

Proof: Two semi-classical parses of the expression that have the
same operators with the same fixities must be identical.

\begin{lemma}\label{CLASSICAL-PARSE-CONTEXT-LEMMA}
In a classical parse of an {\em expression}:
\begin{list}{}{}
\item[(a)] the {\em expression} is not empty,
\item[(b)] the {\em expression} does not end with an {\em operator}
that is not a {\em postfix-operator},
\item[(c)] the {\em expression} does not begin with an {\em operator}
that is not a {\em prefix-operator},
\item[(d)] each {\em prefix-operator} is preceded by the
beginning of the {\em expression}, or by a \verb|(|,
or by an {\em infix-operator}, or
by a {\em prefix-operator},
\item[(e)] each {\em postfix-operator} is followed by the
end of the expression, or by a \verb|)|, or by an {\em infix-operator}, or
by a {\em postfix-operator},
\item[(f)] an {\em expression$_n$} cannot contain outside paraentheses any
{\em infix-operator$_m$} for $m<n$.

\end{list}
\end{lemma}

Proof: Each part can be proved separately by induction on the syntax equations.

\begin{lemma}\label{SEMI-CLASSICAL-PARSE-CONTEXT-LEMMA}
In a semi-classical parse of an {\em expression}:
\begin{list}{}{}
\item[(a)] no {\em primitive-expression} is empty,
\item[(b)] an {\em infix-} or {\em postfix-operator} must be preceded by a
{\em primitive-expression},
\item[(b)] an {\em infix-} or {\em prefix-operator} must be followed by a
{\em primitive-expression}.

\end{list}
\end{lemma}

Proof: Each part can be proved separately by induction on the syntax equations.

\begin{lemma}\label{CLASSICAL-PARSE-AMBIGUITY-LEMMA}
If an {\em expression} has a classical parse and also contains a sequence
`$X$ $Y$' of two operators such that $X$ can be either postfix or infix
and $Y$ can be either infix or prefix, then the {\em expression} has
more than one distinct classical parse (or in other words, has an
`\key{ambiguous}' classical parse).
\end{lemma}

Proof:  The {\em expression} has a semi-classical parse and must by
Lemma~\ref{SEMI-CLASSICAL-PARSE-CONTEXT-LEMMA} be of the form:

\begin{center}
\ldots {\em primitive-expression} $X$ $Y$ {\em primitive-expression} \ldots
\end{center}

This permits $X$ to be an infix operator and $Y$ to be a prefix operator,
or $X$ to be a postfix operator and $Y$ to be an infix operator, giving
two semi-classical parses, which in turn give two distinct classical
parses.  QED

\begin{theorem}
If an {\em expression} has a unique unambiguous classical parse,
the operator selection algorithm of \secref{OPERATOR-SELECTION} will
produce exactly this parse, provided assumptions A1-A5 of this
section hold.
\end{theorem}

Proof: By induction on the classical syntax equations.  The main step is
proving that given

\begin{center}
{\em expression$_n$} ::= {\em expression$_{n+1}$}
	\{ {\em infix-operator$_n$} {\em expression$_{n+1}$} \}$^\star$
\end{center}

the {\em infix-operator$_n$}'s are exactly the operators selected at the
end of step~\stepref{LOWER-PRECEDENCE-STEP} of the operator selection
algorithm.
Each {\em infix-operator$_n$} is preceeded by an
{\em expression$_{n+1}$} that by Lemma~\ref{CLASSICAL-PARSE-CONTEXT-LEMMA}
cannot end in a prefix or infix operator
that is not also a postfix operator.
And each {\em infix-operator$_n$} is followed by an
{\em expression$_{n+1}$} that by Lemma~\ref{CLASSICAL-PARSE-CONTEXT-LEMMA}
cannot begin with a postfix or infix operator
that is not also a prefix operator.
So no {\em infix-operator$_n$} is deselected by
step~\stepref{INFIX-DESELECTION-STEP} of the operator selection algorithm.
It remains to show that no {\em expression$_{n+1}$} contains an infix
operator outside parentheses that is not deselected by
step~\stepref{INFIX-DESELECTION-STEP}.

No {\em expression$_{n+1}$} can contain an infix operator of precedence
below $n+1$ outside parentheses, by Lemma~\ref{CLASSICAL-PARSE-CONTEXT-LEMMA}.
But these subexpressions might contain
an infix operator of precedence below $n+1$ outside parentheses
if that operator is prefix or postfix in the classical parse,
and we must show that these are deselected by
step~\stepref{INFIX-DESELECTION-STEP} of the operator selection algorithm.

We will show that every {\em prefix-operator} or {\em postfix-operator} of
the classical parse of {\em expression$_n$} that is outside parentheses
and that can also be an infix operator is deselected by
step~\stepref{INFIX-DESELECTION-STEP} of the operator selection algorithm.
We will give the argument for {\em prefix-operators} and leave the
symmetical argument for
{\em postfix-operators} to the reader.

By Lemma~\ref{CLASSICAL-PARSE-CONTEXT-LEMMA}
a prefix operator outside parentheses is preceded by
the beginning of the expression, or by an infix operator, or by another
prefix operator.  If it is preceded by the beginning of expression or
by another prefix operator, it must be deselected by
step~\stepref{INFIX-DESELECTION-STEP}, as by assumption A5
a prefix operator cannot be a postfix operator.
If it is preceded by an infix operator that is a postfix operator, then
we have a sequence of two infix operators, the first of which can also be
a postfix operator, and the second of which can also be a prefix operator.
But by Lemma~\ref{CLASSICAL-PARSE-AMBIGUITY-LEMMA}
this would make the classical parse of the expression
ambiguous, which is disallowed, so this case cannot happen.


QED

\begin{lemma}\label{SUBEXPRESSION-DESELECTION-LEMMA}
Given assumptions A1-A5,
if an infix operator is deselected by step~\stepref{INFIX-DESELECTION-STEP}
during a successful parse of an expression
by the operator selection algorithm, then it
will be deselected by step~\stepref{INFIX-DESELECTION-STEP} when any
subexpression of the expression is parsed by a recursive call made
during the operator selection algorithm.
\end{lemma}

Proof: Suppose the operator was deselected because it was a prefix
operator preceeded by a prefix operator that cannot be a postfix
operator, or by an infix operator that cannot be a postfix operator,
or by the beginning of the expression.  Then this will also be true
in the subexpression, though any preceding operator may be replaced
by a subexpression beginning.  A symmetrical argument applies to
deselected postfix operators.  QED

\begin{theorem}
If a sequence of lexemes is successfully
parsed by the operator selection algorithm under assumptions A1-A5,
the resulting parse is the unique classical parse of the sequence.
\end{theorem}

Proof:  By induction on the length of the sequence of lexemes,
any parse produced by the operator selection algorithm that contains
all the operators in the lexeme sequence is a classical parse.

TBD

\subsection{Qualifiers}
\label{QUALIFIERS}

TBD

\subsection{Text Parsing}
\label{TEXT-PARSING}

\ikey{Text parsing}{text parsing} is performed by the \ttkey{-TEXT-PARSER-},
which is the parser for subexpressions of the
\verb|`|...\verb|'|,
\verb|``|...\verb|''|,
\verb|```|...\verb|'''|, etc. matchfix operators.
The \verb/|/ format separator and sentence and paragraph ends are
recognized by text processing, while
operators, qualifiers, qualifier shortcuts, and
the \verb|::?|, \verb|<:>|, \verb|::>|, \verb|@@|, and
\verb|??| marks are \underline{not} recognized.

Text parsing is normally done in the context of a pair of matched
{\em quotes}, and in this context {\em white-space} pre-lexemes
become lexemes.  Note that {\em white-space} lexemes all consist
of zero or more {\em vertical space} characters followed by zero or
more {\em single-space} characters (see \secref{WHITE-SPACE-CONVERSION}).
There are three kinds of {\em white-space} lexemes
used by text parsing:

\begin{list}{}{}

\item[{\bf Spacer Lexemes}.]
A \key{spacer} lexeme is a {\em white-space} lexeme containing
only single spaces.  Spacers are used in text parsing if they follow
a \verb\|\ format separator on a line.

\item[{\bf Line Separator Lexemes}.]
A \key{line separator} lexeme is a {\em white-space}
lexeme that contains a single {\em line-feed} character and no other
{\em vertical-space} characters.  Such lexemes separate
non-blank lines, and are used by text parsing to end lines containing
a \verb\|\ format separator.

\item[{\bf Blank Line Lexemes}.]
A \key{blank line} lexeme is a {\em white-space}
lexeme that contains either two or more {\em line-feed} characters or contains
a {\em vertical-space} character that is not a {\em line-feed} character.
Such lexemes
represent blank lines between non-blank lines, and are used by text parsing
both to end lines containing a \verb\|\ format separator and
to separate paragraphs.

\end{list}

\subsubsection{Section, Paragraph, and Sentence Parsing}
\label{SECTION-PARAGRAPH-AND-SENTENCE-PARSING}

If the text being parsed does not contain any format separators,
the text is parsed into phrases, sentences, and paragraphs.

First the text is divided by blank line lexemes into paragraphs.
The sequence of paragraphs comprises a section.

Then in each paragraph, sentence terminators are located.
White-space lexemes in the paragraph are deleted after sentence terminators
are located.
Each sequence
of lexemes or subexpressions ending in a sentence terminator
is made into a sentence, and any
non-empty sequence
of lexemes or subexpressions following the last sentence terminator
is made into a phrase.
The paragraph is then a sequence of zero or more sentences 
possibly followed by a phrase.

The syntax of the result is:

\begin{indpar}
\key{section} ::= \verb|[-SECTION-| {\em paragraph} {\em paragraph}\,$^\star$
                  \verb|]| \\[1ex]
\key{paragraph}
	\begin{tabular}[t]{rl}
	::= &  \verb|[-PARAGRAPH-| {\em sentence} {\em sentence}\,$^\star$
	       \verb|]| \\
	$|$ &  \verb|[-PARAGRAPH-| {\em sentence}\,$^\star$ {\em phrase}
	       \verb|]|
	\end{tabular} \\[1ex]
\key{sentence} ::= \verb|[-SENTENCE-| {\em sentence-non-terminator}\,$^\star$
                                    {\em sentence-terminator}
                  \verb|]| \\[1ex]
\key{phrase} ::= \verb|[-PHRASE-| {\em sentence-non-terminator}
                                    {\em sentence-non-terminator}\,$^\star$
                  \verb|]| \\[1ex]
\key{sentence-terminator} ::= \verb|.| $|$
                              \verb|?| $|$
                              \verb|!| \\[1ex]
\key{sentence-non-terminator} ::= {\em word} $|$
                                  {\em separator} $|$
                                  {\em subexpression}
\end{indpar}

There are several rules that modify the description just given:

{\bf Sentence Terminator Rule.}\index{Sentence Terminator Rule}
A \key{sentence-terminator} is any lexeme that is syntactically
a sentence terminator, that is not preceded by a {\em white-space}
lexeme, and that is followed by a {\em white-space} lexeme, a
{\em closing-mark} lexeme, or the
end of the lexeme sequence.  All other lexemes and all subexpressions are
\skey{sentence-non-terminator}s.

{\bf Initial Capitalization Rule.}\index{Initial Capitalization Rule}
A {\em word} consisting of an initial capital letter followed
by zero or more lower case letters is converted
to an all lower case word if it begins a sentence.
A {\em word} consisting of an initial
\verb|^|\index{^@{\tt \Circumflex}} followed by an upper
case letter followed by zero or more lower case letters has the
initial \verb|^| removed.

{\bf Text Simplification Rule.}\index{Text Simplification Rule}
If the {\tt -TEXT-PARSER-} is to return a {\em section} with just
one {\em paragraph} and that {\em paragraph} contains nothing but
just one {\em sentence} or {\em phrase},
then just the {\em sentence} or {\em phrase} is returned.
Otherwise, if a {\em section} with just one {\em paragraph} is
to be returned, just the {\em paragraph} is returned.


Some examples follow:

\begin{center}
\begin{tabular}{lcl}

\verb|`the wife of Bob'|
& parses as &
\verb|[-PHRASE- the wife of Bob]|
\\[2ex]
\verb|`She hit the ball.'|
& parses as &
\verb|[-SENTENCE- she hit the ball .]|
\\[2ex]
\begin{tabular}{@{}l@{}}
\verb|``^Bill swung.| \\
\verb|  But he missed!''|
\end{tabular}
& parses as &
\begin{tabular}{@{}l@{}}
\verb|[-PARAGRAPH- [-SENTENCE- Bill swung .]| \\
\verb|             [-SENTENCE- but he missed !]]|
\end{tabular}
\\[5ex]
\begin{tabular}{@{}l@{}}
\verb|``^I liked| \\
\verb|  the party.| \\
\verb|| \\
\verb|  Later, we caught| \\
\verb|  the bus.''|
\end{tabular}
& parses as &
\begin{tabular}{@{}l@{}}
\verb|[-SECTION-| \\
\verb|   [-PARAGRAPH-| \\
\verb|      [-SENTENCE- I liked the party .]]| \\
\verb|   [-PARAGRAPH-| \\
\verb|      [-SENTENCE- later , we caught the| \\
\verb|                  bus .]]]| \\
\end{tabular}

\end{tabular}
\end{center}

Note that capitalized words like proper names and `\verb|I|' need to be
prefixed by `\verb|^|' if they begin a sentence or phrase.


\subsubsection{Text with Format Separators}
\label{TEXT-WITH-FORMAT-SEPARATORS}

TBD

\section{Expression Graphs}
\label{EXPRESSION-GRAPHS}

Expression graphs store expressions.  An \key{expression graph}
is a directed possibly cyclic graph with labels on all arrows and on some
nodes, with a designated root node, and with a possibly empty
set of graph node valued variables.

Expression graph arrow and node labels 
must be single words or separators.  Labeled nodes cannot be the source
of any arrow.  Several arrows with the same source node may have the same
arrow label.

A node that does not have a label and is not the source of any arrows
is called a \key{null node}.\label{NULL-NODE}

An expression graph variable has a name, a value, and an optional default.
Variable names must be single words or separators.
Both the value and the default are graph nodes.  The default may be
missing.  Variable values are often, but by no means always, null nodes.

All nodes in an expression graph are reachable from either the root or
from the value or default of one of the graph's variables.

If there are no variables and no node is the destination
of more than one arrow, the graph is a tree.  In this case it is called
an \key{expression tree}.

There is a correspondence between raw expressions and certain expression
trees, called \skey{raw expression tree}s,
that is one-to-one, except that two raw expressions differing only
in the order of their qualifier clauses and the order of their reorderable
arguments correspond to the same expression tree.

There are several operations that convert raw expression trees into general
expression graphs (\secref{EXPRESSION-GRAPH-REPRESENTATION}).
All these use designated operators, such as
`\verb|//|', to identify expression graph variables and their values.
The most commonly used conversion operation also uses the convention that
words beginning with a capital letter or with `\verb|#|' followed by a
capital letter name expression graph variables.

\subsection{Expression Graph Notation}
\label{EXPRESSION-GRAPH-NOTATION}

The following is an example of the notation we will use to represent
expression graphs:%
\footnote{This notation is standard for feature structures:
e.g., see Bob Carpenter, {\em The Logic of Typed Feature Structures},
1992, Cambridge University Press}

\newcommand{\Glabel}[1]{\mbox{\tt #1}}
\newcommand{\Gvariable}[1]{\fbox{\tt #1}}
\newsavebox{\Gfbox}
\newcommand{\Gdefault}[1]{%
    \sbox{\Gfbox}{\fbox{\tt #1}}%
    {\setlength{\fboxsep}{0.01in}%
     \fbox{\usebox{\Gfbox}}%
    }}
\newenvironment{Graph}%
    { \( \left[ \begin{array}{l}}%
    {\end{array} \right] \) }
\newenvironment{Gchild}[1]%
    {\mbox{\tt #1}:
     \begin{array}{l}
     \rule{0in}{0in} \vspace{-0.15in} \\
     \left[ \begin{array}{l}}%
    {\end{array} \right] \\
     \rule{0in}{0in} \vspace{-0.15in}
     \end{array}}
% Gsingle is Gchild with only one thing in its brackets so
% the brackets can be eliminated.
\newenvironment{Gsingle}[1]%
    {\mbox{\tt #1}:
     \begin{array}{l}
     \rule{0in}{0in} \vspace{-0.15in} \\
     \begin{array}{l}}%
    {\end{array} \\
     \rule{0in}{0in} \vspace{-0.15in}
     \end{array}}

\begin{center}

\begin{Graph}
    \Gvariable{\CurlyBra ROOT\CurlyKet} \\
    \begin{Gchild}{fee}
	\Gvariable{X} \\
	\Glabel{51} \\
    \end{Gchild} \\
    \begin{Gchild}{fie}
	\Gvariable{X} \\
    \end{Gchild} \\
\end{Graph}
\hspace{0.3in}
\begin{Graph}
    \Gdefault{X} \\
    \begin{Gchild}{1}
	\Glabel{foe} \\
    \end{Gchild} \\
    \begin{Gchild}{2}
	\Glabel{fum} \\
    \end{Gchild} \\
\end{Graph}
\hspace{0.3in}
\begin{Graph}
    \Gvariable{Y} \\
    \Gdefault{Y} \\
    \begin{Gchild}{1}
	\Gvariable{\protect\CurlyBra 1\protect\CurlyKet} \\
    \end{Gchild} \\
    \begin{Gchild}{2}
	\begin{Gchild}{*}
	    \Gvariable{\protect\CurlyBra 1\protect\CurlyKet} \\
	\end{Gchild} \\
    \end{Gchild} \\
\end{Graph}


\end{center}

In this notation, the representation of a graph node is a set of lines
enclosed in [~] brackets.

If the node is the value or default of some variables,
the names of those variables, each enclosed in a box or double box, are the top
lines of the representation of the node.
A variable name is boxed if the node is the value of
a variable, and double boxed if the node is the default of the
variable.
In our example, \Gvariable{X}, and \Gvariable{Y}
designate nodes that are variable values and
\Gdefault{X} and \Gdefault{Y} designate nodes that are variable defaults.
The \key{root node} is treated
as if it were the value of a variable named `\verb|{ROOT}|',
and is therefore designated by \Gvariable{\CurlyBra ROOT\CurlyKet} in our
example.
A single node can be the value or default of several variables: in the
example one node is both the value and the default of \verb|Y|.

The example expression graph has two variables, \verb|X|
and \verb|Y|.  While all nodes in the expression graph must be reachable
from the root or from the value or default of some variable in the graph,
all nodes need not be reachable from the root,  The above example
is a single expression graph with a root and two variables, and \underline{not}
three expression graphs.

Two nodes with the same boxed name in their representation
are actually the same node in the graph, and
similarly two nodes with the same doubly boxed name in their
representation are actually the same node in the graph.  When several
nodes are the same in this sense, all but one of these must have only
boxed or doubly boxed names in its representation.

Sometimes it is necessary to indicate that two nodes are the same for
a node that is not the root or the value or default of any variable.
This is done by creating an
\key{expression graph pseudo-variable}\index{pseudo-variable!expression graph}%
\label{PSEUDO-VARIABLES}
whose name is a word or separator in curly brackets.  In the example,
\verb|{1}| is such a pseudo-variable name, and of course \verb|{ROOT}|
is a pseudo-variable name.  Pseudo-variable names are always boxed, and
never double boxed.

If a node has a label, that is the last line in the node's representation,
and is
immediately below any boxed or doubly boxed names.
There are no other lines in the representation.
In the above example, \Glabel{51} labels
the node that is the value of the variable \verb|X|.

If a node is the source of arrows in the directed graph,
representations of each arrow appear below any boxed or doubly
boxed variable names in the
representation of the node.  Each arrow representation consists of the
label of the arrow followed by a colon (:) followed by
a representation of the target node of the arrow.  This later
is of course surrounded by [] brackets.

It is permitted to omit the [] brackets when only one thing is
bracketed.  Thus the above example can also be rendered as:

\begin{center}

\begin{Graph}
    \Gvariable{\CurlyBra ROOT\CurlyKet} \\
    \begin{Gchild}{fee}
	\Gvariable{X} \\
	\Glabel{51} \\
    \end{Gchild} \\
    \begin{Gsingle}{fie}
	\Gvariable{X} \\
    \end{Gsingle} \\
\end{Graph}
\hspace{0.3in}
\begin{Graph}
    \Gdefault{X} \\
    \begin{Gsingle}{1}
	\Glabel{foe} \\
    \end{Gsingle} \\
    \begin{Gsingle}{2}
	\Glabel{fum} \\
    \end{Gsingle} \\
\end{Graph}
\hspace{0.3in}
\begin{Graph}
    \Gvariable{Y} \\
    \Gdefault{Y} \\
    \begin{Gsingle}{1}
	\Gvariable{\protect\CurlyBra 1\protect\CurlyKet} \\
    \end{Gsingle} \\
    \begin{Gsingle}{2}
	\begin{Gsingle}{*}
	    \Gvariable{\protect\CurlyBra 1\protect\CurlyKet} \\
	\end{Gsingle} \\
    \end{Gsingle} \\
\end{Graph}


\end{center}

\subsection{Pure Unification}
\label{PURE-UNIFICATION}

Informally, expression graph nodes represent expressions that
may be thought of as containing information, and the unification of
two nodes is then a node whose information content
is the least upper bound of the information content of each of
the two nodes taken separately.

CASTLE uses two forms of expression graph node unification.
The pure form, called `\key{pure unification}',
is just the standard labeled graph unification
algorithm, and is specified in this section.  The other form, which
has a special merge operation for nodes representing calls on
functions or builtin CASTLE operations, is called `call unification',
and is described in \secref{CALL-UNIFICATION}.

Unification of two expression graph nodes
either succeeds and produces a unique expression
graph node as its result, or fails and produces no result.

Unification algorithms use a set called the \key{merge set}
of node pairs called \skey{merge pair}s.  For pure unification of
two nodes, X and Y, this is initialized to the set containing
only the one merge pair, (X,Y).

A unification algorithm simply extracts a merge pair (M,N) from the
merge set, merges the two nodes named, M and N, and does this
repeatedly until the merge set is empty.  The algorithm succeeds if
every pair of nodes that must be merged can be merged.  When two nodes
are merged, they become the same node.  Merging two nodes can
create new merge pairs.  However, merging two nodes that are identical
does nothing, and since expression graph memory is finite,
the algorithm must terminate after all nodes are merged, if it does not
terminate before then.

In merging two nodes M and N, one of these nodes, say M, is replaced by
a forwarding pointer to the other node, say N, so every reference to M
becomes a reference to N.  N may also be modified by giving it a label
or creating arrows that it sources.  And as mentioned above, new merge
pairs may be created.

If a unification algorithm is unsuccessful, all changes to expression
graph memory are undone.

For pure unification of two nodes X and Y, the merge set is initially
the single pair (X,Y).  If unification is successful, X and Y are merged,
and the result of the unification is the merged node, i.e., the node
X, or equivalently the node Y.

It is possible to run unification with arbitrary initial merge sets.

For pure unification the \key{node merge algorithm}%
\label{NODE-MERGE-ALGORITHM}
applied to the merge pair (M,N) is as follows:

\begin{enumerate}

\item
Remove (M,N) from the merge set.

\item
If M and N are the same node, terminate the node merge algorithm.

\item
\label{UNIFICATION-LABEL-FAILURE}
If M and N are labeled nodes with different labels, the unification
algorithm fails.

\item
If either M or N is a labeled node and the other node is the
source of some arrows, the unification algorithm fails.

\item
\label{UNIFICATION-AMBIGUITY-FAILURE}
If there is an arrow label L such that one of the nodes M or N
is the source of two or more arrows labeled L and the other node is the
source of one or more arrows labeled L, the unification algorithm fails.
Intuitively, when we try to match the arrows sourced at one of the
two nodes with arrows sourced at the other of the two nodes so
that matched arrows have the same arrow label, then we must get a
unique answer.

\item
If M is a labeled node with label L, and N is unlabeled, label N with L.

\item
For every arrow sourced at M do the following.
Let the arrow be labeled L and point at target node MT.
If N is not the source of an arrow labeled L,
make a new arrow labeled L pointing from N to MT.
But if N is the source of an arrow labeled L with target NT, add the
merge pair (MT,NT) to the merge set.

\item
Replace M by a forwarding pointer that points at N.
This means that henceforth any attempt to reference M will be forwarded
to N, so M is effectively merged with N.

\end{enumerate}

Note that the running time of the pure unification algorithm is bounded by

\[
\begin{array}{c}
T(\mbox{number of nodes reachable from nodes in the initial merge set}) \\
\times \\
(\mbox{number of arrows sourced at these nodes})^2
\end{array}
\]

where $T$ is a small constant time (typically a few microseconds).
The total number of nodes reachable from nodes in the initial merge set
bounds the number of node merge
operations, and the
last factor bounds the time to form the union of the arrow labels of
any two nodes that are being merged.  The bound just given is typically
a substantial overestimate, and can be improved to:

\[
\begin{array}{c}
T \left(
   \begin{array}{c}
   \mbox{number of nodes reachable from nodes in the initial merge set} \\
    - \\
  \mbox{number of nodes reachable from these nodes after unification} \\
  \end{array}
  \right) \\
\times \\
(\mbox{maximum number of arrows sourced at any one node reachable
       after unification})^2
\end{array}
\]

\subsection{Raw Expression Trees}
\label{RAW-EXPRESSION-TREES}

Raw expressions represent certain expression trees called
\skey{raw expression tree}s.  For example, the expression

\begin{center}
\verb|[max x y z]|
\end{center}

represents the raw expression tree

\begin{center}
\begin{Graph}
    \Gvariable{\CurlyBra ROOT\CurlyKet} \\
    \begin{Gsingle}{-ARITY-}
	\Glabel{3} \\
    \end{Gsingle} \\
    \begin{Gsingle}{0}
	\Glabel{max} \\
    \end{Gsingle} \\
    \begin{Gsingle}{1}
	\Glabel{x} \\
    \end{Gsingle} \\
    \begin{Gsingle}{2}
	\Glabel{y} \\
    \end{Gsingle} \\
    \begin{Gsingle}{3}
	\Glabel{z} \\
    \end{Gsingle} \\
\end{Graph}
\end{center}

The raw expression is represented by the root node of a raw expression tree.
The raw expression head, `\verb|max|', is represented by a node labeled
`\verb|max|' that is the target of an arrow labeled `\verb|0|' from the root.
Here `\verb|0|' is called the \key{head index} of the root node, the
arrow it labels is called the \key{head arrow} of the root node,
and the target of that arrow is called the \key{head} of the root node.

The three arguments become targets of three arrows from the root labeled
`\verb|1|', `\verb|2|', and `\verb|3|'.
Each argument in this example is a single
word, and is represented by a node labeled with that word.
Here non-zero natural numbers are
\ikey{un-reorderable argument indices}{un-reorderable argument index} of the
root that label
\skey{un-reorderable argument arrow}s of the root, and the targets of these
arrows are the \skey{un-reorderable argument}s of the root.  Reorderable
and rest arguments are introduced below.

An arrow labeled `\ttkey{-ARITY-}' is added to the root node to point
at a node labeled with the number of arguments in the raw expression.
This arrow is called the \key{arity arrow} of the root node,
its target is called the \key{arity target} of the root, and
the label of that target is called the \key{arity} of the root.

A second example is the expression

\begin{center}
\verb|[sort x @@ with key weight @@ with comparator <]|
\end{center}

which is represented by the raw expression tree

\begin{center}
\begin{Graph}
    \Gvariable{\CurlyBra ROOT\CurlyKet} \\
    \begin{Gsingle}{-ARITY-}
	\Glabel{1} \\
    \end{Gsingle} \\
    \begin{Gsingle}{0}
	\Glabel{sort} \\
    \end{Gsingle} \\
    \begin{Gsingle}{1}
	\Glabel{x} \\
    \end{Gsingle} \\
    \begin{Gchild}{-REQUIRED-QUALIFIER-}
	\begin{Gsingle}{-ARITY-}
	    \Glabel{2}
	\end{Gsingle} \\
	\begin{Gsingle}{0}
	    \Glabel{with}
	\end{Gsingle} \\
	\begin{Gsingle}{1}
	    \Glabel{key}
	\end{Gsingle} \\
	\begin{Gsingle}{2}
	    \Glabel{weight}
	\end{Gsingle} \\
    \end{Gchild} \\
    \begin{Gchild}{-REQUIRED-QUALIFIER-}
	\begin{Gsingle}{-ARITY-}
	    \Glabel{2}
	\end{Gsingle} \\
	\begin{Gsingle}{0}
	    \Glabel{with}
	\end{Gsingle} \\
	\begin{Gsingle}{1}
	    \Glabel{comparator}
	\end{Gsingle} \\
	\begin{Gsingle}{2}
	    \Glabel{<}
	\end{Gsingle} \\
    \end{Gchild} \\
\end{Graph}\label{QUALIFIER-EXAMPLE}
\end{center}

Here each qualifier becomes the target of an arrow labeled
`\ttkey{-REQUIRED-QUALIFIER-}' because
the `\verb|@@|' \key{required-qualifier-mark} is used (the arrow label
would be `{\tt -OPTIONAL-\EOL QUALIFIER-}' if the `\verb|??|'
optional-qualifier-mark had been used).
The arrows with these labels are called \skey{qualifier arrow}s of the
root node and their targets are called \skey{qualifier}s of the root.
In this case there are two \skey{required qualifier arrow}s and
two \skey{required qualifier}s.
Each qualifier sources arity, head, and un-reorderable argument arrows
analogous to those of the root node, and could source qualifier,
reorderable argument (see below), and rest argument (see below) arrows.

A third example is the expression

\begin{center}
\verb|[sort x @@ with key weight ?? with order X]|
\end{center}

which is represented by the raw expression tree

\begin{center}
\begin{Graph}
    \Gvariable{\CurlyBra ROOT\CurlyKet} \\
    \begin{Gsingle}{-ARITY-}
	\Glabel{1} \\
    \end{Gsingle} \\
    \begin{Gsingle}{0}
	\Glabel{sort} \\
    \end{Gsingle} \\
    \begin{Gsingle}{1}
	\Glabel{x} \\
    \end{Gsingle} \\
    \begin{Gchild}{-REQUIRED-QUALIFIER-}
	\begin{Gsingle}{-ARITY-}
	    \Glabel{2}
	\end{Gsingle} \\
	\begin{Gsingle}{0}
	    \Glabel{with}
	\end{Gsingle} \\
	\begin{Gsingle}{1}
	    \Glabel{key}
	\end{Gsingle} \\
	\begin{Gsingle}{2}
	    \Glabel{weight}
	\end{Gsingle} \\
    \end{Gchild} \\
    \begin{Gchild}{-OPTIONAL-QUALIFIER-}
	\begin{Gsingle}{-ARITY-}
	    \Glabel{2}
	\end{Gsingle} \\
	\begin{Gsingle}{0}
	    \Glabel{with}
	\end{Gsingle} \\
	\begin{Gsingle}{1}
	    \Glabel{order}
	\end{Gsingle} \\
	\begin{Gsingle}{2}
	    \Glabel{X}
	\end{Gsingle} \\
    \end{Gchild} \\
\end{Graph}
\end{center}

This is similar to the last example except one qualifier is an
`\ttkey{-OPTIONAL-QUALIFIER-}' because the
`\verb|??|' \key{optional-qualifier-mark} is used.
In this case there is one \skey{required qualifier arrow},
one \skey{required qualifier}, one \key{optional qualifier arrow}, and
one \key{optional qualifier}.  The only difference between
required and optional qualifiers is the label on the arrow to the qualifier
node, which is either `\ttkey{-REQUIRED-QUALIFIER-}'
or `\ttkey{-OPTIONAL-QUALIFIER-}'.

A fourth example is the expression

\begin{center}
\verb|[fill Prefix ::? Matrix <:> Value Postfix ::> Runs]|
\end{center}

which is represented by the raw expression tree

\begin{center}
\begin{Graph}
    \Gvariable{\CurlyBra ROOT\CurlyKet} \\
    \begin{Gsingle}{-ARITY-}
	\Glabel{1-4} \\
    \end{Gsingle} \\
    \begin{Gsingle}{0}
	\Glabel{fill} \\
    \end{Gsingle} \\
    \begin{Gsingle}{1}
	\Glabel{Prefix} \\
    \end{Gsingle} \\
    \begin{Gsingle}{2-3}
	\Glabel{Matrix} \\
    \end{Gsingle} \\
    \begin{Gsingle}{2-3}
	\Glabel{Value}
    \end{Gsingle} \\
    \begin{Gsingle}{4}
	\Glabel{Postfix}
    \end{Gsingle} \\
    \begin{Gsingle}{-REST-}
	\Glabel{Runs}
    \end{Gsingle} \\
\end{Graph}
\end{center}

Arguments appearing after the \key{optional argument mark} \ttnbkey{::?} are
optional.  This is indicated by the arity `\verb|1-4|' that indicates
that argument `\verb|1|' is the last required argument and there are
`\verb|4|' arguments total.  In general, the arity can have the form
`$m$\verb|-|$n$', where $0\leq m<n$, $m$ is the
\skey{number of required argument}s, $n$ is the
\skey{total number of argument}s,%
\label{TOTAL-NUMBER-OF-ARGUMENTS}
and $n-m$ is the number of optional arguments.

If there are no optional arguments and the arity is just a natural
number $n$, then $n$ is both the number of required arguments and the
total number of arguments.

Consecutive arguments separated by the \key{reorder mark} \ttnbkey{<:>} are
reorderable.  These arguments are indicated by argument indices that
describe the positions the arguments can occur in.  Thus in the example
the two arguments with index `\verb|2-3|' can each appear as either the
2nd or 3rd argument.  In general,
an argument index that is a range of the form
`$i$\verb|-|$j$', where $1\leq i<j\leq n$, and
$n$ is the total number of arguments, indicates that the argument can
be the $i$'th through $j$'th argument position.
These argument indices are called the
\ikey{reorderable argument indices}{reorderable argument index} of the
root node,
the arrows they label are called \skey{reorderable argument arrow}s
of the root,
and the targets of these arrows are called \skey{reorderable argument}s
of the root.

Note that if an argument has index `$i$\verb|-|$j$', then the $i$'th
and $j$'th argument must be either both required or both optional.
That is, if there are optional arguments and
$m$ is the number of required arguments, either
$j\leq m$ or $m<i$.

The argument after a \key{remainder mark} \ttnbkey{::>} is
given the special argument index `\ttkey{-REST-}' and names a list of
all arguments that occur after the total number of arguments specified
by the arity.  Here \verb|-REST-|
is called the \key{rest argument index} of the root node, the arrow it labels
is called the \key{rest argument arrow} of the root, 
and the target of this arrow is called the \key{rest argument}.
The rest argument is not counted in the arity.

\subsection{Call Nodes and the Call Check}
\label{CALL-NODES-AND-CHECK}

During expression evaluation (\secref{EXPRESSION-EVALUATION})
the expression being evaluated is unified with a pattern in an expression
definition.  The unification used for this purpose is
a variant called `call unification' (\secref{CALL-UNIFICATION}).

Call unification treats graph nodes called `call nodes'
differently than pure unification (\secref{PURE-UNIFICATION}) does.
A \key{call node} is a node that has
an \mkey{arity arrow}{of call node}.
That is, it is the source of an arrow labeled
\ttmkey{-ARITY-}{of call node}.  Call unification
replaces the node merge algorithm
(\pagref{NODE-MERGE-ALGORITHM})
with the call merge algorithm described below if one of the nodes
being merged is a call node and the other is not a
null node.

The call merge algorithm performs a subalgorithm called
the \key{call check algorithm} that checks whether a call node
is legal.  Specifically, a call node N passes the call check
algorithm if and only if the following are true:

\begin{enumerate}

\item
The arity of N is either a natural number $n$ (string of digits without
high order zeros) or has the form $m$\verb|-|$n$ where $m$ and $n$
are natural numbers and $m<n$.  In the second case $m$ is called the
\key{minimum arity} of N and $n$ is called the
\key{maximum arity} of N.  In the first case $n$ is both the minimum
and the maximum arity of N.

\item
N has exactly one head arrow.

\item
There exists a 1-1 map between the set of un-reorderable and reorderable
(but not rest) argument arrows of N and the set of
natural numbers from \verb|1| through $n$, where $n$ is the
maximum arity of N, such that if $i$ is a natural number
from \verb|1| through $n$, the arrow mapped to $i$
is either an un-reorderable argument arrow labeled $i$, 
or is a reorderable argument arrow labeled $j$\verb|-|$k$
where $j\leq i\leq k$.

Such a mapping is called a \key{argument order assignment} of N.%
\label{ARGUMENT-ORDER-ASSIGNMENT}
If there are any reorderable arguments of N, there will be
more than one argument order assignment of N.

\item
\label{NULL-REST-ARGUMENT}
N has at most one rest argument arrow.  If N has a rest argument
arrow, the rest argument of N is a null node (a node with no label
that is the source of no arrows).

\item
N can have any number of qualifier arrows (required or optional).

\item
There are no arrows sourced at N other than those with labels
enumerated above.  That is, any arrow sourced at N is either an arity
arrow, a head arrow, an argument arrow (un-reorderable, reorderable, or rest),
or a qualifier arrow (required or optional).

\item
The qualifiers of N (targets of qualifier arrows)
pass the call check algorithm recursively.  The call check
algorithm allows cycles in the graph, e.g. the case that N and one
of its qualifiers are the same node.

Note that raw expressions cannot represent call nodes that have
qualifiers which in turn have qualifiers, but the conversions
of \secref{EXPRESSION-GRAPH-REPRESENTATION} can represent such call nodes.
Because of the difficulty of representing them, such call nodes are
of mostly theoretical interest.

\end{enumerate}

\subsection{Paths and Witnesses}
\label{PATHS-AND-WITNESSES}

A \ikey{non-empty path}{path!non-empty}
is a sequence of one or more arrows in some expression graph,
such that if A1 and A2 are consecutive
arrows in the sequence, the target of A1 is the source of A2.
The \mkey{path name}{of non-empty path}
of the path is the
sequence of words and separators that are the arrow labels of the
arrows of the path.  The source node of the first arrow in the path
is the \mkey{source}{of non-empty path} of the path.
The target node of the last
arrow in the path is the \mkey{target}{of non-empty path} of the path.
Note that the path name and source node of a path are together
not adequate to determine the path in all cases, since we allow
a node to source several arrows with the same label.

An \ikey{empty path}{path!empty} is just a node.  This node is both
the \mkey{source}{of empty path} of the empty path and
the \mkey{target}{of empty path} of the empty path.
The \mkey{path name}{of empty path} of the path is the empty sequence.

A \key{path name} is just a possibly empty sequence of words or separators.
A \key{node label} is just any word or separator.

A \key{witness} is a path name and a node label.
We use `{\em path-name}\,: {\em node-label}\,' to name the witness.
A \mkey{witness}{of node} of a node S in an expression graph is a witness
P:~L with path name P and node label L such that there is a path with source S,
path name P, and target that has node label L.

For example, consider the expression graph of

\begin{center}
\verb|[sort x @@ with key weight @@ with comparator <]|
\end{center}

on \pagref{QUALIFIER-EXAMPLE}.  The root of this expression graph
has `\verb|0|: \verb|sort|' as one of its witnesses and
`\verb|-REQUIRED-QUALIFIER- 0|: \verb|with|' as another.  There are
actually two distinct paths corresponding to this second witness.

Two witnesses are said to be \mkey{incompatible}{witness}
if they have the same path name but have different labels.
Two witnesses are said to be \mkey{compatible}{witness}
if they are not incompatible: that is, if they have different path
names, or if they have both the same path names and the same labels.
For example, `\verb|0|: sort' and `\verb|1|: x' are compatible while
`\verb|0|: sort' and `\verb|0|: switch' are incompatible.

It is not true that all witnesses for a node in an expression graph
are compatible.  This is because we allow one node to source several
arrows with the same label.  In the example expression graph
on \pagref{QUALIFIER-EXAMPLE},
`\verb|-REQUIRED-QUALIFIER- 1|: \verb|key|' and
`\verb|-REQUIRED-QUALIFIER- 1|: \verb|comparator|' are incompatible
witnesses for the value of \verb|{ROOT}|.  However, for an expression
graph in which no node sources two arrows with the same arrow label, it can
be easily proved that all witnesses of every node are compatible.

Two expression graph nodes, S1 and S2, possibly the same node, and possibly
in different expression graphs,
are said to be \key{witness compatible} if and only if every
witness for S1 is compatible with every witness for S2.  Otherwise
S1 and S2 are said to be \key{witness incompatible}.

For an integer N$\geq$0, an N-witness is a witness whose path name
has at most N arrow labels.
Two expression graph nodes, S1 and S2,
are said to be \key{N-witness compatible} if and only if every
N-witness for S1 is compatible with every N-witness for S2.  Otherwise
S1 and S2 are said to be \key{N-witness incompatible}.

It is possible for
a node to be 1-witness incompatible with itself, without being witness
incompatible with many other nodes.  For example, a node whose only
witnesses are the incompatible witnesses `\verb|1|:~\verb|fee|' and
`\verb|1|:~\verb|fie|' would be witness compatible with any
node that was not the source of any arrow with arrow label `\verb|1|'.

It can be easily proved that if two expression graphs can be unified
by pure unification (\secref{PURE-UNIFICATION}),
then any two nodes that are merged during
unification are 1-witness compatible.  This is because
step \stepref{UNIFICATION-AMBIGUITY-FAILURE} of the node merge algorithm
(\pagref{NODE-MERGE-ALGORITHM})
means that if the nodes have incompatible 1-witnesses then the nodes each
source only one arrow with the witness arrow label, and therefore
the targets of these two arrows must merge, which is forbidden by
step \stepref{UNIFICATION-LABEL-FAILURE} as according to the incompatible
1-witnesses the targets have unequal labels.

It can even be proved that if two expression graphs can be unified
by pure unification (\secref{PURE-UNIFICATION}),
then any two nodes that are merged during
unification are witness compatible.  This is because
if there are two incompatible witnesses of the two nodes, there
would be two paths with the same path name,
one for each witness, with consecutive
nodes on the two paths being merged, because
step \stepref{UNIFICATION-AMBIGUITY-FAILURE}
requires that along each of the two paths each node sources exactly
one arrow with the next arrow label on the paths.
The two paths would end at two nodes that
would have different labels, but would have to be merged, causing
the unification algorithm to fail by step \stepref{UNIFICATION-LABEL-FAILURE}.

In the unification algorithm,
arrow labels are used to match arrows to be merged.  More specifically,
when two nodes M and N are merged, arrows sourced at M are matched
with arrows sourced at N by arrow label.  If this match cannot be done,
step \stepref{UNIFICATION-AMBIGUITY-FAILURE} of the unification algorithm
causes unification to fail.  In order to merge qualifier nodes,
we need to avoid this failure, and we do this in \secref{CALL-UNIFICATION}
by using some of the
the 1-witnesses of the qualifier nodes to make the match.
The 1-witnesses we use include the qualifier head, if that
is a node with a label, and any un-reorderable non-rest
qualifier argument that is simply a node with a label.

\subsection{Call Unification}
\label{CALL-UNIFICATION}

\ikey{Call unification}{call unification}\index{unification!call}
is a variant of pure unification (\secref{PURE-UNIFICATION}) that differs
from pure unification when merging nodes one of which is a call node
and the other of which is not a null node (node with no label that sources
no arrows).  Call unification is
used in the expression evaluation algorithm (\secref{EVALUATION-ALGORITHM}).

Call unification is identical to pure unification (\secref{PURE-UNIFICATION})
with two differences.  The first difference is that when one of two nodes
being merged is a call node (\secref{CALL-NODES-AND-CHECK}), and the other
node is not a null node, call unification
replaces the node merge algorithm (\pagref{NODE-MERGE-ALGORITHM})
with the call merge algorithm described below.

The second difference is that call unification makes choices during its
execution, because the call merge algorithm makes choices.  Each
set of possible choices over the whole call unification algorithm
leads to a separate algorithm execution that either succeeds or fails.

The \key{call merge algorithm} for a merge pair (M,N) in the merge set,
where either M or N or both is a call node, and neither is a null node,
with a particular choice, is as follows.

\begin{enumerate}

\item
Remove (M,N) from the merge set.

\item
If either M or N fails to pass a call check, the unification algorithm
fails.

\item
If M and N are the same node, terminate the call merge algorithm.

\item\label{DETERMINATE}
A call node is said to be \key{indeterminate} if it has
an optional, reorderable, or rest argument or an optional qualifier.
Otherwise the node is said to be \key{determinate}.

If \underline{both} M and N are indeterminate,
the unification algorithm fails.

Otherwise, if just N is indeterminate, switch M and N so that
N is always determinate.

Later in this call merge algorithm M will be replaced by a forwarding
pointer to N, and N will not be given any optional, rest, or reorderable
arguments, so the result of the merge will be determinate.

\item
If M is determinate and the arities of M and N are not equal,
the unification algorithm fails.

If M has more required arguments than N has arguments, the unification
algorithm fails.

\item
For the rest of this algorithm,  let MT be the total number of arguments
(\pagref{TOTAL-NUMBER-OF-ARGUMENTS})
of M and NT be the total number of arguments of N.

\item
If M has a rest argument R, then
For each natural number I from MT$+$1 through NT,
an arrow labeled I$-$MT is added that has R as its source and the
I'th argument of N as its target.
Note that before this is done R is a null node
(step \stepref{NULL-REST-ARGUMENT} of the call check algorithm on
\pagref{NULL-REST-ARGUMENT}).
If NT$\leq$MT, this step does nothing (R remains a null node).

\item
Choose an argument order assignment (\pagref{ARGUMENT-ORDER-ASSIGNMENT})
for M.  For \verb|1|$\leq$I$\leq$MT, let MI let the assigned
I'th argument of M.

\item
Let T be the minimum of MT and NT.
For \verb|1|$\leq$I$\leq$T, let
NI be the I'th argument of N,
and add the merge pair (MI,NI) to the merge set.
For T$<$I$\leq$MT (if T$<$MT), add an arrow labeled I from N to MI.

\item
Let MH be the head of M and NH be the head of N.  Add a merge pair
(MH,NH) to the merge set.

\item
If there is any qualifier arrow of M whose target is
is 1-witness compatible with the target of more than one qualifier arrow
of N, the unification algorithm fails.  Ditto with M and N switched:
if there is any qualifier arrow of N whose target
is 1-witness compatible with the target of more than one qualifier arrow
of M, the unification algorithm fails.

\item
For each qualifier arrow MA of M whose target is 1-witness compatible with
the target of exactly one qualifier arrow NA of N, let MQ be the target
of MA and NQ be the target of NA.  Add (MQ,NQ) to the merge set.

\item\label{ADD-ARROW-STEP}
For each qualifier arrow MA of M whose target is 1-witness compatible with
the targets of no qualifier arrows N, let MQ be the target of MA,
and make an arrow from N to MQ
that has the arrow label \verb|-REQUIRED-QUALIFIER|.

\item
Replace M by a forwarding pointer that points at N.
This means that henceforth any attempt to reference M will be forwarded
to N, so M is effectively merged with N.

\end{enumerate}

\subsection{Expression Graph Representation}
\label{EXPRESSION-GRAPH-REPRESENTATION}

Raw expressions can be used to represent expression graphs.  This is
done by defining \skey{graph creation conversion}s that convert
raw expression trees to expression graphs.

A graph creation conversion is performed
by first converting the raw expression to an expression tree plus
a set of variables where each variable has not a single value or
single optional default, but instead has a set of one or more values
and zero or more defaults.  Then all the values of each variable
are unified using pure unification, and all the defaults of each
variable with defaults are similarly unified.  The result after
unification is an expression graph.

There are two kinds of graph creation conversion: explicit and implicit.
In implicit conversion words beginning with a capital letter or
with `\verb|#|' followed
by a capital letter are taken to be variable names if they appear where
a node label would appear.  In explicit conversion such words are not
given special treatment.

In converting a raw expression to an expression tree,
the rules for representing raw expressions as expression trees
(\secref{RAW-EXPRESSION-TREES})
are followed, with the following exceptions:

\begin{indpar}
\begin{list}{}{}

\item[{\tt [}{\tt //} {\em variable-name} {\em variable-value}{\tt]}]~\\
This expression converts to the same tree that the {\em variable-value}
converts to, and adds the root node of this tree to the value set of
the named variable.

\item[{\tt [}\ttkey{//} {\em variable-name}{\tt]}]~\\
This expression converts to a tree consisting of a single null root
node, and adds this node to the value set of the named variable.

\item[{\em variable-name}]~\\
For implicit conversion this is
treated as the equivalent of `\verb|[// |{\em variable-name}\verb|]|'
if {\em variable-name} begins with a capital letter or with
`\verb|#|' followed by a capital letter.
Otherwise this converts to a tree with a single node
labeled with a word that is not in general a variable name.

\item[{\tt [\Tilde\Tilde}\index{~~@{\tt \protect\Tilde\protect\Tilde}}
           {\em variable-name} {\em variable-default} {\tt]}]~\\
This expression converts to the same tree that the {\em variable-default}
converts to, and adds the root node of this tree to the default set of
the named variable.  Thus \verb|~~| is like \verb|//| except that the node is
added to the default set instead of the value set of the variable.

\item[{\tt [}\ttkey{\#\#\#\#}
      \{ {\em arrow-label} {\em target-value} \}\,$^\star${\tt]}]~\\
This expression converts to a tree whose root is an unlabeled node
that is the source of arrows labeled with the {\em arrow-labels}.
The target of each arrow is the tree obtained by converting
the {\em target-value} raw expression that follows the arrow's
{\em arrow-label}.

\item[{\tt [}\ttkey{++++}
      {\em expression-graph} {\em expression-graph}\,$^\star${\tt]}]~\\
This expression converts to the tree that the first {\em expression-graph}
converts to.  The other {\em expression-graphs} are also converted to trees.
All the {\em expression-graphs} may contribute variables, variable values,
and variable defaults, and the values and defaults for each variable
will be merged by the unification at the end of the conversion.

\end{list}
\end{indpar}

After the expression tree is created, its root node becomes the root
of the expression graph resulting from conversion.

Then pure unification is performed as
described in \secref{PURE-UNIFICATION}, except that the merge set is initialized
to merge pairs that merge the values of each variable and the
defaults of each variable.  It is a conversion error if this
unification fails or if any variable has an empty set of values
before unification is attempted.  After unification a variable has a default
if and only if its set of default values before unification was non-empty.

There are two kinds of graph creation conversions: explicit and implicit.
In \ikey{implicit conversions}{implicit conversion!to expression graph}%
\label{IMPLICIT-CONVERSION}
what appear to be nodes labeled by a word L beginning with
a capital letter or with `\ttkey{\#}' followed by a capital
letter are treated as the equivalent of `\verb|[// |L\verb|]|'.
Thus L is a variable name, and when used like a node label
in the raw expression, L
represents a null node that is a value of the variable named L.
For \ikey{explicit conversions}{explicit conversion!to expression graph}
no such special provision is made for words that are used like node labels.

The exact operation names used in graph creation conversions may be different
from those given above.  The names to be used are given as arguments to the
conversion operations, with the names used above as defaults.  These
default names and the descriptive names of the operations are:

\begin{center}
\begin{tabular}{l@{~~~~~}l}
\verb|//|	& \key{graph variable value operation} \\
\verb|~~|	& \key{graph variable default operation} \\
\verb|####|	& \key{graph source construction operation} \\
\verb|++++|	& \key{graph concatenation operation} \\
\end{tabular}
\end{center}

\ikey{Pseudo-variable}{expression graph pseudo-variable}%
\index{pseudo-variable!expression graph}
names (\pagref{PSEUDO-VARIABLES})
of the form `\verb|{|{\em word-or-separator}\verb|}|' can be used
with the `\verb|//|' operation
to merge nodes that are not the value or default of any real variable.
This use simply
creates variables with names that are not single words or separators,
and these variables are discarded at the end of conversion.
The pseudo-variable `\verb|{ROOT}|' is always given
the root node of the expression tree as one of its values, but may
be given other values by this method.
Pseudo-variables cannot be given defaults.

Some examples of expression trees represented by raw expressions and the
expression graphs they convert to are as follows:

\begin{indpar}

\begin{tabular}{p{2.5in}@{~~~~~}l}
\begin{tabular}{l}
\verb|[z [// X foo] X]| \\
implicit conversion
\end{tabular}
&
\begin{Graph}
    \Gvariable{\CurlyBra ROOT\CurlyKet} \\
    \begin{Gsingle}{-ARITY-}
	\Glabel{2} \\
    \end{Gsingle} \\
    \begin{Gsingle}{0}
	\Glabel{z} \\
    \end{Gsingle} \\
    \begin{Gchild}{1}
	\Gvariable{X} \\
	\Glabel{foo}
    \end{Gchild} \\
    \begin{Gsingle}{2}
	\Gvariable{X} \\
    \end{Gsingle} \\
\end{Graph}
\end{tabular}

\medskip

\begin{tabular}{p{2.5in}@{~~~~~}l}
\begin{tabular}{l}
\verb|[z [// X foo] X]| \\
explicit conversion
\end{tabular}
&
\begin{Graph}
    \Gvariable{\CurlyBra ROOT\CurlyKet} \\
    \begin{Gsingle}{-ARITY-}
	\Glabel{2} \\
    \end{Gsingle} \\
    \begin{Gsingle}{0}
	\Glabel{z} \\
    \end{Gsingle} \\
    \begin{Gchild}{1}
	\Gvariable{X} \\
	\Glabel{foo}
    \end{Gchild} \\
    \begin{Gsingle}{2}
	\Glabel{X} \\
    \end{Gsingle} \\
\end{Graph}
\end{tabular}

\medskip

\begin{tabular}{p{2.5in}@{~~~~~}l}
\begin{tabular}{@{}l@{}}
\verb|[++++| \\
\verb|  [z X X]| \\
\verb|  [~~ X foo]]| \\[1ex]
implicit conversion
\end{tabular}
&
\begin{Graph}
    \Gvariable{\CurlyBra ROOT\CurlyKet} \\
    \begin{Gsingle}{-ARITY-}
	\Glabel{2} \\
    \end{Gsingle} \\
    \begin{Gsingle}{0}
	\Glabel{z} \\
    \end{Gsingle} \\
    \begin{Gsingle}{1}
	\Gvariable{X} \\
    \end{Gsingle} \\
    \begin{Gsingle}{2}
	\Gvariable{X} \\
    \end{Gsingle} \\
\end{Graph}
~~~
\begin{Graph}
    \Gdefault{X} \\
    \Glabel{foo} \\
\end{Graph}
\end{tabular}

\medskip

\begin{tabular}{p{2.5in}@{~~~~~}l}
\begin{tabular}{@{}l@{}}
\verb|[++++| \\
\verb|  [#### fee X fie X]| \\
\verb|  [// X 51]| \\
\verb|  [~~ X [#### 1 foe 2 fum]]| \\
\verb|  [~~ Y| \\
\verb|    [// Y| \\
\verb|      [#### 1 [// {1}]| \\
\verb|            2 [####| \\
\verb|                *| \\
\verb|                [// {1}]]| \\
\verb|            ]]]]| \\[1ex]
implicit conversion
\end{tabular}
&
\begin{tabular}{@{}l@{}}
\begin{Graph}
    \Gvariable{\CurlyBra ROOT\CurlyKet} \\
    \begin{Gchild}{fee}
	\Gvariable{X} \\
	\Glabel{51} \\
    \end{Gchild} \\
    \begin{Gsingle}{fie}
	\Gvariable{X} \\
    \end{Gsingle} \\
\end{Graph}
\hspace{0.1in}
\begin{Graph}
    \Gdefault{X} \\
    \begin{Gsingle}{1}
	\Glabel{foe} \\
    \end{Gsingle} \\
    \begin{Gsingle}{2}
	\Glabel{fum} \\
    \end{Gsingle} \\
\end{Graph}
\\
~\\
\begin{Graph}
    \Gvariable{Y} \\
    \Gdefault{Y} \\
    \begin{Gsingle}{1}
	\Gvariable{\protect\CurlyBra 1\protect\CurlyKet} \\
    \end{Gsingle} \\
    \begin{Gchild}{2}
	\begin{Gsingle}{*}
	    \Gvariable{\protect\CurlyBra 1\protect\CurlyKet} \\
	\end{Gsingle} \\
    \end{Gchild} \\
\end{Graph}
\end{tabular}

\end{tabular}
\end{indpar}

\subsection{Expression Graph Implementation}
\label{EXPRESSION-GRAPH-IMPLEMENTATION}

In this section we give ideas that may or may not be used to
implement CASTLE expression graphs.

CASTLE may have a single memory of nodes and arrows that holds all expression
graphs.  We will call this the expression graph memory.

There may be at most one node in expression graph memory that has a given
label L.  That is, all nodes labeled L, for a particular L, are the same
node.

Giving a null node a label L is then implemented by forwarding the null node
to the node with label L.

A frequent operation is copying expression graphs as part of expression
evaluation (\secref{EVALUATION-ALGORITHM}).  To make this more efficient,
an expression graph can be separated into two parts: an immutable part,
and a mutable part.  The mutable part is just a vector of node references,
one per node if the expression graph.
The immutable part is just a set of immutable nodes, with
associated arrows, except that arrow targets may be indices of node references
in the mutable vector.  Thus there are now two kinds of nodes in memory:
normal nodes, which include those that are labeled and those that are
mutable in the normal way, and immutable nodes.  The latter can only be
pointed at by a node reference in a mutable vector.

Node references in mutable vectors are like nodes.  They can be null, forwarded,
or point at an immutable node associated with the mutable vector.  In the
last case, the node reference and immutable node together behave like a
mutable node, and we say the node reference is `\key{coupled}' to the
immutable node.

During unification arrows are sometimes added to a node.  To make this
work for a node reference coupled to an immutable node, a node reference may
also point to a structure that stores a pointer to an immutable node plus
a list of extra arrows added to that node.  The node reference is still
coupled to the immutable node, but the node reference now represents
a new node that has more arrows than the immutable node.

An arrow target can be a normal node,
that is, either a labeled node or a normal mutable node.
An arrow target may not be an immutable node unless that node
is never forwarded and arrows are never added to the node.  Instead the
arrow target be a node reference coupled to the immutable node.

In CASTLE things can be arranged so the nodes to be evaluated,
which are guard nodes in expression definitions or nodes in expression
definition blocks, are never forwarded.  They are determinant
(\pagref{DETERMINATE}), and in any call unification at most one node is
being evaluated, while the other
is the expression defined by an expression definition.  However, in CASTLE
arrows may be added to an expression being evaluated (Step~\ref{ADD-ARROW-STEP}
\pagref{ADD-ARROW-STEP}).
So in CASTLE probably no immutable node can
point directly at another immutable node.\footnote{CASTLE differs from
PROLOG in that in PROLOG arrows are not added to nodes during unification
so immutable guard nodes can point directly at other immutable guard nodes.}
Luckily CASTLE is not intended to run large programs.  However, it should be
possible to compile code that will check whether an expression defined by
a given definition unifies with an arbitrary expression to be evaluated.
Call unification is just a specification for a kind of pattern matching,
and pattern matching specifications can be compiled into classical
imperative code.


\section{Expression Evaluation}
\label{EXPRESSION-EVALUATION}

An expression is evaluated by first searching for an expression definition
that matches the expression.  Expression definitions also have guards, which
are expressions that must evaluate to true in order for the expression
definition match to succeed.
An expression definition may have an expression block
that executes in order to produce a value for the expression if the definition
matches.  If a matching
expression definition has no expression block, the expression
evaluates to `\ttkey{true}'.  If no expression definition matches an
expression, the expression evaluates to `\ttkey{false}'.

Expression definitions are searched for in a context, which is a list
of expression definitions and pointers to other contexts.
Each point in the program has a lexical context, which is used by default
for expression evaluation.  There is also a global context to which
definitions may be added or from which they may be deleted.
The block of an expression definition usually evaluates expressions in the
lexical context of its expression definition,
but may evaluate expressions in the lexical context of the expression being
evaluated by the expression definition.

When an expression definition is found that matches an expression, a
copy of the expression definition is made, and a part of this copy called
the pattern is unified with the matched expression.  This unification defines
variables in the expression definition and null nodes in the matched
expression that are values of variables outside the expression definition.
Expression definition variables that receive no value in this way,
but which have default values, are given the default values.
However, values received from unification may be incomplete, in that they
may be expressions which include null nodes that represent unknown values
of other variables.
When the guards of the expression definition
are matched in turn with other expression
definitions, and unified with patterns in copies of these matched definitions,
the incomplete values may become complete.  For this reason,
matching of guards with definitions and unification of guards
is done as much as possible before any blocks are evaluated.

The expression being evaluated may also have null nodes that represent
unknown values of variables.  During evaluation
these null nodes may be unified with patterns in expression definitions,
and cease to become null nodes.  This process is known as
`\key{completing the expression}' being evaluated.  An expression with
no null nodes is said to be \mkey{complete}{expression}, whereas
an expression with null nodes is said to be \mkey{incomplete}{expression}.

After an expression definition pattern is unified with an
expression the definition matches, and after default values are assigned,
some variable values are evaluated and replaced by their evaluated values.
These variables are called evaluated variables, and typically have names
beginning with a capital letter, whereas other variables are
called unevaluated variables, and typically have names beginning with
`\verb|#|' followed by a capital letter.  Evaluation of evaluated variable
values happens before guard expressions are matched to definitions,
so guard expressions see only the evaluated value of evaluated variables.
The values which are evaluated in this manner must not be incomplete,
and their evaluation must have no visible side effects.

After all guards are matched with definitions and unified,
blocks are evaluated, beginning with any blocks in the definitions matched
to guards.  If any of these guard blocks fails to produce the value true,
the expression definition match fails, and the search for other matching
definitions continues.
Evaluations of guard blocks are required to have no visible side effects.

\subsection{Expression Definitions}
\label{EXPRESSION-DEFINITIONS}

\ikey{Expression definitions}{expression definition} have the syntax:

\begin{indpar}
\key{EXPRESSION-DEFINITION}\label{EXPRESSION-DEFINITION} ::=
	{\em pattern} \verb|<--| {\em guard-list-option} {\em block-option}
	\\[1ex]
\key{pattern} ::= {\em EXPRESSION} \\[1ex]
\key{guard-list-option} ::= {\em empty} $|$ {\em guard-list} \\[1ex]
\key{guard-list} ::= {\em guard} \{ \verb|,| {\em guard} \}\,$^\star$ \\[1ex]
\key{guard} ::= {\em EXPRESSION} \\[1ex]
\key{block-option} ::= {\em empty} $|$ {\em block} \\[1ex]
\key{block} ::= \verb|{| {\em statement}
                         \{ \verb|;| {\em statement} \}\,$^\star$ \verb|}|
\end{indpar}%
\label{PATTERN}

{\em Blocks} and {\em statements} are further defined in
\secref{BLOCKS}.

In use, an expression definition being matched to an expression is
copied, and then the pattern of the copy is call unified
(\secref{CALL-UNIFICATION}) with the expression to be matched.
If unification fails, the definition does not match.  If
unification succeeds, variables bound to null values are given their
default values, evaluated variable values are evaluated,
and then the matching process continues by searching for
definitions that match the guards.

An expression definition is an expression graph which may have variables
as well as graph nodes.   When an expression definition is copied,
the copy has its own variables that are distinct from the variables in
the original expression definition or in any other expression definition copy.

\subsection{The Evaluation Algorithm}
\label{EVALUATION-ALGORITHM}

The \key{evaluation algorithm} inputs an expression to be evaluated
and a context.  The context (\secref{CONTEXTS}) provides a list of expression
definitions that may match the expression.

An expression to be evaluated may contain variables that are assigned
values during matching.  The result of evaluation is both a value for
the expression and an assignment of values for these variables.

More than one definition may match an expression.
More than one definition may match a guard of a definition,
and different guard definitions may lead to different completions of
values of variables in the expression being evaluated.
In matching a definition, more than
one argument order assignment (\pagref{ARGUMENT-ORDER-ASSIGNMENT})
may allow the definition to be matched.  So expression
evaluation is a search process to find a choice of expression definitions
and argument order assignments which leads to success, and more than
one choice may succeed.

Note that the guards of an expression are always matched from left to
right, so order of guard matching is not a choice.  Similarly guard
block evaluation order is fixed, left to right, depth first, so this
is not a choice.  Lastly evaluation of evaluated variable values and
of guard blocks are required to have no side effects, so these can be
undone trivially when part of the search fails.

Evaluation may be done in any of the following modes:

\begin{list}{}{}

\item[\ttkey{first-value}]~\\
The first definitions in contexts and first
argument order assignments tried that lead to successful matches
are the only ones
used.  Definitions are tried in the order they are given in the contexts
used in evaluation.
The order in which argument order assignments are tried is implementation
dependent.

\item[\ttkey{all-values}]~\\
All possible choices are tried and the
successful results are collected in a set of results.  Each result
in this set consists of a value for the expression being evaluated
and values for each null node in that expression.

\item[\ttkey{consistent-values}]~\\
All possible choices are tried and the
successful results are collected in a set of values.  Then these results
are tested to see if they are pairwise equal.
All the values of the expression
being evaluated must be equal, and all the values of each null node
contained in the expression must be equal.  If all values of the expression
or of a null node are equal, one of these values is returned as the value
of the expression or null node.  If some of the values are unequal, an
error value giving the context of the evaluation and the unequal values
is returned as the value of the expression or null node.

\item[\ttkey{consistent-reordering}]~\\
Definitions are 
tried in the order they are given in the contexts used in evaluation,
and the first definitions that match are used.  However, for each definition
all possible argument order assignments are tried.  The results are collected
in a set of results that is tested for pairwise equality.
All the values of the expression
being evaluated must be equal, and all the values of each null node
contained in the expression must be equal.  If all values of the expression
or of a null node are equal, one of these values is returned as the value
of the expression or null node.  If some of the values are unequal, an
error value giving the context of the evaluation and the unequal values
is returned as the value of the expression or null node.
\end{list}

If the expression match search process yields no matches at all,
the expression is given the value `\verb|false|', and variables in the
expression are not changed.

In the following description of algorithms we use a `\key{choose operation}'
as if there were an oracle that allowed us to make appropriate
choices.  In actuality a search process is used, as indicated above.

Evaluating an expression uses subalgorithms for matching an expression with
a definition and for evaluating a block.

The following subalgorithm is used to match an expression to be matched
with an expression definition.

\begin{enumerate}

\item
Make a copy of the expression definition.  Variables in this copy are
distinct from other variables of the same name in memory.

\item
If there are reorderable arguments in the expression definition pattern,
choose an argument order.

\item

Call unify (\secref{CALL-UNIFICATION})
the pattern (\secref{EXPRESSION-DEFINITIONS})
from the definition copy with the expression to be matched,
using the chosen argument order if any.
If the unification fails, the definition does not match.  If the
unification succeeds, it provides values for the variables
in the pattern and for null nodes in the matched expression.

\item
For any pattern variable bound to a null node, rebind the variable
to its default value, if the variable has a default value.

\item\label{PROTECTED-VARIABLE}
For any pattern variable whose name does \underline{not} begin
with `\ttkey{\#}', evaluate the value of that variable to obtain
a new variable value.  Then simultaneously replace all the evaluated
variable values by their new values.  Each replacement is done by
forwarding a variable value graph node to the new value graph node.

These variable value evaluations are not permitted to have
visible side effects (\secref{VISIBLE-SIDE-EFFECTS}).

\end{enumerate}

The subalgorithm for evaluating a block is given in \secref{BLOCK-EVALUATION}.

Evaluating an expression is as follows:

\begin{enumerate}

\item
Choose and expression definition in the appropriate context that
matches the expression to be evaluated, and match the definition
with the expression.

Note the evaluated variable value evaluations of
\ref{PROTECTED-VARIABLE} above are done before guard expression matching
is done.

\item
For each guard of the expression definition, from left to right,
choose an expression definition
in the appropriate context that matches the guard, and match the definition
with the guard.

\item
For each guard that has a block, evaluate the block, working in left
to right depth first order of guards.  If a guard block evaluates to
something other
than `\verb|true|', declare the choices made so far to be a failure,
and continue the search.  These guard block evaluations are not
permitted to have visible side effects (\secref{VISIBLE-SIDE-EFFECTS}).

\item
If the definition matched to the expression to be evaluated has no block,
the value of the expression is `\verb|true|'.
If it has a block, the block is evaluated to produce a value and possibly
side effects (\secref{BLOCK-EVALUATION}).

\end{enumerate}

It is always an error if a null node is to be evaluated.  In particular,
the value of an evaluated variable just before the value is to be evaluated
must not be a null node.

\subsection{Contexts}
\label{CONTEXTS}

An expression is evaluated in a context.  The context is searched
for an expression definition whose pattern matches the expression being
evaluated, and that definition is then used to evaluate the expression.

A \key{context} is either a list or a set of expression definitions and
other contexts.  Context elements that are expression definitions are
matched to the expression being evaluated.  Context elements that are
themselves contexts are searched recursively.

\ikey{Context lists}{list!context} are searched in order.
\ikey{Context sets}{set!context} are searched exhaustively,
and it is always an error if matching definitions are found in more than
one element of a set.

An expression definition is an object (\secref{OBJECTS})
of \ttkey{expression-definition}
type that consists of a pattern, a list of guards,
an optional block, and an optional context.  An
{\em EXPRESSION-DEFINITION} expression (\pagref{EXPRESSION-DEFINITION})
computes an expression definition that has no context.
A context can be added to the expression definition later by executing:

\begin{indpar}
\verb|set| {\em EXPRESSION-DEFINITION} \verb|context| {\em CONTEXT}
\end{indpar}

Once a context has been added to an expression definition, the context
cannot be changed.

A new expression definition can be made from an old one by
the expression:

\begin{indpar}
	\verb|an| \ttkey{expression-definition}
	      {\em EXPRESSION-DEFINITION}
	      {\em CONTEXT}
\end{indpar}

The new expression definition has a different context, given by
the second argument, than the first argument does.  The special
value \ttmkey{UNDEFINED}{argument of!an expression-definition@{\tt an
expression-definition}} can be given as the {\em CONTEXT} argument
to create a new expression definition whose pattern, guards, and block
are the same as those of {\em EXPRESSION-DEFINITION} argument
but whose context part is missing and can be set later.

There are two kinds of contexts: \mkey{immutable}{context} and
\mkey{mutable}{context}.
An immutable context cannot be modified.  A mutable context can have
its list (or set) modified.
Each kind can be either a set or a list.

A context can be created by:

\begin{indpar}
\verb|a| \ttkey{context}
    \begin{tabular}[t]{@{}l@{}}
    \verb|(| {\em CONTEXT-ELEMENT} \{ \verb|,| {\em CONTEXT-ELEMENT} \}
	\verb|)|
    \\
    \begin{tabular}[t]{@{}rl@{}}
    [ & \ttmkey{is list}{of context!of {\tt context}} {\em LIST} \\
    $|$ & \ttmkey{is mutable}{of context!of {\tt context}}
          {\em MUTABLE} \\
    $|$ & \ttmkey{with contexts missing}{of context!of {\tt context}}
           {\em CONTEXTS-MISSING} ]\opt
    \end{tabular}
    \end{tabular}
\end{indpar}

in which each {\em CONTEXT-ELEMENT} is either an expression definition or
a context, and {\em LIST}, {\em MUTABLE}, and {\em CONTEXTS-MISSING}
are either `{\tt false}' (the default) or `{\tt true}'.
If {\em CONTEXTS-MISSING} is {\tt false} (the default), any expression
definition {\em CONTEXT-ELEMENTS} that do not have their
contexts set will have them set equal to the context being created.

Thus given expression definitions that do not have their contexts set,
the default is to create an immutable context set whose expression definitions
have the new context and therefore can reference each other.  Blocks
containing {\em EXPRESSION-DEFINITIONs} perform exactly this kind of
context creation.

The {\em CONTEXT-ITEM} list of a context object is a list object
(\pagref{LIST}) which can be extracted from the context object by

\begin{indpar}
\verb|the| \ttmkey{list}{of context} \verb|of| {\em CONTEXT}
\end{indpar}

This list object is a list or set according to whether or not the
context is a list or set, and the list object is immutable or mutable
according to whether or not the context object is immutable or mutable.
If mutable, altering the list object will alter its containing context
object, and this is in fact the only way to mutate a mutable context.

The above expressions are defined by the
expression definitions (\secref{EXPRESSION-DEFINITIONS}):

\begin{indpar}
\begin{verbatim}
an expression-definition {
    on an expression-definition EXPRESSION-DEFINITION CONTEXT
       <-- expression-definition EXPRESSION-DEFINITION,
           context CONTEXT
    on set SELF context CONTEXT <-- context CONTEXT
}
a context {
    on a context CONTEXT-ELEMENT-LIST
       ?? is list ( LIST ~ false )
       ?? is mutable ( MUTABLE ~ false )
       ?? with context missing ( CONTEXT-MISSING ~ false )
       <-- list CONTEXT-ELEMENT-LIST of context-items
}
context-item X <-- expression-definition X
context-item X <-- context X
\end{verbatim}
\end{indpar}

\section{Blocks}
\label{BLOCKS}

A block is a set of variables, values for some of the variables, and
code for computing these values.

\subsection{Block Syntax}
\label{BLOCK-SYNTAX}

The code of a block has the following syntax:

\begin{indpar}
\key{block} ::= \verb|{| {\em group}
                         \{ {\em sequence-break} {\em group} \}\,$^\star$
			 \verb|}| \\[1ex]
\key{sequence-break} ::= \ttnbkey{---}\verb|-|$^\star$
	(1 word consisting of 3 or more \verb|-|'s) \\[1ex]
\key{group} ::= {\em declaration-group} $|$ {\em statement-group}
			 \\[1ex]
\key{declaration-group}\label{DECLARATION-GROUP} ::= {\em declaration}
    \{ \verb|;| {\em declaration} \}$^\star$ \\[1ex]
\key{statement-group} ::= {\em statement}
	\{ \verb|;| {\em statement} \}$^\star$ \\[1ex]
\key{declaration}
    \begin{tabular}[t]{rl}
    ::= & {\em expression-definition} \\
    $|$ & {\em method-definition} \\
    $|$ & {\em empty} \\
    \end{tabular} \\[1ex]
\key{expression-definition} ::= {\em EXPRESSION-DEFINITION} 
				(see \pagref{EXPRESSION-DEFINITION}) \\[1ex]
\key{method-definition} ::= \ttkey{on} {\em EXPRESSION-DEFINITION} \\[1ex]
\key{statement} ::= {\em qualified-statement} $|$ {\em empty} \\[1ex]
\key{qualified-statement}
    \begin{tabular}[t]{rl}
    ::= & {\em assignment-statement} \\
    $|$ & {\em unguarded-subblock} \\
    $|$ & {\em guarded-statement} \\
    $|$ & {\em statement-qualifier} {\em qualified-statement}
    \end{tabular} \\[1ex]
\key{statement-qualifier} ::= \ttkey{first}
			  $|$ \ttkey{always}
			  $|$ \ttkey{default}
			  \\[1ex]
\key{assignment-statement}
	\begin{tabular}[t]{rl}
	::= & {\em variable-assignment-statement} \\
	$|$ & {\em pattern-assignment-statement}
	\end{tabular} \\[1ex]
\key{variable-assignment-statement} ::=
	{\em output-variable} \ttkey{=} {\em right-side} \\[1ex]
\key{right-side} \
    \begin{tabular}[t]{rl}
    ::= & {\em right-side-expression} \\
    $|$ & {\em right-side-expression} \ttnbkey{=>} {\em output-variable}
		\{ \verb|,| {\em output-variable} \}\,$^\star$
    \end{tabular} \\[1ex]
\key{right-side-expression} ::= {\em EXPRESSION} \\[1ex]
\key{output-variable} ::= {\em variable-name} $|$ {\em next-variable} \\[1ex]
\key{input-variable} ::= {\em variable-name} $|$ {\em next-variable} \\[1ex]
\key{next-variable} ::= \ttkey{next} \verb|(| {\em variable-name} \verb|)|
		\\[1ex]
\key{variable-name} ::= {\em word} \\[1ex]
\key{pattern-assignment-statement} ::=
	{\em assignment-pattern} \verb|~=~|\index{~=~@{\tt \Tilde=\Tilde}}
	{\em right-side} \\[1ex]
\key{assignment-pattern} ::= {\em EXPRESSION} \\[1ex]
\key{unguarded-subblock} ::= \verb|{| {\em statement-group} \verb|}| \\[1ex]
\key{guarded-statement} ::=
      {\em if-statement} $|$ {\em when-statement} \\[1ex]
\key{if-statement} ::=
      \begin{tabular}[t]{l}
      \ttkey{if} {\em guard} {\em guarded-subblock} \\
      {\em else-if-continuation}\,$^\star$ \\
      {\em else-continuation-option}
      \end{tabular} \\[1ex]
\key{else-if-continuation} ::=
      \verb|;| \ttkey{else if} {\em guard} {\em guarded-subblock} \\[1ex]
\key{else-continuation-option} ::= {\em empty} $|$
      \verb|;| \ttkey{else} {\em guard} {\em guarded-subblock} \\[1ex]
\key{when-statement} ::=
      \ttkey{when} {\em guard} {\em guarded-subblock} \\[1ex]
\key{guard} ::= {\em right-side} \\[1ex]
\key{guarded-subblock} ::= \verb|{| {\em statement-group} \verb|}|
\end{indpar}

A block is parsed when the statement that contains it (typically
an {\em EXPRESSION-DEFINI\-TION}, \pagref{EXPRESSION-DEFINITION})
is parsed.  Because the \ttmkey{;}{statement separator} operator used
as a statement separator in a {\em block} is by default
{\tt definitional} (\pagref{DEFINITIONAL}), in addition to {\em statements}
a {\em block}
can contain definitions that control parsing but do not become part of the
parsed block.  Such definitions are omitted from the above syntax.

When the pattern and guard parts of an expression definition are parsed,
they are parsed together to create an expression graph, and
implicit conversion (\pagref{IMPLICIT-CONVERSION}) of variable names
is used to produce variables for that graph.
Any {\em block} part of the expression
definition is parsed separately to produce a separate expression graph that
has no expression graph variables (it does have variables in
a different sense: see \secref{BLOCK-VARIABLE-NAMES}).
Implicit conversion is not used for any part of {\em block} parsing,
except for {\em assignment-patterns}, {\em expression-definitions},
and {\em method-definitions}, each of which becomes a separate
expression graph with its own separate expression graph variables
[TBD: how is this represented and done?].

\subsection{Block Variable Names}
\label{BLOCK-VARIABLE-NAMES}

After parsing, the {\em variable-names} in the code of
a block are identified.  Each
{\em variable-name} is a subexpression consisting of a single
{\em word}, but not all such subexpressions are {\em variable-names}.
Some {\em variable-names} may be \mkey{inherited}{variable-name}
from a statement containing the block.
Some are {\em output-variables} in {\em assignment-statements}
or {\em guards}.
Some are expression graph variables of {\em assignment-patterns}.
All the {\em variable-names}
in the block are inherited or can be identified by looking at the left
sides of {\em assignment-statements} or at the {\em output-variables}
following \verb|=>| in {\em assignment-statements} or {\em guards}.

When identifying {\em variable-names} in a {\em block}, {\em statements} in a
{\em subblock} of the {\em block} are treated as if they
were in the {\em block} proper.  Thus variables named in the
{\em subblock} are variables named in the {\em block}.\footnote{
CASTLE does not have the notion of name space nesting, because the
{\tt \CurlyBra\CurlyKet} brackets that would
indicate nesting can be implied by the {\tt :} construction.}

If a {\em block} is part of an {\em EXPRESSION-DEFINITION}
(\pagref{EXPRESSION-DEFINITION}), the names of expression graph variables of
the {\em pattern} and {\em guard-list} expression tree
become {\em variable-names} inherited by the {\em block}.
Thus in

\begin{indpar}[1in]
\verb|sum from X through Y <-- integer X, integer Y| {\em block}
\end{indpar}

the variable names \verb|X| and \verb|Y| are inherited by the {\em block}.

An {\em assignment-pattern} is parsed to an expression graph with its
own expression graph variables.  These variables are called
\skey{pattern variable}s, and their names become
{\em variable-names} of the {\em block} containing the
{\em assignment-pattern}.  Thus in the statement

\begin{indpar}[1in]
\verb|X + Y ~=~ `5 + ( 7 * y )'|
\end{indpar}

the variable names \verb|X| and \verb|Y| are pattern variable names
that are {\em variable-names} of the {\em block} containing this
{\em pattern-assignment-statement}.

The variable named before the \verb|=| in a {\em variable-assignment-statement}
is an {\em output-variable}.
Variables named after \verb|=>| following an expression in
a {\em right-side} are also {\em output-variables}.  In the statements

\begin{indpar}[1in]\begin{verbatim}
when sort x to y => y:
    z = first 
\end{verbatim}\end{indpar}

\verb|y| and \verb|z| are {\em output-variables}.

From the point of view of block evaluation there is no distinction between
variable names beginning with \verb|#| and other variable names.  The
only distinction occurs in {\em EXPRESSION-DEFINITION} {\em patterns},
where the values obtained by call unification for input variables
whose names do not begin with \verb|#| are replaced by their evaluations
(\pagref{PROTECTED-VARIABLE}).

TBD: Arrays and array element names.

\subsection{Block Evaluation}
\label{BLOCK-EVALUATION}

\ikey{Blocks}{block!evaluation}
are divided into \ikey{groups}{group!evaluation} by \skey{sequence-break}s.
The {\em groups} are evaluated in order: each group being completely
evaluated before the next group is evaluated.  However,
evaluation within a \mkey{statement-group}{evaluation}
is driven by availability of variable values,
and not by the order of the {\em statements} in the group.

Each variable in a block can be assigned at most one value: it is
an error if the variable is assigned a value more than once during
a block evaluation, even if all the values assigned are the same.

The \skey{input-variable}s of a {\em right-side-expression} are all
variables in the expression that are not {\em output-variables} or
{\em pattern-variables} of
the {\em assignment-statement} or {\em guard} containing the expression.
Each {\em right-side-expression} in a {\em statement-group}
is evaluated only when all its input variables have values.
When the {\em right-side-expression} of an {\em assignment-statement}
is evaluated, the variables named on the left side of the statement and any
{\em output-variables} named after a \verb|=>| in the {\em right-side}
are given values.
When the {\em right-side-expression} of a {\em guard} is evaluated, any
{\em output-variables} named after a \verb|=>| in the {\em guard}
are given values.

None of the statements in an {\em if-statement}
{\em guarded-block} are
evaluated until the block's {\em guard} has been evaluated to true.
If the guard evaluates to false, no statement in the
{\em guarded-block} is ever evaluated.  An {\em else-if-continuation}
{\em guard} is not evaluated until all {\em guards}
in any preceding {\em if-statement}
or {\em else-if-continuations} in the same {\em guard-statement}
have been evaluated to false.  The {\em guarded-block} of an
{\em else-continuation} is evaluated if and only if
all {\em guards} in any preceding {\em if-statement}
or {\em else-if-continuation} in the same {\em guard-statement}
have been evaluated to false.

An example application of these rules is:

\begin{indpar}\begin{verbatim}
{
  z = y1
  z = y2
  if X > 5:
    y1 = 9
  else:
    y2 = 10
}
\end{verbatim}\end{indpar}

where \verb|X| is an inherited variable name.  If \verb|X > 5| is true,
the variable \verb|y1| is given the value \verb|9| and then
\verb|z| is given this value, while the variable \verb|y2|
is never given a value.  If \verb|X > 5| is false,
the variable \verb|y2|
is given the value \verb|10| and then \verb|z| is given this
value, while the variable \verb|y1| is never given a value.

A {\em when-statement} is just like an {\em if-statement} that has
no {\em else-if-continuation} or {\em else-continu\-a\-tion}.
[TBD: what about making a variable true if it has ANY value, for the
purposes of a {\em when-statement}?]

A {\em statement-group} terminates when all the
{\em right-side-expressions} in it have either been evaluated or
cannot be evaluated because of lack of an input variable value or
because of {\em guards}.
Once a {\em statement-group}
terminates, no part of the group can be evaluated, even if another group
later in the block defines that part's input variables.

However, group evaluation is additionally modified by {\em statement-qualifiers}
(\secref{DEFAULT-STATEMENTS}, \secref{ITERATION}).

The \ikey{declarations}{declaration!evaluation} of a
\mkey{declaration-group}{evaluation} are evaluated in order.  Evaluation of a
{\em declaration} just adds its definition to the current context.
The {\em declaration-group} terminates when its last {\em declaration}
has evaluated.  There are no {\em guards} or block variables in a declaration
group (the variables of a definition are not variables of the block).

\ikey{Empty-statements}{empty-statement!evaluation} and
\ikey{empty-declarations}{empty-declaration!evaluation} do nothing
when they evaluate.

The {\em groups} of a {\em block} are evaluated in order.  No part of
a {\em group}
can evaluate until all previous {\em groups} of the block have completely
finished evaluating.  Once a {\em group} starts to evaluate, no part of
a previous {\em group} can evaluate.

A {\em block} terminates when its last group terminates.

When a block terminates, the \mkey{value}{of block} of the block is the
value of its {\tt value} variable\index{value variable@{\tt value} variable},
if any.  Thus the block

\begin{center}
\verb|{ value = X + Y }|
\end{center}

which inherits the variables \verb|X| and \verb|Y| will return
the sum of its inherited variables as the value of the block.

If a block finishes without producing a value for a variable named
{\tt value}, the value of the block is \ttmkey{true}{block value}.

Block evaluation is additionally modified by {\em statement-qualifiers}
and {\em next-variables}
(\secref{DEFAULT-STATEMENTS} and \secref{ITERATION}).

\subsection{Default Statements}
\label{DEFAULT-STATEMENTS}

The \ttkey{default} {\em statement-qualifier} modifies group execution.
A statement qualified by {\tt default}
is called a \key{default statement}.  Default statements in a {\em group}
are initially inactive, meaning that they are treated as if they do not exist,

After the {\em group} without its default statements finishes executing,
any default statement in the {\em group} that has
\underline{no} output or pattern variable with a value
is made active.  All default statements that can be made active in this
way are made active at the same time.  Then the {\em group}, which now
consists of all non-default statements and all active default statements,
continues executing, until no more non-default or active default statement
can be executed.

Since all default statements that become active in a group become active
at the same time, it is possible for an error to occur if two such
statements assign values the same variable.

An example application of these rules is:

\begin{indpar}\begin{verbatim}
{
  if X > 5:
    value = `true'
  default value = `false'
}
\end{verbatim}\end{indpar}

where \verb|X| is an inherited variable name.  If \verb|X > 5| is true,
the value of the block is `{\tt true}' and the {\tt default}
{\em assignment-statement} remains inactive, but if \verb|X > 5| is false,
the {\tt default} {\em assignment-statement} becomes active and
the value of the block is `{\tt false}'.

\subsection{Iteration}
\label{ITERATION}

A block can \key{iterate}, meaning that it generates another block
that is the next block in a sequence of blocks.  A block
iterates if it does \underline{not} produce a value of a {\tt value}
variable and if it does produce a value for a {\em next-variable}.
The sequence of blocks are called the
\skey{iteration}s of the sequence.  Evaluation of a block can always
be thought of as producing a sequence of iterations, though this
sequence might include only one block which does not iterate.

A {\em next-variable} is named by a {\em variable-name} that is the
operand of a \ttkey{next} unary operator.  A {\em next-variable}
is effectively a new variable with a name derived from the
{\em variable-name}.  We will used the notation \verb|next(|$V$\verb|)|
to denote the {\em next-variable} made from the variable name $V$.
The value of \verb|next(|$V$\verb|)| at the end of execution of the
current block iteration becomes the value of $V$ at the beginning
of execution of the next block iteration.  In order for there to be
a next iteration, the current iteration must compute the value of
some {\em next-variable}, and the current iteration must not compute
the value of the {\tt value} variable.

{\em Next-variables} can be both output and input variables.
When used as input variables they are just like other input variable.
The {\tt next} operator can be applied to an expression that does not
consist solely of a {\em variable-name}.  When this is done, it is
as if the {\tt next} operator had instead been applied to every
{\em variable-name} in the expression.  Thus `\verb|next(x+y)|' is
the equivalent of `\verb|next(x) + next(y)|'.

If a default statement outputs a {\em next-variable}, the statement
cannot become active unless some other {\em next-variable} has already
been given a value.  Thus the decision to iterate cannot be made inside
a default statement.

A statement of the form

\begin{center}
\verb|default| \verb|next(|$V$\verb|)| = $V$
\end{center}

is implied in the last group of a block
for every inherited {\em variable-name} $V$ provided
no other default statement in the last group of the block
outputs \verb|next(|$V$\verb|)|.
Thus inherited variables are normally propagated unchanged from
one iteration to the next.

If a {\em next-variable} is given the value of
the expression `\ttkey{UNDEFINED}',\label{UNDEFINED}
the variable will become undefined
at the beginning of the next iteration.  Thus the statement

\begin{center}
\verb|default| \verb|next(|$V$\verb|) = UNDEFINED|
\end{center}

for an inherited {\em variable-name} $V$ will keep the inherited
variable from being propagated from one iteration to the next.
The expression `{\tt UNDEFINED}' cannot be used to set a
non-{\em next-variable}.

A \ttkey{first} qualified {\em statement} is only visible in the
first iteration of a block sequence.

An \ttkey{always} qualified {\em statement} is equivalent to the {\em statement}
qualified by {\tt first} plus additional {\em statements} of the form

\begin{center}
\verb|default| \verb|next(|$V$\verb|) = |$V$
\end{center}

for every {\em variable-name} $V$ that can be assigned by the
{\tt always} qualified {\em statement}.  Thus the
{\tt always} qualified {\em statement} will assign values on the first
iteration, and these values will then be propagated to subsequent iterations.


\section{Objects}
\label{OBJECTS}

An object is a typed block that can be used as a value.
A typed block, or object, has a type and inherits code from its type.

An \key{object} can be created by an {\em OBJECT} expression:


\begin{indpar}
\key{OBJECT} ::= \{ \ttkey{a} $|$ \ttkey{an} \} {\em type-name}
		      {\em block-option} \\[1ex]
\key{type-name} ::= {\em word}
\end{indpar}

The code in the {\em block} becomes a permanent part of the object.
The variable values defined by this code become \skey{component}s of the object.
These components can be retrieved by expressions of the form:

\begin{center}
\ttmkey{the}{the of@{\tt the} \ldots {\tt of}}
{\em variable-name}
\ttmkey{of}{the of@{\tt the} \ldots {\tt of}}
{\em object}
\end{center}

Objects are updated by adding code to them either permanently or temporarily.
Whenever code is added to an object, the code executes as much as it
can to define variable values that are then components of the object.
When the code can execute no further (\secref{BLOCK-EVALUATION},
\secref{DEFAULT-STATEMENTS}, \secref{ITERATION}), any
variables that do not have values become undefined components.  If some of
undefined components are given values later, any code that is a permanent
part of the object may restart and produce additional variable values that
define additional components.

Recall that the concept of being a variable of a block
of code is defined syntactically and independently of which variable values
the block actually computes (\secref{BLOCK-VARIABLE-NAMES}).
The components of an object are more precisely the syntactic variables
of the code added permanently to the object, whether or not these
variables have values defined by code added permanently or temporarily
to the object.  Variables of code added temporarily that are not
syntactically variables of code added permanently are
\underline{not} components of the object,
and are not visible outside the temporarily added code.

TBD: need a way to declare an object component without otherwise referencing
it in permanent code.

The permanent code of an object all belongs to the same group.  Blocks
of permanent code cannot have {\em sequence-breaks}, and therefore
have only one {\em group}.  Code that is added temporarily
to an object can have several groups, and the permanent code of the
object behaves as
if it were a separate group executed after the temporary code is executed.

A statement of the form:

\begin{indpar}
\ttkey{for every} {\em type-name} {\em block} 
\end{indpar}

adds the code in its block permanently to every object of the given type,
including both existing objects and objects that are
created in the future.  The code in the block is associated with the
type and is said to be `\skey{inherit}{ed}' by every object of that type.

A statement of the form:

\begin{indpar}
\ttkey{update} {\em OBJECT} {\em block} 
\end{indpar}\label{UPDATE}

where {\em OBJECT} evaluates to an object adds the code in the
{\em block} temporarily to the object.  The code is added and all
code in the object executes until it can do nothing more.  Then
the temporary code is removed from the object.

When code is added to an object and executes, the statement qualifier
{\tt default} acts when execution stops to enable execution of {\tt default}
statements, as per \secref{DEFAULT-STATEMENTS}.  Similarly
the {\tt next} operator can be used to create iterations of the
object.  Each iteration replaces the previous iteration of the object
wherever the object is referenced.  Thus if two variables equal
the object, and one is used to cause the object to iterate, both variable
values will become the new iterated object.

A statement of the form

\begin{center}
\verb|default| \verb|next(|$C$\verb|) = |$C$
\end{center}

is implied in the permanent code
for every component name $C$ of an object, provided
no other default statement in the permanent code
outputs \verb|next(|$C$\verb|)|.
Thus components are normally propagated unchanged from
one object iteration to the next.  A statement of the form

\begin{center}
\verb|default| \verb|next(|$C$\verb|) = UNDEFINED|
\end{center}

can be used to override this behavior to
make $C$ have no value at the beginning of the next object
iteration.

When an iteration of an object is created by temporary code, the
sequence of actions is:

\begin{center}
\begin{tabular}{lp{5.5in}}
(1) & Add the temporary code to the object. \\
(2) & Execute all object code until it terminates. \\
(3) & If any {\tt next} component values were defined by the
      execution in step (2), create
      the next iteration of the object, giving this
      iteration only the permanent code of the object. \\
(4) & In the next iteration of the object execute all
      code until it terminates.
\end{tabular}
\end{center}

Code can be temporarily added to an object by invoking methods.
A \key{method} is defined by a \key{method definition}
that is an expression definition which is part of the code of an object.
The method is callable from code inside or outside the object code block.
The syntax for a method definition is:

\begin{center}
\ttkey{on} {\em expression-definition}
\end{center}

When the method definition is called, the method code block
is added temporarily to the code that contained
the method definition.  The object whose code this is
may be referred to within its
code by the name \ttkey{SELF}, which may or may not also be an argument
of the method definition.  If it is an argument, the method definition
has an implicit guard that requires the {\tt SELF} argument value to be
equal to the object whose code contains the method definition.

If there is no {\tt SELF} argument, a new object
is created when the method is called, and the permanent code plus
method code is executed for that object.  The permanent code must
contain the method definition in this case.  Such a method is
called a {\tt constructor}, and the object created is said to be
constructed by the method execution.  Constructor executions usually return
the object they construct, but this is not required by the language.
Constructors usually
have patterns that begin with `\{ \verb|a| $|$ \verb|an| \} {\em type-name}',
where {\em type-name} names the type of object they construct, but
this is not required by the language either.

TBD: protection; protection zones.


\section{Side Effects}
\label{SIDE-EFFECTS}

A \key{side effect} is an action that changes memory, inputs information from
the outside world, or outputs information to the outside world.
When an expression is evaluated, it may or may not have side effects.

The order in which side effects are executed is determined by
{\em sequence-breaks} that divide a {\em block} into {\em groups}
further (\secref{BLOCK-EVALUATION}).  A programmer typically writes code
so there is at most one side effect per {\em group}, in order to
ensure side effects execute in the desired order.

TBD: could this last rule be enforced.

The \key{side effect mode} controls the execution of side effects.
It has three settings: {\tt execute}, {\tt delay}, and {\tt error}.
In \ttkey{execute mode} a side effect simply executes.  In
\ttkey{error mode} an attempt to execute a side effect raises an error,
and the side effect is not executed.

In \ttkey{delay mode} input and memory change side effects execute,
but put operations on an {\tt undo} list that can undo their effects,
while output side effects do not execute, but are instead put on a
{\tt todo} list.

There are two lists maintained that permit side effects to be delayed
or undone.  The \ttmkey{todo}{list} list is a list of delayed output
actions that have been delayed.  The \ttmkey{undo}{list} list is
a list of input and memory change actions that can be undone.
The position of these lists can be recorded and an undo
operation can be performed that backs up to previously recorded positions
by deleting actions form the end of the {\tt todo} list and undoing
actions on the end of the {\tt undo} list.

To control the side effect mode there is a \key{side effect mode stack}.
This contains items each of which contains a side effect mode and
positions in the {\tt todo} and {\tt undo} stacks.  The side effect mode
of the top item on the side effect mode stack is the effective side
effect mode for current execution.
Whenever an item is pushed to the side effect mode stack, the current
positions of the {\tt todo} and {\tt undo} lists are recorded in the
item.

The following statements operate on the side effect mode stack:

\begin{list}{}{}
\item[\ttkey{begin executing side effects}]~~~Push a new item with side effect
execute mode onto the side effect mode stack.  Before the push the
stack must be empty or the top item in the stack must have execute or
error mode.

\item[\ttkey{end executing side effects}]~~~Pop the top item from
the side effect mode stack.  This top item must have
execute mode.

\item[\ttkey{begin forbidding side effects}]~~~Push a new item with side effect
error mode onto the side effect mode stack.  Before the push the
stack must be empty or the top item in the stack must have execute or
error mode.

\item[\ttkey{end forbidding side effects}]~~~Pop the top item from the
side effect mode stack.  This top item must have
error mode.

\item[\ttkey{delay side effects}]~~~Push a new item with side effect
delay mode onto the side effect mode stack.

\item[\ttkey{commit side effects}]~~~Pop the top item from the
side effect mode stack.  This top item must have
delay mode.  It the resulting stack has a new top item that is not
delay mode, discard the contents of the {\tt undo} stack, and execute
and then discard the contents of the {\tt todo} stack.

\item[\ttkey{abort side effects}]~~~Pop the item from the
the side effect mode stack.  This top item must have
delay mode.  Consider the {\tt todo} and {\tt undo} list positions
of the new item at the top of the stack, or take these positions to be
the beginning of the lists if the stack has become empty.  Remove
elements from ends of the lists until these considered positions become
the current list positions.  When removing an element from the end of the
{\tt undo} list, perform the undo action specified by the element.

\end{list}

\section{Debugging}

Design:

Debugging is based on the notion that almost all
CASTLE programs will run quickly.
Input checkpointing is used to record all inputs to a computation
so the computation can be deterministically rerun.  Detailed
traces can be generated which explain for each value how it was generated.
Values have a sequence number that identifies the point in the execution
where they were generated.  It is therefore possible to ask for a detailed
accounting of how any value was generated, provided the run is short enough
to be repeated once or a few times so the computer can turn the history
tracing on appropriately.

\section{Design Notes}

These are some detailed design rules to be incorporated in the language
definition later.

\begin{list}{}{}

\item
{\bf Blank Algebraic Operators}.
The blank, or missing operator, denotes \verb|*| when it precedes a word,
as in \verb|5x| being equivalent to \verb|5*x|.  When it is between a
preceding integer and a following ratio, it adds the ratio to the integer,
as in \verb|41 1/3|.

\end{list}

\section{To Do}

Aren't there problems with evaluating `\verb|[x [y]]|' in that
the inner `\verb|[y]|' gets an \verb|-EVAL-OFF-|.

Why doesn't `\verb|define qualifier xxx|' mean define expressions equal
to `\verb|qualifier xxx|'.

\verb|missing(#X)| is true if \verb|#X| is a null node.
\verb|integer(#X)| is true if \verb|#X| is an integer.

Qualifier shortcuts should be conditioned on the first words of
the expression being qualified.  E.g., if these words are
`\verb|define operator|' the shortcut `\verb|left => |{\tt with
associativity [left]}' would be defined.

Expressions to be evaluated can have sets of possible values.

Imaginary Units\label{IMAGINARY-UNITS}

Visible Side Effects\label{VISIBLE-SIDE-EFFECTS}

List Objects\label{LIST}

Qualifier Definition\label{QUALIFIER-DEFINITION}

Qualifier Shortcut Definition\label{QUALIFIER-SHORTCUT-DEFINITION}

Automatic Optional Marks\label{AUTOMATIC-OPTIONAL-MARKS}

\bibliographystyle{plain}
\bibliography{castle}

\printindex

\end{document}

