%  RECKON (Personal Reckoning Langauge)
%
% File:         reckon.tex
% Author:       Bob Walton (walton@deas.harvard.edu)
% Date:		See \date below.

% Possible alternative names:
%
%	RECKON	Personal Reckoning Language
%	CASTLE  Calculation and Simulation Total Language Environment
%	MFL	Multi-Facetted Language
%	ROPE	Really Omni Programming Environment
%	RIPE	Robert's Information Processing Environment
%	AGILE	Another Goofy Information Language and Environment
%	OMNI	Omni-Programming Language
%	OPL	Omni-Programming Language
%	OPE	Omni-Programming Environment
%	APE	A Programming Environment
%	RUG	Really Useful Gadget
%	RUCL	Really Useful Computer Language
  
\documentclass[12pt]{article}

\usepackage[T1]{fontenc}
\usepackage{times}
\usepackage{makeidx}
\usepackage{etoolbox}

\makeindex

\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}
\raggedbottom

\setlength{\unitlength}{1in}

\pagestyle{headings}
\setlength{\parindent}{0.0in}
\setlength{\parskip}{1ex}

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}
\newcommand{\subsubsubsection}[1]{\paragraph[#1]{#1.}}
\newcommand{\subsubsubsubsection}[1]{\subparagraph[#1]{#1.}}

% Begin \tableofcontents surgery.

\newcount\AtCatcode
\AtCatcode=\catcode`@
\catcode `@=11	% @ is now a letter

\renewcommand{\contentsname}{}
\renewcommand\l@section{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\l@table{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\tableofcontents{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{0.8in}%
	      \setlength{\rightmargin}{0.8in}}%
    \item\@starttoc{toc}%
    \end{list}}
\renewcommand\listoftables{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}%
	      }%
    \item\@starttoc{lot}%
    \end{list}}

\catcode `@=\AtCatcode	% @ is now restored

% End \tableofcontents surgery.

\newcommand{\CN}[2]%	Change Notice.
    {\hspace*{0in}\marginpar{\sloppy \raggedright \it \footnotesize
     $^{\mbox{#1}}$#2}}
    % Change notice.

\newcommand{\TT}[1]{{\tt \bfseries #1}}

\newcommand{\key}[1]{{\bf \em #1}\index{#1}}
\newcommand{\lkey}[2]{{\bf \em #1 #2}\index{#1!#2}}
\newcommand{\mkey}[2]{{\bf \em #1}\index{#1!#2}}
\newcommand{\skey}[2]{{\bf \em #1#2}\index{#1}}
\newcommand{\smkey}[3]{{\bf \em #1#2}\index{#1!#3}}
\newcommand{\slkey}[3]{{\bf \em #1 #2#3}\index{#1!#2}}
\newcommand{\ikey}[2]{{\bf \em #1}\index{#2}}
\newcommand{\ttkey}[1]{\TT{#1}\index{#1@{\tt #1}}}
\newcommand{\ttlkey}[2]{\TT{#1 #2}\index{#1@{\tt #1}!#2@{\tt #2}}}
\newcommand{\ttmkey}[2]{\TT{#1}\index{#1@{\tt #1}!#2}}
\newcommand{\ttdkey}[1]{\TT{.#1}\index{#1@{\tt .#1}}}
\newcommand{\ttdmkey}[2]{\TT{.#1}\index{#1@{\tt .#1!#2}}}
\newcommand{\ttnbdkey}[1]{\TT{.#1}\index{#1@{\tt .#1}}}
\newcommand{\tttkey}[1]{\TT{<#1>}\index{#1@{\tt <#1>}}}
\newcommand{\tttmkey}[2]{\TT{<#1>}\index{#1@{\tt <#1>}!#2}}
\newcommand{\tttbkey}[1]{{\TT {<#1|}\ldots\TT{|#1>}}%
    \index{#1@\TT{<#1|}\ldots\TT{|#1>}}}
\newcommand{\tttbmkey}[2]{{\TT{<#1|}\ldots\TT{|#1>}}%
    \index{#1@\TT{<#1|}\ldots\TT{|#1>}!#2}}
\newcommand{\ttindex}[1]{\index{#1@{\tt #1}}}
\newcommand{\ttmindex}[2]{\index{#1@{\tt #1}!#2}}
\newcommand{\emkey}[1]{{\bf \em #1}\index{#1@{\em #1}}}
\newcommand{\emlkey}[2]{{\bf \em #1#2}\index{#1@{\em #1}!#2@{\em #2}}}
\newcommand{\emskey}[2]{{\bf \em #1#2}\index{#1@{\em #1}}}
\newcommand{\emslkey}[3]{{\bf \em #1#2#3}\index{#1@{\em #1}!#2@{\em #2}}}
\newcommand{\emikey}[2]{{\bf \em #1}\index{\em #2}}
\newcommand{\emindex}[1]{\index{#1@{\em #1}}}

\newcommand{\opt}{$^!$}

\newcommand{\itemref}[1]{\ref{#1}$\,^{p\,\pageref{#1}}$}
\newcommand{\secref}[1]{\ref{#1}$\,^{p\,\pageref{#1}}$}
\newcommand{\stepref}[1]{\ref{#1}\,$^{p\,\pageref{#1}}$}
\newcommand{\appref}[1]{\ref{#1}$\,^{p\,\pageref{#1}}$}
\newcommand{\figref}[1]{\ref{#1}$\,^{p\,\pageref{#1}}$}
\newcommand{\pagref}[1]{p\pageref{#1}}
\newcommand{\pagnote}[1]{$\,^{p\,\pageref{#1}}$}

\newcommand{\EOL}{\penalty \exhyphenpenalty}

\newcommand{\STAR}{{\Large $^\star$}}
\newcommand{\PLUS}[1][]{{$^{+#1}$}}
\newcommand{\QMARK}{{$^{\,\mbox{\footnotesize ?}}$}}
\newcommand{\OPEN}{{$\{$}}
\newcommand{\CLOSE}{{$\}$}}

\newcommand{\VSP}{\textvisiblespace}
\newcommand{\TILDE}{\textasciitilde}
\newcommand{\CIRCUM}{\textasciicircum}
\newcommand{\BSLASH}{\textbackslash}

\newlength{\figurewidth}
\setlength{\figurewidth}{\textwidth}
\addtolength{\figurewidth}{-0.40in}

\newsavebox{\figurebox}

\newenvironment{boxedfigure}[1][!btp]%
	{\begin{figure*}[#1]
	 \begin{lrbox}{\figurebox}
	 \begin{minipage}{\figurewidth}

	 \vspace*{1ex}}%
	{
	 \vspace*{1ex}

	 \end{minipage}
	 \end{lrbox}
	 \begin{center}
	 \fbox{\hspace*{0.1in}\usebox{\figurebox}\hspace*{0.1in}}
	 \end{center}
	 \end{figure*}}

\newenvironment{indpar}[1][0.3in]%
	{\begin{list}{}%
		     {\setlength{\itemsep}{0in}%
		      \setlength{\topsep}{0in}%
		      \setlength{\parsep}{1ex}%
		      \setlength{\labelwidth}{#1}%
		      \setlength{\leftmargin}{#1}%
		      \addtolength{\leftmargin}{\labelsep}}%
	 \item}%
	{\end{list}}

\newenvironment{labpar}[2][0.3in]%
	{\begin{list}{}%
		     {\setlength{\itemsep}{0in}%
		      \setlength{\topsep}{0in}%
		      \setlength{\parsep}{1ex}%
		      \setlength{\labelwidth}{#1}%
		      \setlength{\leftmargin}{#1}%
		      \addtolength{\leftmargin}{\labelsep}}%
	 \item[#2]}%
	{\end{list}}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{lemma}[theorem]{Lemma}

\begin{document}
        
\title{Personal Reckoning Language\\[2ex]
       RECKON\\[2ex]
       (Draft 3a)}

\author{Robert L. Walton\thanks{Copyright 2022 Robert L. Walton.
Permission to copy this document verbatim is granted by the author
to the public.  This document was partly inspired
by teaching courses at Suffolk University with the help of
Paul Ezust, and by the work of Thomas
Cheatham and Stuart Shieber.}}

\date{December 14, 2022}

\maketitle

\newpage
\begin{center}
\large \bf Table of Contents
\end{center}

\bigskip

\tableofcontents 

\newpage

\section{Introduction}

This document describes the programming language RECKON.  RECKON,
for what its worth, stands for `Personal Reckoning Language',
which hints at its purpose.

RECKON is designed for naive programmers: that is, for people who may never
be able to program computers well.  It is a fairly simple language with
powerful data types that make it easier to write small programs
that do a variety of tasks a person might want to do.  Generally
the tasks fall into the categories of calculating things (taxes,
probabilities, statistics) or simulating things
(computer games, construction designs, mathematics demonstrations).
Included are:

\begin{center}
\begin{tabular}{l}
Calculations that might be done with a spreadsheet. \\
Drawing pictures. \\
Simulating popular board games and creating new ones. \\
Creating simple computer games, including dialog games. \\
Computing and analyzing documents. \\
Doing elementary algebra and calculus problems. \\
Doing matrix calculations. \\ 
Calculating basic probabilities and statistics. \\
Simulating two and three dimensional objects. \\
Simulating simple electrical, mechanical, chemical, and biological systems.\\
Solving problems in elementary logic. \\
\end{tabular}
\end{center}

There are many computer languages that have some powerful data type that adapts
them for a specific kind of computation.  RECKON tries to combine these.
Some previous computer languages that have influenced RECKON, and
the data types they particularly support, are:

\begin{center}
\begin{tabular}{l@{\hspace{0.5in}}l}
Various Spreadsheets		& Spreadsheets \\
Various Data Base Languages	& Data Bases \\
Various Script Languages	& Documents \\
MATLAB				& Matrices \\
Mathematica			& Mathematical Formulae \\
TCL				& Character Strings and Lists \\
Lisp				& Words and Phrases \\
PROLOG				& Logical Expressions \\
\end{tabular}
\end{center}

RECKON is \underline{not} designed to be a computer-efficient language.
It is designed to be person-efficient, and to do small calculations
rapidly enough with inexpensive modern computers.

\section{Remarks}

RECKON was created as an answer to the question: what programming language
should you teach beginning programming students most of whom do not have
the talent or will not develop the inclination
to become serious programmers?  The initial answer, that it does
not matter provided you implement some powerful types of data in the
language you choose, has a flaw.  The flaw is that without the right powerful
data types, the language will be useless to the students after the course
is over.  So what is needed is a programming language that will be useful
to students after a first course in programming, and the essence of
such a language is the integration within it of many powerful and useful
data types.

The basic principles of the RECKON design were developed
by the author while teaching the intended customers of
RECKON.\footnote{Specifically, while teaching CS121 at Suffolk University
using the C programming language.}
The language should have as few parts as possible, to cut down
on the amount of detail that must be remembered to use the language, but
conversely, there is no limit to the conceptual complexity of any well-used
part.\footnote{There was no problem teaching recursion, but it was better
not to teach many different looping constructs.}
The language should have powerful data types, well integrated into
the syntax of the language.  As much as possible, statement executions
in the language should have visible effect.

RECKON is also based on the `\key{Syntactic Hypothesis}', which is that
people reason syntactically and not in any other way, and therefore
syntax matters a lot.  In particular, different kinds of reasoning
require different syntactic support.

The current version of RECKON is not stable, because it has not been
implemented, and because, like most programming languages, RECKON
has lots of subtle important interactions between its various features.  The
hope is that after implementation and experimentation a stable sensible
version of RECKON, integrating all its data types and supporting each
with special syntax, can be achieved.

\section{Overview}

RECKON has two major kinds of data: expressions and blocks.  Numbers are
the simplest expressions.  More complex expressions are math
expressions or document expressions.  A block is a set of variables
and pieces of code.  Each variable can have a value, which is an expression.
Each block has a unique indentifier, which by itself can be used as
an expression that names the block.
The code contains expressions that can be evaluated under appropriate
circumstances to produce values for variables.

In RECKON a `description' is a block that has an associated `type'.  For
example, there may be a description `george' with type `person'.  All
descriptions of the same type have the same code,
and many of the same variables,
but typically have different variable values.

You can use RECKON as a calculator by typing into it expressions to
be evaluated, assignments of values to variables, and definitions
of functions, predicates, and blocks.  Some examples involving numbers are:

\begin{indpar}\begin{verbatim}
> 9
9
> 9 + 8
17
> x = 9
9
> y = 9 + 8
17
> x + y
26
> f (B, C, X) = B * X + C
f (B, C, X) evaluates to (B * X + C)
> f (10, x, y)
179
\end{verbatim}\end{indpar}

Here the `\TT{>~}' at the beginning of some lines is the RECKON \key{prompt}
that tells you its OK to input an expression to be evaluated.
Except for this prompt, lines beginning with `\TT{> }' are input lines to
a RECKON interpreter, and other lines are output lines.

Note that in RECKON names must be separated by whitespace.  Thus
`\TT{b * x}' names three things: the variable `\TT{b}', the
operator `\TT{*}', and the variable `\TT{x}'.  In contrast,
`\TT{b*x}' would name one thing, a variable (with a strange name).
However parentheses such as `\TT{(}' and `\TT{)}' need not be
separated from anything else by whitespace, and separators such as
`\TT{,}' need not be separated by what is \underline{before} them
by whitespace.

At somewhat the opposite extreme from numbers are words, phrases, sentences,
and paragraphs.  You can calculate with these `\skey{document expression}s\,'.%
\footnote{In what follows,
if we followed LISP, each \TT{[]} would cancel one \TT{`~'},
so \TT{`{}`[g]'{}'} would evaluate to \TT{`[g]'}
and \TT{`{}`[[g]]'{}'} would evaluate to \TT{`hello'}.  But we do the
reverse of this, so in RECKON \TT{`{}`[g]'{}'} evaluates to \TT{`hello'}
and \TT{`{}`[[g]]'{}'} evaluates to \TT{`[g]'}.}

\begin{indpar}
\verb|> g = `hello'| \\
hello \\
\verb|> `[g] there'| \\
hello there \\
\verb|> z = ``I thought he said `[g]'.''| \\
I thought he said `hello'. \\
\verb|> notice = *TEXT*:| \\
\verb|+     {p} // Introduces paragraph.| \\
\verb|+     This document is meant to be read.| \\
\verb|+     Reading this document is good, but...| \\
\verb|+     | \\
\verb|+     // {p} is implied after blank line.| \\
\verb|+     [z]|

This document is meant to be read.  Reading this document is good, but\ldots
\\[2ex]
I thought he said `hello'. \\
\verb|> `When you add [x] and [y] you get [x + y].'| \\
When you add 9 and 17 you get 26.
\end{indpar}

Modern math computes with expressions, and not just numbers.
You can compute with \skey{math expression}s in RECKON.

\begin{indpar}
\verb/> f = {{ 10 x ^ 2 - 3.67 x - 0.04 }}/ \\
$10x^2-3.67x-0.04$ \\
\verb/> h = {{- 0.96 + 0.67 x}} in x/ \\
$-0.96+0.67x$ \\
\verb/> {{f + h}} in x/ \\
$10x^2-3x-1$ \\
\verb/> solve {{f + h = 0}} in x for x/ \\
$x = (-0.2, 0.5)$ \\
\verb/> {{f + h}} in x at (3, 4, 5)/ \\
\verb/(78.95, 145.28, 231.61)/ \\
\verb/> g = {{ integral (x ^ 2, dx) }}/ \\
$\int x^2 dx$ \\
\verb/> simplify g/ \\
$\frac{1}{3} x^3$ \\
\verb/> g from 1 to 5/ \\
$\int_{x = 1}^{x = 5} x^2 dx$ \\
\verb/> v = simplify ( g from 1 to 5 )/ \\
\verb:41 1/3: \\
\verb/> out = `The value of [g from 1 to 5] is [v].'/ \\
The value of $\int_{x = 1}^{x = 5} x^2 dx$ is $41\frac{1}{3}$.
\end{indpar}

Matrices are another kind of data that you can compute
with:

\begin{indpar}
\verb/> V =# {| 1  2  3 |}/ \\
\verb/1 2 3/ \\
\verb/> M =#:/ \\
\verb/+    | 0  1   1|/ \\
\verb/+    |-1  1   0|/ \\
\verb/+    | 1  0  -1|/ \\
\verb/| 0  1   1|/ \\
\verb/|-1  1   0|/ \\
\verb/| 1  0  -1|/ \\
\verb/> V ^ T/ \\
\verb/|1|/ \\
\verb/|2|/ \\
\verb/|3|/ \\
\verb/> M * V ^ T/ \\
\verb/| 5|/ \\
\verb/| 1|/ \\
\verb/|-2|/
\end{indpar}

Another kind of datum you can compute with in RECKON is
the block.  A \key{block} contains a set of variables, each of which
can have a value which is either an expression or the identifier of a
block.  A block can also
have code, which contains expressions that are evaluated under appropriate
circumstances to produce values for the block's variables.

In RECKON a \key{description}
is a block that has an associated \key{type}.  For
example, there may be a description named `Jack' with type `person'.
All descriptions
of the same type have the same code, and many of the same variables,
but typically have different variable values.  For example:

\begin{indpar}
\verb|> a person:| \\
\verb|+     name = `Jack'| \\
\verb|+     weight = 123 lb| \\
\verb|+     height = 5 ft 9 in| \\
\verb|+     age = 23 yr 2 mo| \\
\begin{tabular}{|r|l|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf type} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000000 & person & Jack & \tt 123 lb & \tt 5 ft 9 in & \tt 23 yr 2 mo \\
\hline
\end{tabular} \\[0.5ex]
\verb|> a person:| \\
\verb|+     name = `Jill'| \\
\verb|+     weight = 110 lb| \\
\verb|+     height = 5 ft 7 in| \\
\verb|+     age = 21 yr 8 mo| \\
\begin{tabular}{|r|l|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf type} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000001 & person & Jill & \tt 110 lb & \tt 5 ft 7 in & \tt 21 yr 8 mo \\
\hline
\end{tabular} \\[0.5ex]
\verb|> all persons| \\
\begin{tabular}{|r|l|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf type} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000000 & person & Jack & \tt 123 lb & \tt 5 ft 9 in & \tt 23 yr 2 mo \\
\tt @1000001 & person & Jill & \tt 110 lb & \tt 5 ft 7 in & \tt 21 yr 8 mo \\
\hline
\end{tabular} \\[0.5ex]
\verb|> the person Jack| \\
\begin{tabular}{|r|l|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf type} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000000 & person & Jack & \tt 123 lb & \tt 5 ft 9 in & \tt 23 yr 2 mo \\
\hline
\end{tabular} \\[0.5ex]
\verb|> the person named Jack's height| \\
\verb|5 ft 9 in| \\
\verb|> the weight of the person named Jack| \\
\verb|123 lb| \\
\verb|> @1000001| \\
\begin{tabular}{|r|l|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf type} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000001 & person & Jill & \tt 110 lb & \tt 5 ft 7 in & \tt 21 yr 8 mo \\
\hline
\end{tabular} \\[0.5ex]
\verb|> the weight of @1000001| \\
\verb|110 lb|
\end{indpar}

It is possible to add code to a type such as `\TT{person}'.  This has
the affect of adding the code to all blocks that are descriptions of that type.
For example:

\begin{indpar}
\verb|> for every person:| \\
\verb|+     body mass index = 703.06958 * weight in lbs| \\
\verb|+                     / height in inches ^ 2| \\
\verb|> all persons| \\
\begin{tabular}{@{}|r|l|l|r|r|r|r|@{}}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf type} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} &
\multicolumn{1}{|c|}{\bf \shortstack{body mass\\index}} \\
\hline
\tt @1000000 & person & Jack
	     & \tt 123 lb & \tt 5 ft 9 in & \tt 23 yr 2 mo & \tt 18.1637 \\
\tt @1000001 & person & Jill
	     & \tt 110 lb & \tt 5 ft 7 in & \tt 21 yr 8 mo & \tt 17.2282 \\
\hline
\end{tabular}
\end{indpar}

One can use definitions to define expressions that compute values:

\begin{indpar}
\verb|> sum from X through Y <-- X is an integer, Y is an integer:| \\
\verb|+     `Sum of integers from X through Y.'| \\
\verb|+     if X > Y:| \\
\verb|+         value = 0| \\
\verb|+     else:| \\
\verb|+         value = X + sum (X + 1) through Y| \\
\verb|> sum from 5 through 10| \\
\verb|45| \\
\verb|> all (sums from X through Y)| \\
\begin{tabular}{|r|r|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf parent} &
\multicolumn{1}{|c}{\bf X} &
\multicolumn{1}{|c}{\bf Y} &
\multicolumn{1}{|c|}{\bf value} \\
\hline
\tt @1000002 &       		& \tt 5	& \tt	10	& \tt 45 \\
\tt @1000003 & \tt @1000002	& \tt 6	& \tt	10	& \tt 40 \\
\tt @1000004 & \tt @1000003	& \tt 7	& \tt	10	& \tt 34 \\
\tt @1000005 & \tt @1000004	& \tt 8	& \tt	10	& \tt 27 \\
\tt @1000006 & \tt @1000005	& \tt 9	& \tt	10	& \tt 19 \\
\tt @1000007 & \tt @1000006	& \tt 10	& \tt	10	& \tt 10 \\
\tt @1000008 & \tt @1000007	& \tt 11	& \tt	10	& \tt 0 \\
\hline
\end{tabular} \\[0.5ex]
\verb|> sum from 1 through 2| \\
\verb|3| \\
\verb|> all (sums from X through Y)| \\
\begin{tabular}{|r|r|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf parent} &
\multicolumn{1}{|c}{\bf X} &
\multicolumn{1}{|c}{\bf Y} &
\multicolumn{1}{|c|}{\bf value} \\
\hline
\tt @1000002 &       		& \tt 5		& \tt	10	& \tt 45 \\
\tt @1000003 & \tt @1000002	& \tt 6		& \tt	10	& \tt 40 \\
\tt @1000004 & \tt @1000003	& \tt 7		& \tt	10	& \tt 34 \\
\tt @1000005 & \tt @1000004	& \tt 8		& \tt	10	& \tt 27 \\
\tt @1000006 & \tt @1000005	& \tt 9		& \tt	10	& \tt 19 \\
\tt @1000007 & \tt @1000006	& \tt 10	& \tt	10	& \tt 10 \\
\tt @1000008 & \tt @1000007	& \tt 11	& \tt	10	& \tt 0 \\
\tt @1000009 &       		& \tt 1		& \tt	2	& \tt 3 \\
\tt @1000010 & \tt @1000009	& \tt 2		& \tt	2	& \tt 2 \\
\tt @1000011 & \tt @1000010	& \tt 3		& \tt	2	& \tt 0 \\
\hline
\end{tabular}
\end{indpar}

Executions can be examined in detail, because
when an expression is computed, the block that computes it is remembered
for some time.  However, as memory is finite, eventually these
computations are forgotten as they can always be regenerated if
needed.

The sum above was computed by recursion: to compute the sum of 5 through 10
one adds 5 to the sum of 6 through 10.  One can also compute sums by
iteration.

\begin{indpar}
\verb|> sum from X through Y <-- X is an integer, Y is an integer:| \\
\verb|+     `Sum of integers from X through Y.'| \\
\verb|+     value = 0| \\
\verb|+     while X <= Y:| \\
\verb|+         next value = value + X| \\
\verb|+         next X = X + 1| \\
\verb|> sum from 5 through 10| \\
\verb|45| \\
\verb|> all (sums from X through Y)| \\
\begin{tabular}{|r|r|r|r|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf previous} &
\multicolumn{1}{|c}{\bf next} &
\multicolumn{1}{|c}{\bf X} &
\multicolumn{1}{|c}{\bf Y} &
\multicolumn{1}{|c}{\bf sum} &
\multicolumn{1}{|c|}{\bf value} \\
\hline
\tt @1000012 &              & \tt @1000013
	     & \tt 5	& \tt 10   & \tt 0	& \\
\tt @1000013 & \tt @1000012 & \tt @1000014
	     & \tt 6	& \tt 10   & \tt 5	& \\
\tt @1000014 & \tt @1000013 & \tt @1000015
	     & \tt 7	& \tt 10   & \tt 11	& \\
\tt @1000015 & \tt @1000014 & \tt @1000016
	     & \tt 8	& \tt 10   & \tt 18	& \\
\tt @1000016 & \tt @1000015 & \tt @1000017
	     & \tt 9	& \tt 10   & \tt 26	& \\
\tt @1000017 & \tt @1000016 & \tt @1000018
	     & \tt 10	& \tt 10   & \tt 35	& \\
\tt @1000018 & \tt @1000017 &
	     & \tt 11	& \tt 10   & \tt 45	& \tt 45 \\
\hline
\end{tabular}
\end{indpar}

One can also iterate over data.

\begin{indpar}
\verb|> average weight of X <-- list X of persons:| \\
\verb|+     first count = 0| \\
\verb|+     first sum = 0| \\
\verb|+     if X = ():| \\
\verb|+         if count = 0:| \\
\verb|+             value = error `Cannot average 0 things.'| \\
\verb|+         else:| \\
\verb|+             value = sum / count| \\
\verb|+     else:| \\
\verb|+         next count = count + 1| \\
\verb|+         next sum = sum + the weight of (first X)| \\
\verb|+         next X = rest X| \\
\verb|> average weight of (all persons)| \\
\verb|116.5 lbs| \\
\verb|> z = 10 + average weight of (all persons named Bill)| \\
\verb|error `Cannot average 0 things.'| \\
\verb|      occurred during: average weight of| \\
\verb|                      (all persons named Bill)| \\
\verb|      occurred during: 10 + ditto| \\
\verb|      occurred during: z = ditto|
\end{indpar}

In case you wonder how some of the above works, here are some hints.

RECKON tends to ignore word endings: thus `\TT{person}' and
`\TT{persons}' are to RECKON the same word.
RECKON can even be told that `\TT{person}'
and `\TT{people}' are the same word.
On the other hand, `\TT{Jack's}' is treated an abbreviation
of two separate words `\TT{Jack}' and `\TT{'s}', where `\TT{'s}' is
a separate word by itself.

Expressions are just strings of words, numbers, and subexpressions.
Subexpressions must be parenthesized unless they
are delimited by operators.

Lists of values can be stored in \skey{list}s, which are computed by comma
separated lists in parentheses.  Thus

\begin{indpar}
\verb|> (the person named Jill, the person named Jack)| \\
\begin{tabular}{|r|l|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf type} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000001 & person & Jill & \tt 110 lb & \tt 5 ft 7 in & \tt 21 yr 8 mo \\
\tt @1000000 & person & Jack & \tt 123 lb & \tt 5 ft 9 in & \tt 23 yr 2 mo \\
\hline
\end{tabular} \\[0.5ex]
\verb|> (the person named Jack, the person named Jill)| \\
\begin{tabular}{|r|l|l|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf type} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} \\
\hline
\tt @1000000 & person & Jack & \tt 123 lb & \tt 5 ft 9 in & \tt 23 yr 2 mo \\
\tt @1000001 & person & Jill & \tt 110 lb & \tt 5 ft 7 in & \tt 21 yr 8 mo \\
\hline
\end{tabular} \\[0.5ex]
\verb|> raw (all persons)| \\
\verb|(the person named Jack, the person named Jill)| \\
\verb|> really raw (all persons)| \\
\verb|(@1000000, @1000001)|
\end{indpar}

The `\TT{raw}' form of a value represents the value
as you could input it in a way that reveals its internal structure.  Thus
`\TT{raw(all~persons)}' denotes the list of all persons, and it is the list
structure that is revealed, not the structure of the elements of the list.

`\TT{the person named Jack}' is a printed representation of the
internal name of a description.  Such printed representations are chosen
automatically from the set of all possible representations, which
in this case include `\TT{the person weighing 123 lbs}',
`\TT{the person named Jack weighing 123 lbs}', and so forth.

The `\TT{really raw}' form of a value identifies descriptions by their IDs.

A single non-list value is equivalent to a list with one element.
Lists cannot have other lists as elements; instead attempts to
compute such lists are \key{flattened}:

\begin{indpar}
\verb|> x = (1,(2,3),4)| \\
\verb|(1,2,3,4)| \\
\verb|> first x| \\
\verb|1| \\
\verb|> rest x| \\
\verb|(2,3,4)| \\
\verb|> rest (rest x)| \\
\verb|(3,4)| \\
\verb|> rest (rest (rest x))| \\
\verb|4| \\
\verb|> rest 4| \\
\verb|()|
\end{indpar}

For this reason RECKON lists are sometimes called `\skey{flat list}s'.

RECKON has different kinds of quotes or brackets.  The brackets
\verb|{{|\ldots\verb|}}| and \verb|`|\ldots\verb|'|
turn
evaluation off, while \verb|[|\ldots\verb|]| turns evaluation on.
The brackets \verb|`|\ldots\verb|'| turn
recognition of operators (e.g., \verb|+| and \verb|=|) off, and turn
recognition of sentence and phrase terminators
(e.g., `\verb|.|' and `\verb|;|') on,
while \verb|[|\ldots\verb|]| and \verb|{{|\ldots\verb|}}|
turn recognition of operators on, and turn recognition of
sentence and phrase terminators off.

RECKON can store information as expressions.  For example:

\begin{indpar}
\verb|> (a person named `Jack') is husband of| \\
\verb|+     (a person named `Jill') <--| \\
\verb|> Y is wife of X <-- X is husband of Y|
\end{indpar}

Here `\verb|<--|' means `is asserted' or `is asserted if'.
All the assertions that have been made can be queried:

\begin{indpar}
\verb|> (a person named `Jill') is wife of| \\
\verb|+     (a person named `Jack') ?| \\
\verb|true| \\
\verb|> (a person named `Jack') is wife of| \\
\verb|+     (a person named `Jill') ?| \\
\verb|false| \\
\verb|> (a person named X) is wife of| \\
\verb|+     (a person named `Jack') ?| \\
\verb|X = `Jill'| \\
\verb|> X is wife of (a person named `Jack') ?| \\
\verb|X = (a person named `Jill')| \\
\verb|> @1000001 is wife of (a person named `Jack') ?| \\
\verb|true| \\
\verb|> @1000001 = (a person named `Jill') ?| \\
\verb|true| \\
\verb|> @1000001 = (a person named `Jack') ?| \\
\verb|false|
\end{indpar}

You can also put tables into RECKON:

\begin{indpar}\begin{verbatim}
> --------------------------------------------------------
> | header 1 | header 2 | header 3 | header 4 | header 5 |
> --------------------------------------------------------
> | entry 11 | entry 12 | entry 13 | entry 14 | entry 15 |
> | entry 21 | entry 22 | entry 23 | entry 24 | entry 25 |
> | entry 31 | entry 32 | entry 33 | entry 34 | entry 35 |
> --------------------------------------------------------
>
\end{verbatim}\end{indpar}
\begin{center}
\begin{tabular}{|c|c|c|c|c|}
\hline
\bf header 1 & \bf header 2 & \bf header 3 & \bf header 4 & \bf header 5 \\
\hline
entry 11 & entry 12 & entry 13 & entry 14 & entry 15 \\
entry 21 & entry 22 & entry 23 & entry 24 & entry 25 \\
entry 31 & entry 32 & entry 33 & entry 34 & entry 35 \\
\hline
\end{tabular}
\end{center}

Here the table ends with a blank line.

Usually tables are put in separate files that can be
input by the `\TT{input}' statement.  If the above table
were put in a file named \TT{F}, the statement
\begin{indpar}\begin{verbatim}
> input F
\end{verbatim}\end{indpar}
would have the same effect as typing the table and its following
blank line in directly had above.  The table following blank line does not
have to be included in the file.

One can use `\TT{=}' in place of `\TT{-}' and `\TT{||}' in
place of `\TT{|}' to get double-lines in place of single lines.
One can abbreviate by omitting all but the first 5 `\TT{-}'s or
`\TT{=}'s on a line containing just these characters.

Lines can be continued with indented lines, but if the text of
an entry is too large, the input can become messy.  This can be
alleviated in some cases by using macros.  For example, if we
changed the file \TT{F} to contain:
\begin{indpar}\begin{verbatim}
------------------------------------
| H  1 | H  2 | H  3 | H  4 | H  5 |
------------------------------------
| E 11 | E 12 | E 13 | E 14 | E 15 |
| E 21 | E 22 | E 23 | E 24 | E 25 |
| E 31 | E 32 | E 33 | E 34 | E 35 |
------------------------------------
H: header
E: entry
\end{verbatim}\end{indpar}

we get the same table as we had before.
Here \TT{H} is a macro replaced
by the text `\TT{header}', and \TT{E} is a macro replaced by the
text `\TT{entry}'.

Entries can be glued together to make larger entries using the
symbols `\TT{<}', `\TT{>}', and `\verb|^|'.  If an entry consists
of just `\TT{<}', this means the entry is to be glued to the
entry on its left.  Similarly `\TT{>}' means to glue the entry to the entry
on its right, and `\verb|^|' means to glue to the entry above.  For
example, if the file \TT{F} contained:
\begin{indpar}\begin{verbatim}
------------------------------------
| H  1 | H  2 | H  3 | H  4 | H  5 |
====================================
| E 11 | E 12 | ABOT |   <  | E 15 |
------------------------------------
| E 21 | E 22 |   >  |   ^  | E 25 |
------------------------------------
| E 31 | E 32 | E 33 | E 34 | E 35 |
------------------------------------
H: header
E: entry
ABOT: a bit of text
\end{verbatim}\end{indpar}

we would have:

\verb|> input F| {\raggedright \\}
\begin{center}
\begin{tabular}{|c|c|c|c|c|}
\hline
\bf header 1 & \bf header 2 & \bf header 3 & \bf header 4 & \bf header 5 \\
\hline\hline
entry 11 & entry 12 & \multicolumn{2}{c|}{a bit} & entry 15 \\
\cline{1-2}\cline{5-5}
entry 21 & entry 22 & \multicolumn{2}{c|}{of text} & entry 25 \\
\hline
entry 31 & entry 32 & entry 33 & entry 34 & entry 35 \\
\hline
\end{tabular}
\end{center}

Gluing is transitive, so in the above 4 entries are all glued together.

Entries have associated formats.  Explicit formats may be given
to override a computed default format.  A format consists of a word
containing format items surrounded by `\TT{/}'s.
A format that applies to all entries in a row may be placed at the end
of the row line.  For columns, a line all of whose entries are formats
for their columns may be given (the surrounding `{\tt/}'s may be
omitted for some but not all of these formats).
A format may be given for a particular entry by making it the first
word of the entry.  And format may be given for the entire table
on a line preceding the table.

For example, if the file \TT{F} contained:
\begin{indpar}\begin{verbatim}
------------------------------------
| H  1 | H  2 | H  3 | H  4 | H  5 | /ib/
------------------------------------
| /l/  | /r/  | c    | P    | cb   |
|   11 |   12 |   13 | 5.4% | E 15 |
| E 21 | E 22 | E23  | 0.8% | E 25 |
| E 31 | E 32 | E 33 | 0.09 | E 35 | /!b/
------------------------------------
H: header
E: entry
E23: /b/ entry 23
P: /.0u%r/
\end{verbatim}\end{indpar}

we would have:

\verb|> input F| {\raggedright \\}
\begin{center}
\begin{tabular}{|l|r|c|r|c|}
\hline
\multicolumn{1}{|c|}{\bf \em header 1} &
\multicolumn{1}{|c|}{\bf \em header 2} &
\multicolumn{1}{|c|}{\bf \em header 3} &
\multicolumn{1}{|c|}{\bf \em header 4} &
\multicolumn{1}{|c|}{\bf \em header 5} \\
\hline
      11 &       12 &       13 & 5.4\% & \bf entry 15 \\
entry 21 & entry 22 & \bf entry 23 & 0.8\% & \bf entry 25 \\
entry 31 & entry 32 & entry 33 & 9.0\% & entry 35 \\
\hline
\end{tabular}
\end{center}

A short guide to some format items is:
\begin{indpar}[1in]
\begin{tabular}{ll}
\tt r & right adjust \\
\tt l & left adjust \\
\tt c & center adjust \\
\tt b & bold face \\
\tt i & italicize \\
\tt .0\PLUS[n]{} & right adjust with $n$ decimal places \\
\tt u\% & multiply by 100 and append a \% sign \\
\tt u\$ & add a \$ sign \\
\tt i, & add commas to integer parts of numbers \\
\end{tabular}
\end{indpar}

An entry may have four formats: a table format,
a column format, a row format, and
an entry format.  These are combined as by set union, except that
conflicts are resolved in favor of the entry format first, the
row format second, the column format third, and the table format
forth.
Putting a `\TT{!}' in front of a format item negates
that item if it was included in the set union by
a less favored format (`\TT{!b}' for the last row above negates the `\TT{b}'
for the last column).
Also, defaults are computed in case no format items are
given for a particular format aspect: for example, if no adjust
format is given entries are centered unless they are in a column
whose entries all end with numbers some containing decimal points, in which
case a default `\TT{.0\PLUS[n]{}}' format item is inferred.

Table entries can be computed from other table entries and from macros
that are not actually in the table.  The computational expressions
are represented by `\TT{[~]}' bracketed lists included within entries.
Names which are words beginning with `\TT{<}' and ending with `\TT{>}'
can be assigned to rows, columns, and entries, after the manner of formats.
For example, if the file \TT{F} contains:
\begin{indpar}\begin{verbatim}
----------------------------------
| Value  | Factor | Contribution |
----------------------------------
| <V>    | <F>    |              |
| /u$/   | /u%/   | /u$.00/      |
| 100    | 20     | C            | <FIRST>
| 200    | 5      | C            |
| 300    | 8      | C            |
----------------------------------
| /lb/ Total | <  | T            |
----------------------------------
C: [(@,<V>) * (@,<F>)]
T: [sum([<FIRST>, ..., @-1], @)] 
\end{verbatim}\end{indpar}

then

\verb|> my table = input F| {\raggedright \\}
\begin{center}
\begin{tabular}{|r|r|r|}
\hline
\multicolumn{1}{|c|}{\bf Value} &
\multicolumn{1}{|c|}{\bf Factor} &
\multicolumn{1}{|c|}{\bf Contribution} \\
\hline
\$100 & 20\% & \$20.00 \\
\$200 & 5\%  & \$10.00 \\
\$300 & 8\%  & \$24.00 \\
\hline
\multicolumn{2}{|l|}{\bf Total} & \$54.00 \\
\hline
\end{tabular}
\end{center}

Here \TT{(I,J)} denotes the value of the cell at the
\TT{I}'th row and \TT{J}'th column, \TT{@} when used
in \TT{I} denotes the row of that cell, and when
used in \TT{J} denotes the column of that cell.  So
\TT{(@,<V>)} denotes the value of the cell in column
\TT{<V>} of the same row as the cell whose denotation
contains the \TT{(<V>,@)}.

Here \TT{[sum([<FIRST>, ..., @-1], @)]} denotes the
sum of the all the values in the column of a cell from the
\TT{<FIRST>} row to the row before that containing
the cell.  `\TT{@-1}' denotes the row before the one
containing the cell, and `\TT[I, ..., J]' denotes
the list of indices from \TT{I} through \TT{J}.

The last example also illustrates that a table is a description
and its identifier can be made the value of a variable,
such as `\TT{my table}'.  The expression `\TT{input F}' has
as its value the last thing in the file \TT{F}, which in this
example is the table.  So `\TT{my table = input F}' assigns
the identifer of this table to the variable `\TT{my table}'.

It is also possible to make a table whose rows are all the
descriptions of a given type.  Suppose file \TT{F} contains:
\begin{indpar}\begin{verbatim}
-----------------------------------------------------
| Name   | Weight   | Height     | Age       | BMI  | /ib/
-----------------------------------------------------
| <name> | <weight> | <height>   | <age>     | B
| /l/    | /U`lb'/  | /U`ft_in'/ | /u`yr'.0/ | /.2/
| George |    205   | 6ft 3in    | 25        |
| Mary   |    135   | 5ft 5in    | 26        |
----------------------------------------------
BMI: Body Mass Index
B: <body mass index>
ROW TYPE: person
SORT ROWS BY: name
\end{verbatim}\end{indpar}

then

\verb|> input F| {\raggedright \\}
\begin{center}
\begin{tabular}{|l|r|r|r|r|}
\hline
\multicolumn{1}{|c|}{\bf Name} &
\multicolumn{1}{|c|}{\bf Weight} &
\multicolumn{1}{|c|}{\bf Height} &
\multicolumn{1}{|c|}{\bf Age} &
\multicolumn{1}{|c|}{\bf \shortstack{Body\\Mass\\Index}} \\
\hline
George	& 205 lb	& 6 ft 3 in	&  25 & 25.62 \\
Jack	& 123 lb	& 5 ft 9 in	&  23 & 18.16 \\
Jill	& 110 lb	& 5 ft 7 in	&  22 & 17.23 \\
Mary	& 135 lb	& 5 ft 5 in	&  26 & 22.46 \\
\hline
\end{tabular}
\end{center}

Here the `\TT{ROW TYPE}' value `\TT{person}' declares that the
rows of the table are exactly all descriptions of type `\TT{person}',
while the `\TT{SORT ROWS BY}' value `\TT{name}' declares that
the rows are to be sorted on the value of their `\TT{name}' variable.
The column names must match the description variable names: e.g.,
the column name \TT{<body mass index>} matches the description variable name
`\TT{body mass index}'.
Data rows in the table are added to the set of descriptions of
type `\TT{person}'.  You can see this via:

\begin{indpar}
\verb|> all persons| \\
\begin{tabular}{@{}|r|l|l|r|r|r|r|@{}}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf type} &
\multicolumn{1}{|c}{\bf name} &
\multicolumn{1}{|c}{\bf weight} &
\multicolumn{1}{|c}{\bf height} &
\multicolumn{1}{|c|}{\bf age} &
\multicolumn{1}{|c|}{\bf \shortstack{body\\mass\\index}} \\
\hline
\tt @1000000 & person & Jack
	     & \tt 123 lb & \tt 5 ft 9 in & \tt 23 yr 2 mo & \tt 18.1637 \\
\tt @1000001 & person & Jill
	     & \tt 110 lb & \tt 5 ft 7 in & \tt 21 yr 8 mo & \tt 17.2282 \\
\tt @1000047 & person & George
	     & \tt 205 lb & \tt 6 ft 3 in & \tt 25 yr 0 mo & \tt 25.6230 \\
\tt @1000048 & person & Mary
	     & \tt 135 lb & \tt 5 ft 5 in & \tt 26 yr 0 mo & \tt 22.4649 \\
\hline
\end{tabular}
\end{indpar}

\bigskip

RECKON also supports pictorial data
that are expressions displayed as pictures:

\begin{indpar}
\verb/> x = {{circle 0.4}}/ \\[1ex]
\begin{picture}(0.4,0.4)
\put(0.2,0.2){\circle{0.4}}
\end{picture} \\
\verb/> y = {{rectangle (0.4,0.2)}}/ \\[1ex]
\begin{picture}(0.4,0.2)
\put(0,0){\framebox(0.4,0.2){}}
\end{picture} \\
\verb/> z = {{(circle 0.4) labeled `Jack'}}/ \\[1ex]
\begin{picture}(0.4,0.4)
\put(0.2,0.2){\circle{0.4}}
\put(0.0,0.0){\makebox(0.4,0.4){Jack}}
\end{picture} \\
\verb/> {{([x] right of [y]) above [z]}}/ \\[1ex]
\begin{picture}(0.8,0.8)
\put(0.6,0.6){\circle{0.4}}
\put(0.0,0.5){\framebox(0.4,0.2){}}
\put(0.4,0.2){\circle{0.4}}
\put(0.2,0.0){\makebox(0.4,0.4){Jack}}
\end{picture} \\
\verb/> {{row([x],[y],[z])}}/ \\[1ex]
\begin{picture}(1.4,0.4)
\put(0.2,0.2){\circle{0.4}}
\put(0.4,0.1){\framebox(0.4,0.2){}}
\put(1.0,0.2){\circle{0.4}}
\put(0.8,0.0){\makebox(0.4,0.4){Jack}}
\end{picture} \\
\verb/> p = {{column (row([x],[y],[z]), row([z],[y],[x]))}}/ \\[1ex]
\begin{picture}(1.4,0.8)
\put(0.2,0.6){\circle{0.4}}
\put(0.4,0.5){\framebox(0.4,0.2){}}
\put(1.0,0.6){\circle{0.4}}
\put(0.8,0.4){\makebox(0.4,0.4){Jack}}
\put(1.0,0.2){\circle{0.4}}
\put(0.4,0.1){\framebox(0.4,0.2){}}
\put(0.2,0.2){\circle{0.4}}
\put(0.0,0.0){\makebox(0.4,0.4){Jack}}
\end{picture} \\
\verb/> raw x/ \\
\verb/{{circle 0.4}}/ \\
\verb/> raw p/ \\
\verb/{{column (row (circle 0.4,/ \\
\verb/               rectangle (0.4,0.2),/ \\
\verb/               (circle 0.4) labeled `Jack'),/ \\
\verb/          row ((circle 0.4) labeled `Jack',/ \\
\verb/               rectangle (0.4,0.2),/ \\
\verb/               circle 0.4))}}/
\end{indpar}

You can also change how an expression is displayed.

\begin{indpar}
\newlength{\ovalraise}
\setlength{\ovalraise}{-0.1in}
\addtolength{\ovalraise}{0.8ex}
\verb/> display ( P ) <-- person ( P ) has name ( X ):/ \\
\verb/+     value = {{oval (0.4,0.2) labeled [X]}}/ \\
\verb/> (a person named `Jack')/ \\
\begin{picture}(0.4,0.2)
\put(0.2,0.1){\oval(0.4,0.2)}
\put(0.0,0.0){\makebox(0.4,0.2){Jack}}
\end{picture} \\
\verb/> ` [a person named `Jill'] is wife of/ \\
\verb/+   [a person named `Jack'] '/ \\
\verb/`/
\raisebox{\ovalraise}{\begin{picture}(0.4,0.2)
\put(0.2,0.1){\oval(0.4,0.2)}
\put(0.0,0.0){\makebox(0.4,0.2){Jill}}
\end{picture}}
{is wife of}
\raisebox{\ovalraise}{\begin{picture}(0.4,0.2)
\put(0.2,0.1){\oval(0.4,0.2)}
\put(0.0,0.0){\makebox(0.4,0.2){Jack}}
\end{picture}}
\verb/'/
\end{indpar}

Displays can be used to make demonstrations:

\begin{indpar}
\verb|> a demo with angle X <-- X is an angle:| \\
\verb|+     angle = X| \\
\verb|> x = a demo with angle 30 degrees| \\
\begin{tabular}{|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf type} &
\multicolumn{1}{|c|}{\bf angle} \\
\hline
\tt @1000043 & demo & 30 degrees \\
\hline
\end{tabular} \\[0.5ex]
\verb|> for every demo D:| \\
\verb|+     update D to X <-- X is an angle:|\\
\verb|+         next angle = X| \\
\verb|+     increment D by X <-- X is an angle:| \\
\verb|+         next angle = angle + X| \\
\verb|> update x to 40 degrees| \\
\begin{tabular}{|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf type} &
\multicolumn{1}{|c|}{\bf angle} \\
\hline
\tt @1000044 & demo & 40 degrees \\
\hline
\end{tabular} \\[0.5ex]
\verb|> increment x by 5 degrees| \\
\begin{tabular}{|r|r|r|}
\hline
\multicolumn{1}{|c}{\bf ID} &
\multicolumn{1}{|c}{\bf type} &
\multicolumn{1}{|c|}{\bf angle} \\
\hline
\tt @1000045 & demo & 45 degrees \\
\hline
\end{tabular} \\[0.5ex]
\verb/> display D <-- D is a demo with angle X:/ \\
\verb/+     c = {{circle diameter 1.0 dotted center (0.0,0.0)}}/ \\
\verb/+     x axis = {{arrow from (-0.75,0.0) to (0.75,0.0)}}/ \\
\verb/+     y axis = {{arrow from (0.0,-0.75) to (0.0,0.75)}}/ \\
\verb/+     line = {{line from (0.0,0.0)/ \\
\verb/+                   to [(0.5*cos X, 0.5*sin X)]}}/ \\
\verb/+     arc = {{arc arrow from (0.3,0.0)/ \\
\verb/+                       to [(0.3*cos X, 0.3*sin X)]}}/ \\
\verb/+     theta = {{Greek th}}/ \\
\verb/+     value = {{label (/ \\
\verb/+                `Depiction of Angle [theta]=[X]',/ \\
\verb/+                overlap (/ \\
\verb/+                  [c],/ \\
\verb/+                  [x axis] labeled `X Axis',/ \\
\verb/+                  [y axis] labeled `Y Axis',/ \\
\verb/+                  [line],/ \\
\verb/+                  [arc] labeled `[theta]' ) ) }}/ \\
\verb/> show x/ \\
See `Depiction of Angle $\theta=45^\circ$' \\
\verb|> increment x by -15 degrees| \\
See `Depiction of Angle $\theta=30^\circ$'
\end{indpar} 

\begin{center}
\newcommand{\anglestuff}{
    \put(1.0,0.95){\qbezier[40](0.5,0.0)(0.46,0.46)(0.0,0.5)}
    \put(1.0,0.95){\qbezier[40](0.0,0.5)(-0.46,0.46)(-0.5,0.0)}
    \put(1.0,0.95){\qbezier[40](-0.5,0.0)(-0.46,-0.46)(0.0,-0.5)}
    \put(1.0,0.95){\qbezier[40](0.0,-0.5)(0.46,-0.46)(0.5,0.0)}
    \put(1.0,0.2){\vector(0,1){1.5}}
    \put(0.0,1.7){\makebox(2.0,0.2){Y Axis}}
    \put(0.25,0.95){\vector(1,0){1.5}}
    \put(1.80,0.85){\makebox(0.7,0.2)[l]{X Axis}}
}
\begin{picture}(5.5,1.9)
\put(0,0){
    \anglestuff
    \put(1.0,0.95){\qbezier[1000](0,0)(0.1767765,0.1767765)(0.353553,0.353553)}
    \put(1.0,0.95){
	\qbezier[250](0.3,0.0)(0.3,0.124264)(0.212132,0.212132)
	\put(0.212132,0.212132){\vector(-1,1){0.00}}
	\put(0.31,0.1){$\theta$}}
    \put(0.0,0.0){\makebox(2.0,0.2){Depiction of Angle $\theta=45^\circ$}}
}
\put(3.0,0){
    \anglestuff
    \put(1.0,0.95){\qbezier[1000](0,0)(0.2165065,0.125)(0.433013,0.25)}
    \put(1.0,0.95){
	\qbezier[250](0.3,0.0)(0.32,0.0745584)(0.2598078,0.15)
	\put(0.2598078,0.15){\vector(-1,1){0.00}}
        \put(0.33,0.05){$\theta$}}
    \put(0.0,0.0){\makebox(2.0,0.2){Depiction of Angle $\theta=30^\circ$}}
}
\end{picture}

\end{center}

In this example we first define a `constructor'
of the form `\TT{a demo with angle X}' to make new \TT{demo} descriptions,
and then we define two `methods', namely `\TT{update THIS to X}' and
`\TT{in\-cre\-ment THIS by X}', to change a \TT{demo} description.  Changing
a \TT{demo} description is like iterating a loop to make a new description.

Next we define how to display a \TT{demo} description.  Then we use the
`\TT{show x}' command
to cause the \TT{demo} description value of \TT{x}
to be displayed in a separate window.
Every time this \TT{demo} description
changes, the window is updated, and every time the description
is to be printed,
`See `Depiction of Angle $\theta=\ldots^\circ$'\,'
is printed instead, where `Depiction \ldots' is the \TT{label} part of
the display.

An extended example is given in the next section.
The remainder of this document is a reference manual for RECKON.

\section{Example}


%\begin{boxedfigure}

\begin{verbatim}
ship codes = [`S', `D', `C', `B', `A']
ship names = [`Submarine', `Destroyer', `Cruzier',
              `Battleship', `Aircraft Carrier']
max ship length = # ship names
max tries = 100    // max tries to position ship on a board

a board of size S <-- S is an integer, S >= 5:

    // Make a board of size SxS.
    size = S

    // state(R, C) is `untouched', `miss', `hit',
    // or `sunk' (if final hit on ship).
    //
    state = an array of size (S, S)
            with initial elements `untouched'

    // ship(R, C) is ID of ship at (R, C) or `none'.
    //
    ship = an array of size (S, S)
           with initial elements `none'

    ships = 0  // Number of ships
    sunk  = 0  // Number of ships sunk

a ship of length L on board B <--
        L is an integer, 1 <= L <= max ship length,
        B is a board:
    // Make a ship of length L on board B.

    (direction, position) =
        find position on B for ship of length L
    place B of length L at (direction, position)
          on B

    length = L
    board = B
    hits = 0  // Number hits on ship so far

for every board B:

    // Return true iff (DIRECTION,START) is an OK (empty)
    // position for a new ship of length L, and false
    // otherwise.
    //
    test position (DIRECTION, START) on B
            for ship of length L
        <-- DIRECTION is a pair of integers,
            START is a pair of integers,
            L is an integer, 1 <= L <= max ship length:

        (X,Y) = DIRECTION
        assert -1 <= X <= +1
        assert -1 <= Y <= +1

        (R, C) = START

        if NOT 0 <= R < size
           OR
           NOT 0 <= C < size:
            value = `false'
        else if ship(START) != `none':
            // Position conflicts with previous ship
            value = `false'
        else if L == 1:
            value = `true'
        else
            value = test position ( DIRECTION,
                                    START + DIRECTION,
                                    L - 1 )

    // Given an empty place (DIRECTION,START) for a ship S of
    // length L, install ship S on the board.
    //
    place ship S of length L at (DIRECTION, START) on B
            <-- S is a ship,
                L is an integer, 1 <= L <= max ship length,
                DIRECTION is a pair of integers,
                START is a pair of integers:

        (R, C) = START
        assert 0 <= R < size
        assert 0 <= C < size

        (X,Y) = DIRECTION
        assert -1 <= X <= +1
        assert -1 <= Y <= +1

        while L > 0:
            ship(START) = S
            next START = START + DIRECTION
            next L = L - 1
        ships = ships + 1

    // Return a random empty place, (DIRECTION,POSITION),
    // where a ship of length L may be placed.  Or return
    // `none' if max tries random attempts fail.
    //
    find position on B for ship of length L
            <-- L is an integer, 1 <= L <= max ship length:
        tries = 0
        loop:
            direction =
                random [ (-1, -1), (-1, 0), (-1, 1), (0, 1),
                         (1, 1), (1, 0), (1, -1), (0, -1) ]
            position = ( random ( 0 .. S ),
                         random ( 0 .. S ) )
            if tries >= max tries:
                value = 'none'
                exit loop
            else if test position (direction, position) on B
                    for ship length L:
                value = (direction, position)
                exit loop
            else:
                next tries = tries + 1

    shoot at (R, C) on B <--
            R is an integer,  0 <= R < size,
            C is an integer,  0 <= C < size:
        if state(R, C) != `untouched':
            value = `no effect'
        else if ship(R, C) == `none':
            value = `miss'
        else:
            s = ship(R, C)
            hits(s) = hits(s) + 1
            if hits(s) == length(s):
                sunk = sunk + 1
                value = `sunk'
            else:
                value = `hit'
        if value != `no effect':
            state(R, C) = value

    // Add ship of length L to B and return true; or
    // return false and do nothing on failure (try
    // smaller L).
    //
    add ship of length L to B
            <-- L is an integer, 1 <= L <= max ship length:
        where = find position on B for ship of length L
        if where == `none':
            value = false
        else:
            S = a ship of length L on board B
            place ship S of length L at (DIRECTION, START) on B
            value = true

for every ship S:
    hit S <--:
        hits = hits + 1
        if hits == length:
            value = `sunk'
        else:
            value = `not sunk yet'

on a board view for (BOARD) PLAYER
        ~ with square size SQSIZE ? <--
        board ( BOARD ),
        PLAYER :=: owner | opponent,
        SQSIZE :=? 0.25in,
        SQSIZE is a number, 0.05in <= SQSIZE:
    board = BOARD
    player = PLAYER
    square size = SQSIZE

    line width = 0.02in
    grid layer = B#00001#
    ship layer = B#00010#
    hit layer = B#00100#
    sunk layer = B#01000#
    letter layer = B#10000#
    plane = a plane with depth 5
            with x size (   2 * line width 
                          + size * SQSIZE )
            with y size (   2 * line width 
                          + size * SQSIZE )

    start = line width / 2
    stop = size * SQSIZE + line width / 2

    rcd = start
    rc = 0
    while rc < size:
        draw line in layer (grid layer)
                  on plane (plane)
                  with line width (line width)
                  from ( start, rcd ) to ( stop, rcd )
        draw line in layer (grid layer)
                  on plane (plane)
                  with line width (line width)
                  from ( rcd, start ) to ( rcd, stop )
        next rcd = rcd + SQSIZE
        next rc = rc + 1

    r = 0
    while r < size:
        next r = r + 1
        c = 0
        while c < size:
            next c = c + 1
            if ship(r, c) != none
                draw ship (ship(r, c)) on S

    on display ( THIS ) <--:
        value = plane

for every ship S:

    // Update ships positions in board view.
    //
    on show ( S ) on ( VIEW ) <--
            VIEW is a board view:
        assert board == VIEW's board
        player = VIEW's player
        plane = VIEW's plane
        sqsize = VIEW's square size
        hlwidth = VIEW's line width / 2
        ship layer = VIEW's ship layer
        hit layer = VIEW's hit layer
        sunk layer = VIEW's sunk layer
        letter layer = VIEW's letter layer
        L = length
        P = position

        T = a 2D transform
            with expansion by ( sqsize, sqsize )
            with translation by (hlwidth, hlwidth )
        center = ( sqsize / 2, sqsize / 2 )
        while L > 0:
            state = board's state(P)
            layers = 0
            if player == `owner':
                layers = ship layer
            if state == `sunk' or hits == L:
                layers = hit layer + sunk layer
            else if state == `hit'
                layers = hit layer
                
            draw filled polygon in (layers)
                 on plane (plane)
                 with vertices
                      [T*P, T*(P+(0,1)), T*(P+(1,1) ),
                            T*(P+(1,0))]

            if player == `owner' or state == `sunk':
                draw text (ship codes(length))
                     in (ship letter layer)
                     on plane (plane)
                     at (T*P + center)

            next P = P + direction
            next L = L - 1
\end{verbatim}

%\caption{Code for the Battleship Game, Part III}
%\label{CODE-FOR-BATTLESHIP-3}
%\end{boxedfigure}

\newpage

\section{Lexemes}

Input text is a sequence of characters.  This is scanned from
left to right and top to bottom to produce a sequence of lexemes,
which include words, marks, separators, numbers, and quoted strings.

For example, the input
\begin{center}
\begin{tabular}{l}
\verb|x = 7ft 1_3/4 in;| \\
\verb|y = ``This is (we think) a sentence.''|
\end{tabular}
\end{center}
contains in order the following lexemes:
\begin{center}
\begin{tabular}{ll@{\hspace{1in}}ll}
\tt x		& word 		& \tt y & word \\
\tt =		& mark		& \tt =	& mark	\\
\tt 7ft		& number with embedded unit & \tt `{}` & (leading) separator \\
\tt 1\_3/4	& number	& \tt This & word \\
\tt in		& unit		& \tt is & word \\
\tt ;		& (trailing) separator	& \tt ( & (strict) separator \\
		&		& \tt we & word \\
		& 		& \tt think & word \\
		& 		& \tt ) & (strict) separator \\
		& 		& \tt a & word \\
		& 		& \tt sentence & word \\
		& 		& \tt . & (trailing) separator \\
		& 		& \tt '{}' & (trailing) separator \\
\end{tabular}
\end{center}

The lexemes are defined in terms of the following character classes:

\begin{indpar}
\emkey{horizontal-space-character}
    \begin{tabular}[t]{rl}
    :::= & character in UNICODE category \TT{Zs} \\
         & (includes single space) \\
    $|$  & {\em horizontal-tab-character}
    \end{tabular}
\\
\emkey{vertical-space-character}
    \begin{tabular}[t]{rl}
    :::= & {\em line-feed} $|$ {\em carriage-return} \\
    $|$ & {\em form-feed} $|$ {\em vertical-tab}
    \end{tabular}
\\
\emkey{space-character} ::= {\em horizontal-space-character}
                        $|$ {\em vertical-space-character}
\\[1ex]
\emkey{graphic-character} :::= character in UNICODE category
                              \TT{L}, \TT{M}, \TT{N}, \TT{P}, or \TT{S}
\\
\emkey{control-character} :::=
	character in UNICODE category \TT{C} or \TT{Z}
\\[1ex]
\emkey{isolated-separating-character} :::=
    \begin{tabular}[t]{l}
    character in UNICODE category \TT{Ps}, \TT{Pi}, \TT{Pe}, \\
    or \TT{Pf}; includes \TT{\{ ( [ << >> ] ) \}}
    \end{tabular}
\\
\emkey{separating-character} :::= \TT{|} $|$ {\em isolated-separating-character}
\\[1ex]
\emkey{leading-separator-character} :::=
	\TT{`} $|$ \TT{\textexclamdown} $|$ \TT{\textquestiondown}
\\
\emkey{trailing-separator-character} :::=
	\TT{'} $|$ \TT{!} $|$ \TT{?} $|$ \TT{.} $|$ \TT{:}
	       $|$ \TT{,} $|$ \TT{;}
\\[1ex]
\emkey{quoting-character} :::= \TT{"}
\\[1ex]
\emkey{letter} :::=
    character in UNICODE category \TT{L}
\\
\emkey{decimal-digit} :::= \TT{0} $|$ \TT{1} $|$ \TT{2} $|$ \TT{3} $|$ \TT{4}
                       $|$ \TT{5} $|$ \TT{6} $|$ \TT{7} $|$ \TT{8} $|$ \TT{9}
\\
\emkey{digit} :::=
    character in UNICODE category \TT{Nd}
    (includes {\em decimal-digits})
\\
\emkey{lexical-item-character}\label{LEXICAL-ITEM-CHARACTER} :::=
	\begin{tabular}[t]{l}
        {\em graphic-character} other than \\
	{\em separating-character} or \TT{"}
	\end{tabular}
\end{indpar}

Comments may be placed at the ends of lines:
\begin{indpar}
\emkey{comment}\label{COMMENT} :::=
    \TT{//} {\em comment-character}\,$^\star$
\\[1ex]
\emkey{comment-character} :::= {\em graphic-character}
                          $|$ {\em horizontal-space-character}
\end{indpar}

Lexemes may be separated by {\em white-space}, which
is a sequence of {\em space-characters},
but, with some exceptions mentioned just below, is not itself a lexeme:
\begin{indpar}
\emkey{white-space} :::= {\em space-character}\PLUS{}
\\[0.3ex]
\emkey{horizontal-space} :::= {\em horizontal-space-character}\PLUS{}
\\[0.3ex]
\emkey{vertical-space} :::= {\em vertical-space-character}\PLUS{}
\end{indpar}

The following is a special virtual lexeme:
\begin{indpar}
\emkey{indent}\label{INDENT} ::=
        virtual lexeme inserted just before the first
	{\em graphic} character on a line
\end{indpar}

\ikey{Indent lexemes}{indent lexeme} have no characters, but
do have an \mkey{indent}{of indent lexeme}, which is the indent of
the graphic character after the indent lexeme.
The \mkey{indent}{of character} of a character is the number
of columns that precede the character in the character's physical line.
{\em Control-characters} other than {\em horizontal-space-characters}
take zero columns, as do characters of classes \TT{Mn} (combining-marks)
and \TT{Me} (ending marks).  All other characters take one column,
except for tabs, that are set every 8 columns.
Indent lexemes are used to form logical lines and blocks
(\pagref{LOGICAL-LINE} and \itemref{LOGICAL-LINES}).

One kind of {\em vertical-space} is given special distinction:
\begin{indpar}
\emkey{line-break}\label{LINE-BREAK} ::=
	\begin{tabular}[t]{l}
        {\em vertical-space} containing exactly one {\em line-feed}
	\end{tabular}
\end{indpar}

This is the {\em line-break} lexeme.

Non-{\em indent}, non-{\em line-break} {\em white-space}, such as occurs
in the middle of text or code outside comments, is discarded and not treated
as a lexeme.  Such {\em white-space} may be used to separate lexemes.

{\em Horizontal-\EOL space-\EOL characters}\label{ILLEGAL-CHARACTERS}
other than single
space are illegal inside {\em quoted-string} lexemes (defined below).
{\em Vertical-space} that has \underline{no} {\em line-feeds} is
illegal (see below).
{\em Control-characters} not in {\em white-space} are illegal.
Characters that have no UNICODE category are {\em unrecognized-characters}
and are illegal:
\begin{indpar}
\emkey{misplaced-horizontal-space-character} :::=
    \begin{tabular}[t]{l}
    {\em horizontal-space-character}, other than \\
    ASCII single space
    \end{tabular}
\\[0.3ex]
\emkey{misplaced-vertical-space-character} :::= {\em vertical-space-character}
	other than {\em line-feed}
\\[0.3ex]
\emkey{illegal-control-character} :::=
    \begin{tabular}[t]{l}
    {\em control-character},
    but \underline{not} a {\em horizontal-space-character} \\
    or {\em vertical-space-character}
    \end{tabular}
\\[0.3ex]
\emkey{unrecognized-character} :::=
    \begin{tabular}[t]{l}
    character with no UNICODE category or \\
    with a category other than
    \TT{L}, \TT{M}, \TT{N}, \TT{P}, \TT{S}, \TT{C}, or \TT{Z}
    \end{tabular}
\end{indpar}

Sequences of these characters generate warning messages,
but are otherwise like {\em horizontal-space}:
\begin{indpar}
\emkey{misplaced-horizontal} :::=
    {\em misplaced-horizontal-space-character}\PLUS{}
\\[0.3ex]
\emkey{misplaced-vertical} :::=
    {\em misplaced-vertical-space-character}\PLUS{}
\\[0.3ex]
\emkey{illegal-control} :::= {\em illegal-control-character}\PLUS{}
\\[0.3ex]
\emkey{unrecognized} :::= {\em unrecognized-character}\PLUS{}
\end{indpar}

{\em Misplaced-horizontal} only exists inside a {\em quoted-string},
but the other three sequences can appear anywhere.  When they occur,
these sequences generate warning messages, but otherwise they behave
like {\em horizontal-space}.  Specifically, outside {\em quoted-strings}
and {\em comments} these sequences can be used to separate other lexemes,
just as {\em horizontal-space} can be used,
whereas inside {\em quoted-strings} and
{\em comments} these sequences do nothing aside from generating
warning messages.

The lexemes in a lexical program are specified in
Figure~\itemref{LEXEME-SYNTAX}.  This specification assumes there
are no illegal characters in the input; see text
above to account for such characters.

The symbol `\ttmkey{:::=}{in syntax equation}' is used in syntax equations
that define lexemes or parts of lexemes whose syntactic elements are
character sequences that must \underline{not} be separated by {\em white-space}.
The symbol `\ttmkey{::=}{in syntax equation}'
is used in syntax equations that define sequences of lexemes that may
and sometimes must be separated by {\em white-space}.

There is a special \emkey{end-of-file}\label{END-OF-FILE}
lexeme that occurs only at the end of a file.


\begin{boxedfigure}[!p]
\begin{indpar}

\emkey{lexeme}
        \begin{tabular}[t]{rl}
	::= & {\em numeric-word} $|$ {\em word} $|$
	      {\em natural} $|$ {\em number} $|$ {\em numeric} $|$
	      {\em mark} $|$ {\em separator} \\
	$|$ & {\em quoted-string} $|$ {\em indent} $|${\em line-break} $|$
	      {\em comment} $|$ {\em end-of-file}
	\end{tabular}
\label{LEXEME}
\\[0.5ex]
\emkey{strict-separator} :::= {\em isolated-separating-character} $|$
                              \TT{|}\PLUS{}
\\
\emkey{leading-separator} :::=
	\TT{`}\PLUS{} $|$ 
	\TT{\textexclamdown}\PLUS{} $|$ \TT{\textquestiondown}\PLUS{}
\\
\emkey{trailing-separator} :::= \TT{'}\PLUS{} $|$
				   \TT{!}\PLUS{} $|$
				   \TT{?}\PLUS{} $|$
				   \TT{.}\PLUS{} $|$
				   \TT{:}\PLUS{} $|$
				   \TT{;} $|$
				   \TT{,}
\\
\emkey{separator}
    ::= {\em strict-separator} 
    $|$ {\em leading-separator}
    $|$ {\em trailing-separator}
\\[0.3ex]
\emkey{quoted-string} :::=
    \TT{"} {\em character-representative}\,\STAR{} \TT{"}
\\
\emkey{character-representative}
	\begin{tabular}[t]{@{}rl@{}}
	::= & {\em graphic-character} other than \TT{"} \\
	$|$ & {\em ASCII-single-space-character} \\
	$|$ & {\em special-character-representative} \\
	\end{tabular}
\\
\emkey{special-character-representative} :::=
    \TT{<} \{ {\em upper-case-letter} $|$ {\em digit} \}\PLUS{} \TT{>}
\\[0.3ex]
\emkey{lexical-item} :::= {\em lexical-item-character}\PLUS{}
                       not beginning with \TT{//}
\\
\emkey{lexical-item} :::= {\em leading-separator}\STAR{}
			  {\em middle-lexeme}\QMARK{}
                          {\em trailing-separator}\STAR{}
\\
\emkey{middle-lexeme} :::= 
	{\em lexical-item}
	\begin{tabular}[t]{@{}l@{}}
	not beginning with a {\em leading-separator-character} \\
	or ending with a {\em trailing-separator-character} \\
	\end{tabular}
\\
\emkey{numeric-word} :::= {\em sign}\QMARK{} \ttkey{nan}
                      $|$ {\em sign}\QMARK{} \ttkey{inf}
		      ~~~~~
		      [where {\em letters} are \underline{case insensitive}]
\\
\emkey{word} :::= {\em middle-lexeme}
                  \begin{tabular}[t]{@{}l@{}}
		  that contains a {\em letter} before any {\em digit} \\
		  and is not a {\em numeric-word}
		  \end{tabular}
\\
\emkey{natural}\label{NATURAL}
	\begin{tabular}[t]{@{}rl@{}}
	:::= & {\em decimal-digit}\PLUS{} not beginning with \TT{0} $|$
	       \TT{0} \\
	\multicolumn{2}{l}{[but lexical type may be changed;
	                    see \pagref{LEXEME-TYPE-CONVERSION}]} \\
	\end{tabular}
\\
\emkey{number}\label{NUMBER}
	\begin{tabular}[t]{@{}rl@{}}
	:::= & {\em sign}\QMARK{} {\em integer-part}
	                          {\em exponent-part}\QMARK{}
	     [that is not a {\em natural}] \\
	 $|$ & {\em sign}\QMARK{} {\em integer-part}\QMARK{}
	                          {\em fraction-part}
				  {\em exponent-part}\QMARK{} \\
	\multicolumn{2}{l}{[but lexical type may be changed;
	                    see \pagref{LEXEME-TYPE-CONVERSION}]} \\
	\end{tabular}
\\
\emkey{integer-part} :::=
       {\em dit}\PLUS{}
    ~ $|$ ~ \{ {\em dit} $|$ {\em dit} {\em dit}
                         $|$ {\em dit} {\em dit} {\em dit} \}
            \{ \TT{,} {\em dit} {\em dit} {\em dit} \}\PLUS{}
\\
\begin{tabular}[t]{@{}l@{\hspace{0.3in}}l@{}}
\emkey{fraction-part} :::= \TT{.} {\em dit}\PLUS{}
&
\emkey{exponent-part} :::= {\em exponent-indicator} {\em sign}\QMARK{}
                           {\em dit}\PLUS{}
\end{tabular}
\\
\begin{tabular}[t]{@{}l@{\hspace{0.3in}}l@{\hspace{0.3in}}l@{}}
\emkey{sign} :::= \TT{+} $|$ \TT{-}
&
\emkey{dit} :::= {\em decimal-digit}
&
\emkey{exponent-indicator} :::= \TT{e} $|$ \TT{E}
\end{tabular}
\\[0.3ex]
\emkey{numeric} :::= {\em middle-lexeme}
                  \begin{tabular}[t]{@{}l@{}}
		  that contains a {\em digit} before any {\em letter} \\
		  and is not a {\em natural} or {\em number}
		  \end{tabular}
\\
\emkey{mark}\label{MARK} :::= {\em middle-lexeme} not containing a
                              {\em letter} or a {\em digit}
\\
\begin{tabular}[t]{@{}l@{\hspace{1in}}l@{}}
{\em indent} ::= see \pagref{INDENT}
&
{\em line-break} ::= see \pagref{LINE-BREAK}
\\
{\em comment} ::= see \pagref{COMMENT}
&
{\em end-of-file} ::= see \pagref{END-OF-FILE}
\end{tabular}


\end{indpar}
\caption{Lexeme Syntax}
\label{LEXEME-SYNTAX}
\end{boxedfigure}

The definition of a {\em middle-lexeme} is unusual: it is what is left over
after removing {\em leading-separators} and {\em trailing-separators}
from a {\em lexical-item}.  The lexical scan first scans a
{\em lexical-item}, and then removes
{\em leading-separators} and {\em trailing-separators} from it.
Also {\em trailing-separators} are removed
from the end of a {\em lexical-item} by a right-to-left scan, and not
the usual left-to-right scan which is used for everything else.
Thus the {\em lexical-item}
`\TT{\textquestiondown 4,987?,{},::}' yields the
{\em leading-separator} `\TT{\textquestiondown}',
the {\em middle-lexeme} `\TT{4,987}',
and the four {\em trailing-separators} `\TT{?}',
`\TT{,}' `\TT{,}' and `\TT{::}'.%
\footnote{It is possible to use a strictly left to right scan with
backup over lexical atoms to perform
the right to left removal of {\em trailing-separators} from a
{\em lexical-item}, by recognizing a sequence of
{\em trailing-separator-characters} not followed by a
{\em lexical-item-character} that is not a
{\em trailing-separator-character}
as an atom that is backed up over and rescanned:
see Appendix \itemref{STANDARD-LEXICAL-PROGRAM}.}

A {\em middle-lexeme} can be continued across physical lines
as per \pagref{MIDDLE-LEXEME-CONTINUATION}.


{\em Words}, {\em numerics}, {\em marks}, {\em separators},
and {\em quoted-strings} represent 
\skey{symbol}s\label{SYMBOL} that store character strings.
The character strings represented by all but {\em quoted-strings}
are exactly the character strings of these lexemes.

Lexemes can be used to form \skey{name}s of variables,
constants, and functions:

\begin{indpar}
\emkey{name}\label{NAME} ::=
	\{ {\em word} $|$ {\em numeric} $|$ {\em quoted-string}
	              $|$ {\em natural}
		      $|$ {\em number}
		      $|$ {\em numeric-word} \}\PLUS{}
\end{indpar}

There is no difference between a {\em word} and a the same {\em word}
quoted in a name: both represent a character string that is a component of
the name.  E.g., there is no difference between \TT{X} and \TT{"X"}.  However,
sometimes words must be quoted to prevent them from being recognized
as operators, e.g., \TT{"AND"}.

As {\em marks} are commonly used as
operators, these are not allowed in names, but they may be quoted:
\TT{"+"} is allowed for example.  Similarly separators are not allowed,
but may be quoted: \TT{","} is allowed for example.

There are many special kinds of {\em names}:
\begin{indpar}
    \begin{tabular}[t]{l@{~~~~~}llll}
          & Section & Examples \\[1ex]
      {\em quoted string}
    & \itemref{QUOTED-STRINGS}
    & \TT{"+"} & \multicolumn{2}{l}{\TT{"Hello There!<LF>"}} \\
      {\em natural}
    & \itemref{NUMBERS}
    & \TT{43} & \TT{9,587} & \TT{1e3} \\
      {\em number}
    & \itemref{NUMBERS}
    & \TT{4.3} & \TT{-0.0098} & \TT{0.314159e1} \\
      {\em numeric-word}
    & \itemref{NUMBERS}
    & \TT{+inf} & \TT{-Inf} & \TT{Nan} \\
      {\em fraction}
    & \itemref{FRACTIONS}
    & \TT{4/3} & \TT{-4/3} & \TT{-1 1/3} \\
      {\em unit}
    & \itemref{UNITS-AND-QUANTITIES}
    & \TT{mi} & \TT{ft*lb} & \TT{mi/hr} \\
      {\em quantity}
    & \itemref{UNITS-AND-QUANTITIES}
    & \TT{5 mi} & \TT{3.4 ft*lb} & \TT{4 ft 2 in} \\
      {\em date}
    & \itemref{DATE}
    & \TT{4 may 2003} & \TT{May 4 2003} & \TT{2003-05-04} \\
      {\em time-interval}
    & \itemref{TIMES}
    & \TT{4:30} & \TT{4:30:23} & \TT{4:30:23.78} \\
      {\em time-of-day}
    & \itemref{TIMES}
    & \TT{16:30} & \TT{4:30pm} & \TT{4.30pm EST} \\
      {\em time}
    & \itemref{TIMES}
    & \TT{4:30pm} & \multicolumn{2}{l}{\TT{2005-05-29T16:30EDT}} \\
      {\em format}
    & \itemref{FORMATS}
    & \TT{/.1/} & \TT{/10.1c/} \\

    \end{tabular}
\end{indpar}

TBD

Some examples are:

\begin{indpar}\begin{verbatim}
"+" = 5
X = "+" + 1
Y15 = `X + 3' 
Z0 = `X'
T = `"A line.<LF>"'
\end{verbatim}\end{indpar}

These statements define
a variable named \TT{"+"} with value \TT{5}, a variable
named \TT{X} with value \TT{6}, and
a variable named \TT{Y15} with value the text \TT{X + 3},
i.e., the vector whose 3 elements are the symbols
\TT{X}, \TT{+}, and \TT{3}.  \TT{Z0} is a variable whose
value is a single symbol whose character string contains
the single character \TT{X}.
\TT{T} is a variable whose value is the single symbol
whose character string is that of the {\em quoted-string} \TT{"A line.<LF>"}.

Some {\em names} have builtin definitions, such as the
words `\TT{ft}' and `\TT{inch}' which in some contexts denote the
units `foot' and `inch' (see Section~\itemref{UNITS-AND-QUANTITIES}),
and `\TT{PI}' which in some contexts denotes the mathematical
constant $\pi$ (see Figure~\itemref{BUILTIN-NUMBER-CONSTANTS}).



\subsection{Quoted Strings}
\label{QUOTED-STRINGS}

A \emkey{quoted-string} represents the character string consisting of
the sequence of characters represented by \emkey{charac\-ter-representatives}
inside the double quotes (\TT{"}).
The {\em quoted-string} is scanned
left-to-right to find {\em character-representatives}
each of which is translated into one UNICODE character.
The beginning and ending quotes (\TT{"}) are \underline{not}
included in the represented character string.

Most characters simply represent themselves.
A \emkey{special-character-representative} represents on UNICODE character
and can consist of the UNICODE character name surrounded by angle brackets.
Examples are
\TT{<NUL>}, \TT{<LF>}, \TT{<SP>}, \TT{<NBSP>}.  There are three other cases:
\tttkey{Q} represents the doublequote \TT{"}, \tttkey{NL} (new line)
represents a line feed (same as \TT{<LF>}), and \tttkey{UUC} represents
the `\key{unknown UNICODE character}' which in turn is used to represent
illegal UTF-8 character encodings.
Figure~\ref{STANDARD-SPECIAL-CHARACTER-REPRESENTATIVES}
gives the most commonly used {\em special-character-reprentatives}.

A special {\em character-representative} can also consist of
a hexadecimal UNICODE character code, which must begin with a decimal digit.
Thus \TT{<0FF>} represents \TT{\"y} whereas \TT{<FF>} represents
a form feed.

\begin{boxedfigure}[!t]

\begin{center}
\begin{tabular}{lp{2in}}
\tttkey{NUL} & nul \\
\tttkey{SOH} & start of heading \\
\tttkey{STX} & start of text \\
\tttkey{ETX} & end of text \\
\tttkey{EOT} & end of transmission \\
\tttkey{ENQ} & enquiry \\
\tttkey{ACK} & acknowledge \\
\tttkey{BEL} & bell \\
\tttkey{BS}  & backspace \\
\tttkey{HT}  & horizontal tab \\
\tttkey{LF}  & line feed \\
\tttkey{VT}  & vertical tab \\
\tttkey{FF}  & form feed \\
\tttkey{CR}  & carriage ret \\
\tttkey{SO}  & shift out \\
\tttkey{SI}  & shift in \\
\tttkey{DLE} & data link escape
\\[1ex]
\tttkey{NL}  & new line (equals \TT{<LF>}) \\
\end{tabular}
\begin{tabular}{lp{2in}}
\tttkey{DC1} & device control 1 \\
\tttkey{DC2} & device control 2 \\
\tttkey{DC3} & device control 3 \\
\tttkey{DC4} & device control 4 \\
\tttkey{NAK} & negative ack. \\
\tttkey{SYN} & synchronous idle \\
\tttkey{ETB} & end of transmission block \\
\tttkey{CAN} & cancel \\
\tttkey{EM}  & end of medium \\
\tttkey{SUB} & substitute \\
\tttkey{ESC} & escape \\
\tttkey{FS}  & file separator \\
\tttkey{GS}  & group separator \\
\tttkey{RS}  & record separator \\
\tttkey{US}  & unit separator \\
\tttkey{SP}  & single space \\
\tttkey{DEL} & delete
\\[1ex]
\tttkey{Q}  & double quote (\TT{"}) \\
\end{tabular}
\end{center}

\caption{Standard Special Character Representatives}
\label{STANDARD-SPECIAL-CHARACTER-REPRESENTATIVES}
\end{boxedfigure}

A {\em quoted-string} lexeme can be continued across physical lines
as per \pagref{QUOTED-STRING-CONTINUATION}.


\subsection{Numbers}
\label{NUMBERS}

{\em Number} and {\em numeric-word} lexemes translate to
number values which are IEEE 64-bit floating point numbers.

When a lexeme translates to a number value, the type of the lexeme
is reset.
\begin{itemize}\label{LEXEME-TYPE-CONVERSION}
\item If the value is \underline{not} a finite number, the
new type is {\em numeric-word}.  For example, this applies to {\tt 1e500}
which converts to the same value as {\tt +inf}.
\item If the value is an integer in the range $[0,10^{15})$ the new
type is {\em natural}.
For example, this applies to {\tt 1e3}
which converts to the same value as {\tt 1000}.
\item Otherwise the new type is {\em number}.
For example, this applies to {\tt 1,234,567,890}
which converts to the same value as {\tt 1e10}.
\end{itemize}

Integers in the range
\begin{center}
$-9,007,199,254,740,992~~~~~..~~~~~+9,007,199,254,740,992$
\end{center}
are exactly represented in number values.
Numbers with absolute values in the range
\begin{center}
$2.2250738585072014\times 10^{-308}~~~~~..~~~~~1.7976931348623157\times
                                                               10^{+308}$
\end{center}
are represented with a relative error of
$2^{-53} \approx 1.110223\times 10^{-16}$,
or $15.95$ decimal digits precision.  Numbers
with absolute value less than
$2.2250738585072014\times 10^{-308}$ are represented as zero.

Numbers with absolute value equal to or greater than
$1.7976931348623158\times 10^{+308}$ are represented as $+$ or $-$
infinity, which can also be represented by the {\em numeric-words}
\TT{+inf} and \TT{-inf}.

Internally $+0$ and $-0$ are distinct, though in most computations
they behave the same.  On output they are usually
both are represented by \TT{0}, which on input represents $+0$.

Some examples of lexemes translating to number values are:

\begin{indpar}[0.1in]
\tt
\begin{tabular}{l@{~~~}l@{~~~}l@{~~~}l}
123e0		& 123e-2	& 123e-321	& 1,234e9 \\
123E0		& -123E-2	& +123E-321	& 0.123456e-3	\\
.123e3	& +.123e+1
				& -0.123456e-3 & 1,234.567890e6 \\
nan		& +NaN		& -Inf		& +inf \\
\end{tabular}
\end{indpar}

\subsection{Fractions}
\label{FRACTIONS}

A \emkey{fraction} has the syntax:

\begin{indpar}
\emkey{fraction}\label{FRACTION}
    ::= {\em fractional-numeric} $|$
        {\em integer} {\em fractional-numeric}
\\
\emkey{fractional-numeric} :::=
    {\em sign}\QMARK{} {\em dit}\PLUS{} \TT{/} {\em dit}\PLUS{}
\\[0.5ex]
{\em sign} :::= see Figure~\itemref{LEXEME-SYNTAX} \\
{\em dit} :::= see Figure~\itemref{LEXEME-SYNTAX}
\end{indpar}

Some examples are:
\begin{center}
\tt
1/3 ~~~~~~ +48/97 ~~~~~~ 42~3/8 ~~~~~~ -10~7/10
\end{center}
Here whitespace separating lexemes denotes `and',
as in \TT{10} and \TT{7/10}'ths,
so the last example equals \TT{-10.7}.

Internally a fraction is stored as an IEEE double precision floating
point number.  If an internally stored number can print as a fraction
with a small denominator more accurately than it can be printed with
some given number of decimal places, it may in some contexts be
printed as a fraction.  Thus in these contexts a number input as
\TT{1/3} will print as \TT{1/3} and not as \TT{0.333333}.

The fraction \TT{0/0}\label{0/0} denotes the IEEE \ttkey{NAN} value, which
stands of `Not a Number'.  The fraction \TT{$N$/0} for $N>0$
denotes \TT{+INF}, or plus infinity, while \TT{-$N$/0} denotes
\TT{-INF}, or minus infinity.

\subsection{Radix Numbers}
\label{RADIX-NUMBER}

A \emkey{radix-number} is similar to a {\em scientific-number},
except that it consists of 2 or 3 consecutive lexemes and the
digits are placed inside a quoted string.  The first lexeme is
a {\em radix-indicator}, and the
permissible {\em digits} and comma spacings depend upon the radix indicator:

\begin{indpar}
\emkey{radix-number} ::= \\
\hspace*{0.2in}
    {\em signed-radix-indicator} {\em quoted-radix-digits}
    {\em exponent-part}\QMARK{}
\\[1ex]
\emkey{radix-indicator} :::= \TT{B\#} $|$ \TT{b\#} $|$
                            \TT{O\#} $|$ \TT{o\#} $|$
			    \TT{D\#} $|$ \TT{d\#} $|$
			    \TT{X\#} $|$ \TT{x\#}
\\[1ex]
\emkey{signed-radix-indicator} :::= {\em sign}\QMARK{} {\em radix-indicator}
\\[1ex]
\emkey{sign} :::= \TT{+} $|$ \TT{-}
\\[1ex]
\emkey{quoted-radix-digits} :::= \TT{"} {\em radix-natural-part}
				{\em radix-fractional-part}\QMARK{} \TT{"}
\\[1ex]
\emkey{radix-natural-part} :::= {\em radix-digit}\PLUS{}
	    \{ \TT{,} {\em radix-digit}\PLUS{} \}\STAR{} ~~~ [see text]
\\[1ex]
\emkey{radix-fractional-part} :::= \TT{.} {\em radix-digit}\PLUS{}
	    \{ \TT{,} {\em radix-digit}\PLUS{} \}\STAR{} ~~~ [see text]
\\[1ex]
\emkey{exponent-part} :::= {\em exponent-indicator} {\em sign}\QMARK{}
                          {\em dit}\PLUS{}
\\[1ex] 
\emkey{exponent-indicator} ::= \TT{e} $|$ \TT{E}
\\[1ex] 
\emkey{dit} ::= {\em decimal-digit}
\end{indpar}

The {\em radix-indicators} have the following denotations:

\begin{center}
\begin{tabular}{clll}
\bf Radix Indicator
	& \bf Meaning	& \bf Radix-Digits	& \bf Comma Positions
\\[1ex]
\ttkey{B\#} or \ttkey{b\#}
        & binary	& \TT{0}, \TT{1}	& every 2, 3, 4, or 5 digits \\
\ttkey{O\#} or \ttkey{o\#}
        & octal		& \TT{0}, \TT{1}, \TT{2}, \TT{3},
			  \TT{4}, \TT{5}, \TT{6}, \TT{7}
			  			& every 2, 3, or 4 digits \\
\ttkey{D\#} or \ttkey{d\#}
        & decimal	& \TT{0}, \TT{1}, \TT{2}, \TT{3},
			  \TT{4}, \TT{5}, \TT{6}, \TT{7}
			  \TT{8}, \TT{9}	& every 3 digits \\
\ttkey{X\#} or \ttkey{x\#}
        & hexa-decimal	& \TT{0}, \TT{1}, \TT{2}, \TT{3},
			  \TT{4}, \TT{5}, \TT{6}, \TT{7}
			  \TT{8}, \TT{9},	& every 2 or 4 digits \\
	&		& \TT{A}, \TT{B}, \TT{C}, \TT{D},
			  \TT{E}, \TT{F}, \\
	&		& \TT{a}, \TT{b}, \TT{c}, \TT{d},
			  \TT{e}, \TT{f} \\
\end{tabular}
\end{center}

Only certain {\em radix-digits} are permitted: e.g., the digit \TT{2}
is not allowed in \TT{B\#"\ldots"} and the digit \TT{E} is not allowed
with \TT{D\#"\ldots"}.  Only certain comma spacings are permitted, and comma
spacing must be consistent.  Thus \TT{x\#"A,C9,BD,8F"} is permitted but
\TT{x\#"A,C9B,D8F"} is not (3-spacing not allowed for hexa-decimal),
and \TT{x\#"A,C9,BD8F"} is not permitted (2-spacing combined with
4-spacing is not consistent).
There may be at most one decimal point.
Commas may be used before the point without being used after the
point, and vice versa, but if used in both places, the comma spacing
must be the same.  The {\em radix-natural-part}
cannot be empty: \TT{d\#"0.5"} is legal but \TT{d\#".5"} is not.

Some example {\em radix-numbers} are:

\begin{indpar}[0.1in]
\tt
\begin{tabular}{@{}l@{~~}l@{~~}l@{~~}l@{}}
b\#"10110100"	& o\#"7534201"   & d\#"9758"	& x\#"E8A932B" \\
b\#"1011.0100"	& o\#"75.34201"  & d\#"97.58"	& x\#"E8,A9.32B" \\
b\#"101101"E2	& o\#"0.7753"    & d\#"97.58"e5	& X\#"0.fe8a"e-4 \\
B\#"10,1101"E+2	& O\#"2,3456"E-3 & D\#"0.1235"	& X\#"E8A.7CCD,83" \\
+B\#"101,101"e2	& -O\#"0.2345,6" & -D\#"0.123,5" & +X\#"E8A,932B.7C" \\
\end{tabular}
\end{indpar}

Just as for {\em numbers}\pagnote{NUMBERS}
the {\em exponent-part} shifts the decimal point right (if +) or left (if -)
by some number of digits (in the given radix).  The {\em dits}
in the {\em exponent-part} are always decimal digits.

Note that a {\em radix-number} consists of two or three separate
lexemes.  The {\em signed-radix-indicator} is always the first
lexeme and is a {\em word}.  The {\em quoted-radix-digits}
is the second lexeme and is a {\em quoted-string}.  The
{\em exponent-part} is an optional third lexeme and is a {\em word}.
The {\em quoted-string} lexeme can be continued across physical lines
as per \pagref{QUOTED-STRING-CONTINUATION}.

\subsection{Units and Quantities}
\label{UNITS-AND-QUANTITIES}

Values may have units, such as `\TT{ft}' for `feet' or
`\TT{inch}' for inch (`\TT{in}' is useful as a preposition and
is therefore not used as a unit).  Units can be combined in
a single lexeme by using the operators
`\TT{/}' for division,
`\TT{*}' for multiplication,
and `\TT{\CIRCUM}' for exponentiation:
\begin{indpar}
\emkey{unit}
    \begin{tabular}[t]{rl}
    :::= & {\em unit-product} \\
     $|$ & \TT{/} {\em unit-product} \\
     $|$ & {\em unit} \TT{/} {\em unit-product} \\
    \end{tabular}
\\
\emkey{unit-product}
    \begin{tabular}[t]{rl}
    :::= & {\em unit-factor} \\
     $|$ & {\em unit-product} \TT{*} {\em unit-factor} \\
    \end{tabular}
\\
\emkey{unit-factor}
    \begin{tabular}[t]{rl}
    :::= & {\em unit-name} \\
     $|$ & {\em unit-name} \TT{\CIRCUM}
           {\em sign}\QMARK{} {\em dit}\PLUS{}  \\
     $|$ & \TT{1} \\
    \end{tabular}
\\
\emkey{unit-name} :::= {\em unit-name-word} $|$ {\em unit-name-mark }
\\
\emkey{unit-name-word} :::= {\em word} containing only letters
\\
\emkey{unit-name-mark} :::=
    \begin{tabular}[t]{@{}l}
    {\em mark} containing only characters with UNICODE class \ttkey{Sc} \\
    (i.e., `Currency Symbol', includes \TT{\$})
    \end{tabular}
		         
\end{indpar}

Some examples are
\begin{indpar}[0.1in]
\tt
\begin{tabular}{l@{~~~}l@{~~~}l@{~~~}l}
ft		& inch	& \$	& kg \\
lb*ft		& inch\CIRCUM-3    & \$/kg & kg/\$ \\
ft/sec		& ft/sec/sec	& m*sec\CIRCUM-2 & lb*ft/sec \\
ft\CIRCUM 2/sec
		& ft/sec*sec	& sec\CIRCUM 2/m\CIRCUM 2
				& sec/lb*ft \\
/sec		& /sec\CIRCUM 2	& /ft*lb  & /ft/sec/sec \\
\end{tabular}
\end{indpar}

`\TT{*}' takes precedence over `\TT{/}', and `\TT{\CIRCUM}'
takes precedence over `\TT{*}'.
A unit beginning with a `\TT{/}' has an implied \TT{1}
at its beginning: e.g., `\TT{/sec}' means \TT{1/sec}.
Consecutive `\TT{/}'s left associate: \TT{/sec/sec} is the same
as \TT{/sec*sec} or \TT{/sec\CIRCUM 2}: `\TT{/}' can be read
as `per'.

A {\em unit} can be simplified to a cannonical form that
\begin{itemize}
\item contains only \TT{*}'s and \TT{/}'s
\item has no \TT{*} after a \TT{/}
\item has unit names before the first \TT{/} sorted in lexigraphic order
\item has unit names after the first \TT{/} sorted in lexigraphic order
\end{itemize}
Examples are:
\begin{center}
\tt
\begin{tabular}{r@{~$\Longrightarrow$~}l}
lb*ft & ft*lb \\
/sec*sec & /sec/sec \\
/sec\CIRCUM2 & /sec/sec \\
sec\CIRCUM-2 & /sec/sec \\
lb/ft*sec & lb/ft/sec \\
ft\CIRCUM2*sec\CIRCUM-2 & ft*ft/sec/sec
\end{tabular}
\end{center}

A {\em quantity} is a combinations of a number and a {\em unit}.
Syntactically, consecutive {\em quantities} must have compatible
{\em units} and are additively combined, with the result having the
smallest of the two {\em units}.
\begin{indpar}
\emkey{quantity} ::= \{ {\em general-number} ~ {\em unit} \}\PLUS{} \\
\emkey{general-number}\label{GENERAL-NUMBER}
    ::= {\em integer} $|$ {\em number} $|$ {\em fraction} $|$ {numeric-word}
\end{indpar}
Examples are:
\begin{center}
\tt
\begin{tabular}{r@{~$\Longrightarrow$~}l}
5 ft & 5 ft \\
5 ft 6 inch & 86 inch \\
5 1/3 ft & 5.333333 ft \\
3 oz 5 g & 90.048569 g \\
3 oz 5 g 13 mg & 90061.569 mg \\
3 oz 5 ft & NaN oz [with `incompatible units' warning] \\
\end{tabular}
\end{center}



Quantities can be combined by the operators \TT{+}, \TT{-},
\TT{*}, \TT{/}, and by \TT{\CIRCUM} with an integer constant exponent.
When \TT{+} or \TT{-} are used, the two quantity {\em units} must be
compatible with other, and the result will have the smallest
of the two {\em units}.  Examples are:
\begin{center}
\tt
\begin{tabular}{r@{~$\Longrightarrow$~}l}
5 ft + 6 ft & 11 ft \\
5 ft + 6 inch & 65 inch \\
24 lb / ( 2 ft * 6 ft ) & 2 lb/ft/ft \\
\end{tabular}
\end{center}

A {\em unit} by itself names a quantity whose number part equals $1$:
e.g., `\TT{ft}' by itself names the quantity `\TT{1 ft}'.

Units may be defined by statements of the form:
\begin{center}
\TT{define unit} {\em unit-name}
    \{ \TT{=} {\em unit-definition-expression} \}\QMARK{}
\end{center}

Here
\begin{indpar}
\emkey{unit-definition-expression} ::= {\em quantity-expression}
    \{ {\em sign} {\em number-expression} \}\QMARK{}
\\
\emkey{quantity-expression} ::= {\em expression} that evaluates to a quantity
\\
\emkey{number-expression} ::= {\em expression} that evaluates to a number
\\
{\em expression} ::= see \pagref{EXPRESSION}
\end{indpar}

Standard definitions are given in Figure~\itemref{PRE-DEFINED-UNITS}.

\begin{boxedfigure}[t]
\begin{indpar}\begin{verbatim}
define unit m                       // meter
define unit cm = 0.01 m             // centimeter
define unit inch = 2.54 cm          // inch
define unit ft = 12 inch            // foot
define unit yd = 3 ft               // yard
define unit sqft = ft^2             // square foot
define unit cuft = ft^3             // cubic foot
define unit degC                    // degree Centigrade
define unit degF = 1.8 degC + 32    // degree Farenheit
define unit degK = degC + 273.15    // degree Kelvin
define unit g                       // gram
define unit kg = 1000 g             // kilogram
define unit mg = 0.001 g            // milligram
define unit oz = 28.349523 g        // ounce
define unit lb = 16 oz              // pound
define unit sec                     // second
\end{verbatim}\end{indpar}

\caption{Pre-Defined UNITS}
\label{PRE-DEFINED-UNITS}
\end{boxedfigure}

A unit may appear in many `\TT{define unit}' statements in order to describe
its relation to other units.  The statements must be consistent.
An example of a definition consistent with the pre-defined
definitions is:

\begin{indpar}\begin{verbatim}
define unit inch = yd / 36
\end{verbatim}\end{indpar}

This is automatically checked by computing:
\begin{center}
\tt inch = yd / 36 = (3 ft) / 36 = 3 * (12 inch) / 36 \\
= (36 inch) / 36 = 1 inch
\end{center}

Equations will be automatically derived from `\TT{define unit}' statements
when such can be done by linear algebra and simple substitution; e.g.
`{\tt yd = 36 inch}' and `{\tt sqft = 144 inch\CIRCUM 2}'
will be derived automatically when needed.



\subsection{Dates}
\label{DATES}

A \key{date} is a quantity whose unit is \TT{sec}
and whose number is an integer
that gives the \key{Julian Day Number} of the day times
the number of seconds in one day ($60*60*24=86,400$).\footnote{
On days in which there are leap seconds, the last second of the
day may be either double-length or zero-length, following the Network
Time Protocol (NTP).  Or all the seconds of a leap second day may be
lengthened or shortened slightly, following Google and others.}
The value \TT{0} is assigned to
12noon, Monday, January 1, 4713BC.
Numerically, \TT{4713-01-01BC == 4713jan01BC == 4713BC == 0}, and every increase
of this date by one day adds \TT{86,400}.  For example,
\TT{2,458,522*86,400} represents
12noon on Thursday, February 7, 2019.

Because dates are quantities with \TT{sec} units, they may be subtracted to
produce time interval quantitites with \TT{sec} units.

There are a large number of date formats in use around the world,
and disambiguating them generally requires context and intelligence.
The formats given here are intended to be unambiguously interpreted
by people and simple computer programs.

The following are the permitted date formats.  Note that a {\em date}
is a sequence of one or more lexemes, and a {\em date-name} is a single
lexeme.

\begin{indpar}
\emkey{date} \begin{tabular}[t]{rl}
	      ::= & {\em weekday}\QMARK{} ~ {\em date-name} \\
	      $|$ & {\em weekday}\QMARK{} ~
	            {\em month-word} ~ {\em day} ~ {\em year} \\
	      $|$ & {\em weekday}\QMARK{} ~
	            {\em day} ~ {\em month-word} ~ {\em year} \\
	      $|$ & {\em month-word} ~ {\em year} \\
	      $|$ & {\em weekday}\QMARK{} ~
	            {\em day-of-year}\QMARK{} ~ {\em year-with-era}  \\
	     \end{tabular}
\label{DATE}
\\[1ex]
\emkey{date-name} \begin{tabular}[t]{rl}
	     :::= & {\em year-name} \TT{-} {\em month-name}
	     	                    \TT{-} {\em day-name} \\
	      $|$ & {\em year-name-with-era}  \TT{-} {\em day-of-year-name} \\
	     \end{tabular}
\\[1ex]
\emkey{year} :::=  {\em integer} {\em era} $|$ {\em year-name}
\\[1ex]
\emkey{year-name} :::= {\em dit} {\em dit} {\em dit} {\em dit}
                   $|$ {\em year-name-with-era}
\\[1ex]
\emkey{year-with-era} :::=  {\em integer} {\em era} $|$ {\em year-name-with-era}
\\[1ex]
\emkey{year-name-with-era} :::= {\em dit}\PLUS{} {\em era}
\\[1ex]
\emkey{month-name} :::=  {\em dit} {\em dit} $|$ {\em month-word}
\\[1ex]
\emkey{month-word} :::= [first letter or whole word may be capitalized] \\
    \hspace*{0.5in}\begin{tabular}[t]{rl}
        & \TT{jan} $|$ \TT{january} \\
    $|$ & \TT{feb} $|$ \TT{february} \\
    $|$ & \TT{mar} $|$ \TT{march} \\
    $|$ & \TT{apr} $|$ \TT{april} \\
    $|$ & \TT{may} $|$ \TT{may} \\
    $|$ & \TT{jun} $|$ \TT{june} \\
    $|$ & \TT{jul} $|$ \TT{july} \\
    $|$ & \TT{aug} $|$ \TT{august} \\
    $|$ & \TT{sep} $|$ \TT{sept} $|$ \TT{september} \\
    $|$ & \TT{oct} $|$ \TT{october} \\
    $|$ & \TT{nov} $|$ \TT{november} \\
    $|$ & \TT{dec} $|$ \TT{december} \\
    \end{tabular}
\\[1ex]
\emkey{day} :::=  {\em integer}
\\[1ex]
\emkey{day-name} :::=  {\em dit} {\em dit}
\\[1ex]
\emkey{day-of-year} :::=  {\em integer}
\\[1ex]
\emkey{day-of-year-name} :::=  {\em dit} {\em dit} {\em dit}
\\[1ex]
\emkey{weekday} :::= [first letter or whole word may be capitalized] \\
    \hspace*{0.5in}\begin{tabular}[t]{rl}
        & \TT{mon} $|$ \TT{monday} \\
    $|$ & \TT{tue} $|$ \TT{tues} $|$ \TT{tuesday} \\
    $|$ & \TT{wed} $|$ \TT{wednesday} \\
    $|$ & \TT{thu} $|$ \TT{thur} $|$ \TT{thursday} \\
    $|$ & \TT{fri} $|$ \TT{friday} \\
    $|$ & \TT{sat} $|$ \TT{saturday} \\
    $|$ & \TT{sun} $|$ \TT{sunday} \\
    \end{tabular}
\\[1ex]
\emkey{era} :::=  \TT{AD} $|$ \TT{BC} $|$ \TT{ADG} $|$ \TT{ADJ}
                          $|$ \TT{BCG} $|$ \TT{BCJ}
\end{indpar}

In a {\em date-name}, years must be 4 decimal digits or
end with an {\em era}, months must be 2 decimal digits or
be named by a {\em month-word}, {\em days} must be two decimal
digits, and {\em day-of-years} must be 3 decimal digits.
In other {\em dates}, days and years may be arbitrary integers
but months must be {\em month-words}.

Where a specific number of decimal digits is required,
high order zeros may be needed.

In a {\em date-name}, years come first.  In other {\em dates},
years come last.

{\em Weekdays} are superfluous; if they are input and are wrong,
a warning message is issued.

The default {\em era} is \TT{AD}.
A `\TT{G}' at the end of an {\em era} indicates the date is in the
Gregorian Calendar, and a `\TT{J}' indicates the date is in the Julian
Calendar.  If neither is given, the date is Gregorian if it is on
or after 15 October 1582, and Julian otherwise.

\TT{0AD} is the same as \TT{1BC}, \TT{0BC} is the same as \TT{1AD},
and negative years count from the zero years (`\TT{-1 AD}' is \TT{2BC},
etc.).

A date containing just a {\em year} must contain an {\em era}
and refers to January 1 of that
year; e.g., \TT{1905AD} has the same value as \TT{1905-01-01}.
A date consisting of just a {\em year} and a {\em month}
refers to the first day of the month;
e.g., \TT{2005 May} and \TT{2005-05-01} have the same value.

A warning message is issued if {\em month} is out of the range
\TT{1..12}, but the date is still computed letting \TT{0} denote
December of the previous year, \TT{13} denote January of the
next year, etc.  A warning message is issued if {\em day} is
\TT{0} or too large for the given month and year, but again
the date is still computed with \TT{0} denoting the last day of
the previous month, etc.
A warning message is issued if {\em day-of-year} is
\TT{0} or too large for the given year, but again
the date is still computed with \TT{0} denoting the last day of
the previous year, etc.

Some example {\em dates} are:

\begin{indpar}[0.1in]
\tt
\begin{tabular}{@{}l@{~~}l@{~~}l@{~~}l@{}}
2000-08-25	& 44BC-March-15   & 1999-01-01   & 2000AD-148 \\
Aug 25 2000	& 15 March -43 AD & 1999AD       & 148 2000 AD \\
25 Aug 2000ADG	& March 15 44BCJ  & Jan 1999     & May 27 2000 \\
\end{tabular}
\end{indpar}

Dates formatted as \TT{05/04/2003} and \TT{May 4 03} are not allowed
because of ambiguities (e.g., Europeans would write this date as
\TT{04/05/2003} and the Japanese as \TT{03/05/04} and in some contexts
\TT{03} might refer to \TT{1903} instead of \TT{2003}).

\subsection{Times}
\label{TIMES}

\ikey{Times}{time}, \ikey{times of day}{time of day}, and \skey{time interval}s
are a quantities with \TT{sec} units
and numbers that need not be integers.  As such times of day can be added
to dates to produce times, dates can be subtracted from times to produce
times of day, time intervals can be added to times to produce new
times, and times can be subtracted from each other to
produce time intervals.

The following are the permitted time and time of day formats.
Note that a {\em date} and {\em time-of-day}
are sequences of one or more lexemes, while a {\em date-name},
{\em time-of-day-name}, and {\em time-interval} are single lexemes.

\begin{indpar}
\emkey{time} \begin{tabular}[t]{rl}
     ::= & {\em time-name} \\
     $|$ & {\em date} ~ {\em time-of-day} \\
    \end{tabular}
\label{TIME}
\\[1ex]
\emkey{time-name} \begin{tabular}[t]{rl}
    :::= & \{ {\em date-name} \TT{-} \}\QMARK{} ~ {\em time-of-day-name} \\
    :::= & {\em date-name} ~ \TT{T} ~ {\em time-of-day-name} \\
    \end{tabular}
\\[1ex]
\emkey{time-of-day-name} \begin{tabular}[t]{rl}
    :::= & {\em time-interval} \\
     $|$ & {\em time-interval} ~ {\em time-zone} \\
     $|$ & {\em time-interval} ~ {\em meridian} \\
    \end{tabular}
\\[1ex]
\emkey{time-interval} :::= {\em hour} \TT{:} {\em minute} ~
                          \{ \TT{:} {\em second} \}\QMARK{}
\label{TIME-INTERVAL}
\\[1ex]
\emkey{meridian-time} :::= {\em time-of-day-name} with {\em meridan}
\\[1ex]
\emkey{time-of-day} \begin{tabular}[t]{rl}
     ::= & {\em time-of-day-name} \\
     $|$ & {\em time-interval} ~ {\em time-zone} \\
     $|$ & {\em meridian-time} ~ {\em time-zone} \\
    \end{tabular}
\\[1ex]
\emkey{hour} :::= {\em digit}\PLUS{}
\\[1ex]
\emkey{minute} :::= {\em digit} {\em digit}
\\[1ex]
\emkey{second} :::=
	{\em digit} {\em digit} {\em fractional-second}\QMARK{}
\\[1ex]
\emkey{fractional-second} :::= \TT{.} {\em digit}\PLUS{}
	$|$ \TT{.} \{ {\em digit} {\em digit} {\em digit} \TT{,} \}\PLUS{}
	    {\em digit} {\em digit}\QMARK{} {\em digit}\QMARK{}
\\[1ex]
\emkey{meridian} :::= \TT{am} $|$ \TT{AM} $|$ \TT{pm} $|$ \TT{PM}
                 $|$ \TT{noon} $|$ \TT{midnight}
\\[1ex]
\emkey{time-zone}
    \begin{tabular}[t]{rl}
    :::= & {\em universal-time-indicator} \\
    $|$ & {\em universal-time-indicator}
          {\em sign} {\em digit} {\em digit}
	   \{ \TT{:} {\em digit} {\em digit} \}\QMARK{} \\
    $|$ & {\em defined-time-zone-name}
    \end{tabular}
\\[1ex]
\emkey{universal-time-indicator} :::= \ttkey{UTC} $|$ \ttkey{GMT} $|$ \ttkey{Z}
\end{indpar}



A {\em time-interval} represents the number
$60*(60*hour+minute)+second$.  A {\em minute} or
{\em second} value equal to or greater than $60$ merely causes a warning
message to be issued.  The {\em hour} and its following `\TT{:}'
must be given, even if the {\em hour} is \TT{0}.  Any {\em Minute}
must have 2 digits, which may require a high order \TT{0}.  
Any {\em second} must have 2 digits before an optional {\em fractional-second}.

A {\em meridian} limits the {\em time-interval}
to be equal to or greater than \TT{1:00} and strictly less than
\TT{13:00}; else a warning message is issued.  A \TT{noon}
or \TT{midnight} {\em meridian} limits the {\em time-interval}
to be equal to \TT{12:00}; else a warning message is issued.
In the absence of a {\em meridian}, the {\em time-interval}
must be equal to or greater than \TT{00:00} and equal to or less
than \TT{24:00}, else a warning message is issued.
Note that \TT{24:00} equals \TT{00:00} of the next day.

If \TT{am} or \TT{AM} is given, $12$ hours is subtracted from
{\em time-interval} values equal to or greater than \TT{12:00}.
If \TT{pm} or \TT{PM} is given, $12$ hours is added to
{\em time-interval} values that are strictly less than \TT{12:00}.
The time \TT{12:00noon} is interpreted as \TT{12:00} and
the time \TT{12:00midnight} is interpreted as \TT{24:00}.
Note that \TT{12:00am == 0:00}, \TT{12:00pm == 12:00}, and neither
equal \TT{24:00}.

{\em Meridians} cannot be preceded by whitespace.
When both {\em meridians} and {\em time-zones} are given
in a {\em time-of-day}, whitespace must preceed the {\em time-zone}.

\begin{boxedfigure}[t]

\footnotesize

\begin{center}
\begin{tabular}{l|l}
\begin{tabular}[t]{@{}lll@{}}
      &                               & UTC \\
HST   & Hawaii Standard Time          & -10:00 \\
AKST  & Alaska Standard Time          & -09:00 \\
AKDT  & Alaska Daylight Time          & -08:00 \\
PST   & Pacific Standard Time         & -08:00 \\
PDT   & Pacific Daylight Time         & -07:00 \\
MST   & Mountain Standard Time        & -07:00 \\
MDT   & Mountain Daylight Time        & -06:00 \\
CST   & Central Standard Time         & -06:00 \\
CDT   & Central Daylight Time         & -05:00 \\
EST   & Eastern Standard Time         & -05:00 \\
EDT   & Eastern Datlight Time         & -04:00 \\
AST   & Atlantic Standard Time        & -04:00 \\
ADT   & Atlantic Daylight Time        & -03:00 \\
ART   & Argentina Time                & -03:00 \\
BRT   & Brasilia Time                 & -03:00 \\
BRST  & Brasilia Summer Time          & -02:00 \\
GMT   & Greenwich Mean Time           & +00:00 \\
WET   & Western European Time         & +00:00 \\
BST   & British Summer Time           & +01:00 \\
\end{tabular}
&
\begin{tabular}[t]{@{}lll@{}}
      &                               & UTC \\
CET   & Central European Time         & +01:00 \\
WAT   & West Africa Time              & +01:00 \\
CEST  & Central European Summer Time  & +02:00 \\
EET   & Eastern European Time         & +02:00 \\
CAT   & Central Africa Time           & +02:00 \\
EEST  & Eastern European Summer Time  & +03:00 \\
EAT   & Eastern Africa Time           & +03:00 \\
GST   & Gulf Standard Time            & +04:00 \\
PKT   & Pakistan Standard Time        & +05:00 \\
IST   & India Standard Time           & +05:30 \\
JST   & Japan Standard Time           & +09:00 \\
AWST  & Australia Western Standard Time        & +09:00 \\
AWDT  & Australia Western Daylight Time        & +10:00 \\
ACST  & Australia Central Standard Time        & +09:30 \\
ACDT  & Australia Central Daylight Time        & +10:30 \\
AEST  & Australia Eastern Standard Time        & +10:00 \\
AEDT  & Australia Eastern Daylight Time        & +11:00 \\
NZST  & New Zealand Standard Time     & +12:00 \\
NZST  & New Zealand Daylight Time     & +13:00 \\
\end{tabular}
\end{tabular}
\end{center}
\vspace*{-3ex}
\caption{Pre-Defined Time Zones}
\label{PRE-DEFINED-TIME-ZONES}
\end{boxedfigure}

\ttkey{UTC} (Coordinated Universal Time), \ttkey{GMT}
(Greenwich Mean Time), and \ttkey{Z} (Zulu Time) can be used interchangeably.
\TT{UTC-05:00} refers to Greenwich Mean Time
minus 5 hours (\TT{-05:00}) and is the same as
Eastern Standard Time, or \TT{EST}.   When localities that use \TT{EST}
go on Daylight Savings Time, they convert to Eastern Daylight Time, or
\TT{EDT}, which is that same as \TT{UTC-04:00}.

As another example, \TT{NZST}, New Zealand Standard Time, is the same
as \TT{UTC+12:00}.

If a {\em time-zone} is given, the difference between the {\em time-zone}
time and GMT is subtracted from the {\em time-interval}.
Thus for \TT{UTC-5:00} 5 hours is added to the {\em time-interval},
so \TT{10:00EST == 15:00GMT}.
Similarly
for \TT{UTC+12:00} 12 hours is subtracted from the {\em time-interval},
so \TT{17:00NZST == 5:00GMT}.
It is possible to get negative numbers, which indicate a time in the previous
GMT day, or numbers equal to or larger than \TT{24:00}, which indicate
a time in the next GMT day.

The standard time zones pre-defined in RECKON are given in
Figure~\ref{PRE-DEFINED-TIME-ZONES}.
Some time zone identifiers are ambiguous.  For example, \TT{CST}
denotes both `Central Standard Time' (\TT{UTC-06:00} in North America)
and `China Standard Time' (\TT{UTC+08:00}).  Only the former is standard.

Additional time zones can be defined, or existing time zone
definitions can be replaced, by the statement:
\begin{center}
\TT{define time zone} ~{\em defined-time-zone-name} ~
    \TT{`}{\em long-name}\TT{' UTC}$\pm${\em offset}
\end{center}

as for example
\begin{indpar}\begin{verbatim}
define time zone WGST `West Greenland Summer Time' UTC-02:00
define time zone AZOST `Azores Summer Time' UTC+00:00
define time zone BST `Bangladesh Standard Time' UTC+06:00
       // Replaces British Summer Time, UTC+01:00
define time zone VLAT `Vladivostok Time' UTC+10:00
\end{verbatim}\end{indpar}

{\em Defined-time-zone-names} are {\em words} in which
capitalization is ignored, both in definition and in usage.
{\em Long-names} are in effect comments.

Some example {\em times} are:

\begin{indpar}[0.1in]
\tt
\begin{tabular}{@{}l@{~}l@{~}l@{}}
0:15EST			& 12:00EST		& 15:37:23.742z \\
12:15am est		& 12:00noon		& 15:37:23.742 Z \\
1:15 edt		& 12:00 est		& 05:37:23.742HST \\
1:15am edt		& 12:00pm EST		& 03:37:23.742pm GMT \\
1975-May-08-0:15edt	& 1999-05-04 12:00est	& 1999May23-15:37z \\
1975-May-08T1:15edt	& 1999-05-04T17:00z	& 1999May24T01:37WDT \\
1975-May-08 1:15am edt	& 1999-05-04 11:00edt	& 1999May23 20:37 PKT \\
\end{tabular}
\end{indpar}

\subsection{Formats}
\label{FORMATS}

A \emkey{format} tells how to print a value, usually a number, but
sometimes a symbol (character string).  {\em Formats} are {\em lexemes}
that begin and end with `\TT{/}'.

Some examples are (where {\tt \VSP} denotes a single
space character):
\begin{indpar}[0.1in]
\tt
\begin{tabular}{l@{~~~}l@{~~~}l@{~~~~~~}l@{~~~}l@{~~~}l}
\rm Value & \rm Format & \rm Printout &
\rm Value & \rm Format & \rm Printout
\\[1ex]
5.4321	  & /0.4/	& 5.4321 &
Hello	  & 		& Hello \\
5.4321	  & /0.4rm/	& \rm 5.4321 &
Hello	  & /rm/	& \rm Hello \\
5.4321	  & /0.4ss/	& \sf 5.4321 &
Hello	  & /ss/	& \sf Hello \\
5.4321	  & /0.2b/	& \bf 5.43 &
Hello	  & /b/		& \bf Hello \\
5.4321	  & /w5sc/0.2/	& \sc \VSP 5.43 &
Hello	  & /rw7sc/	& \sc \VSP\VSP Hello \\
5.4321	  & /cw6sl/0.2/	& \sl \VSP 5.43\VSP &
Hello	  & /w7/sl/	& \sl \VSP Hello\VSP \\
5.4321	  & /w6i/0.2/	& \it \VSP\VSP 5.43 &
Hello	  & /lw7i/	& \it Hello \VSP\VSP \\
\end{tabular}
\end{indpar}

A {\em format} is a {\em word} or {\em numeric} consisting of a sequence of
{\em format-items} surrounded by and optionally separated by
slashes `\TT{/}':
\begin{indpar}
\begin{tabular}{rcl}
\hspace*{1.7in} \\[-2ex]
\emkey{format}
    & ::= & \TT{/} {\em format-item}
                   \{ \TT{/}\QMARK{} {\em format-item} \}\STAR{} \TT{/}
\end{tabular}
\end{indpar}

The following is a complete list of {\em format-items}.
All {\em format-items} contain either a letter or a digit, so all
formats are either {\em words} or {\em numerics}.
The slashes (\TT{/}) between {\em format-items} in a {\em format}
may be omitted if no ambiguity arises.

The items are presented in groups whose items, unless otherwise noted, conflict
with each other; see the rules below for resolving conflicts.

\newcommand{\BEGINGROUP}[2][]{
\begin{tabular}{rllp{4.0in}}
\hspace*{0.1in} & \hspace*{0.1in} & \hspace*{0.4in} \\[-2ex]
& \multicolumn{3}{l}{{\bf #2}\ifstrequal{}{#1}{}{ ~~~~~ #1}} \\
}
\newcommand{\GROUPENTRY}[2][]{
&& \ttmkey{#2}{table format}\ifstrequal{}{#1}{}{#1} & }
\newcommand{\GROUPNEWLINE}{\\&&&}
\newcommand{\ENDGROUP}{\end{tabular}}

\BEGINGROUP[(non-monospace unless indicated)]{Font Style Group}
\GROUPENTRY{ty} typewriter (monospace) [default] \\
\GROUPENTRY{rm} roman (normal non-monospace) \\
\GROUPENTRY{ss} sans-serif \\
\GROUPENTRY{b} bold \\
\GROUPENTRY{i} italic \\
\GROUPENTRY{sl} slanted \\
\GROUPENTRY{sc} small caps \\
\ENDGROUP \\
\BEGINGROUP{Font Size Group}
\GROUPENTRY[\em r]{fs} adjust the font size to {\em r}\% of normal.
\ENDGROUP \\
\BEGINGROUP{Background Color Group}
\GROUPENTRY{gray} light gray background \\
\GROUPENTRY{white} white background [default] \\
\ENDGROUP \\
\BEGINGROUP{Adjust Group}
\GROUPENTRY{r} right adjust [default for numbers] \\
\GROUPENTRY{l} left adjust \\
\GROUPENTRY{c} center adjust [default for symbols] \\
\ENDGROUP \\
\BEGINGROUP{Number Group}
\GROUPENTRY[\em p]{.}
    output with exactly {\em p} decimal places \\
\GROUPENTRY[\em p]{0.}
    ditto but with \TT{0} in the units position if less than \TT{1} \\
\GROUPENTRY{0}
    ditto but with zero decimal places and \underline{no} decimal point \\
\GROUPENTRY[\em s]{p}
    output with exactly {\em s} significant decimal digits,
    \GROUPNEWLINE
    but avoid using exponent if it is more compact not too,
    \GROUPNEWLINE
    suppress low order fraction \TT{0}'s,
    \GROUPNEWLINE
    and suppress decimal point if there are no fraction digits
    \GROUPNEWLINE
    [default is `\TT{p6}'] \\
\GROUPENTRY[\TT{`}\em time-format\TT{'}]{T}
    format time (or date) as per below; \GROUPNEWLINE
    conflicts with \TT{f}\ldots, \TT{u}\ldots, \TT{s}\ldots, \TT{i}\ldots
\ENDGROUP \\
\BEGINGROUP{Fraction Group}
\GROUPENTRY[\em d]{f}
    when a number is about to be output with a fractional part,
    prefer a fractional representation with denominator less than
    or equal to {\em d}, if that is more precise. \\
\GROUPENTRY[\em e]{f2\CIRCUM}
    ditto but denomenator must be a power of $2$ equal to or less
    than $2^e$. \\
\GROUPENTRY{!f}
    do not use fractional representations with demonimators
    \GROUPNEWLINE
    [default] \\
\ENDGROUP \\
\BEGINGROUP{Unit Group}
\GROUPENTRY{u\%} multiply numbers by 100 and add a \% sign \\
\GROUPENTRY{u\$} add \$ sign to numbers; \GROUPNEWLINE
                make \TT{0.2} the Number Group default \\
\GROUPENTRY[\TT{`}\em unit\TT{'}]{u} the numbers are to be expressed in
		the given {\em unit}'s, where {\em unit} is as per
		Section~\itemref{UNITS-AND-QUANTITIES},
		but the {\em unit} itself
		is \underline{not} to be included in the entry\\
\GROUPENTRY[\TT{`}\em unit\TT{'}]{U} ditto but
		the {\em unit} itself
		\underline{is} to be included in the entry\\
\GROUPENTRY{!u} no unit [default]
\ENDGROUP \\
\BEGINGROUP{Sign Group}
\GROUPENTRY{s()} indicate negative numbers by parentheses instead of sign \\
\GROUPENTRY{s+} indicate positive and zero numbers by sign, + or - \\
\GROUPENTRY{s-} indicate negative numbers by sign (-) and positive by absence
               of sign [default] \\
\ENDGROUP \\
\BEGINGROUP{Integer Comma Group}
\GROUPENTRY{i,} add commas to integral parts of numbers [default] \\
\GROUPENTRY{!i,} undo ditto \\
\ENDGROUP \\
\BEGINGROUP{Fraction Comma Group}
\GROUPENTRY{f,} add commas to fractional parts of numbers \\
\GROUPENTRY{!f,} undo ditto [default] \\
\ENDGROUP \\
\BEGINGROUP{Width Group}
\GROUPENTRY[\em c]{w}
    adjust width by {\em c} columns \\
\GROUPENTRY[\em c]{}
    ditto, where {\em c} is unsigned {\em natural-number} \\
\GROUPENTRY{!w}
    set width to `only as wide as necessary' [default] \\
\ENDGROUP \\
\BEGINGROUP{Height Group}
\GROUPENTRY[\em h]{h}
    adjust height by {\em h} lines \\
\GROUPENTRY{!h}
    set height to `only as high as necessary' [default] \\
\ENDGROUP \\
\BEGINGROUP[(\TT{ml} and \TT{mr} do not conflict)]%
           {Horizontal Margin Group}
\GROUPENTRY[\em p]{ml}
    adjust space of left margin of entry by {\em p} points \\
\GROUPENTRY[\em p]{mr}
    adjust space of right margin of entry by {\em p} points \\
\GROUPENTRY[\em p]{mlr}
    adjust space of both left and right margins of entry by {\em p} points
    [default is `\TT{mlr3}'] \\
\ENDGROUP \\
\BEGINGROUP[(\TT{mt} and \TT{mb} do not conflict)]%
           {Vertical Margin Group}
\GROUPENTRY[\em p]{mt}
    adjust space of top margin of entry by {\em p} points \\
\GROUPENTRY[\em p]{mb}
    adjust space of bottom margin of entry by {\em p} points \\
\GROUPENTRY[\em p]{mtb}
    adjust space of both top and bottom margin of
    entry by {\em p} points [default is `\TT{mtb3}'] \\
\ENDGROUP

To `adjust' a value V by a parameter $P$ in the above is to
set V to $P$ if $P$ has no sign, or to add $P$ to the current V if
$P$ has a sign.  Thus `\TT{w7}' sets the width to 7 columns while
`\TT{w-2}' subtracts two columns from the natural (wide as
nessary) width and
`\TT{w+2}' adds two columns to the natural width.

The {\em format-items} are applied left to right, with a {\em format-item}
cancelling conflicting {\em format-items} to its left.  In applying this
rule, however, {\em format-items} that adjust a value by adding
or subtracting a parameter to the value do not conflict with any
{\em format-item}, but instead adjust the previously computed parameter value.

In some contexts
there are multiple formats applied in a given order.  For example,
in tables the table format, column format, and row format are applied in
order, so column format items override conflicting table format items,
and row format items override conflicting table and column format items.
A format item does not override another item with which it does not conflict.



A {\em time-format} is a string of any characters surrounded by
\TT{`~'}s that are
allowed inside a {\em middle-lexeme} in which the following \emskey{time-code}s
are replaced as indicated in Figure~\ref{TIME-FORMAT-CODES}.
Note it is in the nature of formats that the \TT{`~'}s are not at the
ends of the {\em middle-lexeme} and are therefore not recognized as
separators.

Some example {\em time-formats} and associated times are:
\begin{center}
\tt
\begin{tabular}{@{}l@{}l@{}}
\hspace*{3.4in} & \hspace*{3in} \\[-3ex]
/T`mm/dd/yyyy'/ & 02/21/2014 \\
/T`dd/mm/yyyy'/ & 21/02/2014 \\
/T`mm/yyyy'/ & 02/2014 \\
\end{tabular} \\
\begin{tabular}{@{}l@{}l@{}}
\hspace*{3.4in} & \hspace*{3in} \\[-3ex]
/T`www\_dd\_mmm\_\BSLASH'yy'/ & fri 21 feb '14 \\
/T`Www\_ddMmmyy'/ & Fri 21Feb14 \\
\end{tabular} \\
\begin{tabular}{@{}l@{}l@{}}
\hspace*{3.4in} & \hspace*{3in} \\[-3ex]
/T`hh::mm:ss'/ & 13:27:58 \\
/T`hh::mm:ssXM'/ & 1:27:58PM \\
/T`hh::mm:ss'/ & 00:27:58 \\
/T`hh::mm:ssXM'/ & 12:27:58AM \\
/T`hh::mm:ss'/ & 12:27:58 \\
/T`hh::mm:ssXM'/ & 12:27:58PM \\
\end{tabular} \\
\begin{tabular}{@{}l@{}l@{}}
\hspace*{3.4in} & \hspace*{3in} \\[-3ex]
/T`Www\_Mmm\_dd\_hh:mm:ss\_ZZZ\_yyyy'/ & Fri Feb 21 13:27:58 EST 2014 \\
/T`Www\_Mmm\_dd\_hh:mm:ss\_GMT\_yyyy'/ & Fri Feb 21 18:27:58 GMT 2014 \\
/T`Www-ddMmmyy-hh:mm:ss-ZZZ'/	  & Fri-21Feb14-13:27:58-EST \\
\end{tabular}
\end{center}

\begin{boxedfigure}
\begin{center}
\begin{tabular}{lp{4.5in}}
\ttmkey{\BSLASH}{{\em time-code}} & delete the `\TT{\BSLASH}'
                                and keep the following character without
				giving it a special interpretation
				(\TT{\BSLASH'} can be use to include
				 \TT{'} in a {\em time-format})\\
\ttmkey{dd}{{\em time-code}} & day of month: \TT{01} \ldots{} \TT{31} \\
\ttmkey{ddd}{{\em time-code}} & day of year: \TT{01} \ldots{} \TT{366} \\
\ttmkey{ww}{{\em time-code}} & day of week: \TT{01} \ldots{} \TT{07} \\
\ttmkey{www}{{\em time-code}} & day of week: \TT{sun} \ldots{} \TT{sat} \\
\ttmkey{Www}{{\em time-code}} & day of week: \TT{Sun} \ldots{} \TT{Sat} \\
\ttmkey{WWW}{{\em time-code}} & day of week: \TT{SUN} \ldots{} \TT{SAT} \\
\ttmkey{mm}{{\em time-code}} & month: \TT{01} \ldots{} \TT{12}
                               if next to \TT{/} \\
\ttmkey{mmm}{{\em time-code}} & month: \TT{jan} \ldots{} \TT{dec} \\
\ttmkey{Mmm}{{\em time-code}} & month: \TT{Jan} \ldots{} \TT{Dec} \\
\ttmkey{MMM}{{\em time-code}} & month: \TT{JAN} \ldots{} \TT{DEC} \\
\ttmkey{yy}{{\em time-code}} & year: \TT{00} \ldots{} \TT{99} \\
\ttmkey{yyyy}{{\em time-code}} & year: \TT{0000} \ldots{} \TT{9999} \\
\ttmkey{xm}{{\em time-code}} & meridian: \TT{am} or \TT{pm} \\
\ttmkey{XM}{{\em time-code}} & meridian: \TT{AM} or \TT{PM} \\
\ttmkey{hh}{{\em time-code}} & hour: \TT{00} \ldots{} \TT{12}
			       if xm or XM in {\em time-format} \\
			     & or: \TT{00} \ldots{} \TT{23}
			       if xm and XM \underline{not}
			       in {\em time-format} \\
\ttmkey{mm}{{\em time-code}} & minute: \TT{00} \ldots{} \TT{59}
                               if next to \TT{:} \\
\ttmkey{ss}{{\em time-code}} & second: \TT{00} \ldots{} \TT{59} \\
\ttmkey{\_}{{\em time-code}} & single space \\
\ttmkey{zzz}{{\em time-code}} & local time zone (e.g. \TT{est}),
                                and adjust time to be in that zone \\
\ttmkey{ZZZ}{{\em time-code}} & local time zone (e.g. \TT{EST}),
				and adjust time to be in that zone \\
\ttmkey{gmt}{{\em time-code}} & do not replace,
				and adjust time to be gmt \\
\ttmkey{GMT}{{\em time-code}} & do not replace,
				and adjust time to be gmt \\
\end{tabular}
\end{center}
\caption{Time Format Codes}
\label{TIME-FORMAT-CODES}
\end{boxedfigure}

\clearpage

\section{Logical Lines and Paragraphs}
\label{LOGICAL-LINES-AND-PARAGRAPHS}

Input is parsed into a sequence of \skey{logical line}s, each of which is
a sequence of lexemes.  Once parsed, logical lines may be grouped into
paragraphs.  A paragraph with its logical lines may be nested inside
a larger logical line.

In the input, non-blank
physical lines begin with an indent lexeme that
contains an \mkey{indent}{of indent lexeme}
parameter that is the number of columns before the first
graphic character in the physical line.  All physical lines end with a
line-break or end-of-file lexeme.  Blank physical lines have
only a line-break lexeme, and do not have an indent lexeme.

The \mkey{indent}{of physical line} of a non-blank physical line is the
indent of its indent lexeme.

Each indented paragraph has a \key{paragraph indent}.
The \key{top level} behaves like the inside of an indented paragraph
whose paragraph indent is \TT{0}.
The first indent lexeme in a file must have indent \TT{0}.

In code, a logical line ends with an indent lexeme whose indent is
not greater than that of the current paragraph indent,
or with the `\TT{;}' separator lexeme outside brackets,
or with an end-of-file lexeme.
If the logical line ends with an indent lexeme whose indent equals
the current paragraph indent, or ends with a `\TT{;}' separator lexeme,
the next logical line of the paragraph follows immediately.  Otherwise
the paragraph ends.

In text, a logical line ends with an indent lexeme whose indent is
strictly less than the current paragraph ident or with an indent
lexeme that is both immediately preceeded by a blank line and whose
indent equals the current paragraph indent.

TBD


Logical lines consisting of nothing but comment lexeme lexemes and not
ended by a line separator are
called `\skey{comment line}s'.  Comment lines are discarded,
as are empty logical lines not ended by a line separator.

After a logical
line has been scanned, any indent, line-break, end-of-file, terminating
line separator, or comment lexemes
are removed.  The logical line is then compacted to form
a MIN object to which an \TT{.initiator}
attribute is added that equals
the special value \TT{min::\EOL LOGICAL\_\EOL LINE()} and a
\TT{.terminator} attribute is added that is either the terminating 
line separator or equals \TT{"<LF>"}.  The vector part of the MIN
object can only be empty if the \TT{.terminator} is a line separator.

TBD

A `\TT{:}' or `\TT{::}'
lexeme at the \underline{end of a physical line} begins an
\key{indented paragraph}.  If the indent of the next non-blank
physical line exceeds the current paragraph indent, the indent of this
line becomes the new current \key{paragraph indent}, and this line
begins the first physical line of a new indented paragraph.  Otherwise the
indented paragraph is empty.

The indented paragraph ends just before the next
non-blank physical line with less indent than the
current paragraph indent, or just before the end of file if that
occurs first.

A physical line whose indent equals the current paragraph indent
begins a new \key{logical line}.
A physical line whose indent is greater than the current paragraph indent
is a \skey{continuation line} that
continues the current \key{logical line}.
Blank lines preceeding a continuation line are ignored.
The current logical line ends with
a semi-colon (`\TT{;}'), or just before the next non-blank physical line
with indent not greater than the current paragraph indent, or
with an end of file.  Immediately after a logical line ending semi-colon,
a new logical line is begun.

Empty logical lines are ignored
as if they did not exist, so in the file:
\begin{indpar}\begin{verbatim}
This is a first logical line;;; and a second logical line;
And a third logical line.
\end{verbatim}\end{indpar}
there are only 3 logical lines: the extra `\TT{;}'s are ignored at the
end of the first logical line, and the line end after the `\TT{;}' at the
end of the second logical line is ignored.

A comment lexeme which has an indent equal to the current paragraph
indent can begin a logical line that contains only comment lexemes and
is called a \key{comment line}.
A comment
line may be used as the first line of an indented paragraph which sets
the paragraph indent, or as the line after an indented paragraph that
ends the indented paragraph.
A warning message is issued if a comment lexeme that is not
inside a comment line
is not indented more than the current paragraph indent
(such a comment lexeme begins a logical line that is not a comment line).
Aside from rules regarding indentation,
comment lexemes are ignored as if they did not exist.


As an example, consider the file:

\begin{indpar}\begin{verbatim}
This is a logical line.
And another
    logical line.
And a logical line ending with an indented paragraph:

    The first logical line of the
        indented paragraph.

    // A comment line that is ignored.
    The second logical line
        of the indented paragraph.
    The third logical line of the indented
        paragraph containing an indented
        subparagraph:
        // A comment that sets the indented subparagraph
        // paragraph indent.  A warning will be issued
        // because this comment begins a non-comment
        // logical line, but the comment is otherwise
        // ignored.

            Line 1 of subparagraph.

        Line 2 of subparagraph.

    The fourth logical line of the indented paragraph.
// Two comment lines that end the indented paragraph but
// are otherwise ignored.
The logical line after the indented paragraph.  This would
    end the indented paragraph if the two comment lines
    above it did not exist.
\end{verbatim}\end{indpar}

Indented paragraphs are contained within a logical line.  They do
\underline{not} need to be the last thing in their containing logical line.
The first non-blank physical line of an indented paragraph, the line
which determines the paragraph indent of the indented paragraph, may
be a comment line.  Any non-blank physical line with less indent than
the current paragraph indent ends the indented paragraph, and this
too may be a comment line.

As explained so far, the top level, and each indented paragraph,
consists of a sequence of logical lines that contain code.
However, in addition to logical lines, the top level and indented
paragraphs can contain headed paragraphs
and headed lines which contain text or data.

A \key{headed paragraph} begins with a \key{paragraph header}, and
a \key{headed line} begins with a \key{line header}.  These headers
have the syntax:
\begin{indpar}
\begin{tabular}{l}
\emkey{header} ::= {\em prefix} \\
\emkey{prefix} \begin{tabular}[t]{rl}
               ::= & \TT{\{}{\em type}\TT{\}} \\
               $|$ & \TT{\{}{\em type}\TT{:}
	             {\em attribute-representation}\TT{,} \ldots\TT{\}}
	       \end{tabular} \\
{\em attribute-representation} ::= see \pagref{ATTRIBUTE-REPRESENTATION}
\end{tabular}
\end{indpar}

A headed line is a logical line, and has the same indentation rules
as other logical lines.

A headed paragraph may be a sequence of logical lines (headed or not)
ending with
the next blank line, or the headed paragraph may be a single logical
line ending with the next blank line.

The latter kind of headed paragraph
is called a \key{text paragraph}.  In a text the paragraph
physical lines have no indentation rules other than that all paragraph lines
must have indent not less than the current indented paragraph indent.
The text paragraph is a single logical line that
ends at the next blank line, or the at end of its
containing indented paragraph, or at an end of file.

The following are standard text paragraph header types:
\begin{center}
\begin{tabular}{lp{4in}}
\ttkey{p} & Regular text paragraph. \\
\ttkey{quote} & Quoted text paragraph (typically indented and italicized). \\
\ttkey{section} & A section header (generally contains just one short line) \\
\end{tabular}
\end{center}

Some examples are:
\begin{indpar}\begin{verbatim}
{section}First Example

{p}This is the first paragraph of the first
        example.  And
its second sentence.  Line indentation does not
matter in this paragraph, which is ended by the
                                next blank line.

{p}This paragraph contains a quote:
    // In text, `:' can start an indented paragraph.

    {quote}
    Remember to begin at
    the beginning and go to the end.  This quote
                  is a paragraph by itself.
        Within the paragraph, indentation does not
    matter as long as it is at least the paragraph
           indent.
    // Comments do not end the paragraph, as they
    // are not blank lines.
    So this is the last sentence in the paragraph.

{code}
// This is needed to end text and return to code.
// Otherwise the next line would begin with an
// implied `{p}'.  However, `{code}' must appear on
// a line by itself (code lines are NOT of `code'
// type).

This is a line of code:
   // In code, `:' can start an indented paragraph.
   This is a logical code
       line of the indented paragraph.
   And a second logical code line.

   {p}But we can have a text paragraph in an indented
   code paragraph.

   {code}
   This is the third logical line of code.

   {p}Another piece of text.
And a logical line of code that ends the indented
    paragraph.

{section}Second Example

{p: indent = 5}
This is the first paragraph of
    the second example.

This is the next paragraph, which begins
with an implied `{p: indent = 5}', and which
   contains a quote:

    {quote}Simplify, simplify, SMPLFY!

This is the third paragraph of the section.  It begins
with an implied `{p: indent = 5}'.

{code}
This is a line of code.  If it was not preceeded by
     `{code}', it would begin with an implied
     `{p: indent = 5}'.
\end{verbatim}\end{indpar}

The part of a file that is outside headed paragraphs contains code in
logical lines or data in headed logical lines.

Headed text paragraphs must begin at the current paragraph indent
and not contain any lines with less than the current paragraph indent.
Lines of a headed text paragraph other than the first may be indented
by the current paragraph indent, or by more than the current paragraph
indent.

Generally a text paragraph installs an \lkey{implied paragraph}{header}
which will be inserted automatically at the beginning of the first
line after the next blank line, unless that line begins with an
explicit paragraph header or is after the indented paragraph containing
the text paragraph.  The implied
paragraph header is a copy of the explicit paragraph header:
e.g., for `\TT{\{p:~indent = 5\}}' the implied header will
be `\TT{\{p:~indent = 5\}}'.

The `\TT{\{section\}}' paragraph
header does \underline{not} install an implied paragraph header.
To deactivate an implied header, it is necessary
to use `\TT{\{code\}}' as if it were a paragraph header, but
this just deactivates any current implied header
and is otherwise ignored.

Besides text paragraphs, there are headed paragraphs that consist
of a sequence logical lines.  An example is:
\begin{indpar}\begin{verbatim}
{table}
{row}-----------------------------------------------------
{row}| Name   | Weight   | Height     | Age       | BMI  |
                                                      /ib/
{row}-----------------------------------------------------
{row}| <name> | <weight> | <height>   | <age>     | B
{row}| /l/    | /U`lb'/  | /U`ft_in'/ | /u`yr'.0/ | /.2/
{row}| George |    205   | 6ft 3in    | 25        |
{row}| Mary   |    135   | 5ft 5in    | 26        |
{row}----------------------------------------------
BMI: Body Mass Index
B: <body mass index>
ROW TYPE: person
SORT ROWS BY: name
\end{verbatim}\end{indpar}

Here `\TT{\{table\}}' is a paragraph header that introduces
a headed paragraph consisting of logical lines.  The logical
lines can each be continued by indented continuation lines
if neccessary, as is done for the logical line ending with
`\TT{/ib/}' in the example.  The paragraph ends at the next blank line
or the end of a containing indented paragraph.

In this example some of the logical lines are headed lines,
with `\TT{\{row\}}' being their line header.
Other logical lines are not headed: e.g., the line beginning
with `\TT{BMI:}'.

In this example the headers may be omitted because
the first characters of each logical line imply the headers.
In paragraph position (after a blank line or at the beginning
of an intented paragraph or at the beginning of the file)
any line that begins with `\TT{=====}' or `\TT{-{}-{}-{}-{}-}'
has `\TT{\{table\}\{row\}}' inserted at its beginning.  This
starts the headed paragraph and supplies its first logical
line.  Then within the headed paragraph any logical line
beginning with `\TT{=}', `\TT{-}', or `\TT{|}' has
`\TT{\{row\}}' inserted at its beginning.  So the following
is equivalent to the last example:
\begin{indpar}\begin{verbatim}
-----------------------------------------------------
| Name   | Weight   | Height     | Age       | BMI  | /ib/
-----------------------------------------------------
| <name> | <weight> | <height>   | <age>     | B
| /l/    | /U`lb'/  | /U`ft_in'/ | /u`yr'.0/ | /.2/
| George |    205   | 6ft 3in    | 25        |
| Mary   |    135   | 5ft 5in    | 26        |
----------------------------------------------
BMI: Body Mass Index
B: <body mass index>
ROW TYPE: person
SORT ROWS BY: name
\end{verbatim}\end{indpar}

A paragraph headed by an explicit or implied 
`\TT{\{table\}}' paragraph header is called a \key{table paragraph}.
A table paragraph can appear anywhere a headed paragraph can appear.
Table paragraphs do not install implied headers.

A bracketed expression, e.g., \TT{(~\ldots~)}, or a quoted expression,
e.g., \TT{`~\ldots~'} or \TT{`{}`~\ldots~'{}'},
must be completely inside a logical line.
In the case of text paragraphs, the entire paragraph is a single
logical line, so it suffices to be inside the paragraph.

A logical line beginning with \TT{@} has the implied line header
\TT{\{data\}} and is used to enter data.
A logical line beginning with \TT{!@} has the implied line header
\TT{\{raw data\}} and is used similarly.
See the Low Level Data section, \itemref{LOW-LEVEL-DATA}.

There are some special rules for gluing together lexemes within
a logical line.  When reading these rules, recall that in a text
paragraph all lines but the first are continuation lines, while
in a code paragraph, lines with greater indent than the current paragraph
indent are continuation lines.

\begin{enumerate}
\item\label{MIDDLE-LEXEME-CONCATENATION}
Two consecutive \emskey{middle-lexeme}s in a logical line are concatenated
if the first ends with \TT{\#}, the second begins with \TT{\#}, and both
contain more than just a \TT{\#}.
More than two {\em middle-lexemes} may be concatenated
together in this way.

For example,

\begin{indpar}\begin{verbatim}
This is a word-#
     #that-is-con#
     #tinued.
\end{verbatim}\end{indpar}

translates to the lexeme squence

\begin{indpar}\begin{verbatim}
This is a word-that-is-continued .
\end{verbatim}\end{indpar}

and

\begin{indpar}\begin{verbatim}
See http://forecast.weather.gov/MapClick.php?#
           #lat=42&lon=#
           #-71#.V036u7
\end{verbatim}\end{indpar}

translates to the 2 lexeme squence

\begin{indpar}[0.1in]\small\begin{verbatim}
See
http://forecast.weather.gov/MapClick.php?lat=42&lon=-71#.V036u7
\end{verbatim}\end{indpar}

\item\label{STRING-CONCATENATION}
If two \emskey{quoted-string}s in a logical line are separated by
one or two \TT{\#} mark lexemes, the strings
are concatenated \underline{after} {\em character-represen\-ta\-tives}
have been replaced by the characters they represent.  The separating mark
lexemes are deleted.  More than two {\em quoted-strings} may be concatenated
together in this way.

Thus \TT{"<" \# "LF" \# ">"} is equivalent to a single {\em quoted-string}
lexeme with the 4 characters `\TT{<}', `\TT{L}', `\TT{F}', and
`\TT{>}', whereas \TT{"<LF>"} is a {\em quoted-string} with only
1 character, a line feed.

Thus the following multi-line string concatenation example using
two \TT{\#} mark lexemes:
\begin{indpar}\begin{verbatim}
x = "This is a long "#
   #"sentence."
\end{verbatim}\end{indpar}


\end{enumerate}

The following virtual lexemes are used in the rest of this document:

\begin{center}
\begin{tabular}{ll@{\hspace*{1in}}ll}
\emkey{bip}	&	begin indented paragraph &
\emkey{eip}	&	end indented paragraph \\[0.5ex]
\emkey{bll}	&	begin logical line &
\emkey{ell}	&	end logical line
\end{tabular}
\end{center}

The sequence
\begin{center}
{\em indentation-mark} {\em bip} \ldots{} {\em eip}
\end{center}
denotes use of a physical line ending lexeme (or sequence of several),
the \emkey{indentation-mark},
followed by an indented paragraph (the {\em bip} \ldots{} {\em eip}).
Example {\em indentation-marks} are `\TT{:} and `\TT{::}'.
If the line containing the {\em indentation-mark} is a code line,
the indented paragraph consists of code lines, and if instead the
containing line is a text line, the indented paragraph has in
implied \TT{\{p\}} paragraph header, and consists of text subparagraphs
(unless overridden by \TT{\{code\}}).

\section{Low Level Data}
\label{LOW-LEVEL-DATA}

A low level \key{datum} in RECKON is either an atom, an object, or an arrow.

Expressions, blocks, and descriptions are higher level data layered
on top of these low level data.  An expression is either an atom or
a particular kind of object.  A block is a particular kind of object,
and a description is a particular kind of block.

An \key{atom} is a symbol, a number, or a label.
A \key{label} is a sequence of 0 or more atoms.
A single symbol or number is frequently
treated as if were a label whose only element
is the symbol or number itself.

An \key{object}\label{OBJECT}
is just a place in memory, and is like a dot on a blank page.
It can be the source or target of arrows, and it is different from
every other object and from every atom.  But it is nothing more.

However, as a place in memory, an object has a identifier.  Objects are assigned
\skey{raw object identifier}s
of the form `\ttmkey{@}{in raw object identifier}$N$' where $N$
is a natural number (non-negative integer).
Raw object identifiers of this form are assigned only to objects
that must be named in an output stream (e.g., printed output).
The first object named in an output stream is assigned the identifier
\TT{@1}, the second object named in the output stream is assigned
the identifier \TT{@2},
and so forth.  The same object may be assigned different identifiers
in different output streams.%
\footnote{A possible implementation is to give objects that
have been assigned identifiers
in an output stream a hidden system defined output
stream specific attribute (\pagref{ATTRIBUTE})
equal to the object's identifier integer.  Another implementation uses a
hash table per stream.}

There are two kinds of arrows: single and double.

A \key{single arrow} is an arrow from an object to either another object
or to an atom.  The arrow has a label, which is a
sequence of symbols and natural numbers.

A \key{double arrow} is a double headed arrow between two objects.
It has a separate label for each direction, with each label being a
sequence of symbols and natural numbers.
A double arrow is equivalent to a
\underline{related pair}
of single arrows going in opposite directions between the same two objects.
The difference between a double arrow and a pair of single arrows is that
it is possible to delete only one direction of a pair of single arrows, but 
when deleting a double arrow, both directions are deleted.

An \key{arrow label} is an atom that encodes a {\em name} (\pagref{NAME})
or a single {\em natural-index} (\pagref{NATURAL-INDEX}).
If the former, the atom is either
a single symbol, or is a label with 2 or more elements, the first of
which is a symbol, and the remainder of which are either symbols or
natural indices.

Two arrows leaving the same object may have the same label.  Thus
an object and an arrow label together name
a set of arrows sourced at the object.
We say that the object and label together specify a set of values,
each of which is an atom or an object.

\ikey{Arrow flags}{arrow flag} may be attached to arrow labels.
More precisely, a set of arrow flags is defined for each object
and each arrow label, and these flags apply to all arrows sourced at the
object that have the given label.
The standard flags are the \key{dot flag} (\ttmkey{.}{dot flag}),
and the \key{maybe flag} (\ttmkey{?}{maybe flag}).
Arrows with a dot flagged label are not to be output when their source
is output.
Targets of arrows with a maybe flagged label may be garbage collected
(made to disappear automatically, see \secref{GARBAGE-COLLECTION})
if they cannot be reached without traversing an arrow whose label
has a maybe flag.

We will give examples in the next section along with a basic way of
representing sets of objects in text.  In the rest of this document
arrows are called \skey{attribute}s,\label{ATTRIBUTE} arrow labels are called
\skey{attribute label}s, arrow flags are called \skey{attribute flag}s,
and arrow targets are called \skey{attribute value}s.
Also `\ikey{attribute L of object O}{attribute!of an object}\,'
denotes the set of all values (arrow targets) of attributes
of object O (arrows sourced at O) which have the attribute label
(arrow label) L.

A double arrow is called a \key{double attribute}.  When viewed from
an object at one end of the double arrow, the double arrow is an
attribute of that object, the label of the arrow directed away from that object
is the \mkey{attribute label}{of double attribute} of the double attribute,
the object at the other end is the \mkey{attribute value}{of double attribute}
of the double attribute,
and the label of the arrow directed toward the object is the
\mkey{reverse attribute label}{of double attribute} of the double attribute.

For a given object, an attribute label may label both single and double
arrows.  A distinction is made between the set of values of the single
arrows, and the set of values of the double arrows.  The values of double
arrows, of course, must all be objects, while the values of the single
arrows may be either objects or atoms.


\subsection{Object Representations}
\label{RAW-OBJECT-REPRESENTATIONS}

A set of objects can be written to a text file or read from a text file.
When this is done, a textual representation of the object set exists
in the file.  The most basic representation of an object
is the \key{object representation}, which we now describe.

There are two kinds of object representation:
raw and cooked.
When object representations are written to a file,
\skey{raw object representation}s
are used.  Reading raw object representations
makes minimal use of the parser: brackets are recognized , but operators
are not.  When a person types object representations into a file,
they can also use raw representations if they want to.

But when a person types a textual representation into a file,
the person
may decide to use cooked representations.  When these are input
operators are recognized when used in object vector elements.

TBD: vector elements

A {\em object-representation} is a logical line beginning
with a {\em represented-object-identifier}
lexeme, which consists of either `\TT{@}'
or `\TT{!@}', followed by digits.  Use of `\TT{!@}' turns operator and
text parsing off and makes the representation `\key{raw}'.  The use
of just `\TT{@}' instead leaves operator and text parsing on and makes the
representation `\key{cooked}'.  Bracket parsing is on in either case.

\begin{indpar}[0.5em]
\begin{tabular}{l}
\emkey{object-representation}
\\\hspace*{0.5in}
	\begin{tabular}[t]{rl}
        := {\em bll} & {\em represented-object-identifier} ~
	               {\em object-assignment-operator} \\
		     & {\em object-element}\STAR{} \\
	             & \{ \TT{::} {\em bip} ~
		          \{ {\em bll} {\em attribute-representation}
			     {\em ell} \}\STAR{} ~
			  {\em eip} \}\QMARK{} ~ {\em ell} \\
        := {\em bll} & {\em represented-object-identifier} ~ \TT{=} ~
		       {\em object-element} ~ {\em ell} \\
        \end{tabular}
\end{tabular}

\begin{tabular}{l}
\emlkey{represented}{-object-identifier} :::=
    {\em raw-object-identifier} $|$ {\em cooked-object-identifier} \\
\emkey{raw-object-identifier} :::= \TT{!} {\em object-identifier} \\
\emkey{cooked-object-identifier} :::= {\em object-identifier} \\
\emkey{object-identifier} :::=
	\ttmkey{@}{in {\em object-identifier}}
	{\em digit}\PLUS{} \\
\end{tabular}

\begin{tabular}{l}
\emkey{object-assignment-operator} ::= ~~~
	\ttmkey{=}{object assignment operator} $|$
	\ttmkey{=>}{object assignment operator} $|$
	\ttmkey{=>{}>}{object assignment operator}
\end{tabular}

\begin{tabular}{l}
\emkey{object-element}\label{OBJECT-ELEMENT}
    ::= {\em object-identifier} $|$ {\em atom-name} $|$ {\em bracketed-list} \\
\emkey{atom-name}\label{ATOM-NAME}
    ::= {\em word} $|$ {\em quoted-string}
		   $|$ {\em number-name} $|$ {\em bracketed-label} \\
\emkey{number-name} \begin{tabular}[t]{rl}
    ::= & {\em integer} $|$ {\em fraction} $|$
          {\em scientific-number} \\
    $|$ & {\em radix-number} $|$ {\em date} $|$ {\em time}
    \end{tabular} \\
\emkey{bracketed-label}
    ::= \TT{\{*}~~{\em atom-name}\STAR{}~~\TT{*\}} \\
\emkey{bracketed-list} ::= see \pagref{BRACKETED-LIST} \\
\end{tabular}

\begin{tabular}{l}
\emkey{attribute-representation}\label{ATTRIBUTE-REPRESENTATION}
    \begin{tabular}[t]{rl}
    ::= & {\em single-attribute-representation} \\
    $|$ & {\em double-attribute-representation} \\
    \end{tabular}
\end{tabular}

\begin{tabular}{l}
\emlkey{single-attribute}{-representation}%
\label{SINGLE-ATTRIBUTE-REPRESENTATION}
\\\hspace*{0.5in}
    \begin{tabular}[t]{rl}
    ::= & {\em single-attribute-label}
	  \begin{tabular}[t]{l}
	  {\em attribute-label-flags}\QMARK{} ~
	  \TT{=} ~
	  {\em single-attribute-values}
	  \end{tabular} \\
    $|$ & {\em single-attribute-label} \\
    $|$ & \TT{no} {\em single-attribute-label} \\
    \end{tabular}
\end{tabular}

\begin{tabular}{l}
\emkey{single-attribute-label}\label{SINGLE-ATTRIBUTE-LABEL}
    ::= {\em name}\pagnote{NAME} $|$ {\em natural-index}\pagnote{NATURAL-INDEX}
\end{tabular}

\begin{tabular}{l}
\emkey{attribute-label-flags} ::=
    \TT{[} {\em flag-lexeme}\STAR{} \TT{]}
\end{tabular}%
\index{flags!attribute label}%
\index{attribute label!flags}

\begin{tabular}{l}
\emkey{flag-lexeme}
    ::= {\em word} $|$ {\em mark} $|$ \TT{.} $|$ \TT{?} $|$ \TT{!}
                   $|$ {\em quoted-string}
\end{tabular}

\begin{tabular}{l}
\emkey{single-attribute-value}\label{SINGLE-ATTRIBUTE-VALUE}
    ::= {\em atom-name}\STAR{} $|$ {\em object-identifier}
                               $|$ {\em bracketed-list} \\
\emkey{single-attribute-values}\label{SINGLE-ATTRIBUTE-VALUES}
    \begin{tabular}[t]{rl}
    ::= & {\em single-attribute-value} \\
    $|$ & \TT{\{*} {\em single-attribute-value}
          \{ \TT{,} {\em single-attribute-value} \}\STAR{} \TT{*\}}
    \end{tabular}
\end{tabular}

\begin{tabular}{l}
\emlkey{double-attribute}{-representation}%
\label{DOUBLE-ATTRIBUTE-REPRESENTATION}
    ::=
\\\hspace*{0.5in}
	{\em double-attribute-label}
	{\em attribute-label-flags}\QMARK{}
\\\hspace*{1.0in}
	\begin{tabular}[t]{@{}l@{}}
	\TT{=} {\em double-attribute-values} \\
	\TT{=} {\em reverse-attribute-label}
	       {\em attribute-label-flags}\QMARK{}
	\end{tabular}
\end{tabular}

\begin{tabular}{l}
\emkey{double-attribute-label}
    ::= {\em name}\pagnote{NAME}
        $|$ {\em natural-index}\pagnote{NATURAL-INDEX} \\
\emkey{reverse-attribute-label}
    ::= {\em name}\pagnote{NAME}
        $|$ {\em natural-index}\pagnote{NATURAL-INDEX} \\
\end{tabular}

\begin{tabular}{l}
\emkey{double-attribute-value} ::= {\em object-identifier} \\
\emkey{double-attribute-values}\label{DOUBLE-ATTRIBUTE-VALUES}
    \begin{tabular}[t]{rl}
    ::= & {\em double-attribute-value} \\
    $|$ & \TT{\{*} {\em double-attribute-value}
          \{ \TT{,} {\em double-attribute-value} \}\STAR{} \TT{*\}}
    \end{tabular}
\end{tabular}

\end{indpar}

Raw {\em object-representations} only parse the punctuation given
above plus brackets and separators.  Assuming that by custom
all brackets and separators contain a
{\em mark} or {\em separator} lexeme, it is never necessary
to quote a {\em word} in a raw {\em object-representation}.
This can be exploited by quoting just {\em marks},
{\em separators}, and {\em number} symbols when outputting
raw {\em object-representations}.

For example:

\begin{indpar}\begin{verbatim}
!@1 =::
    type = woman
    name = Jill
    husband = @2 = wife
!@2 =::
    type = man
    name = Jack
\end{verbatim}\end{indpar}

These are raw {\em object-representations} of an object pair that can
be represented pictorially as:

\begin{center}
\begin{picture}(3.0,1.5)
\put(0,0){\framebox(3.0,1.5){}}
\put(0.3,1.00){\makebox(0.8,0.3){\tt @1}}
\put(0.7,1.15){\oval(0.8,0.3)}
\put(0.5,1.00){\vector(0,-1){0.5}}
\put(0.45,0.75){\makebox(0,0)[r]{\tt type}}
\put(0.5,0.4){\makebox(0,0){\tt woman}}
\put(0.9,1.00){\vector(0,-1){0.7}}
\put(0.95,0.55){\makebox(0,0)[l]{\tt name}}
\put(0.9,0.2){\makebox(0,0){\tt Jill}}
\put(1.9,1.00){\makebox(0.8,0.3){\tt @2}}
\put(2.3,1.15){\oval(0.8,0.3)}
\put(2.1,1.00){\vector(0,-1){0.5}}
\put(2.05,0.75){\makebox(0,0)[r]{\tt type}}
\put(2.1,0.4){\makebox(0,0){\tt man}}
\put(2.5,1.00){\vector(0,-1){0.7}}
\put(2.55,0.55){\makebox(0,0)[l]{\tt name}}
\put(2.5,0.2){\makebox(0,0){\tt Jack}}
\put(1.1,1.17){\vector(1,0){0.8}}
\put(1.9,1.13){\vector(-1,0){0.8}}
\put(1.5,1.15){\oval(0.07,0.12)}
\put(1.5,1.30){\makebox(0,0){\tt husband}}
\put(1.5,1.00){\makebox(0,0){\tt wife}}
\end{picture}
\end{center}

There are two single attributes of object \TT{@1} (arrows sourced
at \TT{@1}),
one attribute labeled \TT{type} whose value (target) is the atom \TT{woman},
and one attribute labeled \TT{name} whose value is the atom \TT{Jill}.
There are two similar single attributes from object \TT{@2}.
There is a double attribute (double arrow)
between the two objects which has the
label \TT{husband} when going from \TT{@1} to \TT{@2}
and the label \TT{wife} when going in the reverse direction.

It is possible to place \skey{attribute flag}s on attribute labels
by putting flag characters in a {\em flag-lexeme} inside
\TT{[ ]} brackets after a label.
It may be necessary to use a
{\em quoted-string} {\em flag-lexeme} in order to include
separator characters or digits as flag characters.
The following is the same as the above example except that flags
have been added to some of the attributes:

\begin{center}
\begin{tabular}[b]{@{}l@{}}
\verb/!@1 =::/\\
\verb|    type = woman|\\
\verb|    name[-] = Jill|\\
\verb|    husband[*] = @2 = wife[@]|\\
\verb/!@2 =::/\\
\verb|    type = man|\\
\verb|    name[+] = Jack|\\
\end{tabular}
~~~~~~~
\begin{picture}(3.2,1.5)
\put(0,0){\framebox(3.2,1.5){}}
\put(0.3,1.00){\makebox(0.8,0.3){\tt @1}}
\put(0.7,1.15){\oval(0.8,0.3)}
\put(0.5,1.00){\vector(0,-1){0.5}}
\put(0.45,0.75){\makebox(0,0)[r]{\tt type}}
\put(0.5,0.4){\makebox(0,0){\tt woman}}
\put(0.9,1.00){\vector(0,-1){0.7}}
\put(0.95,0.55){\makebox(0,0)[l]{{\tt name}$^{\mbox{\tt -}}$}}
\put(0.9,0.2){\makebox(0,0){\tt Jill}}
\put(1.9,1.00){\makebox(0.8,0.3){\tt @2}}
\put(2.3,1.15){\oval(0.8,0.3)}
\put(2.1,1.00){\vector(0,-1){0.5}}
\put(2.05,0.75){\makebox(0,0)[r]{\tt type}}
\put(2.1,0.4){\makebox(0,0){\tt man}}
\put(2.5,1.00){\vector(0,-1){0.7}}
\put(2.55,0.55){\makebox(0,0)[l]{{\tt name}$^{\mbox{\tt +}}$}}
\put(2.5,0.2){\makebox(0,0){\tt Jack}}
\put(1.1,1.17){\vector(1,0){0.8}}
\put(1.9,1.13){\vector(-1,0){0.8}}
\put(1.5,1.15){\oval(0.07,0.12)}
\put(1.5,1.30){\makebox(0,0){{\tt husband}$^{\mbox{\tt *}}$}}
\put(1.5,1.00){\makebox(0,0){{\tt wife}$^{\mbox{\tt @}}$}}
\end{picture}
\end{center}

In the picture the attribute flags have been added as superscripts on the
attribute labels, and in the text the flags have been added
inside \TT{[ ]} brackets that follow attribute labels.

Several attributes of the same object (arrows sourced at the object)
may have the same attribute
label.  An example of this, in which object \TT{@1} has two
attributes labeled \TT{child}, is:

\begin{center}
\begin{tabular}{l@{\hspace*{0.5in}}l}
\begin{tabular}{@{}l@{}}
\\[-20ex]
\verb/!@1 =::/\\
\verb|    child = @2 = parent|\\
\verb|    child = @3 = parent|\\[1ex]
or\\[1ex]
\verb/!@1 =::/\\
\verb|    child = {* @2, @3 *}|\\
\verb|          = parent|\\
\end{tabular}
&
\begin{picture}(3.1,1.5)
\put(0,0){\framebox(3.1,1.5){}}
\put(0.3,1.00){\makebox(2.4,0.3){\tt @1}}
\put(1.5,1.15){\oval(2.4,0.3)}
\put(0.65,1.00){\vector(0,-1){0.6}}
\put(0.60,0.80){\makebox(0,0)[r]{\tt child}}
\put(0.75,0.40){\vector(0,1){0.6}}
\put(0.80,0.55){\makebox(0,0)[l]{\tt parent}}
\put(2.25,1.00){\vector(0,-1){0.6}}
\put(2.20,0.80){\makebox(0,0)[r]{\tt child}}
\put(2.35,0.40){\vector(0,1){0.6}}
\put(2.40,0.55){\makebox(0,0)[l]{\tt parent}}
\put(0.3,0.10){\makebox(0.8,0.3){\tt @2}}
\put(0.7,0.25){\oval(0.8,0.3)}
\put(1.9,0.10){\makebox(0.8,0.3){\tt @3}}
\put(2.3,0.25){\oval(0.8,0.3)}
\end{picture}
\end{tabular}
\end{center}

We say that the value of the \TT{child} attribute of \TT{@1} is
the set to two elements, \TT{@2} and \TT{@3}.

The differences between \TT{=}, \TT{=>}, and \TT{=>{}>} in a
{\em object-representation} relate
to what is done when an object or attribute label previously exists.

\ttmkey{=}{in {\em object-representation}}
indicates that the object being represented should not previously
exist, or if it does exist, must not have been defined by any previous
{\em object-representation} (it may have been defined as the value of an
attribute).  Second, any attribute label represented in the
{\em object-representation}, if it previously exists because it was part of a
{\em double-attribute-representation} of another {\em object-representation},
must be represented with exactly the same flags as it already has.

At the other extreme,
\ttmkey{=>{}>}{in {\em object-representation}}
adds to existing objects.
The object being represented can previously exist.  Any attribute
representation in the {\em object-representation} creates a new attribute value
to be added to the set of values of the given attribute label (which
is created if it did not previously exist).
Any flags on an attribute label are added to the flags of the label if
that label already exists.

\ttmkey{=>}{in {\em object-representation}}
is like \TT{=>{}>}
except that the {\em object-representation} cannot
add new values to previously existing attributes of the object being
represented.
More precisely, the {\em attribute-label} of any
{\em attribute-representation}
in the {\em object-representation} must not have previously (before the
{\em object-representa\-tion} is read)
been an {\em attribute-label} of the represented object.
Thus \TT{=>} is used to introduce new attributes to an existing object.

However, if \TT{=>} is used to add a double attribute to
object $O1$ whose value is object $O2$, then while
the {\em double-attribute-label}
of the added attribute must \underline{not} have previously existed for $O1$,
the {\em reverse-attribute-label} \underline{may} have previously existed
for $O2$.

Double attributes must have only one representation.  If they
are given two representations, one for each end of the attribute
(double headed arrow),
\underline{two} identical double attributes (two double headed arrows with the
same end points and labels) will be created.
Usually one end of a double attribute is
thought of as the primary end, and its object representation is used to
include the sole representation of the double attribute.

The {\em object-identifier} \ttkey{@0} is special; it always names
a particular object, the \ttnbdkey{GLOBAL} object,
whose attributes are called \skey{global variables}.  One of the global
variables is named \TT{.GLOBAL} and has as its value the \TT{.GLOBAL}
object itself, a situation which can be achieved by the
{\em object-representation}:

\begin{indpar}\begin{verbatim}
!@0 =>::
    .GLOBAL = @0
\end{verbatim}\end{indpar}

Labels beginning with `\ttkey{.}' are reserved for use by
the RECKON system, and should not be defined by RECKON users.  \TT{.GLOBAL}
is an example of such a label.

An {\em attribute-value} that is a sequence of two or more {\em atom-names}
abbreviates a single {\em bracketed-label} atom that can be otherwise
represented by placing the {\em atom-names} in \TT{\{*~*\}} brackets.  Thus the
{\em attribute-representations}
\begin{center}
\TT{X = "\{" "["} ~~~~~~~~~~ and ~~~~~~~~~~ \TT{X = \{* "\{" "[" *\}}
\end{center}
are equivalent.  However, an {\em attribute-value} consisting of just
one {\em atom-name} consists of just the named atom.

{\em Attribute-labels}, which are {\em names}, are also sequences
of {\em atom-names}, and also represent label atoms if there are two
or more {\em atom-names} in the label.  If there is just one {\em atom-name},
the label is the named atom.  However, names
cannot contain {\em bracketed-labels},
so
\begin{center}
\TT{X Y = 1} ~~~~~~~~~~ \underline{cannot} be rewritten as ~~~~~~~~~~
         \TT{\{* X Y *\} = 1}
\end{center}

An attribute may have a single value, or a set of two or more
values.  In the latter case, the values are written separated by
commas (\TT{,}) and surrounded by \TT{\{*~*\}} brackets (the same
as are used to surround the {\em atom-names} of several element label atoms).
Thus
\begin{center}
\tt
\begin{tabular}{l}
!@83 =>:: \\
~~~~X = Y 1 \\
!@83 =>:: \\
~~~~X = Y 2 \\
\end{tabular}
~~~~{\rm can be rewritten as}~~~~
\begin{tabular}{l}
!@83 =>:: \\
~~~~X = \{* Y 1, Y 2 *\} \\
\end{tabular}
\end{center}

A {\em single-attribute-representation} of the form `\TT{X = true}'
can be abbreviated as just `\TT{X}', while one of the form
`\TT{X = false}' can be abbreviated as just `\TT{no X}'.  Thus
\begin{center}
\tt
\begin{tabular}{l}
@49 =>:: \\
~~~~X = true \\
~~~~Y = false \\
\end{tabular}
~~~~{\rm can be rewritten as}~~~~
\begin{tabular}{l}
@49 =>:: \\
~~~~X \\
~~~~no Y \\
\end{tabular}
\end{center}

The RECKON parser (\secref{PARSING}) parses {\em object-representations}.
However, within {\em object-representa\-tions} that begin with
\TT{@} the parser only recognizes brackets and separators, and does
not recognize operators, number units, formats, sentence and phrase
terminators, etc.\label{RAW-PARSING}  The parser does recognize
lists as described in the next sections.  In order to ensure that
the parser does not mistakenly recognize {\em separators} and {\em marks}
as delimiting lists,
both {\em separators} and {\em marks} must be quoted as per \TT{"} when
they are used in {\em atom-names}.

\subsection{Lists}

Objects are implemented so that attributes whose labels are small
strictly positive integers can be accessed with more efficiency
than other attributes.  If an object has attributes with consecutive
labels from \TT{1} to $N$, with no gaps,
then these values are said to form a \key{list} that is represented
by the object.  An example is

\begin{indpar}\begin{verbatim}
!@93 =::
    1 = this
    2 = is
    3 = a
    4 = sentence
    .type = s
    .initiator = "`"
    .terminator = "'"
    capitalize = true
    end mark = "."
\end{verbatim}\end{indpar}

which represents the list
\begin{indpar}
\verb|this is a sentence|
\end{indpar}

but also has some additional attributes, labeled \TT{.type},
\TT{.initiator}, \TT{.terminator},
\TT{cap\-it\-al\-ize}, and \TT{end mark}.

An alternative raw {\em object-representation}
to the one just given is:

\begin{indpar}\begin{verbatim}
!@93 = this is a sentence::
    .type = s
    .initiator = "`"
    .terminator = "'"
    capitalize = true
    end mark = "."
\end{verbatim}\end{indpar}

The {\em object-elements} just after the {\em object-assignment-operator}
in an {\em object-representation} specify
values of the attributes labeled \TT{1}, \TT{2},
\TT{3}, \ldots.  In this case the attributes labeled
\TT{1}, \TT{2}, \TT{3}, and \TT{4} are given respectively the
atoms denoted by the {\em atom-names} `\TT{this}', `\TT{is}',
`\TT{a}', and `\TT{sentence}'.  Additional attribute values can be given by
following the {\em object-list} by a line ending `\TT{::}' that begins an
{\em attribute-representation-subparagraph}, which in this case
gives values to the \TT{.type}, \TT{.initiator}, \TT{.terminator},
\TT{capitalize}, and \TT{end mark} attributes.

Another alternative raw representation to the ones just
given is:

\begin{indpar}\begin{verbatim}
!@93 = `{s} this is a sentence'::
    capitalize = true
    end mark = "."
\end{verbatim}\end{indpar}

This works because bracket parsing, explained in the next section,
is turned on within a raw {\em object-representation}, and parses
the \TT{`~~'} quotes and `\TT{s}' prefix separator to produce the
\TT{.initiator}, \TT{.terminator}, and \TT{.type} attributes.

An alternative \underline{cooked} representation to the ones just
given is:

\begin{indpar}\begin{verbatim}
@93 = `This is a sentence.'
\end{verbatim}\end{indpar}

The absence of an initial `\TT{!}' and the presence of the \TT{`~'}
quotes turns text parsing on, and this
computes the `\TT{type}', `\TT{capitalize}', and `\TT{end mark}' attributes.

Notice that the second form of object representation
\begin{center}
{\em bll} ~ {\em represented-object-identifier} ~ \TT{=} ~
	    {\em object-element} ~ {\em ell} \\
\end{center}

is ambiguous with the first form which permits multi-element lists
and extra attributes.  The second is always preferred when it applies,
and simply assigns the object identifier to the {\em object-element}.
The first form, were it applied, would assign the identifier to a list
whose single element is the {\em object-element}.

Thus

\begin{indpar}\begin{verbatim}
!@93 = (X Y Z)::
    weight = 55
\end{verbatim}\end{indpar}

means

\begin{indpar}\begin{verbatim}
!@93 =::
    1 = X
    2 = Y
    3 = Z
    .initiator = "("
    .terminator = ")"
    weight = 55
\end{verbatim}\end{indpar}

and does \underline{not} mean

\begin{indpar}\begin{verbatim}
!@93 =::
    1 = @94
    weight = 55
!@94 =::
    1 = X
    2 = Y
    3 = Z
    .initiator = "("
    .terminator = ")"
\end{verbatim}\end{indpar}

Similarly

\begin{indpar}\begin{verbatim}
!@93 = "this is a"
       " long symbol with spaces in it"
\end{verbatim}\end{indpar}

means that \TT{@93} identifies not an object, but a symbol
atom, and

\begin{indpar}\begin{verbatim}
!@93 = @94
\end{verbatim}\end{indpar}

means that \TT{@93} is an alternative designation for whatever
\TT{@94} designates.

Also
\begin{indpar}\begin{verbatim}
!@93 = X
\end{verbatim}\end{indpar}

assigns the identifier \TT{@93} to the symbol \TT{X}, but

\begin{indpar}\begin{verbatim}
!@93 = X::
    Y = 5
\end{verbatim}\end{indpar}

means

\begin{indpar}\begin{verbatim}
!@93 =::
    1 = X
    Y = 5
\end{verbatim}\end{indpar}

which has a single element list.

Note that single element lists can be represented using \TT{\{|~|\}}
as described in the next section.  For example,

\begin{indpar}\begin{verbatim}
!@93 = {| X |}
\end{verbatim}\end{indpar}

means

\begin{indpar}\begin{verbatim}
!@93 =::
    1 = X
\end{verbatim}\end{indpar}

It is also true that calling

\begin{indpar}\begin{verbatim}
!@93 = X
\end{verbatim}\end{indpar}

an \underline{object} representation is a misnomer, as its
really an atom representation.

\subsection{Bracket Parsing}
\label{BRACKET-PARSING}

A {\em bracketed-list} represents an object in its own right,
with the brackets typically
becoming the \TT{.initia\-tor} and \TT{.termina\-tor}
attributes of the object, and the elements between the brackets
becoming the list elements of the object.

If operator, text, suffix,
and units parsing are enabled, they operate on the elements of each
separate list, after {\em bracketed-lists} have been parsed.
In raw {\em object-representations}, operator, text, suffix, and
units parsing are disabled, while in cooked {\em object-representations},
they are enabled.  In any case, parsing {\em bracketed-lists} is done
first before any other kind of parsing.

The syntax of a {\em bracketed-list} is:

\begin{indpar}[0.5in]

\emkey{bracketed-list}\label{BRACKETED-LIST} ::= \\
\hspace*{0.5in}
    \begin{tabular}[t]{rl@{\hspace*{1in}}cl}
        & \TT{(} {\em prefix-0-list} \TT{)} &
    $|$ & \TT{`} {\em prefix-0-list} \TT{'} \\
    $|$ & \TT{[} {\em prefix-0-list} \TT{]} &
    $|$ & \TT{`{}`} {\em prefix-0-list} \TT{'{}'} \\
    $|$ & \TT{[[} {\em prefix-0-list} \TT{]]} &
    $|$ & \TT{`{}`{}`} {\em prefix-0-list} \TT{'{}'{}'} \\
    $|$ & \TT{\{|} {\em prefix-0-list} \TT{|\}} &
    $|$ & \TT{\{(} {\em prefix-0-list} \TT{)\}} \\
    $|$ & \TT{\{[} {\em prefix-0-list} \TT{]\}} &
    $|$ & \TT{\{\{} {\em prefix-0-list} \TT{\}\}} \\
    $|$ & \TT{\{`} {\em prefix-0-list} \TT{'\}} &
    $|$ & \TT{\{:} {\em prefix-0-list} \TT{:\}} \\
    $|$ & \TT{\{!} {\em prefix-0-list} \TT{!\}} &
    $|$ & \TT{\{?} {\em prefix-0-list} \TT{?\}} \\
    $|$ & \multicolumn{3}{l}{\TT{\{} {\em mark-type} {\em prefix-0-list}
                               {\em reflected-mark-type} \TT{\}}} \\
    $|$ & \multicolumn{3}{l}{\TT{\{} {\em name-type} {\em attributes}\QMARK{}
          \TT{|} {\em prefix-0-list}
          \TT{|\}}} \\
    $|$ & \multicolumn{3}{l}{\TT{\{} {\em name-type} {\em attributes}\QMARK{}
          \TT{||\}}} \\
    $|$ & \multicolumn{3}{l}{\TT{\{|} {\em prefix-0-list}
          \TT{|} {\em name-type} {\em attributes}\QMARK{} \TT{\}}} \\
    $|$ & \multicolumn{3}{l}{\TT{\{||} {\em name-type}
          {\em attributes}\QMARK{} \TT{\}}} \\
    $|$ & \multicolumn{3}{l}{\TT{\{} {\em name-type} {\em attributes}\QMARK{}
          \TT{| } {\em prefix-0-list}
          \TT{|} {\em name-type} {\em attributes}\QMARK{} \TT{\}}} \\
    $|$ & \TT{\{\}} \\
    \end{tabular}

In the above: \begin{tabular}[t]{l}
               `\TT{||}' may be used to abbreviate `\TT{|~|}'
		(two separate `\TT{|}'s) \\
              \TT{\{\}} may be used to abbreviate \TT{\{||\}}
	        (the empty list: see below)
	      \end{tabular}

\emkey{mark-type} ::= {\em mark} \\
\emkey{reflected-mark-type} ::= reflection of the matching {\em mark-type}
                             [see text]

\emkey{name-type} ::= {\em name}\pagnote{NAME}

\emkey{type} ::= {\em mark-type} $|$ {\em name-type}

\emkey{list-opening}
    \begin{tabular}[t]{rl}
    ::= & \TT{(} $|$ \TT{[} $|$ \TT{[[} $|$
          \TT{`} $|$\TT{`{}`} $|$ \TT{`{}`{}`} $|$
	  \TT{\{|} $|$
          \TT{\{`} $|$ \TT{\{:} $|$ \TT{\{!} $|$ \TT{\{?} $|$
	  \TT{\{(} $|$ \TT{\{[} $|$ \TT{\{\{} \\
    $|$ & \TT{\{} {\em mark-type} \\
    $|$ & \TT{\{} {\em name-type} {\em attributes}\QMARK{} \TT{|} \\
    \end{tabular}

\emkey{list-closing}
    \begin{tabular}[t]{rl}
    ::= & \TT{)} $|$ \TT{]} $|$ \TT{]]} $|$
          \TT{'} $|$\TT{'{}'} $|$  \TT{'{}'{}'} $|$
	  \TT{|\}} $|$
          \TT{'\}} $|$ \TT{:\}} $|$ \TT{!\}} $|$ \TT{?\}} $|$
	  \TT{)\}} $|$ \TT{]\}} $|$ \TT{\}\}} \\
    $|$ & {\em reflected-mark-type} \TT{\}} \\
    $|$ & \TT{|} {\em name-type} {\em attributes}\QMARK{} \TT{\}} \\
    \end{tabular}

\emkey{prefix-n-list}
    ::= \{ {\em prefix-n} {\em prefix-n+1-list} \}\STAR{}
    $|$ {\em simple-list}

\emkey{prefix-n} ::= {\em prefix}

\emkey{prefix}\label{PREFIX}
    ::= \TT{\{} {\em mark-type} \TT{\}}
    $|$ \TT{\{} {\em name-type} {\em attributes}\QMARK{} \TT{\}}

\begin{center}
All {\em prefix-n}'s in a {\em prefix-n-list} have the same type.
\end{center}

\emkey{simple-list} ::= {\em object-element}\STAR{} \\
\emkey{object-element} ::= see \pagref{OBJECT-ELEMENT}

\emkey{attributes}
    \begin{tabular}[t]{rl}
    ::= & \TT{:} {\em attribute-representation}
                 \{ \TT{,} {\em attribute-representation} \}\STAR{} \\
    $|$ & \TT{::} {\em bip} \{ {\em bll} {\em attribute-representation}
                  {\em ell} \}\STAR{} {\em eip} \\
    \end{tabular}

\emkey{attribute-representation} ::= see \pagref{ATTRIBUTE-REPRESENTATION}

\end{indpar}

{\em Bracketed-lists} containing {\em prefixes} are described
at the end of this section.  For now, we give examples of lists
that contain no {\em prefixes}.

A {\em list-closing} must match the {\em list-opening} of the last unclosed
list.  The matching {\em list-openings} and {\em list-closings} that do
\underline{not} involve {\em types} are:
\begin{center}
\begin{tabular}{l@{~~~~~matches~~~~~}l@{\hspace*{1in}}l@{~~~~~matches~~~~~}l}
\TT{(} & \TT{)} &
\TT{`} & \TT{'} \\
\TT{[} & \TT{]} &
\TT{`{}`} & \TT{'{}'} \\
\TT{[[} & \TT{]]} &
\TT{`{}`{}`} & \TT{'{}'{}'} \\
\TT{\{|} & \TT{|\}} &
\TT{\{(} & \TT{)\}} \\
\TT{\{\{} & \TT{\}\}} &
\TT{\{[} & \TT{]\}} \\
\TT{\{`} & \TT{'\}} &
\TT{\{:} & \TT{:\}} \\
\TT{\{!} & \TT{!\}} &
\TT{\{?} & \TT{?\}} \\
\end{tabular}
\end{center}

These {\em list-openings} and {\em list-closings} that do
\underline{not} involve {\em types} may \underline{not} be split
across physical lines, even though some consist of two lexemes
that may be separated by horizontal whitespace.
These {\em list-openings} and {\em list-closings} become the
\TT{.initiator} and \TT{.terminator} of the object represented
by the {\em bracketed-list}, with the exception of the \TT{\{|~|\}}
brackets, which enclose a pure list that has no attributes other
than its list elements.

Thus, for example:

\begin{center}
\tt
\begin{tabular}{p{2.5in}@{\hspace*{0.5in}}p{3.0in}}
\begin{tabular}[t]{l}
!@53 = \{| X Y Z |\} \\[1ex]
\multicolumn{1}{c}{\rm is equivalent to} \\[1ex]
!@53 =:: \\
~~~~1 = X \\
~~~~2 = Y \\
~~~~3 = Z \\
\end{tabular}
&
\begin{tabular}[t]{l}
!@53 = `{}`X Y Z'{}' \\[1ex]
\multicolumn{1}{c}{\rm is equivalent to} \\[1ex]
!@53 =:: \\
~~~~1 = X \\
~~~~2 = Y \\
~~~~3 = Z \\
~~~~.initiator = "`" "`" \\
~~~~.terminator = "'" "'" \\
\end{tabular}
\end{tabular}

\bigskip
\bigskip

\begin{tabular}{p{2.5in}@{\hspace*{0.5in}}p{3.0in}}
\begin{tabular}[t]{l}
!@53 = ( X Y Z ) \\[1ex]
\multicolumn{1}{c}{\rm is equivalent to} \\[1ex]
!@53 =:: \\
~~~~1 = X \\
~~~~2 = Y \\
~~~~3 = Z \\
~~~~.initiator = "(" \\
~~~~.terminator = ")" \\
\end{tabular}
&
\begin{tabular}[t]{l}
!@53 = \{\{X Y Z\}\} \\[1ex]
\multicolumn{1}{c}{\rm is equivalent to} \\[1ex]
!@53 =:: \\
~~~~1 = X \\
~~~~2 = Y \\
~~~~3 = Z \\
~~~~.initiator = "\{" "\{" \\
~~~~.terminator = "\}" "\}" \\
\end{tabular}
\end{tabular}

\bigskip
\bigskip

\begin{tabular}{p{2.5in}@{\hspace*{0.5in}}p{3.0in}}
\begin{tabular}[t]{l}
!@53 = `X Y Z' \\[1ex]
\multicolumn{1}{c}{\rm is equivalent to} \\[1ex]
!@53 =:: \\
~~~~1 = X \\
~~~~2 = Y \\
~~~~3 = Z \\
~~~~.initiator = "`" \\
~~~~.terminator = "'" \\
\end{tabular}
&
\begin{tabular}[t]{l}
!@53 = \{`X Y Z'\} \\[1ex]
\multicolumn{1}{c}{\rm is equivalent to} \\[1ex]
!@53 =:: \\
~~~~1 = X \\
~~~~2 = Y \\
~~~~3 = Z \\
~~~~.initiator = "\{" "`" \\
~~~~.terminator = "'" "\}" \\
\end{tabular}
\end{tabular}
\end{center}

A {\em bracketed-list} with a {\em mark-type} is similar to an untyped
{\em bracketed-list}, but the {\em mark-type} becomes the \TT{.type}
attribute of the list, and there is no \TT{.initiator} or \TT{.terminator}
attribute.  Such a {\em bracketed-list} consists of
a `\TT{\{} {\em mark-type}' list opening and a
`{\em reflected-mark-type} \TT{\}}'
list closing surrounding the list elements.
The {\em mark-type} is a {\em mark} lexeme.  The {\em reflected-mark-type}
is this same lexeme with the order of characters reveresed and the
characters \TT{<} and \TT{>} interchanged, if they occur.  If the
{\em mark-type} and {\em reflected-mark} type are identical, the
{\em mark-type} becomes the \TT{.type} attribute value for the list.
But if they are not identical, the label atom
\begin{center}
\TT{\{*} {\em mark-type} {\em reflected-mark-type} \TT{*\}}
\end{center}
becomes the \TT{.type} attribute value.

Thus we have the examples:

\begin{center}
\tt
\begin{tabular}{p{2.5in}@{\hspace*{0.5in}}p{3.0in}}
\begin{tabular}[t]{l}
!@53 = \{+ X Y Z +\} \\[1ex]
\multicolumn{1}{c}{\rm is equivalent to} \\[1ex]
!@53 =:: \\
~~~~1 = X \\
~~~~2 = Y \\
~~~~3 = Z \\
~~~~.type = "+" \\
\end{tabular}
&
\begin{tabular}[t]{l}
!@53 = \{<+ X Y Z +>\} \\[1ex]
\multicolumn{1}{c}{\rm is equivalent to} \\[1ex]
!@53 =:: \\
~~~~1 = X \\
~~~~2 = Y \\
~~~~3 = Z \\
~~~~.type = "<+" "+>" \\
\end{tabular}
\end{tabular}

\bigskip
\bigskip

\begin{tabular}{p{2.5in}@{\hspace*{0.5in}}p{3.0in}}
\begin{tabular}[t]{l}
!@53 = \{\$\$ X Y Z \$\$\} \\[1ex]
\multicolumn{1}{c}{\rm is equivalent to} \\[1ex]
!@53 =:: \\
~~~~1 = X \\
~~~~2 = Y \\
~~~~3 = Z \\
~~~~.type = "\$\$" \\
\end{tabular}
&
\begin{tabular}[t]{l}
!@53 = \{\$* X Y Z *\$\} \\[1ex]
\multicolumn{1}{c}{\rm is equivalent to} \\[1ex]
!@53 =:: \\
~~~~1 = X \\
~~~~2 = Y \\
~~~~3 = Z \\
~~~~.type = "\$*" "*\$" \\
\end{tabular}
\end{tabular}
\end{center}

{\em Bracketed-lists} with {\em named-types} but no {\em attributes}
are similar but have the syntax:
\begin{center}
\TT{\{} {\em name-type}\QMARK{} \TT{|} {\em prefix-0-list}
                                \TT{|} {\em name-type}\QMARK{} \TT{\}}
\end{center}
where the {\em name-type} must not be completely omitted, and if
given twice, must be identical in both instances.
Examples are:

\begin{center}
\tt
\begin{tabular}{p{2.5in}@{\hspace*{0.5in}}p{3.0in}}
\begin{tabular}[t]{l}
!@53 = \{T| X Y Z |\} \\[1ex]
\multicolumn{1}{c}{\rm is equivalent to} \\[1ex]
!@53 =:: \\
~~~~1 = X \\
~~~~2 = Y \\
~~~~3 = Z \\
~~~~.type = T \\
\end{tabular}
&
\begin{tabular}[t]{l}
!@53 = \{T| X Y Z |T\} \\[1ex]
\multicolumn{1}{c}{\rm is equivalent to} \\[1ex]
!@53 =:: \\
~~~~1 = X \\
~~~~2 = Y \\
~~~~3 = Z \\
~~~~.type = T \\
\end{tabular}
\end{tabular}

\bigskip
\bigskip

\begin{tabular}{p{2.5in}@{\hspace*{0.5in}}p{3.0in}}
\begin{tabular}[t]{l}
!@53 = \{| X Y Z |T\} \\[1ex]
\multicolumn{1}{c}{\rm is equivalent to} \\[1ex]
!@53 =:: \\
~~~~1 = X \\
~~~~2 = Y \\
~~~~3 = Z \\
~~~~.type = T \\
\end{tabular}
&
\begin{tabular}[t]{l}
!@53 = \{"*" 1| X Y Z |\} \\[1ex]
\multicolumn{1}{c}{\rm is equivalent to} \\[1ex]
!@53 =:: \\
~~~~1 = X \\
~~~~2 = Y \\
~~~~3 = Z \\
~~~~.type = "*" 1 \\
\end{tabular}
\end{tabular}
\end{center}

{\em Bracketed-lists} with {\em named-types} can have {\em attributes}.
These are either comma separated {\em attribute-representations}
placed after a \TT{:} following the {\em name-type}, or
{\em attribute-representations} on one logical line each in an indented
paragraph introduced by a physical line ending \TT{::} placed just
after the {\em name-type}.  So, for example:
\begin{center}
\tt
\begin{tabular}{l}
!@27 = X Y Z:: \\
~~~~.type = T \\
~~~~J = 1 \\
~~~~K = B 1 \\
~~~~L = \{* 1, B 1 *\} \\
\end{tabular}
\begin{tabular}{c}
\rm is \\
\rm equivalent \\
\rm to
\end{tabular}
\begin{tabular}{l}
!@27 = \{| X Y Z | T:: \\
~~~~~~~~~~~~J = 1 \\
~~~~~~~~~~~~K = B 1 \\
~~~~~~~~~~~~L = \{* 1, B 1 *\} \\
~~~~~~~|\} \\
\end{tabular}
\\[1ex]
{\rm is equivalent to}
\\[1ex]
!@27 = \{| X Y Z | T: J = 1, K = B 1, L = \{* 1, B 1 *\} \}
\\[1ex]
{\rm is equivalent to}
\\[1ex]
!@27 = \{ T: J = 1, K = B 1, L = \{* 1, B 1 *\} | X Y Z |\}
\end{center}


A beginning `\TT{\{||}' is equivalent to `\TT{\{|~|}', that is, in this
case the two `\TT{|}' are treated as separate 1-character lexemes, and
the `\TT{|~|}' denotes an empty list.  Similarly `\TT{||\}}' is
equivalent to `\TT{|~|\}}' and denotes an empty list.

The brackets `\TT{\{}' and `\TT{\}}' match, even if the {\em type-names}
that follow `\TT{\{}' and preceed `\TT{\}}' fail to match.
The latter case is a type match error.

{\em Simple-lists} may be parsed after they have been read.
Operators, including
separators such as comma `\TT{,},' are recognized by such a parse.  See
\itemref{PARSING} for details.

The {\em named-type} \TT{"{}"} is specially treated as denoting a missing
\TT{.type} attribute.  Thus
\begin{center}
\tt
\begin{tabular}{l}
!@27 = X Y Z:: \\
~~~~J = 1 \\
~~~~K = B 1 \\
\end{tabular}
\begin{tabular}{c}
\rm is \\
\rm equivalent \\
\rm to
\end{tabular}
\begin{tabular}{l}
!@27 = \{| X Y Z | "":: \\
~~~~~~~~~~~~J = 1 \\
~~~~~~~~~~~~K = B 1 \\
~~~~~~~|\} \\
\end{tabular}
\end{center}

The empty list can be denoted by any of `\TT{\{""||\}}', `\TT{\{||\}}',
or the abbreviation `\TT{\{\}}'.

\subsection{Prefixes}
\label{PREFIXES}

{\em Prefixes} are an unusual kind of separator
that must appear at the beginning of the list as well as between
elements of the list, and their appearance at the beginning of the list
announces their use as a separator for the list and also establishes their
precedence relative to other {\em prefix} separators.
More explicitly, the {\em type} of the first {\em prefix-n}
in a {\em prefix-n-list}
specifies that all {\em prefixes} of that {\em type} shall be {\em prefix-n}'s,
and {\em prefixes} of other {\em types} shall not be {\em prefix-n}'s,
where {\em n} = {\em 0}, {\em 1}, {\em 2}, {\em 3}, \ldots{}
is the priority of the {\em prefix} in the sense of operator
hierarchy.

Algorithmically, during a left to right scan of a {\em prefix-0-list},
there is a stack of `\key{open list prefix types}'.  Initially we are
at the beginning of the {\em prefix-0-list} and the stack is empty.
Then:
\begin{enumerate}

\item
When a {\em prefix} of a type that is not in the stack is scanned,
and the {\em prefix} follows a {\em prefix} or is at the
beginning of the {\em prefix-0-list},
the type of the {\em prefix} is pushed into the stack, and a new sublist
of that type beginning with the {\em prefix} is started.
This sublist is a {\em prefix-n-list} where {\em n} is the depth of
the stack just before the type is pushed.

\item
When a {\em prefix} of a type that is in the stack is scanned, the
stack is popped
until the type is has been popped.  Sublists of popped types
are terminated.
The type of the {\em prefix} (which was just popped)
is pushed into the stack, and a new sublist
of that type beginning with the {\em prefix} is started.
This sublist is a {\em prefix-n-list} where {\em n} is the depth of
the stack just before the type is pushed.

\item
When a {\em prefix} of a type that is not in the stack is scanned,
and the {\em prefix} follows a non-{\em prefix},
the {\em prefix} is announced as an error and ignored as if it
did not exist.  In particular, what immediately follows the {\em prefix}
will still be treated as following a non-{\em prefix}.

\item
Each sublist is associated with a {\em prefix} that starts the
sublist.  The type and attributes of this {\em prefix} become the
type and attributes of the sublist.

\end{enumerate}


Thus we have the following example parse of a {\em prefix-0-list}:

\begin{tabular}{lll}
Text	& Separator &  Syntactic Category
\\\hline
\tt \{p\} \{s\} This is a sentence.	& \tt \{p\} & \em prefix-0-list \\
\tt ~~~ \{s\} And another. \\
\tt \{p\} \{s\} And a new \{foo\} paragraph.
\\\hline
\tt \{s\} This is a sentence.	& \tt \{s\} & \em prefix-1-list \\
\tt \{s\} And another.
\\\hline
\tt This is a sentence.	& (none) & \em prefix-2-list  \rm ::= \em simple-list
\\\hline
\tt And another. & (none) & \em prefix-2-list \rm ::= \em simple-list
\\\hline
\tt \{s\} And a new \{foo\} paragraph. & \tt \{s\} & \em prefix-1-list
\\\hline
\tt And a new \{foo\} paragraph. & (none) & \em prefix-2-list \\
			       &        & \TT{\{foo\}} is in error \\
			       &        & and is ignored (deleted).
\end{tabular}

The {\em prefix-0-list} in this example is equivalent to:
\begin{indpar}\begin{verbatim}
{|  {p|  {s| This is a sentence "." |}
         {s| And another "." |} |}
    {p|  {s| And a new paragraph "." |} |} |}
             // `{foo}' deleted
\end{verbatim}\end{indpar}

\section{Parsing}
\label{PARSING}

Input is read and parsed to form objects from {\em bracketed-lists}.
These objects are then further parsed to find operators, separators,
number units (e.g., \TT{lb} and \TT{\$}), and some other constructions
such as possessives (\TT{George's weight} become \TT{George 's weigth}).
The input to this parsing is a list of \skey{token}s, which initially are
all lexemes.  But as the parsing proceeds, bracketed lists are replaced
by tokens that are \skey{expression object}s (e.g., objects which may have
\TT{.initiators} and \TT{.terminators}), and parsing proceeds on 
a list of tokens some of which are lexemes and some of which are objects.

Parsing at this point is a top down process.  The parser is organized
into \skey{pass}{es} which are applied to the token list in order.
The first pass always handles bracketed expressions.
Then the brackets of a subexpression establish a parsing
\key{context} which determines
which subsequent passes will be run on the token list of the backeted
subexpression.  For an \key{operator expression}, the passes
handle operators, number units, and possessives.  For a
\key{text expression}, a pass handles phrases and sentences.
If a pass succeeds it may discover subexpressions, which are
parsed independently as they are discovered.

In general a pass modifies the list of tokens it is given,
both replacing sublists by expression objects and possibly
reordering the list.

The standard passes in order from first to last are:

\begin{center}
\begin{tabular}%
  {l@{\hspace*{0.3in}}l@{\hspace*{0.3in}}p{2.2in}}
\bf Parser & \bf Parsing \\
\bf Pass & \bf Context & \bf Usage \\[1ex]
\TT{suffix} & \TT{operator}
	& split suffixes from words \\
\TT{operators} & \TT{operator}
	& parse operators \\
\TT{units} & \TT{operator}
	& parse number units \\
\TT{singularize} & \TT{operator}
	& replace plurals by singulars \\
\TT{text} & \TT{text}
	& parse sentences and phrases \\
\end{tabular}
\end{center}

Which brackets select which parsing contexts is described
in Section~\itemref{PARSING-CONTEXTS}.

Tables such
as this are constructed from parsing instructions which appear
in a list called the parsing stack.  Parsing instructions can be
pushed into the stack and later popped from the stack in order
to undo their affects, and they can be disabled and re-enabled while still
in the stack.  In this document we only describe a few of the many
types of parsing instructions.

\subsection{Parsing Examples}
\label{PARSING-EXAMPLES}

{\em Prefixes}, {\em types}, and {\em attributes} are explained
below.  First we give some examples involving just parsed untyped
{\em bracketed-lists} without {\em attributes}.  In some of these
the fact is used that
`\TT{\{!~!\}}' brackets translate to a list of \TT{.type} \TT{"!"}.

As a first example,

\begin{indpar}\begin{verbatim}
@93 = `This is a sentence.'
\end{verbatim}\end{indpar}

is the cooked representation of the object

\begin{center}
\begin{tabular}[b]{@{}l@{}}
\verb/@93 =::/\\
\verb|    1 = this|\\
\verb|    2 = is|\\
\verb|    3 = a|\\
\verb|    4 = sentence|\\
\verb|    .type = s|\\
\verb|    .initiator = "`"|\\
\verb|    .terminator = "'"|\\
\verb|    capitalize = true|\\
\verb|    end mark = "."|\\
\end{tabular}
~~~~~
\begin{picture}(5.6,2.0)
\put(0,0){\framebox(5.6,2.0){}}
\put(0.2,1.50){\makebox(4.8,0.3){\tt @93}}
\put(2.6,1.65){\oval(4.8,0.3)}
\put(0.60,1.50){\vector(0,-1){0.4}}
\put(0.55,1.35){\makebox(0,0)[r]{\tt 1}}
\put(0.60,1.00){\makebox(0,0)[c]{\tt this}}
\put(0.95,1.50){\vector(0,-1){0.4}}
\put(0.90,1.35){\makebox(0,0)[r]{\tt 2}}
\put(0.95,1.00){\makebox(0,0)[c]{\tt is}}
\put(1.20,1.50){\vector(0,-1){0.4}}
\put(1.15,1.35){\makebox(0,0)[r]{\tt 3}}
\put(1.20,1.00){\makebox(0,0)[c]{\tt a}}
\put(1.70,1.50){\vector(0,-1){0.4}}
\put(1.65,1.35){\makebox(0,0)[r]{\tt 4}}
\put(1.70,1.00){\makebox(0,0)[c]{\tt sentence}}
\put(2.30,1.50){\vector(0,-1){0.6}}
\put(2.25,1.35){\makebox(0,0)[r]{\tt .type}}
\put(2.30,0.80){\makebox(0,0)[c]{\tt s}}
\put(2.60,1.50){\vector(0,-1){1.2}}
\put(2.55,0.55){\makebox(0,0)[r]{\tt .initiator}}
\put(2.60,0.20){\makebox(0,0)[c]{\tt "`"}}
\put(3.00,1.50){\vector(0,-1){1.2}}
\put(3.05,0.55){\makebox(0,0)[l]{\tt .terminator}}
\put(3.00,0.20){\makebox(0,0)[c]{\tt "'"}}
\put(4.15,1.50){\vector(0,-1){0.4}}
\put(4.10,1.35){\makebox(0,0)[r]{\tt capitalize}}
\put(4.15,1.00){\makebox(0,0)[c]{\tt true}}
\put(4.60,1.50){\vector(0,-1){0.6}}
\put(4.65,1.35){\makebox(0,0)[l]{\tt end mark}}
\put(4.60,0.80){\makebox(0,0)[c]{\tt "."}}
\end{picture}
\end{center}


The second example contains simple code:

\begin{indpar}\begin{verbatim}
@45 = {! straight 3.2; left; straight (y + 9.4) !}
\end{verbatim}\end{indpar}

is the cooked representation of the objects

\begin{center}
\begin{tabular}[b]{@{}l@{}}
\verb/@42 =::/\\
\verb|    1 = straight|\\
\verb|    2 = 3.2|\\
\verb/@43 =::/\\
\verb|    1 = "+"|\\
\verb|    2 = y|\\
\verb|    3 = 9.4|\\
\verb|    .initiator = "("|\\
\verb|    .terminator = ")"|\\
\verb/@44 =::/\\
\verb|    1 = straight|\\
\verb|    2 = @43|\\
\verb/@45 =::/\\
\verb|    1 = @42|\\
\verb|    2 = left|\\
\verb|    3 = @44|\\
\verb|    .type = "!"|\\
\verb|    .separator = ";"|\\
\end{tabular}
~~~~~
\begin{picture}(4.4,3.7)
\put(0,0){\framebox(4.4,3.7){}}
\put(1.5,0.0){
\put(0.0,0.90){\makebox(2.0,0.3){\tt @43}}
\put(1.0,1.05){\oval(2.0,0.3)}
\put(0.40,0.90){\vector(0,-1){0.4}}
\put(0.35,0.75){\makebox(0,0)[r]{\tt .initiator}}
\put(0.40,0.40){\makebox(0,0)[c]{\tt "("}}
\put(0.70,0.90){\vector(0,-1){0.6}}
\put(0.65,0.75){\makebox(0,0)[r]{\tt 1}}
\put(0.70,0.20){\makebox(0,0)[c]{\tt "+"}}
\put(1.00,0.90){\vector(0,-1){0.6}}
\put(0.95,0.75){\makebox(0,0)[r]{\tt 2}}
\put(1.00,0.20){\makebox(0,0)[c]{\tt y}}
\put(1.30,0.90){\vector(0,-1){0.6}}
\put(1.25,0.75){\makebox(0,0)[r]{\tt 3}}
\put(1.30,0.20){\makebox(0,0)[c]{\tt 9.4}}
\put(1.60,0.90){\vector(0,-1){0.4}}
\put(1.60,0.40){\makebox(0,0)[c]{\tt ")"}}
\put(1.65,0.75){\makebox(0,0)[l]{\tt .terminator}}
}
\put(0.7,1.3){
\put(0.0,0.50){\makebox(1.2,0.3){\tt @42}}
\put(0.60,0.65){\oval(1.2,0.3)}
\put(0.30,0.50){\vector(0,-1){0.3}}
\put(0.25,0.35){\makebox(0,0)[r]{\tt 1}}
\put(0.30,0.10){\makebox(0,0)[c]{\tt straight}}
\put(0.90,0.50){\vector(0,-1){0.3}}
\put(0.85,0.35){\makebox(0,0)[r]{\tt 2}}
\put(0.90,0.10){\makebox(0,0)[c]{\tt 3.2}}
}
\put(2.3,1.3){
\put(0.0,0.50){\makebox(1.2,0.3){\tt @44}}
\put(0.60,0.65){\oval(1.2,0.3)}
\put(0.30,0.50){\vector(0,-1){0.3}}
\put(0.25,0.35){\makebox(0,0)[r]{\tt 1}}
\put(0.30,0.10){\makebox(0,0)[c]{\tt straight}}
\put(0.90,0.50){\vector(0,-1){0.6}}
\put(0.85,0.35){\makebox(0,0)[r]{\tt 2}}
}
\put(0.3,2.7){
\put(0.0,0.50){\makebox(3.2,0.3){\tt @45}}
\put(1.60,0.65){\oval(3.2,0.3)}
\put(0.80,0.50){\vector(0,-1){0.3}}
\put(0.75,0.35){\makebox(0,0)[r]{\tt .type}}
\put(0.80,0.10){\makebox(0,0)[c]{\TT{"!"}}}
\put(1.30,0.50){\vector(0,-1){1.1}}
\put(1.25,0.35){\makebox(0,0)[r]{\tt 1}}
\put(1.70,0.50){\vector(0,-1){0.4}}
\put(1.65,0.30){\makebox(0,0)[r]{\tt 2}}
\put(1.70,0.00){\makebox(0,0)[c]{\tt left}}
\put(2.30,0.50){\vector(0,-1){1.1}}
\put(2.25,0.35){\makebox(0,0)[r]{\tt 3}}
\put(2.70,0.50){\vector(0,-1){0.8}}
\put(2.75,-0.15){\makebox(0,0)[l]{\tt .separator}}
\put(2.70,-0.40){\makebox(0,0)[c]{\tt ";"}}
}
\end{picture}
\end{center}

A third example uses multiple indented lines to represent code, so that

\begin{indpar}\begin{verbatim}
@138 = {! function (x,y):

            if (x > y):
                return y
            else:
                return x
       !}
\end{verbatim}\end{indpar}

is the cooked representation of the object in
Figures~\ref{EXAMPLE-CODE-OBJECT-REPRESENTATION-1}
and~\ref{EXAMPLE-CODE-OBJECT-REPRESENTATION-2}.
Note that here the \TT{:} indentation mark is used to introduce
subparagraphs within the code,
and not {\em attribute-representations}.


\begin{boxedfigure}

\begin{center}
\begin{tabular}[t]{l@{\hspace*{1in}}l}
\begin{tabular}[t]{l}
\verb/@130 =::/\\
\verb|    1 = x|\\
\verb|    2 = y|\\
\verb|    .separator = ","|\\
\verb|    .initiator = "("|\\
\verb|    .terminator = ")"|\\
\verb/@131 =::/\\
\verb|    1 = ">"|\\
\verb|    2 = x|\\
\verb|    3 = y|\\
\verb|    .initiator = "("|\\
\verb|    .terminator = ")"|\\
\verb/@132 =::/\\
\verb|    1 = return|\\
\verb|    2 = y|\\
\verb|    .type = ":"|\\
\verb/@133 =::/\\
\verb|    1 = if|\\
\verb|    2 = @131|\\
\verb|    3 = @132|\\
\end{tabular} & \begin{tabular}[t]{l}
\verb/@134 =::/\\
\verb|    1 = return|\\
\verb|    2 = x|\\
\verb|    .type = ":"|\\
\verb/@135 =::/\\
\verb|    1 = else|\\
\verb|    2 = @134|\\
\verb/@136 =::/\\
\verb|    1 = @133|\\
\verb|    2 = @135|\\
\verb|    .type = ":"|\\
\verb|    .separator = "<*>"|\\
\verb/@137 =::/\\
\verb|    1 = function|\\
\verb|    2 = @130|\\
\verb|    3 = @136|\\
\verb|    .type = "!"|\\
\end{tabular}
\end{tabular}
\end{center}
\vspace*{-3ex}
\caption{Example Code Object Representation I}
\label{EXAMPLE-CODE-OBJECT-REPRESENTATION-1}
\end{boxedfigure}

\begin{boxedfigure}

\begin{center}
\begin{picture}(4.0,5.5)
\put(0.6,0.0){
\put(0.0,0.50){\makebox(2.0,0.3){\tt @131}}
\put(1.0,0.65){\oval(2.0,0.3)}
\put(0.25,0.50){\vector(0,-1){0.25}}
\put(0.20,0.40){\makebox(0,0)[r]{\tt .initiator}}
\put(0.25,0.15){\makebox(0,0)[c]{\tt "("}}
\put(0.70,0.50){\vector(0,-1){0.25}}
\put(0.65,0.40){\makebox(0,0)[r]{\tt 1}}
\put(0.70,0.15){\makebox(0,0)[c]{\tt ">"}}
\put(1.00,0.50){\vector(0,-1){0.25}}
\put(0.95,0.40){\makebox(0,0)[r]{\tt 2}}
\put(1.00,0.15){\makebox(0,0)[c]{\tt x}}
\put(1.30,0.50){\vector(0,-1){0.25}}
\put(1.25,0.40){\makebox(0,0)[r]{\tt 3}}
\put(1.30,0.15){\makebox(0,0)[c]{\tt y}}
\put(1.75,0.50){\vector(0,-1){0.25}}
\put(1.80,0.40){\makebox(0,0)[l]{\tt .terminator}}
\put(1.75,0.15){\makebox(0,0)[c]{\tt ")"}}
}
\put(1.4,1.4){
\put(0.0,0.50){\makebox(1.3,0.3){\tt @132}}
\put(0.65,0.65){\oval(1.3,0.3)}
\put(0.20,0.50){\vector(0,-1){0.25}}
\put(0.15,0.40){\makebox(0,0)[r]{\tt .type}}
\put(0.20,0.15){\makebox(0,0)[c]{\tt ":"}}
\put(0.70,0.50){\vector(0,-1){0.25}}
\put(0.65,0.40){\makebox(0,0)[r]{\tt 1}}
\put(0.70,0.15){\makebox(0,0)[c]{\tt return}}
\put(1.15,0.50){\vector(0,-1){0.25}}
\put(1.10,0.40){\makebox(0,0)[r]{\tt 3}}
\put(1.15,0.15){\makebox(0,0)[c]{\tt y}}
}
\put(2.9,0.7){
\put(0.0,0.50){\makebox(1.3,0.3){\tt @134}}
\put(0.65,0.65){\oval(1.3,0.3)}
\put(0.20,0.50){\vector(0,-1){0.25}}
\put(0.15,0.40){\makebox(0,0)[r]{\tt .type}}
\put(0.20,0.15){\makebox(0,0)[c]{\tt ":"}}
\put(0.70,0.50){\vector(0,-1){0.25}}
\put(0.65,0.40){\makebox(0,0)[r]{\tt 1}}
\put(0.70,0.15){\makebox(0,0)[c]{\tt return}}
\put(1.15,0.50){\vector(0,-1){0.25}}
\put(1.10,0.40){\makebox(0,0)[r]{\tt 3}}
\put(1.15,0.15){\makebox(0,0)[c]{\tt x}}
}
\put(0.2,2.0){
\put(0.0,0.50){\makebox(1.2,0.3){\tt @133}}
\put(0.60,0.65){\oval(1.2,0.3)}
\put(0.30,0.50){\vector(0,-1){0.25}}
\put(0.25,0.40){\makebox(0,0)[r]{\tt 1}}
\put(0.30,0.15){\makebox(0,0)[c]{\tt if}}
\put(0.60,0.50){\line(0,-1){0.45}}
\put(0.50,0.05){\oval(0.2,0.2)[br]}
\put(0.50,-0.05){\line(-1,0){0.40}}
\put(0.10,-0.15){\oval(0.2,0.2)[tl]}
\put(0.00,-0.15){\line(0,-1){1.10}}
\put(0.10,-1.25){\oval(0.2,0.2)[bl]}
\put(0.10,-1.35){\vector(1,0){0.30}}
\put(0.55,0.40){\makebox(0,0)[r]{\tt 2}}
\put(0.90,0.50){\line(0,-1){0.35}}
\put(1.00,0.15){\oval(0.2,0.2)[bl]}
\put(1.00,0.05){\vector(1,0){0.2}}
\put(0.85,0.40){\makebox(0,0)[r]{\tt 3}}
}
\put(2.9,2.0){
\put(0.0,0.50){\makebox(0.8,0.3){\tt @135}}
\put(0.40,0.65){\oval(0.8,0.3)}
\put(0.20,0.50){\vector(0,-1){0.25}}
\put(0.15,0.40){\makebox(0,0)[r]{\tt 1}}
\put(0.20,0.15){\makebox(0,0)[c]{\tt else}}
\put(0.60,0.50){\vector(0,-1){1.0}}
\put(0.55,0.40){\makebox(0,0)[r]{\tt 2}}
}
\put(1.5,2.4){
\put(0.05,1.00){\makebox(1.8,0.3){\tt @136}}
\put(0.95,1.15){\oval(1.8,0.3)}
\put(0.40,1.00){\vector(0,-1){0.25}}
\put(0.35,0.90){\makebox(0,0)[r]{\tt .type}}
\put(0.40,0.65){\makebox(0,0)[c]{\tt ":"}}
\put(0.70,1.00){\line(0,-1){0.65}}
\put(0.60,0.35){\oval(0.2,0.2)[br]}
\put(0.60,0.25){\vector(-1,0){0.70}}
\put(0.65,0.90){\makebox(0,0)[r]{\tt 1}}
\put(1.10,1.00){\line(0,-1){0.65}}
\put(1.20,0.35){\oval(0.2,0.2)[bl]}
\put(1.20,0.25){\vector(1,0){0.20}}
\put(1.05,0.90){\makebox(0,0)[r]{\tt 2}}
\put(1.50,1.00){\vector(0,-1){0.25}}
\put(1.55,0.90){\makebox(0,0)[l]{\tt .separator}}
\put(1.50,0.65){\makebox(0,0)[c]{\tt "<*>"}}
}
\put(0.6,3.2){
\put(0.2,1.00){\makebox(1.3,0.3){\tt @130}}
\put(0.85,1.15){\oval(1.3,0.3)}
\put(0.40,1.00){\vector(0,-1){0.25}}
\put(0.35,0.90){\makebox(0,0)[r]{\tt .initiator}}
\put(0.40,0.65){\makebox(0,0)[c]{\tt "("}}
\put(0.70,1.00){\vector(0,-1){0.25}}
\put(0.65,0.90){\makebox(0,0)[r]{\tt 1}}
\put(0.70,0.65){\makebox(0,0)[c]{\tt x}}
\put(1.00,1.00){\vector(0,-1){0.25}}
\put(0.95,0.90){\makebox(0,0)[r]{\tt 2}}
\put(1.00,0.65){\makebox(0,0)[c]{\tt y}}
\put(1.30,1.00){\vector(0,-1){0.25}}
\put(1.35,0.90){\makebox(0,0)[l]{\tt .terminator}}
\put(1.30,0.65){\makebox(0,0)[c]{\tt ")"}}
\put(1.50,1.15){\vector(1,0){1.0}}
\put(1.55,1.25){\makebox(0,0)[l]{\tt .separator}}
\put(2.55,1.15){\makebox(0,0)[l]{\tt ","}}
}
\put(0.0,4.5){
\put(0.1,0.50){\makebox(4.0,0.30){\tt @137}}
\put(1.90,0.65){\oval(4.0,0.3)}
\put(0.20,0.50){\vector(0,-1){0.25}}
\put(0.15,0.40){\makebox(0,0)[r]{\tt .type}}
\put(0.20,0.15){\makebox(0,0)[c]{\tt "!"}}
\put(0.90,0.50){\vector(0,-1){0.25}}
\put(0.85,0.40){\makebox(0,0)[r]{\tt 1}}
\put(0.90,0.15){\makebox(0,0)[c]{\tt function}}
\put(1.45,0.50){\vector(0,-1){0.5}}
\put(1.40,0.40){\makebox(0,0)[r]{\tt 2}}
\put(3.60,0.50){\line(0,-1){1.35}}
\put(3.50,-0.85){\oval(0.2,0.2)[br]}
\put(3.50,-0.95){\vector(-1,0){0.15}}
\put(3.55,0.40){\makebox(0,0)[r]{\tt 3}}
}
\end{picture}
\end{center}

\caption{Example Code Object Representation II}
\label{EXAMPLE-CODE-OBJECT-REPRESENTATION-2}
\end{boxedfigure}

\newpage

Cooked representations may replace raw object identifiers in the
description of other objects, as in

\begin{indpar}\begin{verbatim}
@291 =::
      text = `This is a sentence.'
      outline = {! straight 3.2, left, straight (y + 9.4) !}
      min = {! function (x,y):

                  if (x > y):
                      return y
                  else:
                      return x
	    !}
\end{verbatim}\end{indpar}

is the cooked representation of the object

\begin{indpar}\begin{verbatim}
@291 =::
    text = @93
    outline = @45
    min = @137
\end{verbatim}\end{indpar}

given the above examples.

One question left unanswered by the discussion so far is whether

\begin{indpar}\begin{verbatim}
@291 =::
    text A = `This is a sentence.'
    text B = `This is a sentence.'
\end{verbatim}\end{indpar}

represents

\begin{indpar}\begin{verbatim}
@291 =::
    text A = @93
    text B = @93
\end{verbatim}\end{indpar}

or instead

\begin{indpar}\begin{verbatim}
@291 =::
    text A = @93
    text B = @999
\end{verbatim}\end{indpar}

where object \TT{@999} happens to have the same structure as
object \TT{@93}.  The default is to make both \TT{text A}
and \TT{text B} be the same object, \TT{@93}, and to make
that object `immutable', meaning that it cannot be changed.  The
rule is that unless otherwise indicated, only immutable objects
have the property that their cooked representations can replace
their raw object identifiers in the cooked representations of other
objects.

\subsection{Parsing Contexts}
\label{PARSING-CONTEXTS}

During parsing both the parsing passes and definitions of parsing units such as
operators are turned on or off by manipulating a \key{parsing context},
which is just a set of \skey{parsing selector}s.\label{PARSING-SELECTORS}
Thus the passes and
definitions appropriate to text processing are turned on by the
`\TT{text}' selector, and those appropriate to code parsing are
turned on by the `\TT{code}' selector.

The parsing context can only be changed by \underline{explicit} brackets.  So,
for example, the \TT{`\ldots'} brackets always set the
parsing context to just the `\TT{text}' selector during the
parse of the \TT{`\ldots'} bracketed list.
As another example, `\TT{(\ldots)}' brackets do not change the
parsing context but instead inherit it from their containing object.

The following is a list of the standard selector-changing brackets:

\begin{center}
\begin{tabular}%
  {l@{\hspace*{0.3in}}l@{\hspace*{0.3in}}l@{\hspace*{0.3in}}p{2.2in}}
\bf Brackets & \bf Context & \bf New Context & \bf Usage \\[1ex]
\TT{\{*\ldots*\}} & all & none & comment \\
\TT{`\ldots'} & all & \TT{text} & text \\
\TT{\{!\ldots!\}} & all & \begin{tabular}[t]{@{}l@{}}
                          \TT{expression}, \\
			  \TT{code}
			  \end{tabular}
    & unevaluated code \\
\TT{\{\{\ldots\}\}} & all & \begin{tabular}[t]{@{}l@{}}
                          \TT{expression}, \\
			  \TT{math}
			  \end{tabular}
    & unevaluated math subexpression \\
\TT{[\ldots]} & \begin{tabular}[t]{@{}l@{}}
              \TT{text}, \\
	      \TT{math}
	      \end{tabular} & \TT{expression}
    & evaluated subexpression in text or math expression \\
\end{tabular}
\end{center}

According to this table, in any parsing context the \TT{\{*\ldots*\}}
brackets turn off all selectors,
the \TT{`\ldots'} brackets change
the context to have just the `\TT{text}' selector,
the \TT{\{!\ldots!\}} brackets change
the context to have both the `\TT{expression}' and `\TT{code} selectors,
and so forth.

Brackets not listed do not change the parsing context.
The \TT{[\ldots]} brackets only change the parsing context if their
containing parsing context has the `\TT{text}' or `\TT{math}' selectors.
None of the brackets change the context if there are no selectors on
in the current parsing context, as is the case inside a \TT{\{*\ldots*\}}
comment (but unquoted brackets are still recognized and must match inside
the comment).

\subsection{Parser Suffix Pass}
\label{PARSER-SUFFIX-PASS}

The \key{parser suffix pass} splits suffixes from words so that
they may be recognized as operators.  Thus `\TT{George's}'
is split to become `\TT{George~'s}'.

The following are standard suffixes:

\begin{center}
\TT{'s} ~~~ \TT{'S}
\end{center}

Suffixes split from words are usually recognized as operators
by the parser operator pass.

\subsection{Parser Operator Pass}
\label{PARSER-OPERATOR-PASS}

The \key{parser operator pass} identifies operators in a subexpression
and reformats subexpressions in which operators are found.  Each
operator can be enabled or disabled according to the current parser
context.

The following are the standard operators enabled by various selectors.

Enabled by `\TT{code}' selector:

\hspace*{0.2in}\begin{tabular}{rll@{\hspace*{2em}}l@{\hspace*{2em}}l}
\hspace*{0.8in} & \hspace*{1.5in} & \hspace*{0.8in} & \hspace*{0.6in} \\[-2ex]

Precedence & Reformatter	& Kind	& Name		& Meaning 
\\[2ex]
-2000	& \TT{separator}	& \TT{nofix}	& \ttkey{<*>}	& separator \\
\end{tabular}

\hspace*{0.2in}\begin{tabular}{rll@{\hspace*{2em}}l@{\hspace*{2em}}l}
\hspace*{0.8in} & \hspace*{1.5in} & \hspace*{0.8in} & \hspace*{0.6in} \\[-2ex]
-1000	& \TT{separator}	& \TT{nofix}	& \ttkey{;}	& separator \\
\end{tabular}

\hspace*{0.2in}\begin{tabular}{rll@{\hspace*{2em}}l@{\hspace*{2em}}l}
\hspace*{0.8in} & \hspace*{1.5in} & \hspace*{0.8in} & \hspace*{0.6in} \\[-2ex]
+0000	& \TT{define}	& \TT{nofix}	& \ttkey{<-{}-}	& define \\
	&			& \TT{afix}
	                        & \ttkey{\TT{\{:~:\}}}
				& block \\
\end{tabular}

\hspace*{0.2in}\begin{tabular}{rll@{\hspace*{2em}}l@{\hspace*{2em}}l}
\hspace*{0.8in} & \hspace*{1.5in} & \hspace*{0.8in} & \hspace*{0.6in} \\[-2ex]
+1000	& \TT{right}		& \TT{nofix}	& \ttkey{=}	& assignment \\
     	& \TT{associative}     	&          	& \ttkey{+=}	& increment \\
     	&               	&          	& \ttkey{-=}	& decrement \\
     	&               	&          	& \ttkey{*=}	& multiply by \\
     	&               	&          	& \ttkey{/=}	& divide by \\
\end{tabular}

Enabled by `\TT{operator}' selector:

\hspace*{0.2in}\begin{tabular}{rll@{\hspace*{2em}}l@{\hspace*{2em}}l}
\hspace*{0.8in} & \hspace*{1.5in} & \hspace*{0.8in} & \hspace*{0.6in} \\[-2ex]

Precedence & Reformatter	& Kind	& Name		& Meaning 
\\[2ex]

+2000	& \TT{separator}	& \TT{nofix}	& \ttkey{,}	& separator \\
\end{tabular}

\hspace*{0.2in}\begin{tabular}{rll@{\hspace*{2em}}l@{\hspace*{2em}}l}
\hspace*{0.8in} & \hspace*{1.5in} & \hspace*{0.8in} & \hspace*{0.6in} \\[-2ex]
+3000	& \TT{unary}	& \TT{nofix}		& \ttkey{NOT}	& logical not \\
+3000	& \TT{infix}	& \TT{nofix}		& \ttkey{BUT NOT}
								& logical but
								  not \\
\end{tabular}

\hspace*{0.2in}\begin{tabular}{rll@{\hspace*{2em}}l@{\hspace*{2em}}l}
\hspace*{0.8in} & \hspace*{1.5in} & \hspace*{0.8in} & \hspace*{0.6in} \\[-2ex]
+4000	& \TT{infix}	& \TT{nofix}		& \ttkey{AND}	& logical and \\
	&			&		& \ttkey{OR}	& logical or \\
\end{tabular}


\hspace*{0.2in}\begin{tabular}{rll@{\hspace*{2em}}l@{\hspace*{2em}}l}
\hspace*{0.8in} & \hspace*{1.5in} & \hspace*{0.8in} & \hspace*{0.6in} \\[-2ex]
+5000 	& \TT{infix to(AND)}
			& \TT{nofix}		& \ttkey{==}	& equal \\
	& 		&		& \ttkey{/=}  & not equal \\
	&			&		& \ttkey{!=}	& ditto \\
	&		      	&		& \ttkey{<}	& less than \\
	&			&		& \ttkey{<=}	& less than or
								  equal \\
	&			&		& \ttkey{=<}	& ditto \\
	&		      	&		& \ttkey{>}	& greater than
									\\
	&			&		& \ttkey{>=}	& greater than
								  or equal \\
	&			&		& \ttkey{=>}	& ditto \\
\end{tabular}

\hspace*{0.2in}\begin{tabular}{rll@{\hspace*{2em}}l@{\hspace*{2em}}l}
\hspace*{0.8in} & \hspace*{1.5in} & \hspace*{0.8in} & \hspace*{0.6in} \\[-2ex]
+6000	& \TT{summation(+,-)}	& \TT{infix}	&  \ttkey{+}	& addition \\
	& 			&		& \ttkey{-}	& subtraction \\
\end{tabular}

\hspace*{0.2in}\begin{tabular}{rll@{\hspace*{2em}}l@{\hspace*{2em}}l}
\hspace*{0.8in} & \hspace*{1.5in} & \hspace*{0.8in} & \hspace*{0.6in} \\[-2ex]
+6100	& \TT{binary}	& \TT{infix}	& \ttkey{/}	& division \\
+6200	& \TT{infix}	& \TT{infix}	& \ttkey{*}
							& multiplication \\
+6300	& \TT{binary}	& \TT{infix}	& \ttkey{\^~}
							& exponentiation \\
\end{tabular}

\hspace*{0.2in}\begin{tabular}{rll@{\hspace*{2em}}l@{\hspace*{2em}}l}
\hspace*{0.8in} & \hspace*{1.5in} & \hspace*{0.8in} & \hspace*{0.6in} \\[-2ex]
+10000	& \TT{right}		& \TT{infix}	& \ttkey{OF}	& attribute \\
     	& \TT{associative}     	&          	& \ttkey{of}	& selector \\
\end{tabular}

\hspace*{0.2in}\begin{tabular}{rll@{\hspace*{2em}}l@{\hspace*{2em}}l}
\hspace*{0.8in} & \hspace*{1.5in} & \hspace*{0.8in} & \hspace*{0.6in} \\[-2ex]
+11000	& \TT{left}		& \TT{infix}	& \ttkey{'S}	& attribute \\
     	& \TT{associative}     	&          	& \ttkey{'s}	& selector \\
\end{tabular}

\hspace*{0.2in}\begin{tabular}{rll@{\hspace*{2em}}l@{\hspace*{2em}}l}
\hspace*{0.8in} & \hspace*{1.5in} & \hspace*{0.8in} & \hspace*{0.6in} \\[-2ex]
none	& \TT{unary}		& \TT{prefix}	&  \ttkey{-}	& minus \\
	& 			& \TT{prefix}	&  \ttkey{+}	& plus \\
	& 			& \TT{prefix}	&  \ttkey{@}	& object
	                                                          identifier \\
\end{tabular}

\hspace*{0.2in}\begin{tabular}{rll@{\hspace*{2em}}l@{\hspace*{2em}}l}
\hspace*{0.8in} & \hspace*{1.5in} & \hspace*{0.8in} & \hspace*{0.6in} \\[-2ex]
none	& \TT{implied}	& \TT{postfix}	&  \ttkey{[...]}
								& subscript \\
	& \multicolumn{2}{l}{~~~~\TT{( subscript )}} \\
\end{tabular}

Enabled by `\TT{text}' selector:

\hspace*{0.2in}\begin{tabular}{rll@{\hspace*{2em}}l@{\hspace*{2em}}l}
\hspace*{0.8in} & \hspace*{1.5in} & \hspace*{0.8in} & \hspace*{0.6in} \\[-2ex]

Precedence & Reformatter	& Kind	& Name		& Meaning 
\\[2ex]
-10000	& \TT{terminator}
			& \TT{nofix}	& \ttkey{.}	& (sub)sentence \\
	& ~~\TT{(s,cap,noend)}
			& \TT{nofix}	& \ttkey{!}	& terminator \\
	& 		& \TT{nofix}	& \ttkey{?}	& \\
	& 		& \TT{nofix}	& \ttkey{;}	& \\
	& 		& \TT{nofix}	& \ttkey{:}	& \\

\end{tabular}

Each entry in these tables describes an
`\ikey{operator parsing instruction}{operator parsing!instruction}'.
Parsing instructions appear in an ordered list, called the
parsing instruction stack.

List \key{parsing} is performed by a left to right scan.
At each point in the scan an attempt is made to find an
operator instruction whose name begins at the scan point.
Instructions are rejected if the are not enabled by a selector
in the current parsing context.

Other instructions are rejected on the basis of their kind and
the scan point position:
for example, an infix instruction is rejected if the scan point is
at the beginning of the list, at the end of the list, right after
a just-recognized prefix operator, etc.

If there are non-rejected
instructions, those with the longest names beginning at the scan
point are selected, and among these, the one earliest in the parsing
instruction stack is used, unless that instruction has the
`\ttkey{undefined}' flag, in which case the
process is repeated with only shorter names allowed.

With this in mind the possible operator parsing instruction
\ikey{kinds}{kind!of operator parsing!instruction}
are recognized according to the following rules:

\begin{indpar}[0.5in]
\hspace*{-0.3in}\ttkey{prefix} \\
To be recognized a prefix operator must begin the list,
or immediately follow a previously recognized prefix, infix, nofix,
or afix operator of less precedence,
or immediately follow a previously recognized prefix operator of
equal precedence.
Also the prefix operator may not end the list.

\hspace*{-0.3in}\ttkey{postfix} \\
To be recognized a postfix operator must immediately follow a non-operator,
or a postfix, nofix, or afix operator of higher
precedence, or another postfix operator of equal precedence.

\hspace*{-0.3in}\ttkey{infix} \\
To be recognized an infix operator must immediately follow a non-operator,
or a postfix, nofix, or afix operator of higher precedence.
Also the infix operator may not end the list.

\hspace*{-0.3in}\ttkey{nofix} \\
A nofix operator is always recognizable.

\hspace*{-0.3in}\ttkey{afix} \\
To be recognized an afix operator must appear after another
operator of equal precedence without any intervening operator
of less precedence.

\end{indpar}

You will note that in the above table some operators defined
to be \TT{nofix} can in fact only be used in \TT{infix} positions.
This is done to minimize coding errors by recognizing misplaced
operators.  However, this cannot be done with operators which
are different according to their kind, such as \TT{infix} `\TT{-}'
and \TT{prefix} `\TT{-}'.

During the left to right scan, errors are detected and processed
as follows:

\begin{indpar}[0.5in]
\hspace*{-0.3in}after \ttkey{prefix} \\
If an operator is found after a prefix operator that has lower
precedence than the prefix operator, or that has equal precedence
and is not itself a prefix operator, an error operand is inserted
between the two operators and an error is announced.

\hspace*{-0.3in}after \ttkey{infix} \\
If an operator is found after an infix operator that has
precedence lower than or equal to that of the infix operator,
an error operand is inserted
after the infix operator and an error is announced.

\hspace*{-0.3in}after \ttkey{postfix} \\
If an non-operator is found after a postfix operator,
or if an operator is found that has
precedence higher than the postfix operator,
or if a non-postfix operator is found that has
precedence equal to the postfix operator,
an error nofix operator of precedence one less than the
postfix operator is inserted after the postfix operator,
and an error is announced.

\end{indpar}

The output of the parse is obeys the following context
free grammar:

\begin{tabular}{rcl}
\hspace*{1.7in} \\[-2ex]
{\em expression-n}
    & ::= & {\em prefix-operand-n} {\em operand-continuation-n}\QMARK{} \\
    & $|$ & {\em operator-continuation-n} \\
    & $|$ & {\em symbol}\PLUS{} not part of an operator \\
{\em operand-continuation-n}
    & ::= & {\em infix-operator-n} {\em expression-n+1}
                                   {\em operand-continuation-n}\QMARK{} \\
    & $|$ & {\em infix-operator-n} {\em postfix-operand-n} \\
    & $|$ & {\em nofix-operator-n} {\em operator-continuation-n}\QMARK{} \\
    & $|$ & {\em afix-operator-n} {\em operator-continuation-n}\QMARK{} \\
{\em operator-continuation-n}
    & ::= & {\em expression-n+1} {\em operand-continuation-n}\QMARK{} \\
    & $|$ & {\em postfix-operand-n} \\
    & $|$ & {\em nofix-operator-n} {\em operator-continuation-n}\QMARK{} \\
    & $|$ & {\em afix-operator-n} {\em operator-continuation-n}\QMARK{} \\
{\em prefix-operand-n}
    & ::= & {\em prefix-operator-n} {\em expression-n+1} \\
    & $|$ & {\em prefix-operator-n} {\em prefix-operand-n} \\
{\em postfix-operand-n}
    & ::= & {\em expression-n+1} {\em postfix-operator-n} \\
    & $|$ & {\em postfix-operand-n} {\em postfix-operator-n} \\
{\em prefix-operator-n}
    & ::= & prefix operator of precedence n \\
{\em infix-operator-n}
    & ::= & infix operator of precedence n \\
{\em postfix-operator-n}
    & ::= & postfix operator of precedence n \\
{\em nofix-operator-n}
    & ::= & nofix operator of precedence n \\
{\em afix-operator-n}
    & ::= & afix operator of precedence n \\
\end{tabular}

Here {\em expression-n} denotes an expression whose operators are of
precedence n.
Not reflected in the above is the rule that an afix operator cannot
be the first operator in an expression.

An operator parsing instruction may associate an
\key{operator reformatter} with an operator.  After parsing a list,
if the first operator in a resulting expression has an
associated operator reformater, the expression is reformatted
according to that reformater.  For example, if the `\TT{*}' operator
has the `\TT{infix}' reformatter, then expression
`\TT{5 * x * y}' will be reformatted as `\TT{* 5 x y}'.  If in
addition the operator `\TT{/}' has the same precedence
as `\TT{*}', the expression `\TT{5 * x / y}' would be declared to
be in error because the `\TT{infix}' reformatter insists that
all operators in an expression it reformats be the same.

The possible reformatters are:

\begin{indpar}[0.5in]

\hspace*{-0.3in}\ttkey{infix} \\
It is an error unless the expression has alternating operands and operators and
begins and ends with an operand.

It is an error if all the operators in the expression are not
the same operator.

The first of these operators is moved to the
beginning of the expression and the remaining operators are removed
from the expression.

\hspace*{-0.3in}\ttkey{unary} \\
It is an error unless there is only one operator in the expression
and it is at the beginning of the expression.  The expression is
not itself changed.

\hspace*{-0.3in}\ttkey{binary} \\
It is an error unless there is only one operator in the expression
and it is surrounded by operands.  The operator is moved to the
beginning of the expression.

\hspace*{-0.3in}\ttkey{right associative} \\
It is an error unless the expression has alternating operands and operators and
begins and ends with an operand.

Brackets are introduced so the operators are all binary and the
rightmost is done first, and then all the binary operators are moved
to the beginning of their subexpressions:
e.g., 
\begin{center}
\tt x = y -= z += 5
\end{center}
becomes
\begin{center}
\tt = x \{| -= y \{| += z 5 |\} |\}
\end{center}
if `\TT{=}', `\TT{-=}', and `\TT{+=}' have the same precedence and
`\TT{=}' has this reformatter.

\hspace*{-0.3in}\ttkey{left associative} \\
Like \TT{right associative} except that brackets are introduced
so the leftmost is done first:
e.g.,
\begin{center}
\tt x + y - z + 5
\end{center}
becomes
\begin{center}
\tt + \{|- \{| + x y |\} z |\} 5
\end{center}
if `\TT{+}' and `\TT{-}' have the same precedence and `\TT{+}' has
this reformatter (but `\TT{+}' and `\TT{-}' have a different
reformatter in the above tables).

\hspace*{-0.3in}\ttkey{separator} \\
Only allowed for operators of `\TT{nofix}' kind.

It is an error if all the operators in the expression are not
the same operator.

Empty list operands (i.e., \TT{\{||\}} lists) are inserted so that all
the operators become infix.
Then all the operators are removed and the operator name is made
into the value of the `\TT{.separator}' property of the list.

Thus if `\TT{,}' is a nofix operator with this reformatter,
the expression
\begin{center}
\tt , w x,, y, z,
\end{center}
is reformatted to
\begin{center}
\tt \{"", .separator = ","| \{||\} \{| w x |\} \{||\} y z \{||\} |\}
\end{center}


\end{indpar}

It is possible to make new reformatters using \skey{reformatter constructor}s
that take arguments which are constant expressions.  There are examples
in the above tables; e.g., \TT{summation (`+', `-')}.

The following are the reforrmatter constructors:

\begin{indpar}[0.5in]

\hspace*{-0.3in}\ttkey{infix to} \TT{(} {\em and-op} \TT{)} \\
This reformatter is used for infix comparison operators such as
`\TT{<}', `\TT{==}', `\TT{<=}'.

It is an error unless the expression has alternating operands and operators and
begins and ends with an operand.

Each operator is executed separately from left to right and the
results combined by the `{\em and-op}' operator.  Thus
\begin{center}
\em x1 op1 x2 op2 x3
\end{center}
becomes
\begin{center}
\tt {\em and-op} \{| {\em op1} {\em x1} {\em x2} |\}
                 \{| {\em op2} {\em x2} {\em x3} |\}
\end{center}

\underline{except} that temporaries are introduced to prevent
non-end operands from being evaluated more than once, so the
actual final reformatting of the example just given is
\begin{center}
\tt {\em and-op} \{| {\em op1} {\em x1} \{| = \#\#1 {\em x2} |\} |\}
                 \{| {\em op2} \#\#1 {\em x3} |\}
\end{center}

where `\TT{\#\#1}' denotes a temporary variable
(see below\pagnote{TEMPORARY}).

\hspace*{-0.3in}\ttkey{summation}
        \TT{(} {\em plus-op}\TT{,} {\em minus-op} \TT{)} \\
It is an error unless the expression has alternating operands and operators and
begins and ends with an operand.

It is an error unless all the operators in the expression are either
{\em plus-op} or {\em minus-op}.

Each `{\em minus-op operand}' subsequence of the expression is
replaced by
\begin{center}
{\em plus-op} \verb/{|/ {\em minus-op} {\em operand} \verb/|}/
\end{center}
and then the expression is processed as by the \TT{infix} reformatter,
copying the first {\em plus-op} operator
to the beginning of the expression while
removing all the other {\em plus-op} operators.

Thus if `\TT{+}' has this reformatter with
arguments \TT{(+,-)}, and `\TT{+}' and `\TT{-}' are infix
operators with the same precedence, then the expression
\begin{center}
\tt w + x - y + z 
\end{center}
is first changed to
\begin{center}
\tt w + x + \{| - y |\} + z 
\end{center}
and finally reformatted as
\begin{center}
\tt + w x \{| - y |\} z
\end{center}

\hspace*{-0.3in}\ttkey{implied} \TT{(} {\em implied-op} \TT{)} \\
This reformatter is used for postfix operators which do not have
ordinary names but are instead explicitly bracketed subexpressions
named by their subexpression \TT{.type} or \TT{.initiator}.

No errors are detected.  The {\em implied-op} is merely added to the
beginning of the expression.

\end{indpar}

Sometimes \ikey{temporaries}{temporary}\label{TEMPORARY}
are introduced by reformatting.  The syntax involving temporaries is:

\begin{indpar}
\emkey{temporary-definition} ::= {\em temporary} {\em subexpression} \\[1ex]
\emkey{temporary} ::= \TT{\#\#} {\em integer}\pagnote{INTEGER}
\end{indpar}

During reformatting, a subexpression may be replaced by
a {\em temporary-definition} containing the subexpression.  This
defines the {\em temporary} as a name for the value of the subexpression.
Then the {\em temporary} can be used in the reformatted
expression to refer to this value.  As an example, given the above
tables

\begin{center}
\verb|x == y + 3 == z|
\end{center}

becomes

\begin{center}
\verb/AND {| == x {| ##563 {| + y 3 |} |} |} {| == {| ##563 |} z |}/
\end{center}

Here the temporary has been used to avoid computing \TT{y + 3}
more than once.

The {\em decimal-naturals} in {\em temporaries} are assigned so no
two {\em temporary-definitions} ever have the same {\em temporary}.

\subsection{Parser Units Pass}
\label{PARSER-UNITS-PASS}

The function of the \key{parser units pass} is to identify number
units, such as \TT{ft} and \TT{lb}, and turn them into multipliers
and divisors.  For example, `\TT{35~ft~lb}' is reformatted as
`\TT{* 35 ft lb}' and `\TT{\$100~per~yr}' is reformatted as
`\TT{/ \{| * \$ 100 |\} yr}'.

The following are standard units:

\newcommand{\BU}{\STAR{}}

\hspace*{0.2in}\begin{tabular}{llllll}
\hspace*{1.0in} & \hspace*{0.8in} & \hspace*{0.8in} & \hspace*{0.4in} &
                  \hspace*{0.7in} \\[-2ex]

Unit		& Singular & Plural & Fixity & Type & Equivalent
\\[2ex]
Gram\BU		& \TT{g} & & postfix & continuous \\
Pound		& \TT{lb} & \TT{lbs} & postfix & continuous
                                               & \TT{453.59237 g} \\
Ounce		& \TT{oz} &          & postfix & continuous
                                               & \TT{28.349523 g} \\
Kilogram	& \TT{kg} & & postfix & continuous & \TT{1000 g} \\
\end{tabular}

\hspace*{0.2in}\begin{tabular}{llllll}
\hspace*{1.0in} & \hspace*{0.8in} & \hspace*{0.8in} & \hspace*{0.4in} &
                  \hspace*{0.7in} \\[-2ex]
Centimeter\BU	& \TT{cm} & & postfix & continuous \\
Meter		& \TT{m}  & & postfix & continuous & \TT{100 cm} \\
Foot		& \TT{ft} & & postfix & continuous & \TT{30.48 cm} \\
Yard		& \TT{yd} & & postfix & continuous & \TT{91.44 cm} \\
Mile		& \TT{mi} & & postfix & continuous & \TT{160934.4 cm} \\
\end{tabular}

\hspace*{0.2in}\begin{tabular}{llllll}
\hspace*{1.0in} & \hspace*{0.8in} & \hspace*{0.8in} & \hspace*{0.4in} &
                  \hspace*{0.7in} \\[-2ex]
Second\BU	& \TT{sec} & & postfix & continuous \\
Minute		& \TT{min} & & postfix & continuous & \TT{60 sec} \\
Hour		& \TT{hr} & & postfix & continuous & \TT{3600 sec} \\
\end{tabular}

\hspace*{0.2in}\begin{tabular}{llllll}
\hspace*{1.0in} & \hspace*{0.8in} & \hspace*{0.8in} & \hspace*{0.4in} &
                  \hspace*{0.7in} \\[-2ex]
Degrees C\BU	& \TT{C} & & postfix & continuous \\
Degrees F	& \TT{F} & & postfix & continuous & \TT{1.8 C + 32} \\
Degrees K	& \TT{K} & & postfix & continuous & \TT{1.0 C + 273.15} \\
\end{tabular}

\hspace*{0.2in}\begin{tabular}{llllll}
\hspace*{1.0in} & \hspace*{0.8in} & \hspace*{0.8in} & \hspace*{0.4in} &
                  \hspace*{0.7in} \\[-2ex]
Person		& \TT{person} & \TT{persons}, & postfix & discrete \\
		&	  & \TT{people} \\ 
\end{tabular}

The parser units pass attempts to parse a subexpression according to the
following syntax:

\begin{indpar}
\emkey{units-subexpression}
    \begin{tabular}[t]{@{}rl}
    ::= & {\em unit-phrase}\PLUS{} \\
    $|$ & {\em unit-prefix-subexpression} \\
        & {\em unitless-name} \\
        & {\em unit-suffix-subexpression}\QMARK{} \\
    $|$ & {\em bifrucated-number} \\
    \end{tabular}
\\[1ex]
\emkey{unit-phrase} ::= {\em unitless-name} {\em unit-suffix-subexpression}
\\[1ex]
\emkey{unitless-name}
    \begin{tabular}[t]{@{}rl}
    ::= & {\em bifrucated-number} \\
    $|$ & other {\em name}\pagnote{NAME} that does not contain
			  any {\em unit} or {\em unit-subexpression}
    \end{tabular}
\\[1ex]
\emkey{bifrucated-number} ::= {\em integer} {\em unsigned-fraction}
\\[1ex]
\emkey{unsigned-fraction} ::= {\em number} in the range $[0,1)$
\\[1ex]
\emkey{unit-prefix-subexpression} ::= {\em prefix-unit}\PLUS{}
\\[1ex]
\emkey{unit-postfix-subexpression}
    \begin{tabular}[t]{@{}r@{~}l}
    ::= & {\em postfix-unit}\PLUS{} \\
    $|$ & {\em postfix-unit}\STAR{} \TT{per} {\em postfix-unit}\PLUS{} \\
    $|$ & {\em unit-subexpression}
    \end{tabular}
\\[1ex]
\emkey{unit-subexpression} ::= \TT{(} {\em unit-expression} \TT{)}
\\[1ex]
\emkey{unit-expression}
    \begin{tabular}[t]{@{}r@{~}l}
    ::= & {\em unit-primary} \{ \TT{*}\QMARK{} {\em unit-primary} \}\STAR{} \\
    $|$ & {\em unit-primary} \TT{/} {\em unit-primary}
    \end{tabular}
\\[1ex]
\emkey{unit-primary}
    ::= {\em unit} $|$ \TT{(} {\em unit-expression} \TT{)}
\\[1ex]
\emkey{unit}
    ::= {\em prefix-unit} $|$ {\em postfix-unit}
\end{indpar}

If the pass finds any {\em unit} or {\em unit-expression} but
the subexpression does not conform to the above syntax, an error
message is issued.  If there is no {\em unit} or {\em unit-expression}
and the subexpression is not a {\em bifructed-number}, the
pass leaves the expression alone.  Otherwise the subexpression is reformatted
according to the following rules:
\begin{itemize}
\item[(1)] A `\TT{+}' is placed between consecutive {\em unit-phrases}.
\item[(2)] A `\TT{*}' is placed between consecutive {\em unit-primaries},
after any {\em unit-prefix-subexpression}, and before any
{\em unit-postfix-subexpression}.
\item[(3)] Any `\TT{per}' is replaced by `\TT{/}', any
{\em unit-postfix-subexpression} containing it is surrounded by
\TT{\{|~|\}} brackets, and if there is no {\em postfix-unit} before
the `\TT{per}', a `\TT{1.0}' is inserted before the `\TT{/}'. Thus
\begin{center}
\TT{40 lb per sec } $\Longrightarrow$ \TT{40 * \{| lb / sec |\}} \\
\TT{40 per sec } $\Longrightarrow$ \TT{40 * \{| 1.0 / sec |\}}
\end{center}
\item[(4)] Then subexpressions containing infix \TT{+}'s,\TT{*}'s, or
\TT{/}'s are
reformatted as per the operator pass.  This moves infix operators
to the beginning of the subexpression containing them.
\item[(6)] Next nested subexpressions beginning with \TT{*} are
collapsed: e.g.,
\begin{center}
\TT{* X \{|~* y z |\} W} $\Longrightarrow$ \TT{* X y z W}
\end{center}
\item[(7)] Lastly the two {\em numbers} in each {\em bifrucated-number}
are combined by addition.  E.g.,
\begin{center}
\TT{40 1/5} $\Longrightarrow$ \TT{40.2}
\end{center}
\end{itemize}

The following are examples of parser units pass subexpression reformatting:
\begin{center}
\TT{40 lb 3 oz} $\Longrightarrow$ \TT{+ \{| * 40 lb |\} \{| * 3 oz |\}}
\\
\TT{100 m per sec} $\Longrightarrow$ \TT{* 100 \{| / m sec |\}}
\end{center}



\subsection{Parser Dequoting Pass}
\label{PARSER-DEQUOTING-PASS}

\subsection{Parser Control}
\label{PARSER-CONTROL}

After input text is scanned into symbols and these are parsed into
typed lists, each typed list may optionally be parsed further using
instructions in a parsing table associated with the type of the list.
A \key{parsing table} is a list
of \ikey{operator parsing instructions}{operator parsing!instruction}
which have the form:

\begin{tabular}{rcl}
\hspace*{1.7in} \\[-2ex]
\emlkey{operator-parsing}{-instruction}
    & ::= & \TT{\{ operator parsing instruction:} \\
    &     & ~~~ \TT{name =} {\em operator-name}\TT{,} \\
    &     & ~~~ \TT{kind =} {\em operator-kind}\PLUS{} \\
    &     & ~~~ \{ \TT{, undefine} \}\QMARK{} \\
    &     & ~~~ \{ \TT{, type =}
                   {\em operator-type} \}\QMARK{} \\
    &     & ~~~ \{ \TT{, precedence =}
                   {\em operator-precedence} \}\QMARK{} \\
    &     & ~~~ \{ \TT{, reformatter =}
                   {\em operator-reformatter} \}\QMARK{} \\
    &     & \TT{||\}} \\
\emkey{operator-name}
    & ::= & {\em word}\PLUS{} \\
\emkey{operator-kind}
    & ::= & \TT{prefix} $|$ \TT{infix} $|$ \TT{postfix} $|$
            \TT{nofix} $|$ \TT{afix} \\
\emkey{operator-type}
    & ::= & {\em word}\PLUS{} \\
\emkey{operator-precedence}
    & ::= & 32 bit signed integer \\
\emkey{operator-reformatter}
    & ::= & \TT{infix} $|$ \TT{unary} \\
    & $|$ & \TT{binary} $|$ \TT{infix to} \\
    & $|$ & \TT{right-associative} $|$ \TT{left-associative} \\
    & $|$ & \TT{separator} $|$ \TT{summation} \\
\end{tabular}






\subsubsection{Number Pair Recognition}
\label{NUMBER-PAIR-RECOGNITION}

A \key{number pair} is a pair of {\em numbers}, the first
of which is in integer and the second of which is a fraction
containing a slash.

\begin{indpar}
\emkey{number-pair} ::= {\em integer} {\em fraction}
    \\[1ex]
{\em integer} ::= see \pagref{INTEGER} \\[1ex]
{\em fraction} ::= see \pagref{FRACTION}
\end{indpar}

Some examples of number pairs are:

\begin{indpar}[0.1in]
\tt
\begin{tabular}{l@{~~~~~}l@{~~~~~}l@{~~~~~}l}
1 1/2	& 55 3/4	& 174 15/16  & 1,234,567 2,875/3,408
\end{tabular}
\end{indpar}

When a {\em number-pair} is encountered during number parsing,
it is surrounded by \TT{(\# \#)} implicit brackets and a \TT{+} is
inserted between its two parts.  Thus if
\TT{41 3/4} is input to number parsing,
\TT{(\# 41 + 3/4 \#)}
will be output.

A number pair is illegal if either of its two parts is illegal.

Number pairs are recognized after scientific numbers have been
recognized.

\subsubsection{Number Unit Grouping}
\label{NUMBER-UNIT-GROUPING}

A {\em number-unit-group} is a sequence of one or more {\em number-unit-pairs}
each of which consists of two lexemes: a {\em real-number}
and a {\em unit-specifier}.
The syntax equations are:

\begin{indpar}
\emkey{number-unit-group} ::= {\em number-unit-pair}\PLUS{} \\[1ex]
\emkey{number-unit-pair} \begin{tabular}[t]{r@{~}l}
                     ::= & {\em prefix-unit-specifier} {\em real-number} \\
                     $|$ & {\em real-number} {\em postfix-unit-specifier} \\
		     \end{tabular} \\[1ex]
\emkey{prefix-unit-specifier} ::= {\em name} \\[1ex]
\emkey{postfix-unit-specifier} ::= {\em name} \\[1ex]
\emkey{unit-specifier} ::= {\em prefix-unit-specifier} $|$
                         {\em postfix-unit-specifier} \\[1ex]
{\em name} ::= see \pagref{NAME}
\end{indpar}

In order to be recognized as a {\em unit-specifier} a {\em symbol} sequence
must be defined as a {\em unit-specifier-name} by the following:

\begin{indpar}
\emkey{unit-specifier-definition} \\
	\hspace*{0.5in}::= \TT{define unit specifier}
	    \begin{tabular}[t]{l}
	    {\em unit-specifier-fixity} \\
	    {\em unit-specifier} {\em parsing-selectors}
	    \end{tabular}
\label{UNIT-SPECIFIER-DEFINITION}
	    \\[1ex]
\emkey{unit-specifier-fixity} ::= \ttkey{prefix} $|$ \ttkey{postfix}
	\\[1ex]
{\em parsing-selectors} ::= see \pagref{PARSING-SELECTORS}
\end{indpar}

The \key{number unit grouping} phase of
parsing recognizes {\em number-unit-groups} containing more than
one {\em number-unit-pair}, places
\TT{(\# \#)} implied brackets around them,
and places implied `\TT{+}' operators
between their {\em number-unit-pairs}.

For example, if `\TT{hr}' and `\TT{min}'
are {\em postfix-unit-specifiers},
`\TT{7 hr 30 min}' is a {\em number-unit-group} containing
2 {\em number-unit-pairs} that number unit grouping transforms into
\begin{center}
\verb/(# 7 hr + 30 min #)/
\end{center}
As another example,
if `\TT{ft}' and `\TT{in}' are {\em postfix-unit-specifiers},
`\TT{12ft 11 3/4in}' becomes
\begin{center}
\verb|(# 12 ft + (# 11 + 3/4 #) in #)|
\end{center}

Number unit groups are recognized after number pairs have been
recognized.

\subsubsection{Unit Multiplication Insertion}
\label{UNIT-MULTIPLICATION-INSERTION}

The \lkey{unit multiplication}{insertion} phase of
parsing inserts a multiplication operator lexeme, `\TT{*}',
before a {\em postfix-unit-specifier}, and
after a {\em prefix-unit-specifier}, unless the point at which the
`\TT{*}' is to be inserted is already occupied by a
`\TT{*}' or `\TT{/}' lexeme.  This is done after number unit
grouping (\secref{NUMBER-UNIT-GROUPING}).

For example, if `\TT{sec}', `\TT{ft}', and `\TT{lb}'
are {\em postfix-unit-specifiers},
then
\begin{indpar}\begin{verbatim}
some function ( 3 ft 2 1/4 in / sec,
                9 ft ^ 2 lb / sec,
                $3.50 )
\end{verbatim}\end{indpar}
becomes
\begin{indpar}\begin{verbatim}
some function ( (# 3 * ft + (# 2 + 1/4 #) * in #) / sec,
                9 * ft ^ 2 * lb / sec,
                $ * 3.50 )
\end{verbatim}\end{indpar}

Unit multiplication insertion is done after number unit groups have been
recognized.

\subsection{Text Parsing}
\label{TEXT-PARSING}

Text parsing is similar to operator parsing except that brackets and
most operators are `named'.
For example, `\TT{<p>}' is a standard paragraph operator,
and `\TT{<indented p>}' is a standard paragraph operator
that is a child of `\TT{<p>}'
and inherits attributes from `\TT{<p>}'.  As another example,
`\TT{<b|} \ldots{} \TT{|b>}' are standard `bold' brackets.

The named text brackets and operators
have the syntax:

\begin{indpar}
\emkey{named-operator} ::=
    \TT{<} {\em text-type} {\em arguments-option} {\em labels-option} \TT{>}
    \\[1ex]
\emkey{named-left-bracket} ::=
    \TT{<} {\em text-type} {\em arguments-option} {\em labels-option} \TT{|}
    \\[1ex]
\emkey{named-right-bracket} ::=
    \TT{|} {\em text-type} {\em arguments-option} {\em labels-option} \TT{>}
    \\[1ex]
{\em text-type} ::= {\em name}
    \\[1ex]
{\em arguments-option} ::= {\em empty} $|$ \TT{(} {\em argument-list} \TT{)}
    \\[1ex]
{\em argument-list} ::= {\em empty}
                    $|$ {\em argument} \{ \TT{,} {\em argument} \}\STAR{}
    \\[1ex]
{\em argument} ::= {\em name} $|$ {\em number} $|$ {\em quoted-string}
    \\[1ex]
{\em labels-option} ::= {\em empty} $|$ \TT{:} {\em label}
				\{ \TT{,} {\em label} \}\STAR{}
    \\[1ex]
{\em label} ::= {\em name}
    \\[1ex]
{\em name} ::= see \pagref{NAME}
    \\[1ex]
{\em number} ::= see \pagref{NUMBER}
    \\[1ex]
{\em quoted-string} ::= see \pagref{QUOTED-STRING}
\end{indpar}

The names of text brackets and operators are
referred to as `\skey{text type}s'.  For example, `\TT{<p>}' is a text
operator of text type `\TT{p}', and `\TT{<b|}~\ldots~\TT{|b>}'
are text brackets of text type `\TT{b}'.
Text types have attributes
such as `\TT{style}', `\TT{weight}', `\TT{indent}', and `\TT{adjust}',
that are used to format the text for printing and display.
For example `\TT{b}' has a the `\TT{weight}' attribute value
`\TT{heavy} and `\TT{n}', as in
`\TT{<n|}~\ldots~\TT{|n>}',
has a `\TT{weight}' attribute value `\TT{normal}'.

Text types
can also inherit attributes from other text types.  To facilitate this
there are also virtual text types that are never used in the text,
but can be ancestors of other text types and serve as repositories of
attributes.  Lastly it is possible to give several names to the same
text type, and to give names to attribute values (e.g., `\TT{default style}'
is a standard name for a `\TT{style}' attribute value).

If a text type has no value for an attribute, or has the value
`\ttmkey{none}{text attribute value}', a piece of text of that type
has no value for the attribute, and
gets the attribute value if it needs it from the surrounding text, or from an
\mkey{initial value}{for text attribute}
for the attribute if there is no surrounding text.
Thus since `\TT{p}' has no `\TT{weight}' attribute value, surrounding a
paragraph by `\TT{<b|}~\ldots~\TT{|b>}' produces a bold paragraph,
and not surrounding a paragraph by text with any `\TT{weight}' attribute
gets the initial `\TT{weight}' attribute, which is `\TT{normal}'.

Although there are many
standard text types, each with standard attributes, a large piece of
text typically defines new types specific to that text and resets some
attributes of the standard types in a way specific to the particular
text.

Text surrounded by named brackets like `\TT{<b|}~\ldots~\TT{|b>}'
is converted by the text parser
into a list which has the \ttdkey{text-type} and \ttdkey{label}
extra attributes supplied by the named brackets.
Similarly text prefaced by a named operator like `\TT{<p>}'
is converted to such a list.  So, for example, the text

\begin{indpar}\begin{verbatim}
<p>
This is a <b|bold|b> sentence.
\end{verbatim}\end{indpar}

is converted by the text parser to

\begin{indpar}\begin{verbatim}
@1 = @2 {| .text-type = p |}
@2 = this is a @3 sentence :|
    .text-type = s
    .initiator = capital 
    .terminator = "."
@3 = bold {| .text-type = b |}
\end{verbatim}\end{indpar}

Here the named operator `\TT{<p>}' prefaces the text included in \TT{@1},
the unnamed operator `\TT{.}' ends the text included in \TT{@2},
and the named brackets `\TT{<b|}~\ldots~\TT{|b>}' surround the text
included in \TT{@3}.  The unnamed operator `\TT{.}' terminates
a piece of text that is assigned the `\TT{s}' text type,
the `\TT{capital}' \TT{.initiator}, and
the `\TT{.}' \TT{.terminator}.  Here the text type `\TT{s}' denotes
a `sentence', and the result would be the same if
the named operator `\TT{<s>}' were explicitly included just before
`\TT{This}', as in

\begin{indpar}\begin{verbatim}
<p>
<s> This is a <b|bold|b> sentence.
\end{verbatim}\end{indpar}

A piece of text can be given a {\em label} by including the {\em label}
in the named bracket or named operator which gives the piece of text
its text type.
These labels are internal to the document, and not printed.
They are used to create references from one place in the document to
another.  For example:

\begin{indpar}\begin{verbatim}
<p: porch definition>
. . . <b: porch|porch|b> . . .
. . . . . . . . .
. . . <r|porch|r> . . .
. . . . . . . . .
. . . <r|porch definition|r> . . .
. . . . . . . . .
\end{verbatim}\end{indpar}

in which the \TT{<r|  |r>} bracketed {\em labels} are references
to the labeled bold text and labeled paragraph.  For convenience
`\TT{<k|}{\em text}\TT{|k>}' can be used to abbreviate
`\TT{<b:} {\em text}\TT{|}{\em text}\TT{|b>}', for example,
`\TT{<k|porch|k>}' could be used above instead of
`\TT{<b: porch|porch|b>}' (the text type `\ttmkey{k}{text type}'
denotes a `keyword').


The text parser converts text into a list whose elements are lexemes
and sublists, where in general each sublist has elements that are
lexemes and sublists.
The text types end up as \ttdkey{text-type}
attributes of these lists and sublists.
Similarly {\em labels} included in named brackets
or named operators end up as \ttdkey{label}
attributes.  Operators frequently cause additional reformatting
of the parse output.  {\em Arguments} in named operators and
brackets are passed to reformatters which use them to control
the reformatting and may insert them as various attributes in the
parsed output.  As an example, the text

\begin{indpar}\begin{verbatim}
<section(1)|A Section Header|>
<p>
<s: HERE>An important sentence.
Another sentence.
\end{verbatim}\end{indpar}

is converted by the text parser to

\begin{indpar}\begin{verbatim}
@1 = @3 :|
    .text-type = section
    .level = 1
    .title = @2
@2 = A Section Header
@3 = @4 @5 {| .text-type = p |}
@4 = an important sentence :|
    .text-type = s
    .label = HERE
    .initiator = capital 
    .terminator = "."
@5 = another sentence :|
    .text-type = s
    .initiator = capital 
    .terminator = "."
\end{verbatim}\end{indpar}

Here the entire bracketed subexpression
`\TT{<section(1)|} \ldots{} \TT{|>}'
also is the lowest precedence operator which reformats everything that
follows (and in general everything following up to the next operator of
equal or lower precedence or a closing outer bracket) into a single list.
It attaches the bracketed text to this list as the \TT{.title} attribute.
Also the `\TT{<section>}' operator is programmed to attach its argument,
`\verb|1|' in this case, to the list as the \TT{.level} attribute

In general named operators can be used in bracketed form to attach
a bracketed expression as a \TT{.title} attribute to the same text
the operator attaches its \TT{.text-type} to.  In general some
named operators or brackets are programmed to take arguments which
they may use to control formatting or compute text attribute values
(such as \TT{.level} in this example).

Note that closing brackets may omit their name, as `\TT{|>}' does
when it closes `\TT{<section(1)|}' in this example.  Its also allowed to
use either an initial or final segment of the name in a closing
named bracket, as in `\TT{<bold italic|} \ldots{} \TT{|bold>}'
or `\TT{<bold italic|} \ldots{} \TT{|italic>}'.
Arguments may be given in either the opening or closing bracket of a named
bracket, but if given in both, must be identical in both.  E.g.,
\begin{center}
\verb/<section(1)|/ \ldots{} \verb/|section>|/ \\
\verb/<section|/ \ldots{} \verb/|section(1)>|/ \\
\verb/<section(1)|/ \ldots{} \verb/|section(1)>|/ \\
\end{center}
are all acceptable and equivalent, but
\begin{center}
\verb/<section(1)|/ \ldots{} \verb/|section(2)>|/
\end{center}
is illegal.


In the above example,
`\TT{<p>}' is a higher precedence operator than `\TT{<section>}', and
`\TT{<s>}' is higher precedence than `\TT{<p>}'.  Also the sentence
terminator `\TT{.}' has the same precedence as `\TT{<s>}' and these
operators work together to form sentences.  The `\TT{<s>}' operator
is optional and is only given in the example in order to assign a \TT{.label}
attribute to the first sentence.  The second sentence has its `\TT{<s>}'
operator omitted.

Some text operators do \underline{not} set the \TT{.text-type} attribute,
but instead set only a \TT{.separator} attribute.  The `\TT{,}'
operator is an example.  Thus the text

\begin{indpar}\begin{verbatim}
this is, certainly, a phrase
\end{verbatim}\end{indpar}

is converted by the text parser to

\begin{indpar}\begin{verbatim}
@1 = @2 certainly @3 {| .separator = "," |}
@2 = this is
@3 = a phrase
\end{verbatim}\end{indpar}

Because the reformatted expression in this case is a list with
no \TT{.text-type} attribute, it can be assigned a \TT{.text-type}
attribute by a text operator of precedence lower than the
precedent of `\TT{,}'.  Thus the text

\begin{indpar}\begin{verbatim}
<p>
this is, certainly, a phrase
<p>
This is, certainly, a sentence.
\end{verbatim}\end{indpar}

is converted by the text parser to

\begin{indpar}\begin{verbatim}
@1 = @2 @6
@2 = @3 certainly @4 :|
    .separator = ","
    .text-type p
@4 = this is
@5 = a phrase
@6 = @7 {| .text-type p |}
@7 = @8 certainly @9 :|
    .separator = ","
    .initiator = capitalize
    .terminator = "."
    .text-type s
@8 = this is
@9 = a sentence
\end{verbatim}\end{indpar}

Unnamed brackets, namely
`\TT{(} \ldots{} \TT{)}',
`\TT{[} \ldots{} \TT{]}', and
`\TT{\{} \ldots{} \TT{\}}',
produce bracketed subexpressions just as they do for other
parsers.  Thus the text

\begin{indpar}\begin{verbatim}
the book (Bartholomew 2043) previously mentioned
\end{verbatim}\end{indpar}

is converted by the text parser to

\begin{indpar}\begin{verbatim}
@1 = the book @2 previously mentioned
@2 = Bartholomew 2043 :|
    .initiator = "("
    .terminator = ")"
\end{verbatim}\end{indpar}

If you want to eliminate spacing where it would normally occur,
you can use \skey{glue bracket}s, `\TT{<g|} \ldots{} \TT{|g>}',
which can also be implied by the absence of spacing in the input.
Thus

\begin{indpar}\begin{verbatim}
the book[Bartholomew 2043] previously mentioned
\end{verbatim}\end{indpar}

is equivalent to

\begin{indpar}\begin{verbatim}
the <g|book[Bartholomew 2043]|g> previously mentioned
\end{verbatim}\end{indpar}

and both are converted by the text parser to

\begin{indpar}\begin{verbatim}
@1 = the @2 previously mentioned
@2 = book @3 {| .text-type = g |}
@3 = Bartholomew 2043 :|
    .initiator = "["
    .terminator = "]"
\end{verbatim}\end{indpar}

\subsubsection{Standard Text Operators}
\label{STANDARD-TEXT-OPERATORS}

The following are the standard text operators

\begin{center}

\begin{tabular}{rl@{\hspace*{2em}}l@{\hspace*{2em}}l}

precedence & reformatter	& operator	& meaning 
\\[2ex]
-10000+100$n$
	& \ttkey{text-prefix}	& \tttkey{section($n$)}
						& section header \\
-1100	& \ttkey{text-prefix}	& \tttkey{tr}	& table row \\
-1000	& \ttkey{text-prefix}	& \tttkey{ti($m$,$n$)}	& table item \\
-500	& \ttkey{text-prefix}	& \tttkey{li}	& list item \\
0	& \ttkey{text-prefix}	& \tttkey{p($i$)}	& paragraph \\
100	& \ttkey{sentence}	& \tttkey{s}	& sentence \\
	&			& \ttkey{.}	& sentence terminator \\
	&			& \ttkey{!}	& sentence terminator \\
	&			& \ttkey{?}	& sentence terminator \\
200	& \ttkey{text-separator}
				& \ttkey{;}	& subsentence separator \\
	&			& \ttkey{:}	& subsentence separator \\
300	& \ttkey{text-separator}
				& \ttkey{--}	& phrase separator \\
	& 			& \ttkey{---}	& phrase separator \\
400	& \ttkey{text-separator}
				& \ttkey{,}	& phrase separator \\
\end{tabular}

\end{center}


\begin{indpar}[1em]

\newcommand{\OP}[1]{\tttmkey{#1}{reformatting}}

\bigskip

\ttmkey{text-prefix}{reformatter} \hfill \OP{section($n$)}
~~~ \OP{tr} ~~~ \OP{ti($m$,$n$)}
~~~ \OP{li} ~~~ \OP{p}

\begin{indpar}[0.5em]
These operators have different
precedences, and so cannot appear together in the same expression.

The expression must have the form
\begin{center}
\{ {\em operator} {\em subexpression} {\em subexpression}\STAR{} \}\STAR{}
\end{center}

That is, {\em operators}
(e.g., `\TT{<p>}') must begin the expression and may
not be consecutive or end the expression.  Each operator and the
{\em subexpressions} following it are reformatted into a list whose
\TT{.text-type} attribute is given by the operator.  If there is one
{\em operator}, this reformatted list becomes the reformatted expression.
If there is more than one, a list of these reformatted lists
becomes the reformatted expression.

The list of {\em subexpressions} following an {\em operator} is parsed as
an expression.  The result is then converted to a list with no
\TT{.text-type} attribute; if it is not already such, it is made
the sole element of a new list.  Then the \TT{.text-type} and \TT{.label}
attributes of this list are set from the {\em operator} and the result
is the reformatted list for that {\em operator}.

If the operator brackets text, that text becomes the \TT{.title} attribute
value of the reformatted list.

The `\TT{<section>}'
operator takes an additional argument $n$ (default \TT{0})
which becomes the \TT{.level} attribute of the reformated list.  Also,
$100n$ is added to the precedence of the operator.

The `\TT{<ti>}' table item
operator takes an additional arguments $m$ and $n$ (defaults \TT{1} and
\TT{1})
which become the \TT{.rows} and \TT{.columns} attributes, respectively,
of the reformated list.  These specify that the table item is to span
$m$ rows and $n$ columns.  $m$ can be omitted, as in \TT{<ti(}$n$\TT{)>}.

The `\TT{<p>}'
operator takes an additional argument $i$ (default \TT{0})
which becomes the \TT{.indent} attribute of the reformated list.  This
specifies that the entire paragraph is to be indented.

[TBD: maybe not the \TT{.indent} attribute.]

\end{indpar}

\bigskip

\ttmkey{sentence}{reformatter} \hfill \OP{s} ~~~ \ttmkey{.}{reformatting}
					     ~~~ \ttmkey{?}{reformatting}
					     ~~~ \ttmkey{!}{reformatting}

\begin{indpar}[0.5em]

The expression must have the form
\begin{center}
\{ \TT{<s>}{\em -option} {\em subexpression} {\em subexpression}\STAR{}
	{\em terminator} \}\STAR{}
\end{center}
where the {\em terminator} is one of `\ttmkey{.}{terminator}',
`\ttmkey{?}{terminator}', or `\ttmkey{!}{terminator}'.

That is, it must consist of a sequence of `\skey{sentence}s' each beginning
with an optional `\TT{<s>}', each ending with one of the {\em terminators},
and each being non-empty otherwise.  Each sentence is reformatted into
a list whose \TT{.text-type} is `\ttmkey{s}{\tt .text-type}', whose
\TT{.initiator} may be `\ttmkey{capitalize}{\tt .text-type}', and whose
\TT{.terminator} is the {\em terminator} at the end of the sentence.
If there is just one sentence, its reformatted list becomes the
reformatted expression.  If there
is more than one, a list of these reformatted sentence lists
becomes the reformatted expression.

The list of {\em subexpressions} in a sentence is parsed as
an expression.  The result is then converted to a list with no
\TT{.text-type}, \TT{.initiator}, or \TT{.terminator} attributes;
if it is not already such, it is made
the sole element of a new list.  Then the \TT{.text-type} attribute
of this list is set to `\TT{s}', the \TT{.label}
attribute of this list is set to any value provided by
an optional `\TT{<s:} {\em label\,}\TT{>}' {\em operator},
and the
\TT{.terminator} is set to the {\em terminator}.
If the first element of the list is a capitalized word, it is decapitalized
and the list \TT{.initiator} is set to `\TT{capitalize}'.
This list is then the reformatted list for the sentence.

\end{indpar}

\bigskip

\ttmkey{text-separator}{reformatter} \hfill \ttmkey{--}{reformatting}
				   ~~~ \ttmkey{---}{reformatting}
				   ~~~ \ttmkey{,}{reformatting}
				   ~~~ \ttmkey{;}{reformatting}
				   ~~~ \ttmkey{:}{reformatting}

\begin{indpar}[0.5em]
Here `\TT{--}' (or `\TT{---}'),
`\TT{,}', and `\TT{;}' (or `\TT{:}') have different
precedences, and so cannot appear together in the same expression.

The expression must have the form
\begin{center}
\{ {\em subexpression} {\em subexpression}\STAR{}
	{\em operator} \}\STAR{} {\em subexpression}\PLUS{}
\end{center}
where all the {\em operators} must be the same (i.e., if you
mix `\TT{;}' and `\TT{:}'
or `\TT{--}' and `\TT{---}' in the same expression, the expression
will be declared illegal by the reformatter).

That is, the expression
must consist of a sequence of non-empty {\em subexpression} lists
separated by {\em operators}.  The entire expression is reformatted as
a list whose
\TT{.separator} is the {\em operator}.  The elements of this list
are the lists that are the {\em subexpressions} between operators,
though if there
is only one {\em subexpression} between two operators, it becomes an
element of the final list.

\end{indpar}


\end{indpar}

\subsubsection{Standard Text Brackets}
\label{STANDARD-TEXT-BRACKETS}

\begin{center}

\begin{tabular}{l@{\hspace*{2em}}l}

bracket	& meaning 
\\[2ex]
\tttbkey{b} & boldface text (heavy weight) \\
\tttbkey{n} & normal text (normal weight) \\
\tttbkey{i} & italic text (TBD) \\
\tttbkey{r} & roman text (TBD) \\
\tttbkey{em} & emphasized text (TBD) \\
\tttbkey{table} & table (TBD) \\
\tttbkey{list} & list (TBD) \\
\tttbkey{g} & glued text (TBD) \\
\end{tabular}

\end{center}

\subsubsection{Text Mark Attributes}
\label{TEXT-MARK-ATTRIBUTES}

OBSOLETE - incorporate into above

\ikey{Text parsing}{text parsing} is performed by the \ttkey{-TEXT-PARSER-},
which is the parser for subexpressions of the
\TT{`}...\TT{'}, etc. matchfix operators.
The \TT{|} format separator and sentence and paragraph ends are
recognized by text processing, while
operators, qualifiers, qualifier shortcuts, and
the \TT{::?}, \TT{<:>}, \TT{::>}, \TT{@@}, and
\TT{??} marks are \underline{not} recognized.

Text parsing is normally done in the context of a pair of matched
{\em quotes}, and in this context {\em white-space} pre-lexemes
become lexemes.  Note that {\em white-space} lexemes all consist
of zero or more {\em vertical space} characters followed by zero or
more {\em single-space} characters (reference: TBD: make white space
lexemes sometimes?).
There are three kinds of {\em white-space} lexemes
used by text parsing:

\begin{list}{}{}

\item[{\bf Spacer Lexemes}.]
A \key{spacer} lexeme is a {\em white-space} lexeme containing
only single spaces.  Spacers are used in text parsing if they follow
a \TT{|} format separator on a line.

\item[{\bf Line Separator Lexemes}.]
A \key{line separator} lexeme is a {\em white-space}
lexeme that contains a single {\em line-feed} character and no other
{\em vertical-space} characters.  Such lexemes separate
non-blank lines, and are used by text parsing to end lines containing
a \TT{|} format separator.

\item[{\bf Blank Line Lexemes}.]
A \key{blank line} lexeme is a {\em white-space}
lexeme that contains either two or more {\em line-feed} characters or contains
a {\em vertical-space} character that is not a {\em line-feed} character.
Such lexemes
represent blank lines between non-blank lines, and are used by text parsing
both to end lines containing a \TT{|} format separator and
to separate paragraphs.

\end{list}

\subsubsection{Section, Paragraph, and Sentence Parsing}
\label{SECTION-PARAGRAPH-AND-SENTENCE-PARSING}

OBSOLETE - incorporate into above

If the text being parsed does not contain any format separators,
the text is parsed into phrases, sentences, and paragraphs.

First the text is divided by blank line lexemes into paragraphs.
The sequence of paragraphs comprises a section.

Then in each paragraph, sentence terminators are located.
White-space lexemes in the paragraph are deleted after sentence terminators
are located.
Each sequence
of lexemes or subexpressions ending in a sentence terminator
is made into a sentence, and any
non-empty sequence
of lexemes or subexpressions following the last sentence terminator
is made into a phrase.
The paragraph is then a sequence of zero or more sentences 
possibly followed by a phrase.  However, a paragraph cannot be empty.

The syntax of the result is:

\begin{indpar}
\emkey{section} ::= \TT{[-SECTION-} {\em paragraph}\PLUS{}
                  \TT{]} \\[1ex]
\emkey{paragraph}
	\begin{tabular}[t]{rl}
	::= &  \TT{[-PARAGRAPH-} {\em sentence}\PLUS{}
	       \TT{]} \\
	$|$ &  \TT{[-PARAGRAPH-} {\em sentence}\STAR{} {\em phrase}
	       \TT{]}
	\end{tabular} \\[1ex]
\emkey{sentence} ::= \TT{[-SENTENCE-} {\em sentence-non-terminator}\STAR{}
                                    {\em sentence-terminator}
                  \TT{]} \\[1ex]
\emkey{phrase}
	\begin{tabular}[t]{rl}
	::= &  \TT{[} \begin{tabular}[t]{@{}l@{}}
			{\em sentence-non-terminator}
			{\em sentence-non-terminator} \\
		        {\em sentence-non-terminator}\STAR{} \TT{]}
			\end{tabular} \\
	$|$ &  {\em sentence-non-terminator}
	\end{tabular} \\[1ex]
\emkey{sentence-terminator} ::= \TT{.} $|$
                              \TT{?} $|$
                              \TT{!} \\[1ex]
\emkey{sentence-non-terminator} ::= {\em symbol} $|$
                                  {\em subexpression}
\end{indpar}

Note that a {\em phrase} with more than one {\em sentence-non-terminator}
is a list, but a {\em phrase} with just one {\em sentence-non-terminator}
is not a list, but just the single {\em sentence-non-terminator} by itself.

There are several rules that modify the description just given:

{\bf Sentence Terminator Rule.}\index{Sentence Terminator Rule}
A \key{sentence-terminator} is any lexeme that is syntactically
a sentence terminator, that is not preceded by a {\em white-space}
lexeme, and that is followed by a {\em white-space} lexeme, a
{\em closing-mark} lexeme, or the
end of the lexeme sequence.  All other lexemes and all subexpressions are
\skey{sentence-non-terminator}s.

{\bf Initial Capitalization Rule.}\index{Initial Capitalization!Rule}
A {\em word} consisting of an initial capital letter followed
by zero or more lower case letters is converted
to an all lower case word if it begins a sentence.
A {\em word} consisting of an initial
\ttkey{\^~} followed by an upper
case letter followed by zero or more lower case letters has the
initial \TT{\^~} removed.

{\bf Text Simplification Rule.}\index{Text Simplification Rule}
If the \TT{-TEXT-PARSER-} is to return a {\em section} with just
one {\em paragraph} and that {\em paragraph} contains nothing but
just one {\em sentence} or {\em phrase},
then just the {\em sentence} or {\em phrase} is returned.
Otherwise, if a {\em section} with just one {\em paragraph} is
to be returned, just the {\em paragraph} is returned.


Some examples follow:

\begin{center}
\begin{tabular}{lcl}

\verb|`the wife of Bob'|
& parses as &
\verb|[-PHRASE- the wife of Bob]|
\\[2ex]
\verb|`She hit the ball.'|
& parses as &
\verb|[-SENTENCE- she hit the ball .]|
\\[2ex]
\begin{tabular}{@{}l@{}}
\verb|`^Bill swung.| \\
\verb|  But he missed!'|
\end{tabular}
& parses as &
\begin{tabular}{@{}l@{}}
\verb|[-PARAGRAPH-| \\
\verb|    [-SENTENCE- Bill swung .]| \\
\verb|    [-SENTENCE- but he missed !]]|
\end{tabular}
\\[5ex]
\begin{tabular}{@{}l@{}}
\verb|`^I liked| \\
\verb|  the party.| \\
\verb|| \\
\verb|  Later, we caught| \\
\verb|  the bus.'|
\end{tabular}
& parses as &
\begin{tabular}{@{}l@{}}
\verb|[-SECTION-| \\
\verb|   [-PARAGRAPH-| \\
\verb|      [-SENTENCE-| \\
\verb|          I liked the party .]]| \\
\verb|   [-PARAGRAPH-| \\
\verb|      [-SENTENCE-| \\
\verb|          later , we caught| \\
\verb|                  the bus .]]]| \\
\end{tabular}

\end{tabular}
\end{center}

Note that capitalized words like proper names and `\TT{I}' need to be
prefixed by `\TT{\^~}' if they begin a sentence or phrase.


\subsubsection{Text with Format Separators}
\label{TEXT-WITH-FORMAT-SEPARATORS}

TBD

\subsection{The Parsing Algorithm}
\label{THE-PARSING-ALGORITHM}
Parsing is done by a recursive descent left-to-right algorithm.
A parser is called to parse each subexpression.  This parser is
given the following explicit arguments:

\begin{center}
\begin{tabular}{l}
a list of lexemes to parse \\
an optional (closing) bracket definition \\
an optional (terminating) operator precedence \\
\end{tabular}
\end{center}

The bracket definition, if given, specifies a closing bracket
which must appear in the list of lexemes.  When the parser
finds this bracket outside other brackets, the parser terminates
the parse.

The operator precedence, if given, specifies that infix or
nofix operators of this and lower precedence will terminate the parsing if
they are encountered in the list of lexemes.

In addition the parser is given the following implicit
arguments:

\begin{center}
\begin{tabular}{l}
the parsing definition stack \\
the parsing selector set stack
\end{tabular}
\end{center}

The parser returns

\begin{center}
\begin{tabular}{l}
the parsed expression \\
the unparsed final segment of the input lexeme list
\end{tabular}
\end{center}

When parsing is terminated by finding a closing bracket matching
the closing bracket definition argument, then the part of the
input lexeme list after this closing bracket is returned as the
unparsed final segment of the input lexeme list.  When parsing is
terminated by finding a terminating operator of precedence equal to or lower
than an operator precedence argument, the part of the input
lexeme list beginning with this terminating operator is returned as the
unparsed final segment of the input lexeme list.  Otherwise the
returned unparsed final segment of the input lexeme list is empty.

There are two standard kinds of parser: the operator parser
and the text parser.  These use somewhat different algorithms.

\subsubsection{The Text Parser}
\label{TEXT-PARSER}

The text parser divides the input into paragraphs that are separated by
blank lines.

Paragraphs are classified as tabular or free-form according
to whether their first line is a tabular format line.
A \key{tabular format line} contains optional whitespace characters,
followed by a `\ttmkey{+}{in tabular format line}', followed
by any number of `\TT{+}' or
`\ttmkey{-}{in tabular format line}' characters,
followed by a `\TT{+}' that ends the line, except that superfluous
whitespace characters are allowed after the `line ending' {\tt+}.
An example of a tabular paragraph is:


\begin{indpar}\begin{verbatim}
+------------------------+--------+------+
 ice melt                 40 lbs    $4.50
 2x4's, 8ft               10       $27.70
 16d nails                 2 lbs     3.21
\end{verbatim}\end{indpar}


A paragraph that is not tabular is \ikey{free-form}{paragraph}.
Each free-form paragraph is scanned for explicitly bracketed subexpressions,
phrase separators, and sentence terminators.  The paragraph is divided into
sentences using sentence terminators outside brackets, and each sentence
is given \TT{<* *>} implicit brackets.
Each sentence is then divided into
phrases if it has any phrase separators, and 



\section{Expression Evaluation}
\label{EXPRESSION-EVALUATION}

An expression is evaluated by first searching for an expression definition
that matches the expression.  Expression definitions have patterns that
are matched to the expression.

An expression definition may have
qualifiers.  Some qualifiers are logical expressions that
must evaluate to true in order for the expression definition match to succeed.
Other qualifiers require that subexpressions match patterns or each other
in order for the expression definition match to succeed.
Still other qualifiers provide default values for missing
arguments.

An expression definition may have an expression block that executes
in order to produce a value for the expression if the definition
matches.  If a matching
expression definition has no expression block, the expression
evaluates to `\ttkey{true}'.  If no expression definition matches an
expression, the expression evaluates to `\ttkey{false}'.

Expression definitions are searched for in a context, which is a list
of expression definitions and pointers to other contexts.
Each point in the program has a lexical context, which is used by default
for expression evaluation. 
By default expressions are evaluated in the
lexical context of the place in the program code where the expression
appears.  In addition, there may be other
contexts in which expressions may be evaluated that effectively implement
either data bases or alternative programming languages.

When an expression definition is found whose pattern matches an expression,
a set of qualifiers are established that must be satisfied to
complete the match.  There are five kinds of qualifiers: syntax
equations, pattern equations, default equations, alternative
equations, and guards.
Syntax equations equate expressions that involve syntax variables,
which are names beginning with a \TT{\$} followed by a capital letter.
Pattern equations are like syntax equations but
involve a pattern which can represent one of many possible syntax
expressions.  Default equations assign values to those
syntax variables that where
discarded when a pattern was unfolded to become the syntax expression
it actually represented.  Alternative equations specify alternatives
for simple atomic clauses that may be in a pattern.
Guards are just expressions that must evaluate to
\TT{true} in order for the match to succeed.

The syntax equations are solved during the matching process,
to produce values for the syntax variables.  Patterns are unfolded during
the matching process to become the syntax expressions they represent.
Guards are evaluated, and in some cases the value of a syntax variable
value is evaluated.
If the syntax equations or pattern equations are inconsistent and
cannot be solved, or if a guard or syntax variable value that must be
evaluated cannot be evaluated, or if a guard evaluates to \TT{false},
the match fails.  Evaluation of the guards or syntax variable values
may result in additional matches which generate more
qualifiers involving more syntax variables.

The matching process must consider all possible choices of which definitions
to match to an expression being evaluated.  If all choices fail, the
expression evaluates to \TT{false}.  If only one choice succeeds, that
choice is used to evaluate the expression.  If several choices succeed,
the situation becomes ambiguous, and the evaluation proceeds according
to the matching mode, as is described below
(\secref{EXPRESSION-MATCHING-ALGORITHM}).

A syntax variable name beginning with
\ttmkey{\$}{in syntax variable name} denotes an unevaluated
expression.  The same name without the \TT{\$} denotes the value
of this unevaluated expression when it is evaluated
in the context in which the unevaluated expression appears.
This last value is called the `\key{evaluation}' of the unevaluated
expression.  Thus, for example, \TT{\$X} denotes an unevaluated
expression and \TT{X} denotes the evaluation of that expression.

As an example, given the syntax equation
\begin{center}
\verb|foo(2+2) :=: foo($X)|
\end{center}
(where \TT{:=:} means `is syntactically equal to'), we get
the syntax equation
\begin{center}
\verb|2+2 :=: $X|
\end{center}
that defines \TT{\$X}.  If there is then a guard `\TT{X is a number}',
the expression \TT{\$X}, namely `\TT{2+2}',
will be evaluated in its context, the context in which `\TT{foo(2+2)}'
appeared, to produce the value \TT{4}, which will become the value of
\TT{X}, so the guard will become `\TT{4 is a number}'.

An expression cannot be evaluated if it contains any undefined syntax
variables.  For example, if we began with the syntax equation
\begin{center}
\verb|foo(2+$Y) :=: foo($X)|
\end{center}
and guard `\TT{X is a number}', \TT{\$X} would be `\TT{2+\$Y}' which
could not be evaluated.  If at some later time in the matching process
the syntax equation
\begin{center}
\verb|$Y :=: 7|
\end{center}
is generated, then the value of \TT{\$X} becomes `\TT{2+7}'
which can now be evaluated to produce the value \TT{9} for \TT{X}
and allow the guard to become `\TT{9 is a number}'.

In the above \TT{\$X} is an `unevaluated syntax variable' and
\TT{X} is its `associated' `evaluated syntax variable'.  It is
possible to use \TT{X} in a definition where \TT{\$X} is actually
meant, but if that is done once, then it must be done for every occurrence
of \TT{\$X} in the definition, and the only computation that may be
performed on the (unevaluated) value of \TT{\$X} is to evaluate it to
produce a value for \TT{X}.

Except for choices of which definitions to match to which expressions,
the entire matching process is monotonic.  This means the order in which
syntax equations are solved, patterns are unfolded, guards are evaluated,
and unevaluated syntax variable values are evaluated does not matter.

In order to make the matching process monotonic, pattern unfolding must
be monotonic.  This means that if undefined syntax variables in a pattern
equation whose pattern has been unfolded are given arbitrary values later,
the pattern unfolding must still be valid and unambiguous.

Similarly guard evaluations must not have side effects.  In other
words, evaluating a guard cannot affect any future valuations.
Side effects can only occur during block execution, so any blocks
executed during the guard evaluation process must not have side effects.

Lastly, required evaluations of unevaluated syntax variable values
must be monotonic.  For example, given the syntax variable \TT{\$X},
if the value of \TT{X} is required, the evaluation of the value of
\TT{\$X} must be monotonic.
In order to ensure this, an unevaluated expression is not evaluated until
all syntax variables it contains have been given values, so that
the expression to be evaluated does not contain any undefined syntax
variables.  Furthermore, evaluation of such an expression may not have
side effects.  Again this last means that any blocks executed during
the evaluation of the expression must not have side effects.
If an evaluation is needed, but the expression to be evaluated contains
a syntax variable that never becomes defined,
then the matching process fails for the expression definition, just as it
would if a guard evaluated to false.

\subsection{Expression Definitions}
\label{EXPRESSION-DEFINITION}

\ikey{Expression definitions}{expression definition} have the syntax:

\begin{indpar}
\emkey{expression-definition} ::=
	{\em pattern} \TT{<-{}-} {\em qualifier-list}\QMARK{}
	                         {\em block}\QMARK{} \\[1ex]
\emkey{pattern} ::= see \pagref{PATTERN}] \\[1ex]
\emkey{qualifier-list}
    ::= {\em qualifier} \{ \TT{,} {\em qualifier} \}\STAR{} \\[1ex]
\emkey{qualifier} ::= {\em syntax-equation}
		       \begin{tabular}[t]{@{}l@{}}
		       $|$ {\em pattern-equation} $|$ {\em default-equation} \\
		       $|$ {\em alternative-equation} $|$ {\em guard}
		       \end{tabular} \\[1ex]
\emkey{syntax-equation} ::= {\em syntax-expression}
		\TT{:=:} {\em syntax-expression}
	        ~~~ [see \pagref{SYNTAX-EQUATIONS}]
	 	\\[1ex]
\emkey{pattern-equation} ::= {\em syntax-expression}
		\TT{:=\TILDE} {\em pattern}
	        ~~~ [see \pagref{PATTERN-EQUATIONS}]
		\\[1ex]
\emkey{default-equation} ::= {\em syntax-variable}
		\TT{:=?} {\em syntax-expression}
	        ~~~ [see \pagref{DEFAULT-EQUATIONS}]
		\\[1ex]
\emkey{alternative-equation} ::= \\
\hspace*{3em}{\em syntax-variable}
		\TT{:=|} {\em alternative}
		          \TT{|} {\em alternative}
			  \{ \TT{|} {\em alternative} \}\STAR{}
	                  ~~~ [see \pagref{ALTERNATIVE-EQUATIONS}]
		\\[1ex]
\emkey{alternative} ::= {\em name} ~~~ [see \pagref{NAME}]
		\\[1ex]
\emkey{guard} ::= {\em subexpression} \\[1ex]
\emkey{block} ::= \TT{\{~\}} $|$ \TT{\{} {\em statement}
                           \{ \TT{;} {\em statement} \}\STAR{} \TT{\}}
	    \\[1ex]
{\em statement} ::= see \pagref{STATEMENT}
\end{indpar}

The \mkey{pattern}{in expression definition} of an expression definition
is the subexpression before the \TT{<-{}-}.  If the expression definition
with pattern $p$ is being matched to the expression $e$,
the pattern equation $e$ \TT{:=\TILDE} $p$ is asserted and
alternative equations are used to unfold the pattern.  If this
match succeeds, syntax and pattern equation qualifiers in the definition
are asserted, and the definition guards are required to evaluate
to \TT{true}.
Default equations are asserted as necessary.

Just before an expression definition is matched to an expression, the
definition is copied, and the act of copying 
creates a new set of variables that are distinct from any
previous variables.  Thus if \TT{\$X} appears in a definition, each
use of the definition will involve a \underline{different}
variable named \TT{\$X}.

\subsection{Syntax Equations}
\label{SYNTAX-EQUATIONS}

Although pattern equations are asserted before syntax equations are asserted,
a knowledge of syntax equations is required to understand pattern
equations.

A \key{syntax equation} asserts syntactic identity between two
\skey{syntax expression}s.  A syntax expression is a syntax variable,
an atom, or an object whose attribute values are single valued with
these values being syntax expressions.
Atoms are represented by {\em atom-names} (\pagref{ATOM-NAME})
and objects by {\em bracketed-lists} (\pagref{BRACKETED-LIST})
where \TT{\{|~|\}} brackets may be omitted if the object representation
is surrounded by operators or other suitable delimiters (see \pagref{TBD}).

The syntax of a syntax equation is:

\begin{indpar}
\emkey{syntax-equation} ::= {\em syntax-expression} \ttkey{:=:}
			    {\em syntax-expression}
			    \\[1ex]
\emkey{syntax-expression} ::= {\em syntax-variable}
			   $|$ {\em atom} $|$ {\em syntax-object}
			   \\[1ex]
\emkey{syntax-variable}\label{SYNTAX-VARIABLE}
			\begin{tabular}[t]{rl}
			::= & \TT{\$} {\em capitalized-word }
				as a single lexeme \\
			$|$ & \TT{\$} \TT{(} {\em name} beginning with
			      {\em capitalized-word } \TT{)} \\
			$|$ & {\em place-holding-syntax-variable} \\
			$|$ & {\em evaluated-syntax-variable} \\
			\end{tabular} \\[1ex]
{\em capitalized-word} ::= {\em word} beginning with capitalized letter
				in which all letters are capitalized \\[1ex]
\emlkey{place-holding}{-syntax-variable} ::= \TT{\$\$}
	~~~ [see \secref{PLACE-HOLDING-SYNTAX-VARIABLES}] \\[1ex]
\emlkey{evaluated}{-syntax-variable} ::= {\em capitalized-word}
	~~~ [see \secref{EVALUATED-SYNTAX-VARIABLES}] \\[1ex]
\emkey{atom}\label{ATOM-REPRESENTATION}
    ::= {\em atom-name} \\[1ex]
\emkey{syntax-object}\label{SYNTAX-OBJECT}
    ::= \begin{tabular}[t]{@{}l@{}}
        {\em object} with single valued attributes \\
	whose attribute values are {\em syntax-expressions}
	\end{tabular}
\end{indpar}

All the different forms of {\em syntax-variable} are abbreviations
for the form:
\begin{center}
\TT{\$(}{\em name} beginning with {\em captitalized-word}\TT{)}
\end{center}
A syntax variable of the form \TT{\$}{\em captitalized-word}
abbreviates \TT{\$(}{\em captitalized-word}\TT{)}.

Syntax equations can be consistent or inconsistent according to the:

\begin{indpar}
\begin{list}{}{}
\item[\ikey{Syntax Equation Consistency Rules}%
           {consistency rules!syntax equation}%
	   \label{SYNTAX-EQUATION-CONSISTENCY-RULES}:]~

\begin{enumerate}
\item If either syntax expression has both an \TT{.initiator} equal to \TT{"("}
and a \TT{.ter\-min\-a\-tor} equal to \TT{")"}, its \TT{.initiator} and
\TT{.terminator} attributes are removed and these rules are applied to the
result.
\item If either syntax expression is an object with only a single attribute
that is a list element,
the object is replace by this list element,
and these rules are applied to the
result.
\item If one syntax expression is a syntax variable, the syntax equation
is consistent.
\item If the two syntax expressions are both atoms and these atoms are
equal, the syntax equation is consistent.
\item If the two syntax expressions are both objects, and these objects
have the same attributes (including the same number of list elements),
the syntax expression is consistent and the Propagation Rule
below is applied.
\item If the two syntax expressions are both objects, these objects
have some non-list element attributes, and both objects have the same
non-list element attributes,
the syntax expression is consistent and the Propagation Rule
below is applied.
\end{enumerate}

Syntax equations that are not consistent are \key{inconsistent}.

Note that rules (1) and (2) may be applied recursively
before the other rules are applied.
\end{list}
\end{indpar}

Thus the following are examples:

\begin{center}
\begin{tabular}{r@\TT{~:=:~}ll}
\verb/5/ & \verb/6/      & inconsistent; Rule (4) fails \\
\verb/5/ & \verb/5/      & consistent by Rule (4) \\
\verb/5/ & \verb/{|5|}/  & consistent by Rules (2) and (4) \\
\verb/5 + 6/ & \verb/$X/ & consistent by Rule (3) \\
\verb/5 + 6/ & \verb/($X)/ & consistent by Rules (1) and (3) \\
\verb/5 + 6/ & \verb/A + B/ & consistent by Rule (5) \\
\verb/[5 + 6]/ & \verb/[$X]/ & consistent by Rule (6) \\
\verb/[5, 6]/ & \verb/{{A, B, C}}/ & consistent by Rule (6) \\
\end{tabular}
\end{center}

The following rule is applied when two objects are consistent according
to Syntax Equation Consistency Rules (5) or (6):

\begin{indpar}
\begin{list}{}{}
\item[\ikey{Syntax Equation Propagation Rules}%
           {propagation rules!syntax equation}:]%
	   \label{SYNTAX-EQUATION-PROPAGATION-RULES}
From a consistent syntax equation asserting the identity
of two objects new equations are deduced as follows:
\begin{enumerate}
\item
If consistency was deduced according to Syntax Equation Consistency Rule (5),
a new equation is deduced for every attribute label shared by the two objects.
Given such an attribute label, the values
of the attribute for the two objects are asserted to be syntactically
identical.
\item
If consistency was deduced according to Syntax Equation Consistency Rule (6),
a new equation is deduced for every non-list-element
attribute label shared by the two objects.
Given such an attribute label, the values
of the attribute for the two objects are asserted to be syntactically
identical.

\medskip

An additional syntax equation is asserted between the two objects
with all their non-list-element attributes removed.
\end{enumerate}

The deduced equations need not be consistent in order to be deduced.
\end{list}
\end{indpar}

For example, from

\begin{center}
\verb/{| sort ($X) | foo = 5 } :=: {| sort ( 5 + 6 ) | foo = 10 }/
\end{center}

we can deduce by propagation that

\begin{center}
\begin{tabular}{r@\TT{~:=:~}l}
\verb/sort/ & \verb/sort/ \\
\verb/($X)/ & \verb/( 5 + 6 )/ \\
\verb/5/ & \verb/10/
\end{tabular}
\end{center}

The deduced equations need not be consistent in order to be deduced.
In this case the first two equations are consistent and the third is not.

In addition to the Propagation Rule, we apply the following, where
$e_1$, $e_2$, and $e_3$ are subexpressions of the original
syntax equations:

\begin{indpar}
\begin{list}{}{}
\item [\ikey{Subexpression Symmetry Rule}{subexpression!symmetry rule}:]%
\label{SUBEXPRESSION-SYMMETRY-RULE}
From $e_1$ \TT{:=:} $e_2$ we deduce $e_2$ \TT{:=:} $e_1$.

\item [\ikey{Subexpression Transitivity Rule}%
            {subexpression!transitivity rule}:]%
\label{SUBEXPRESSION-TRANSITIVITY-RULE}
From $e_1$ \TT{:=:} $e_2$ and $e_2$ \TT{:=:} $e_3$
we deduce $e_1$ \TT{:=:} $e_3$.

\end{list}
\end{indpar}

It is very important to notice that so far each subexpression of an
original syntax equation is distinct in all the deduced equations.
In particular, two different subexpressions
are not necessarily \TT{:=:} even if they are syntactically the same.
For example, given the original syntax equation:

\begin{center}
\verb/sort ($X, $Y) :=: sort ( 5, 5 )/
\end{center}

we derive by propagation that

\begin{center}
\begin{tabular}{r@\TT{~:=:~}l}
\verb/sort/ & \verb/sort/ \\
\verb/,/ & \verb/,/ \\
\verb/$X/ & \verb/5/$^1$ \\
\verb/$Y/ & \verb/5/$^2$ \\
\end{tabular}
\end{center}

where we have put superscripts $^1$ and $^2$ on the two \TT{5}'s to
indicate that they are different subexpressions of the original
syntax equations.  But our rules do \underline{not}
generate the syntax equation \TT{5$^1$ :=: 5$^2$} and as a consequence
they \underline{cannot} generate \TT{\$X := \$Y}.

There is one last rule.  Given subexpressions $v_1$, $v_2$,
$e_1$, and $e_2$ of the original syntax equations:

\begin{indpar}
\begin{list}{}{}
\item [\ikey{Syntax Variable Identity Rule}%
            {syntax variable!identity rule}:]%
\label{SYNTAX-VARIABLE-IDENTITY-RULE} ~\\
If $v_1$ and $v_2$ name the same syntax variable, \\
then from $v_1$ \TT{:=:} $e_1$ and $v_2$ \TT{:=:} $e_2$
we deduce $e_1$ \TT{:=:} $e_2$.

\end{list}
\end{indpar}

This if we modified the above example to:

\begin{center}
\verb/sort ($X, $X) :=: sort ( 5, 5 )/
\end{center}

we derive by propagation that

\begin{center}
\begin{tabular}{r@\TT{~:=:~}l}
\verb/sort/ & \verb/sort/ \\
\verb/,/ & \verb/,/ \\
\verb/$X/ & \verb/5/$^1$ \\
\verb/$X/ & \verb/5/$^2$ \\
\end{tabular}
\end{center}

and by syntax variable identity that

\begin{center}
\begin{tabular}{r@\TT{~:=:~}l}
\verb/5/$^1$ & \verb/5/$^2$ \\
\end{tabular}
\end{center}

since both occurances of \TT{\$X} are identified.
This last is consistent.

But if instead we started we started instead with:

\begin{center}
\verb/sort ($X, $X) :=: sort ( 5, 6 )/
\end{center}

we would end with:

\begin{center}
\begin{tabular}{r@\TT{~:=:~}l}
\verb/5/ & \verb/6/ \\
\end{tabular}
\end{center}

which is inconsistent.

We have given all the deduction rules used to solve syntax equations.
Note that these rules do \underline{not} create new syntax expressions:
all the syntax expressions in any deduced equation were subexpressions
in previous equations.  Because of this,
an algorithm that keeps making deductions until
no new deductions can be made will stop quite quickly.

\subsection{Patterns}
\label{PATTERNS}
\label{PATTERN-EQUATIONS}

A \emkey{pattern} is an object that represents one of
a set of syntax expressions.  Patterns are used in
{\em pattern-equations}, which identify a {\em syntax-expression} with
a {\em pattern}.  The syntax of a pattern equations and patterns is:

\begin{indpar}
\emkey{pattern-equation} ::= {\em syntax-expression} \ttkey{:=\TILDE}
			    {\em pattern}
\\[1ex]
\emkey{pattern} \begin{tabular}[t]{@{}rl}
                ::= & {\em pattern-object} \\
		$|$ & {\em syntax-expression}
		      that is not a {\em pattern-object}
		\end{tabular}
\\[1ex]
\emkey{pattern-object} ::= {\em object}
		           \begin{tabular}[t]{l}
			   all of whose attributes have single values, \\
		           whose list portion is a {\em pattern-list}, \\
		           and whose non-list-element attribute values \\
		           are {\em patterns} \\
		           \end{tabular}
\\[1ex]
\emkey{pattern-list} ::=
    \begin{tabular}[t]{l}
    {\em pattern-term}
        \{ {\em pattern-separator} {\em pattern-term} \}\STAR{} \\
    \end{tabular}
\label{PATTERN}
    \\[1ex]
\emkey{pattern-separator} ::= \ttmkey{\TILDE}{pattern separator} \\[1ex]
\emkey{pattern-term} ::= {\em pattern-clause} {\em pattern-qualifier}\QMARK{}
	\\[1ex]
\emkey{pattern-clause} ::= {\em pattern-factor}\PLUS{} ~~~ [see text]
	\\[1ex]
\emkey{pattern-factor} ::= {\em atom-name}
		       $|$ {\em syntax-variable}
		       $|$ {\em bracketed-pattern}
       \\[1ex]
\emkey{bracketed-pattern} ::= {\em pattern} with \TT{.initiator} and
                              \TT{.terminator} attributes
       \\[1ex]
\emkey{pattern-qualifier} ::=
		           \ttmkey{?}{pattern qualifier}
		       $|$ \ttmkey{??}{pattern qualifier}
		       $|$ \ttmkey{...}{pattern qualifier}
		       $|$ \ttmkey{...?}{pattern qualifier}
\end{indpar}

A `\mkey{key}{of a pattern clause}' of a {\em pattern-clause}
an {\em atom-name} that is a {\em pattern-factor} in the clause
or in one of the alternatives of
an {\em alternative-syntax-variable} that is in the clause
(an {\em alternative-syntax-variable} is replaced by one of its
alternatives when the pattern is unfolded: see 
\itemref{ALTERNATIVE-EQUATIONS}),
or a key may be an {\em object} with an
\TT{.initiator} other than \TT{"("}
that is a {\em pattern-factor}
in the clause (informally the \TT{.initiator} is the key).

\begin{enumerate}

\item Every {\em pattern-clause} must contain a key.

\item The first {\em pattern-term} of a {\em pattern}
may not have any {\em pattern-qualifier} other than `\TT{...}'
(so the first {\em pattern-clause} must be copied at the beginning
of the unfolded pattern).

\end{enumerate}

For example, the {\em pattern}

\begin{center}
\verb/replace ($X) ~ in ($Y) ~ by ($Z) ?/
\end{center}

contains the following keys: \TT{replace}, \TT{in}, and \TT{by}.

A pattern represents one of many possible syntax expressions, which are
called `\skey{unfolded pattern}s' or `\skey{unfolding}s' of the pattern,
and are made by concatenating the
{\em pattern-clauses} in different ways.  For example,
the {\em pattern} just given has three unfoldings:

\begin{center}
\verb/replace ($X) in ($Y) by ($Z)/ \\
or \\
\verb/replace ($X) by ($Z) in ($Y)/  \\
or \\
\verb/replace ($X) in ($Y)/ 
\end{center}

The rules for unfolding are:

\begin{indpar}
\begin{list}{}{}
\item[\ikey{Pattern Unfolding Rules}%
           {pattern unfolding rules}%
	   \index{unfolding rules}%
	   \label{PATTERN-UNFOLDING-RULES}:]~

\begin{enumerate}

\item An unfolding of a {\em pattern} is a sequence of copies of
{\em pattern-clauses} from the {\em pattern} taken in any order,
\underline{except} a copy of the first {\em pattern-clause} in the
{\em pattern} must be first in the unfolded {\em pattern}.
No {\em pattern-separators} or {\em pattern-qualifiers} are included
in the unfolded {\em pattern}.

\item A {\em pattern-clause} not followed by a {\em pattern-qualifier}
(\TT{?}, \TT{??}, \TT{...}, or \TT{...?})
in the {\em pattern} must be copied exactly
once in the unfolded {\em pattern}.

\item A {\em pattern-clause} followed by `\TT{?}'
in the {\em pattern} is an \key{optional pattern clause}
and must be copied exactly once or not at all
in the unfolded {\em pattern}.
See \secref{DEFAULT-EQUATIONS} for examples.

\item\label{OPTIONAL-TRUTH-VALUE-CLAUSE-RULE}
A {\em pattern-clause} followed by `\TT{??}'
in the {\em pattern} is an
\ikey{optional truth-value pattern clause}{optional truth-value!pattern clause}.
It must end with a {\em pattern-factor} of the form
`\TT{(} {\em syntax-variable} \TT{)}'.
Like an optional {\em pattern-clause}, this {\em pattern-clause}
must be copied exactly once or not at all
in the unfolded {\em pattern}.  The copy may omit the last
{\em pattern-factor}, in which case the omitted {\em syntax-variable}
will default to `\TT{TRUE'}.
Or the copy may both omit the last factor and add the factor
`\ttmkey{not}{in optional truth-value!pattern clause copy}' to the beginning
of the copy, in which case the omitted {\em syntax-variable}
will default to `\TT{FALSE}'.
See \secref{OPTIONAL-TRUTH-VALUE-PATTERN-CLAUSES} for examples.

\item A {\em pattern-clause} followed by `\TT{...}'
in the {\em pattern} is a \key{repeated pattern clause}
and must be copied one or more times
in the unfolded {\em pattern}.
See \secref{REPEATED-PATTERN-CLAUSES} for examples.

\item A {\em pattern-clause} followed by `\TT{...?}'
in the {\em pattern} is an \lkey{optional repeated}{pattern clause}
and must be copied one or more times or not at all
in the unfolded {\em pattern}.
See \secref{REPEATED-PATTERN-CLAUSES} for examples.

\item A {\em syntax-variable} in a {\em pattern}
that appears in an {\em alternative-equation}
is called an \key{alternative-syntax-variable} and must be replaced
in the unfolded {\em pattern}
by one of the {\em alternatives} from the {\em alternative-equation}.
These {\em alternatives} are sequences of {\em atoms}.
If the replacement is a sequence of more than one atom, the replacement
atoms are inserted in the unfolded pattern increasing the length of
the unfolded pattern (and not simply replacing
the {\em alternative-syntax-variable} by a single list object).
See \secref{ALTERNATIVE-EQUATIONS} for examples.

\item An attribute that does \underline{not} have the \TT{?} attribute flag
must appear exactly once in the unfolded {\em pattern}.

\item An attribute that \underline{does} have the \TT{?} attribute flag
and must appear exactly once or not at all
in the unfolded {\em pattern}.

\end{enumerate}

\end{list}
\end{indpar}

A consistent pattern equation produces a unique matching between
the syntax expression on the right and an unfolding of the pattern
on the left.  Matching makes use of the concept of a
`\mkey{terminating key}{of a pattern}' of a {\em pattern}.  This is
just a key of the {\em pattern} that can follow a `\TT{(~)}' bracketed
element in an unfolding of the {\em pattern}.  For example, given
the pattern

\begin{center}
\verb/replace ($X) ~ $WHERE ? ~ in ($Y) ~ by ($Z) ?/
\end{center}

with \TT{\$WHERE} being an {\em alternative-syntax-variable}
(see \secref{ALTERNATIVE-EQUATIONS} for details)
defined by

\begin{center}
\verb/$WHERE :=: everywhere | at beginning | at end/
\end{center}

then the following are terminating keys of the pattern: \TT{everywhere},
\TT{at}, \TT{in}, \TT{by}.



The rules governing the formation of the matching are:

\begin{indpar}
\begin{list}{}{}
\item[\ikey{Pattern Matching Rules}%
           {pattern matching rules}%
	   \index{matching rules}%
	   \label{PATTERN-MATCHING-RULES}:]~

\begin{enumerate}

\item If a syntax expression (equation left side) is not an object
(it is a single atom or a syntax variable)
it is replaced by a list object containing as its
sole attribute a single list element equal to the original syntax expression
before it is matched.

\item A matching is an order-preserving
1-1 correspondence between all the the list elements of
the unfolded pattern (right side)
and sequences of list elements of the syntax expression (left side).
Each list element of the syntax expression must be included in
one of the matched sequences.

\item Each atom of the pattern is matched to an identical atom of the
syntax expression.

\item Each object of the pattern that does not have
an \TT{.initiator} equal to \TT{"("},
or which has a terminator that is not \TT{")"} or
some other non-list-element attribute other than \TT{.separator},
is match\-ed to a single element of the of the syntax expression
that is also an object.  Both objects must have the same
\TT{.initiator} and \TT{.terminator} values.  The pattern object
must have every
non-list-element attribute that the syntax expression has.
The syntax expression must have every non-list-element attribute that
the pattern has unless the pattern attribute has the `\TT{?}' attribute
flag.

\item Each object of the pattern whose \TT{.initiator} \underline{is}
\TT{"("}, whose \TT{.ter\-min\-a\-tor} \underline{is} \TT{")"},
and which has \underline{no other} non-list-element attributes,
is either matched as in (4), or this object
is matched to a (possibly empty)
sequence of elements of the syntax expression such that
the sequence contains no element that could be matched to any
terminating key of the original folded pattern, and no element
that is a syntax variable, and the sequence is
followed by (a) the end of the syntax expression, or (b)
an syntax expression element matched using rules (3) or (4).

\medskip

Not allowing a syntax expression element
sequence around which parentheses have been omitted
to contain any initial key of the original unfolded pattern means
that no pattern clause of the original unfolded pattern could
possibly match some part of the syntax expression that overlapped
the sequence.

\end{enumerate}

\end{list}
\end{indpar}

Then the pattern equation consistency rule is:

\begin{indpar}
\begin{list}{}{}
\item[\ikey{Pattern Equation Consistency Rule}%
           {pattern equation!consistency rule}:] ~\\
A pattern equation is \key{consistent} if either:
\begin{enumerate}
\item
Its right side is not a {\em pattern-object}, but if the
pattern equation is changed to a syntax equation by
replacing \TT{:=\TILDE} by \TT{:=:}, the syntax equation is consistent.
\item
Its right
side is a {\em pattern-object} and
the syntax expression on the left side is not a syntax
variable or an object containing a list element that is
a syntax variable.  Then the pattern equation is consistent if
the pattern has a unique unfolding such that there is a matching,
and that matching is unique for the given unfolding.

\medskip

If the syntax expression on the left side contains a syntax
variable or an object list element that is a syntax variable,
processing the pattern equation is delayed until these
syntax variables are given values, which are then substituted
into the pattern equation.  However, if there is no longer
any possiblity of one of these syntax variables getting a value,
the pattern equation is declared to be inconsistent.

\end{enumerate}

\end{list}
\end{indpar}

The following rule is applied when two list elements match according
to Pattern Equation Consistency Rules:

\begin{indpar}
\begin{list}{}{}
\item[\ikey{Pattern Equation Propagation Rules}%
           {propagation rules!pattern equation}:]%
	   \label{PATTERN-EQUATION-PROPAGATION-RULES}
When a pattern equation is consistent, the following
deduce new pattern equations or syntax equations.

\begin{enumerate}

\item
If the pattern equation was replaced by a syntax equation according to
Pattern Equation Consistency Rule (1), new syntax equations are deduced
as per the Syntax Equation Propagation Rules
(\pagref{SYNTAX-EQUATION-PROPAGATION-RULES}).

\item
If consistency was deduced according to Pattern Equation Consistency Rule (2),
and bracketed list elements were matched according to Pattern Matching Rule (4),
a new pattern equation is deduced for every non-list-element
attribute label shared by the two matched bracketed lists.
Given such an attribute label, if its value in the syntax expression is
\TT{S} and its value in the pattern is \TT{P} the pattern equation
\TT{S :=\TILDE{} P} is asserted.

\medskip

An additional pattern equation is asserted between the two bracketed lists
with all their non-list-element attributes removed.


\item
If consistency was deduced according to Pattern Equation Consistency Rule (2),
and a pattern bracketed list element was matched to a sequence of
syntax expression elements according to Pattern Matching Rule (5),
a new pattern equation is deduced between the sequence of syntax expression
elements, made into an unbracketed list, and the pattern bracketed list
with its bracket attributes removed.

\end{enumerate}

The deduced equations need not be consistent in order to be deduced.
\end{list}
\end{indpar}

Besides the unfolding, pattern equations differ from syntax equations
in that they permit \TT{(~)} parentheses to be omitted from the
syntax expression if the latter does not contain any terminating keys.
For example,

\begin{center}
\verb/sin my variable :=~ sin ($X)/
\end{center}

matches and deduces

\begin{center}
\verb/my variable :=: $X/
\end{center}

As another example, given the pattern equation:

\begin{indpar}
\verb/replace {{b}} by {{5 + c}} in (exp 1) :=~/ \\
\verb/    replace ($X) ~ in ($Y) ~ by ($Z) ?/
\end{indpar}

The pattern may be unfolded so the equation becomes:

\begin{indpar}
\verb/replace {{b}} by {{5 + c}} in (exp 1) :=~/ \\
\verb/    replace ($X) by ($Z) in ($Y)/
\end{indpar}

from which we deduce using the Pattern Propagation Rule:

\begin{center}
\begin{tabular}{r@{\TT{~:=\TILDE~}}l}
\verb/{| {{b}} |}/ & \verb/$X/ \\
\verb/{| {{5 + c}} |}/ & \verb/$Z/ \\
\verb/exp 1/ & \verb/$Y/ \\
\end{tabular}
\end{center}

Note that this results in pattern equations and \underline{not}
syntax equations.  But when we apply the Pattern Equation Consistency Rules
to these equations, they first turn into syntax equations, and then
the Syntax Consistency Rules eliminate the superfluous \TT{\{|~|\}}'s
giving:

\begin{center}
\begin{tabular}{r@{\TT{~:=:~}}l}
\verb/{{b}}/ & \verb/$X/ \\
\verb/{{5 + c}}/ & \verb/$Z/ \\
\verb/exp 1/ & \verb/$Y/ \\
\end{tabular}
\end{center}


The matching algorithm in Section \itemref{EXPRESSION-MATCHING-ALGORITHM}
starts with a single pattern equation.  It checks this for
consistency, and if consistent, deduces new equations by
propagation.  Each deduced equation is then checked for
consistency, and more equations are deduced.  The process
stops quickly because no new syntax expressions or pattern
expressions are created.  If an inconsistent equation is
discovered, the process fails.  Otherwise when the process
ends any syntax variables in the original have been assigned
values or may be given default values.

\subsection{Expression Definition Matching}

When an expression is to be evaluated,
various candidate expression definitions are examined
to see if any match the expression.  This process of matching
an expression and an expression definition is as follows.

First a copy of the expression definition is made with
each syntax variable replaced by a new syntax variable that
is distinct from every other syntax variable.

Then a pattern equation of the form
\begin{center}
{\em expression-to-be-evaluated} \TT{:=\TILDE}
{\em expression-definition-pattern}
\end{center}
is asserted, and along with all the {\em qualifiers} in the
expression definition.

The consistency of these equations is determined, and new equations
are deduced using propagation and some other qualifier related
rules described below.
If no inconsistent equations are deduced, the match succeeds.
Otherwise the match fails.

The following sections describe different types of {\em qualifiers}
and some other specialized aspects of this matching process. 

\subsubsection{Default Equations}
\label{DEFAULT-EQUATIONS}

When a pattern is unfolded, syntax variables in optional pattern clauses
not included in the unfolded pattern are given default values
provided by default equation qualifiers.  These qualifiers have the
syntax:

\begin{indpar}
\emkey{default-equation} ::= {\em syntax-variable} \ttkey{:=?}
			     {\em default-value}
\\[1ex]
\emkey{default-value} ::= {\em syntax-expression}
\end{indpar}

For example, given the equations:

\begin{center}
\begin{tabular}{rcl}
\verb/sort x/ & \TT{:=\TILDE} & \verb/sort ($X) ~ in direction ($Y) ?/ \\
\verb/$Y/ & \tt :=? & \verb|ascending|
\end{tabular}
\end{center}

the pattern in the first equation will be unfolded to give the equation:

\begin{center}
\begin{tabular}{rcl}
\verb/sort x/ & \TT{:=\TILDE} & \verb/sort ($X)/ \\
\end{tabular}
\end{center}

and because the variable \TT{\$Y} was dropped during the unfolding,
the default equation that defines it will promoted to become the syntax
equation:

\begin{center}
\begin{tabular}{rcl}
\verb/$Y/ & \tt :=: & \verb|ascending|
\end{tabular}
\end{center}

thereby establishing a value for \TT{\$Y}.  Default equations that
are not promoted to become syntax equations by this mechanism are
ignored.  This mechanism does \underline{not} apply to repeated pattern
clauses or optional repeated pattern clauses.

\subsubsection{Alternative Equations}
\label{ALTERNATIVE-EQUATIONS}

An {\em alternative-equation} specifies that a syntax variable must take
one of several alternative values.

\begin{indpar}
\emkey{alternative-equation} ::= \\
\hspace*{3em}{\em syntax-variable}
		\TT{:=|} {\em alternative}
		          \TT{|} {\em alternative}
			  \{ \TT{|} {\em alternative} \}\STAR{}
		\\[1ex]
\emkey{alternative} ::= {\em atom}\PLUS{}
\end{indpar}

For example,
\begin{center}
\verb/DIRECTION :=| in ascending order | in descending order/
\end{center}

Note that the {\em alternatives} are simple {\em atom} sequences,
and cannot include more complex objects or {\em syntax-var\-i\-ables}.

The {\em syntax-variable} in an alternative equation is called an
\key{alternative-syntax-variable}.  When such a variable appears
in a pattern it must be replaced by one of the {\em alternatives}
from the {\em alternative-equation} when the pattern is unfolded.
The replacing {\em alternative} is integrated into the unfolded
pattern as a sequence of elements (and \underline{not} a single element that
is a list of atoms) replacing the {\em alternative-syntax-variable}
in the pattern.

For example, given the above {\em alternative-equation} and the
{\em pattern-equation}
\begin{center}
\verb/sort my data in descending order :=~ sort ($X) ~ $DIRECTION ?/
\end{center}
the pattern in thus equation can be unfolded to make the {\em pattern-equation}
\begin{center}
\verb/sort my data in descending order/ \\
\verb/:=~ / \\
\verb/sort ($X) in descending order/
\end{center}

that is consistent.  Note that in the {\em pattern} the atom
`\TT{in}' is a terminating key, and so
cannot be part of the list of elements matched to \TT{\$X}.

Whenever a pattern containing a {\em alternative-syntax-variable}
is unfolded, a particular {\em alternative} replaces the
variable in the pattern, and the syntax equation
\begin{center}
{\em alternative-syntax-variable} \TT{:=:} {\em alternative}
\end{center}
is asserted.  Thus in the above
example where the pattern was unfolded, the equation
\begin{center}
\verb/$DIRECTION :=: in descending order/
\end{center}
is asserted.

A default equation can also be given for an {\em alternative-syntax-variable}.
Thus if in our example
\begin{center}
\verb/$DIRECTION :=? in ascending order/
\end{center}
were also asserted, then from the pattern equation
\begin{center}
\verb/sort my data :=~ sort ($X) ~ $DIRECTION ?/
\end{center}
on would deduce among other things:

\begin{center}
\verb/$DIRECTION :=: in ascending order/
\end{center}



\subsubsection{Optional Truth-Value Pattern Clauses}
\label{OPTIONAL-TRUTH-VALUE-PATTERN-CLAUSES}

An \ikey{optional truth-value pattern clause}%
{optional truth-value!pattern clause}%
\index{truth-value!pattern clause}%
\index{pattern clause!optional truth value}
(with `\TT{??}' {\em clause-qualifier}\,)
must end with a syntax variable $v$ in parenthesis,
and this variable is treated specially in the following ways.
First, the equations:
\begin{center}
\tt
\begin{tabular}{l}
$v$ :=? false \\
$v$ :=\TILDE{} \$TRUTH-VALUE \\
\$TRUTH-VALUE :=| true | false \\
\end{tabular}
\end{center}
are asserted.
These ensure
that if the {\em optional truth-value pattern clause} is
omitted when its containing {\em pattern} is unfolded,
the variable is given the value `\TT{false}', and also ensure that
the variable is given the value `\TT{true}' or `\TT{false}'.
Second, if the clause appears on the left with its ending `\TT{($v$)}'
missing, instead of `\TT{\{\} :=\TILDE{} $v$}' being asserted,
`\TT{true :=\TILDE{} $v$}' is asserted.  And lastly, if the clause
appears without its ending `\TT{($v$)}' but with `\TT{not}' prefixed,
it is recognized and `\TT{false :=\TILDE{} $v$}' is asserted.

For example, consider the pattern equations:

\begin{center}
\begin{tabular}{r}
\verb/sort x :=~ sort ($X) ~ ascending ($ASCENDING) ??/ \\
\verb/sort x ascending :=~ sort ($X) ~ ascending ($ASCENDING) ??/ \\
\verb/sort x not ascending :=~ sort ($X) ~ ascending ($ASCENDING) ??/ \\
\verb/sort x ascending yes :=~ sort ($X) ~ ascending ($ASCENDING) ??/ \\
\end{tabular}
\end{center}

These all produce the equations:
\begin{center}
\tt
\begin{tabular}{l}
\$ASCENDING :=? false \\
\$ASCENDING :=\TILDE{} \$TRUTH-VALUE \\
\$TRUTH-VALUE :=| true | false \\
\end{tabular}
\end{center}

The first pattern equation produces by the rule for default variables:
\begin{center}
\tt \$ASCENDING :=: false \\
\end{center}

The second pattern equation produces by special rule:
\begin{center}
\tt \$ASCENDING :=: true \\
\end{center}

The third pattern equation produces by special rule:
\begin{center}
\tt \$ASCENDING :=: false \\
\end{center}

The fourth pattern equation produces by normal rules:
\begin{center}
\tt \$ASCENDING :=: yes \\
\end{center}
and since we have
\begin{center}
\tt
\begin{tabular}{l}
\$ASCENDING :=\TILDE{} \$TRUTH-VALUE \\
\$TRUTH-VALUE :=| true | false \\
\end{tabular}
\end{center}
we deduce
\begin{center}
\tt
\begin{tabular}{l}
yes :=\TILDE{} \$TRUTH-VALUE \\
\$TRUTH-VALUE :=| true | false \\
\end{tabular}
\end{center}

which is inconsistent.

\subsubsection{Repeated Pattern Clauses}
\label{REPEATED-PATTERN-CLAUSES}

When a pattern is unfolded, a syntax variable in a
repeated or optional repeated pattern clause is replaced
in the unfolded pattern by new variables that represent elements of a list,
and a new syntax equation setting the original variable to this list
is created.  For example, when the pattern in the equation

\begin{center}
\begin{tabular}{rcl}
\verb/increment x by 5 by 10/ & \TT{:=\TILDE}
			      & \verb/increment ($X) ~ by ($Y) ...?/ \\
\end{tabular}
\end{center}

is unfolded, the following equations result:

\begin{center}
\begin{tabular}{l}
\verb/increment x by 5 by 10 :=~/ \\
\verb/    increment ($X) by ($(Y 1)) by ($(Y 2))/ \\
\verb/$Y :=: ($(Y 1), $(Y 2))/
\end{tabular}
\end{center}

With an optional repeated pattern clause it is also possible for the
resulting list to be empty.  Thus

\begin{center}
\begin{tabular}{rcl}
\verb/increment x/ & \TT{:=\TILDE}
			      & \verb/increment ($X) ~ by ($Y) ...?/ \\
\end{tabular}
\end{center}

yields

\begin{center}
\begin{tabular}{rcl}
\verb/increment x/ & \TT{:=\TILDE}
			      & \verb/increment ($X)/ \\
\verb/$Y/ & \tt :=: & \verb|()|
\end{tabular}
\end{center}

\subsubsection{Place Holding Syntax Variables}
\label{PLACE-HOLDING-SYNTAX-VARIABLES}

A `\TT{\$\$}' by itself can be used as a syntax variable called
a \lkey{place holding}{syntax variable} that has the special
property that each of its original equation occurrences
is treated as if it were a \underline{different} variable.  The syntax is:

\begin{indpar}
\emlkey{place-holding}{-syntax-variable} ::= \ttkey{\$\$}
\end{indpar}

More specifically, whenever \TT{\$\$} appears in an original
equation, it is replaced by a unique new syntax variable name. 
For example, the pattern equation:

\begin{indpar}
\verb/replace {b} by {5 + c} in (exp 1) :=:/ \\
\verb/    replace ($X) ~ by $$ ~ in $$/
\end{indpar}

is treated as if it were

\begin{indpar}
\verb/replace {b} by {5 + c} in (exp 1) :=:/ \\
\verb/    replace ($X) ~ by ($X.1$) ~ in ($X.2$)/
\end{indpar}

where `\TT{\$X.1\$}' and `\TT{\$X.2\$}' are unique new
syntax variable names created by the RECKON system.




\subsubsection{Evaluated Syntax Variables}
\label{EVALUATED-SYNTAX-VARIABLES}

Syntax variables
take values that are syntax expressions
which are \underline{not} evaluated.  Such syntax variables are called
\lkey{unevaluated}{syntax variables}.  With every unevaluated syntax
variable there can be associated an \key{evaluated syntax variable}
whose name is made by omitting the \TT{\$} from the beginning of the
unevaluated syntax variable name.  Thus \TT{X} is associated with
\TT{\$X} and \TT{X 5} is associated with \TT{\$(X 5)}.  The syntax is:

\begin{indpar}
\emlkey{unevaluated}{-syntax-variable}\label{UNEVALUATED-SYNTAX-VARIABLE}
			\begin{tabular}[t]{rl}
			::= & \TT{\$} {\em capitalized-word }
				as a single lexeme \\
			$|$ & \TT{\$} \TT{(} {\em name} beginning with a
			      {\em capitalized-word } \TT{)} \\
			\end{tabular}
\\[1ex]
\emkey{evaluated-syntax-variable} 
			::= {\em name} beginning with a {\em capitalized-word }
\end{indpar}

Informally, an evaluated syntax variable is assigned the value obtained by
evaluating its associated unevaluated syntax variable's value.  In order
for this to happen, the unevaluated syntax variable must be evaluatable.
This means that its value, a syntax expression, must not contain any
unevaluatable syntax variables.

More formally:

\begin{indpar}
\begin{list}{}{}
\item [\ikey{Evaluatable Definition}{evaluatable definition}:]%
\label{EVALUATABLE-DEFINITION}
An unevaluated
syntax variable \TT{\$}$v$ is evaluatable if a syntax equation
\TT{\$}$v$ \TT{:=:} $e$
has been deduced and every syntax variable in $e$ is evaluatable.
In particular, \TT{\$}$v$ is evaluatable if $e$ does not contain any syntax
variables.

Here $e$ is called the \key{unevaluated value} of \TT{\$}$v$, and
the \lkey{completed}{unevaluated value} of \TT{\$}$v$ is $e$ with all the
syntax variables it contains replaced by their completed unevaluated values.

\item [\ikey{Evaluation Rule}{evaluation rule}:]%
\label{EVALUATION-RULE}
If an evaluated syntax variable $v$ appears in a syntax equation and
its associated unevaluated syntax variable \TT{\$}$v$ is evaluatable,
then the syntax equation $v$ \TT{:=:} $E$ is deduced, where $E$
is the value obtained by evaluating the unevaluated value of
\TT{\$}$v$ in the context
in which the unevaluated value of \TT{\$}$v$ appears.
It is an error if this evaluation has side effects (\pagref{SIDE-EFFECTS}).

In this case $v$ may be replaced by $E$ whereever $v$ appears.
\end{list}
\end{indpar}

For example, given the code

\begin{indpar}\begin{verbatim}
sum ($X) and ($Y) <-- X is a number, Y is a number
    { value = X + Y }
. . . . .
z = sum (1+1) and (5+5)
\end{verbatim}\end{indpar}

the call to `\TT{sum}' in the last line is matched with the definition
of `\TT{sum}' in the first two lines giving rise to a number of deduced
equations, among which are:

\begin{center}
\begin{tabular}{l}
\verb/sum (1+1) and (5+5) :=~ sum ($X) and ($Y)/ \\
\verb/$X :=: (1+1)/ \\
\verb/$Y :=: (5+5)/ \\
\verb/X :=: 2/ \\
\verb/Y :=: 10/ \\
\end{tabular}
\end{center}

The last two equations are required to deduce the value of the evaluated
variables \TT{X} and \TT{Y} that are needed for the guards
\TT{X is a number} and \TT{Y is a number} and the block code statement
`\TT{value = X + Y}'.  These last two equations are obtained by
the Evaluation Rule.  For example, to obtain the value \TT{2} for the
evaluated variable \TT{X}, the value `\TT{(1+1)}' of the a associated
unevaluated variable \TT{\$X} is evaluated.  `\TT{(1+1)}' is
evaluatable because it contains no syntax variables and for this reason is
also its own `completed unevaluated value'.

Semantically, evaluated syntax variables are not permitted in patterns.
However, syntactically they can be placed in patterns according to the
following:

\begin{indpar}
\begin{list}{}{}
\item [\ikey{Evaluated Variable Promotion Rule}%
{evaluated variable!promotion rule}:]%
\label{EVALUATED-VARIABLE-PROMOTION-RULE}
If an evaluated syntax variable $v$ appears in an expression definition
in places where only an unevaluated syntax variable can appear
(e.g., in patterns or the left sides of default and alternative
equations), it is
replaced in these places by its associated unevaluated variable
\TT{\$}$v$ when the expression definition is initially copied,
provided the unevaluated \TT{\$}$v$ does not appear \underline{anywhere}
in the expression definition.  Note that in places where it is ambiguous
whether an evaluated or unevaluated variable is intended, the evaluated
variable will be used.

If an unevaluated syntax variable \TT{\$}$v$ appears anywhere in
an expression definition, its associated evaluated syntax variable $v$
is \underline{never} replaced by \TT{\$}$v$, and therefore the evaluated
variable $v$ must not appear anywhere an evaluated syntax variable
cannot appear.
\end{list}
\end{indpar}

For example, the definition

\begin{indpar}\begin{verbatim}
for every counter:
    on increment THIS ~ by Y ? <-- Y is a number, Y :=? 1:
        next count = count + Y
\end{verbatim}\end{indpar}

is treated as if it were

\begin{indpar}\begin{verbatim}
for every counter:
    on increment $THIS ~ by $Y ? <-- Y is a number, $Y :=? 1:
        next count = count + Y
\end{verbatim}\end{indpar}

while the definition

\begin{indpar}\begin{verbatim}
for every counter:
    on increment THIS ~ by Y ? <-- Y is a number, $Y :=? 1:
        next count = count + Y
\end{verbatim}\end{indpar}

would be in error because \TT{Y} is used in the pattern but
\TT{\$Y} is used in the default equation.

\subsubsection{Guards}
\label{GUARDS}

A \key{guard} is an expression definition qualifier that
can be any of the following:
\begin{enumerate}
\item An expression.  The expression must evaluate
to \TT{true} if its containing expression definition is to
match.

If the Evaluated Variable Promotion Rule is using used for
a variable in such a guard, it is assumed that the variable
is unevaluated.

For example, in
\begin{indpar}\begin{verbatim}
for every counter:
    on increment $THIS ~ by $Y ?
            <-- Y is a number, $Y :=? 1:
        next count = count + Y
\end{verbatim}\end{indpar}

the expression `\TT{Y is a number}' is a guard.

\item
A syntax or pattern equation.  The equation is asserted.

If the Evaluated Variable Promotion Rule is using used for
a variable in such a guard, it is assumed that the variable
is unevaluated.

If the left side of a pattern equation consists of just a single
syntax variable, or is an object with list element that is a syntax variable,
these syntax variables must be replaced by their
values before the pattern equation is processed.
If processing gets to the point where this is no longer possible,
the pattern equation is inconsistent.

For example, in
\begin{indpar}\begin{verbatim}
    sort ($X) ($D) <-- $D :=~ $DIRECTION,
        $DIRECTION :=| ascending | descending
\end{verbatim}\end{indpar}

the pattern equation `\TT{\$D :=\TILDE{} \$DIRECTION}' is a
pattern equation guard that cannot be processed untion \TT{\$D} is
given a value.

\end{enumerate}

\subsection{The Expression Matching Algorithm}
\label{EXPRESSION-MATCHING-ALGORITHM}

The \key{evaluation algorithm} inputs an expression to be evaluated
and a context.  The context (\secref{CONTEXTS}) provides a list of expression
definitions that may match the expression.  Evaluating the expression
requires searching contexts for expression definitions that match the
expression.

An expression to be evaluated may contain syntax variables that are assigned
values during matching.  The result of matching is both a list of values for
the expression and an assignment of values for these variables.

More than one definition may match an expression.  Different matchings
may lead to different expression values and values of syntax variables
in the expression.

Note that evaluations of guards and evaluations
used to find values of evaluated syntax variables are required to have
no side effects, so the order of these evaluations does not matter.
Given the choices of which definitions are matched to which expressions,
the outcome of the matching process is uniquely determined, and does not
depend on the order of syntax equation deductions, guard evaluations, etc.,
or on the order in which the choices are tried.

Matching may be done in any of the following \skey{matching mode}s:

\begin{list}{}{}

\item[\ttkey{first-value}]~\\
The first definition tried that successfully matches is the only one
used.  Definitions are tried in the order they are given in the contexts
used in evaluation.

\item[\ttkey{all-values}]~\\
All possible choices are tried and the
successful results are collected in a set of results.  Each result
in this set consists of a value for the expression being evaluated
and values for each syntax variable in that expression.

\item[\ttkey{consistent-values}]~\\
All possible choices are tried and the
successful results are collected in a set of results.  Then these results
are tested to see if they are pairwise equal.
All the values of the expression
being evaluated must be equal, and all the values of each syntax variable
contained in the expression must be equal.  If all expression values are
equal and all values of any syntax variable are equal,
one expression value
is returned as the value of the expression, and one syntax variable value
is returned as the value of each syntax variable.
If some of the expression values or syntax variable values are unequal, an
error value giving the context of the evaluation and the unequal values
or values is returned as the value of the expression or syntax variable.

\end{list}

If the expression match search process yields no matches at all,
the expression is given the value `\TT{false}', and variables in the
expression are not given any values.

\subsection{Contexts}
\label{CONTEXTS}

An expression is evaluated in a context.  The context is searched
for an expression definition whose pattern matches the expression being
evaluated, and that definition is then used to evaluate the expression.

A \key{context} is either a list or a set of expression definitions and
other contexts.  Context elements that are expression definitions are
matched to the expression being evaluated.  Context elements that are
themselves contexts are searched recursively.

\ikey{Context lists}{list!context}
\label{CONTEXT-MODE}
are searched in order if the
matching mode is \TT{first-value}, and are searched exhaustively
otherwise.
\ikey{Context sets}{set!context} are always searched exhaustively.

There is a \key{current context} which is the value of the
global variable `\ttkey{CURRENT CONTEXT}'.

An expression definition is an object (\pagref{OBJECT})
that consists of a pattern, an optional list of qualifiers,
and an optional block.  An
{\em expression-definition} (\pagref{EXPRESSION-DEFINITION})
computes an expression definition.  More specifically, the
top level operator of an {\em expression-definition} is \TT{<-{}-}
and this returns an expression definition object.

An {\em expression-definition} given by itself adds the
expression definition it computes to the beginning
of the current context.

The expression
\begin{indpar}
\ttkey{a context}
\end{indpar}
computes a new context.  Contexts are lists of expression
definitions, other contexts, and context marks.  The expression
\begin{indpar}
\ttkey{a context mark}
\end{indpar}
computes a new context mark.

The statements
\begin{indpar}
\ttmkey{add}{to context} {\em expression-definition} \TT{to}
    {\em context} \{ \TT{beginning} $|$ \TT{end} \}\QMARK{} \\
\ttmkey{add}{to context} {\em context} \TT{to}
    {\em context} \{ \TT{beginning} $|$ \TT{end} \}\QMARK{} \\
\ttmkey{add}{to context} {\em context-mark} \TT{to}
    {\em context} \{ \TT{beginning} $|$ \TT{end} \}\QMARK{}
\end{indpar}
add elements to the context beginning or end, where the
default is to add to the \underline{beginning} (which is searched first).
The statement
\begin{indpar}
\ttmkey{pop}{from context} {\em context-mark} \TT{from}
    {\em context} \{ \TT{beginning} $|$ \TT{end} \}\QMARK{}
\end{indpar}
removes elements from the context beginning or end until the
context mark is removed.  The default is to remove from the beginning.
It is an error if the context mark is not an element of the context.

Contexts are like files, and can be read-write, read-only, or
write-only.  They can also be treated as lists or sets when
searched (\pagref{CONTEXT-MODE}).  These context attributes
can be changed by the statement
\begin{indpar}
\ttmkey{make}{context} {\em context} {\em context-mode} \\
\emkey{context-mode} \begin{tabular}[t]{@{}cl}
                     ::= & \ttmkey{READ-WRITE}{context mode} \\
                     $|$ & \ttmkey{READ-ONLY}{context mode} \\
                     $|$ & \ttmkey{WRITE-ONLY}{context mode} \\
                     $|$ & \ttmkey{SET-SEARCH}{context mode} \\
                     $|$ & \ttmkey{LIST-SEARCH}{context mode} \\
		     \end{tabular}
\end{indpar}



The list of context elements
can be copied from the context object by

\begin{indpar}
\TT{the} \ttmkey{list}{of context} \TT{of} {\em context}
\end{indpar}

The result is a list object whose elements are expression definition,
context, and context marker objects.  This list object is not
part of the context object, and changing this list does not change
the context object.

\section{Blocks}
\label{BLOCKS}

A block is a set of variables, values for some of the variables, and
code for computing these values.  Blocks are optional parts of
{\em expression-definitions} (\secref{EXPRESSION-DEFINITION}).

\subsection{Block Syntax}
\label{BLOCK-SYNTAX}

The code of a block has the following syntax:

\begin{indpar}
\emkey{block} ::= {\em bip} {\em group}
                         \{ {\em sequence-break} {\em group} \}\STAR{}
			 {\em eip}
\\[1ex]
\emkey{sequence-break} ::=
    \begin{tabular}[t]{@{}l@{}}
    {\em bll} \ttkey{-{}-{}-{}-{}-}\TT{-}\STAR{} {\em ell} \\
    (a logical line containing 1 word
     consisting of 5 or more \TT{-}'s)
    \end{tabular}
\\[1ex]
\emkey{group} ::= {\em declaration-group} $|$ {\em statement-group}
			 \\[1ex]
\emkey{declaration-group}\label{DECLARATION-GROUP} ::= {\em declaration}\PLUS{}
\\[1ex]
\emkey{statement-group} ::= {\em statement}\PLUS{}
\\[1ex]
\emkey{declaration} ::= {\em bll} {\em expression-definition} {\em ell}
\\[1ex]
\emkey{expression-definition} ::= see \pagref{EXPRESSION-DEFINITION} \\[1ex]
\emkey{statement} ::=
    {\em bll} {\em statement-qualifier}\QMARK{} {\em unqualified-statement}
    {\em ell}
\label{STATEMENT}
\\[1ex]
\emkey{statement-qualifier} ::= \ttkey{first}
			    $|$ \ttkey{always}
			    $|$ \ttkey{default}
\\[1ex]
\emkey{unqualified-statement}
    \begin{tabular}[t]{rl}
    ::= & {\em variable-assignment-statement} \\
    $|$ & {\em variable-assignment-subblock} \\
    $|$ & {\em pattern-assignment-statement} \\
    $|$ & {\em guarded-statement}
    \end{tabular}
\\[1ex]
\emlkey{variable}{-assignment-statement} \\
\hspace*{0.5in}
	\begin{tabular}[t]{rl}
	::= & {\em output-variable} \ttmkey{=}{in assignment}
	      {\em value-expression} \\
	$|$ & \TT{(} {\em output-variable}
	             \{ \TT{,} {\em output-variable} \}\STAR{} \TT{)}
	      \ttkey{=} {\em value-expression} \\
	\end{tabular}
\\[1ex]
\emlkey{variable}{-assignment-subblock} \\
\hspace*{0.5in}
	\begin{tabular}[t]{rl}
	::= & {\em output-variable} \ttmkey{=}{in assignment}
	      {\em temporary-subblock} \\
	$|$ & \TT{(} {\em output-variable}
	             \{ \TT{,} {\em output-variable} \}\STAR{} \TT{)}
	      \ttkey{=} {\em temporary-subblock} \\
	\end{tabular}
\\[1ex]
\emkey{value-expression} ::= {\em expression} ~~~~~ [see \pagref{EXPRESSION}]
\\[1ex]
\emkey{output-variable} ::= {\em variable-name} $|$ {\em next-variable}
\\[1ex]
\emkey{next-variable} ::= \ttkey{next} {\em variable-name}
\\[1ex]
\emkey{variable-name} ::= {\em name} ~~~~~ [see \pagref{NAME}]
\\[1ex]
\emlkey{pattern}{-assignment-statement} ::=
	{\em pattern}~~\TT{\TILDE=:}\index{~=:@{\TT{\TILDE=:}}}~~%
	{\em value-expression}
\\[1ex]
{\em pattern} ::= see \pagref{PATTERN} \\[1ex]
\emkey{temporary-subblock} ::= \TT{:} {\em block}
\\[1ex]
\emkey{guarded-statement} ::=
      {\em if-statement} $|$ {\em when-statement}
\\[1ex]
\emkey{if-statement} ::=
      \begin{tabular}[t]{l}
      \ttkey{if}~~{\em guard}~~{\em permanent-subblock} \\
      \{ {\em ell}~~{\em bll}~~%
         \ttkey{else if}~~{\em guard}~~{\em permanent-subblock} \}\STAR{} \\
      \{ {\em ell}~~{\em bll}~~%
         \ttkey{else}~~{\em permanent-subblock} \}\QMARK{} \\
      \end{tabular} \\[1ex]
\emkey{when-statement} ::=
      \ttkey{when}~~{\em guard}~~{\em permanent-subblock} \\[1ex]
\emkey{guard} ::= {\em value-expression} $|$ {\em assignment-statement}
\\[1ex]
\emkey{permanent-subblock} ::= \TT{:} {\em block}
\end{indpar}

\subsection{Block Variables}
\label{BLOCK-VARIABLES}

In order to evaluate a block, the variables of a block
must be identified.  These have
{\em variable-names} that are one of the following:
\begin{enumerate}
\item
{\em Variable-names} \mkey{inherited}{variable-name}
from a {\em expression-definition} containing the block.
\item
{\em Output-variables} in {\em assignment-statements}.
\item
Syntax variables in the {\em patterns} of
{\em pattern-assign\-ment-statements}.
\item
The evaluated syntax variable names associated with unevaluated syntax
variable names that name block variables.
\end{enumerate}
All block variables are one of these kinds of variables.

If a {\em name} that is not the {\em variable-name} of a block variable
appears in a {\em value-expression}, that {\em name} does not
name a block variable, and it must be
defined by matching it to an expression definition in the block context.

For example, in

\begin{indpar}[1in]
\verb|sum from X through Y| \\
\verb|        <--- X is an integer, Y is an integer:| \\
\verb|    |{\em block}
\end{indpar}

the variable names \TT{X} and \TT{Y} are inherited by the {\em block}
and name block variables.

As another example, in

\begin{indpar}[1in]\begin{verbatim}
when y = sort x:
    z = first 
\end{verbatim}\end{indpar}

\TT{y} and \TT{z} are {\em output-variables} and therefore name
block variables.

As a last example, in

\begin{indpar}[1in]\begin{verbatim}
$X + $Y ~=~ `5 + ( 7 * y )'
\end{verbatim}\end{indpar}

the variable names \TT{\$X} and \TT{\$Y} are pattern syntax variable names
that name block variables.  The associated evaluated syntax variable names
`\TT{X}' and `\TT{Y}' also name block variables.

Variables of a {\em permanent-subblock} are also variables of
that subblock's containing block.  For example, in:
\begin{indpar}[1in]\begin{verbatim}
if X < 5:
    z = X + 10
\end{verbatim}\end{indpar}
the variable \TT{z} is a variable of both the permanent subblock and
a variable of its containing block (that includes the `\TT{if}' statement).

Variables of a {\em temporary-subblock} are \underline{not}
also variables of that subblock's containing block, unless they
are {\em output-variables} of the containing block's
{\em variable-assignment-subblock} statement that conains the
subblock.  For example, in:
\begin{indpar}[1in]\begin{verbatim}
z =:
    w = X + 10
    z = w - 5
    y = w + 5
\end{verbatim}\end{indpar}
the variable \TT{z} is a variable of both the temporary subblock
and its containing block (and is the same variable named as an
output variable in two places), but the variables \TT{w} and 
and \TT{y} are variables of the subblock but \underline{not}
variables of its containing block.

To avoid confusion, variables of a {\em temporary-subblock}
that are \underline{not} also variables of its containing
block may not have the same names as variables of the containing block.

\subsection{Block Evaluation}
\label{BLOCK-EVALUATION}

Block evaluation proceeds according to the following rules:

\begin{enumerate}

\item
\ikey{Blocks}{block!evaluation}
are divided into \ikey{groups}{group!evaluation} by \skey{sequence-break}s.
The {\em groups} are evaluated in order: each group being completely
evaluated before the next group is evaluated.  No part of a {\em group}
can evaluate until all previous {\em groups} of the block have completely
finished evaluating.  Once a {\em group} starts to evaluate, no part of
a previous {\em group} can evaluate.

A {\em block} terminates when its last group terminates.

\item
The \ikey{declarations}{declaration!evaluation} of a
\mkey{declaration-group}{evaluation} are evaluated in order.  Evaluation of a
{\em declaration} just adds its definition to the current context.
The {\em declaration-group} terminates when its last {\em declaration}
has evaluated.

\item
Evaluation within a \mkey{statement-group}{evaluation}
is driven by availability of variable values,
and not by the order of the {\em statements} in the group.

\item
Each \key{block variable} (see \itemref{BLOCK-VARIABLES}) can be assigned at most one value: it is
an error if the variable is assigned a value more than once during
a block evaluation, even if all the values assigned are the same.

\item
Block variables named in an {\em value-expression}
are called \skey{input-variable}s.
Each {\em value-expres\-sion} in a {\em statement-group}
is evaluated \underline{only after all} its input variables have be
given values.

\item
Input variables named in {\em value-expressions} within a
subblock that are not block variables of the
subblock are called `\key{inherited-variables}'.
Each {\em temporary-subblock} in a {\em statement-group}
is evaluated \underline{only after all} its inherited variables have be
given values.

\item
The {\em output-variables} in a {\em variable-assignment-statement}
are given values as soon as the {\em value-expression} of the
statement is evaluated.

\item
The {\em output-variables} in a {\em variable-assignment-subblock}
are given values by name in the {\em temporary-subblock}.  For example,
in:

\begin{indpar}\begin{verbatim}
  z =:
      y = 5
      x = 6
      z = x + y
\end{verbatim}\end{indpar}

the two instances of the {\em variable-name} \TT{z} refer to the same
block variable, which is set by the statement `\TT{z = x + y}'.

\item
The {\em pattern-variables} in a {\em pattern-assignment-statement}
are given values as soon as the {\em value-expression} of the
statement is evaluated.

\item
None of the statements in an {\em if-statement}'s first
{\em permanent-subblock} are
evaluated until the block's {\em guard} has been evaluated to true.
If the guard evaluates to false, no statement in the
{\em permanent-subblock} is ever evaluated.

An `\TT{else if}'
{\em guard} is not evaluated until all {\em guards} preceeding it
in the {\em if-statement} have been evaulated to false.
The {\em permanent-subblock} following an `\TT{else if}' {\em guard}
is not evaluated until the {\em guard} is evaluated to true.

The {\em permanent-subblock} following an `\TT{else}'
is not evaluated until
all {\em guards} preceeding it in the {\em if-statement}
have been evaluated to false.

An example application of these rules is:

\begin{indpar}\begin{verbatim}
  z = y1
  z = y2
  if X > 5:
    y1 = 9
  else:
    y2 = 10
\end{verbatim}\end{indpar}

where \TT{X} is an inherited variable name.  If \TT{X > 5} is true,
the variable \TT{y1} is given the value \TT{9} and then
\TT{z} is given this value, while the variable \TT{y2}
is never given a value.  If \TT{X > 5} is false,
the variable \TT{y2}
is given the value \TT{10} and then \TT{z} is given this
value, while the variable \TT{y1} is never given a value.

\item
A {\em when-statement} is just like an {\em if-statement} that has
no `\TT{else if}' or `\TT{else}' parts.

\item
A {\em statement-group} terminates when all the
{\em value-expressions} in it (and its subblocks)
have either been evaluated or
cannot be evaluated because of lack of an input variable value or
because of {\em guards}.
Once a {\em statement-group}
terminates, no part of the group can be evaluated, even if another group
later in the block defines that part's input variables.

However, {\em statement-group}
evaluation is additionally modified by {\em statement-qualifiers}:
see Default Statements \secref{DEFAULT-STATEMENTS}
and Iteration \secref{ITERATION}.

\item
When a block that is not a subblock
terminates, the \mkey{value}{of block} of the block is the
value of its \TT{value} variable\index{value variable@\TT{value} variable},
if any.  Thus a one-statement block

\begin{indpar}
\verb|value = X + Y|
\end{indpar}

which inherits the variables \TT{X} and \TT{Y} will return
the sum of its inherited variables as the value of the block.

If a block that is not a subblock
finishes without producing a value for a variable named
\TT{value}, the value of the block is \ttmkey{true}{block value}.

\end{enumerate}

\subsection{Default Statements}
\label{DEFAULT-STATEMENTS}

The \ttkey{default} {\em statement-qualifier} modifies {\em statement-group}
execution.  A statement qualified by \TT{default}
is called a \key{default statement}.  Default statements in a
{\em statement-group}
are initially inactive, meaning that they are treated as if they do not exist,

If execution of a {\em statement-group} gets to the point where there
is \underline{no possibility} of \underline{any} of the variables
set by a default statement receiving a value from another statement,
then the default statement is activated.

The `\TT{default}' qualifier may only be applied to {\em assignment-statements},
and not to {\em guarded-statements}.
A block variable may be a settable by at most one default statement in
the block.

An example application of these rules is:

\begin{indpar}\begin{verbatim}
if x > 5:
    value = `true'
default value = `false'
\end{verbatim}\end{indpar}

If \TT{x} gets the value \TT{6}, then `\TT{value}' is set to `\TT{true}'.
If \TT{x} gets the value \TT{4}, then `\TT{value}' is set to `\TT{false}'.
If execution gets to the point where \TT{x} cannot ever be given a
value, then `\TT{value}' is set to `\TT{false}'.

The proof that a variable like \TT{x} can never get a value is
conservative.  For example, in:
\begin{indpar}\begin{verbatim}
if x > 5:
    y = 10
if y > 5:
    x = 10
default x = 8
default y = 8
\end{verbatim}\end{indpar}

one can prove that \TT{x} never gets a value only if one can prove
that \TT{y} never gets a value, and vice versa.  As a consequence
one can never prove either, and both default statements never activate.

\subsection{Iteration}
\label{ITERATION}

A block can \key{iterate}, meaning that it generates another block
that is the next block in a sequence of blocks.  A block
iterates if it produces a value for a block {\em next-variable},
which is a block variable whose name has the form `\TT{next} $V$'
for some ordinary variable name $V$.

The blocks in the sequence are called the
\skey{iteration}s of the original {\em block}.
Evaluation of a block can always
be thought of as producing a sequence of iterations, though this
sequence might include only one block which does not iterate.

The value of `\TT{next} $V$' in a block iteration becomes the
value of $V$ in the block's next iteration.

A block that is going to iterate terminates only after
\underline{all} the block's {\em next-variables} have been given values.
The next iteration of the block
begins only after the previous iteration terminates.

Note that a {\em next-variable} output in a {\em permanent-subblock}
is actually a block variable of the containing block, whereas
a {\em next-variable} output in a {\em temporary-subblock} is
a block variable of the subblock, and not its containing
block, unless it is named as an
{\em output-variable} of the {\em variable-assignment-subblock}
statement containing the subblock.  So {\em permanent-subblocks}
can never iterate, though their containing blocks can,
while {\em temporary-subblocks} can iterate.

A {\em next-variable} is named by a {\em variable-name} preceded by
the `\ttkey{next}' keyword.  A {\em next-variable}
is effectively a new variable with a name derived from the
{\em variable-name}.  We will used the notation `\TT{next }$V$'
to denote the {\em next-variable} made from the variable name $V$.
The value of \TT{next }$V$ at the end of execution of the
current block iteration becomes the value of $V$ at the beginning
of execution of the next block iteration.  In order for there to be
a next iteration, the current iteration must compute the value of
some {\em next-variable}.

{\em Next-variables} can be both output and input variables.
When used as input variables they are just like other input variables.
The \TT{next} unary operator can be applied to an expression that does not
consist solely of a {\em variable-name}.  When this is done, it is
as if the \TT{next} keyword had instead been prefaced to every
{\em variable-name} in the expression.  Thus `\TT{next(x+y)}' is
the equivalent of `\TT{next x + next y}'.

If a default statement outputs a {\em next-variable}, the statement
cannot become active unless some other {\em next-variable} has already
been given a value.  Thus the decision to iterate cannot be made inside
a default statement.

If a {\em next-variable} is given the value of
the expression `\ttkey{UNDEFINED}',\label{UNDEFINED}
the variable will become undefined
at the beginning of the next iteration.
The expression `\TT{UNDEFINED}' cannot be used to set a
non-{\em next-variable}.

A \ttkey{first} qualified {\em statement} is only visible in the
first iteration of a block iteration sequence.

An \ttkey{always} qualified {\em statement} is equivalent to the {\em statement}
qualified by \TT{first} plus additional {\em statements} of the form

\begin{center}
\verb|default next |$V$\verb| = |$V$
\end{center}

for every {\em variable-name} $V$ that can be assigned by the
\TT{always} qualified {\em statement}.  Thus the
\TT{always} qualified {\em statement} will assign values on the first
iteration, and these values will then be propagated to subsequent iterations.


\section{Descriptions}
\label{DESCRIPTIONS}

A description is a typed block that can be used as a value.
A description is an object with a type that inherits code from its type.

An \key{description} can be created by an {\em description-expression}:

\begin{indpar}
\emkey{description-expression} ::=
       \{ \ttkey{a} $|$ \ttkey{an} \} {\em type-name}
		              \{ \TT{:} {\em block} \}\QMARK{} \\[1ex]
\emkey{type-name} ::= {\em name} ~~~~~ [see \pagref{NAME}]
\end{indpar}

The {\em block} executes and the block variables it gives values to
become \skey{component}s of the description.
These components can be retrieved by expressions of the form:

\begin{indpar}
\emkey{component-expression} ::=
    \ttmkey{the}{the of@\TT{the} \ldots \TT{of}}
    {\em variable-name}
    \ttmkey{of}{the of@\TT{the} \ldots \TT{of}}
    {\em description}
\end{indpar}

where {\em variable-name} names a component of the {\em description}.

Description components can be updated by
expressions such as:

\begin{indpar}
\emlkey{description}{-update-expression} ::=
    \ttmkey{for}{description update}
    {\em description} \TT{:} {\em block}
\end{indpar}

Here the {\em block} inherits existing components of the {\em description}
and may add new components.  The {\em block} in a
{\em description-update-expression} may also define `\skey{update variable}s'
that have names of the form `\TT{update} $v$'.  When the {\em block}
terminates, if it has given a value to a block variable with such a name,
the value becomes the new value of description component $v$.
The one exception is the block variable `\TT{value}', which if
given a value becomes the value of the {\em description-update-expression}.

Code can be added to a description type by:
\begin{indpar}
\emkey{type-update-statement} ::=
    \ttmkey{for every}{type update}
    {\em type-name} \TT{:} {\em block}
\end{indpar}

The block is added to the description type and any statement group
in the block is immediately executed for every existing description
of the type.  Statement groups of a description type are also executed
for a new description immediately after any {\em description-expression}
block is executed.


Alternative syntax is usually used for creating and updating descriptions.

For creating descriptions, a `\key{constructor}' can be defined that
is a function whose {\em expression-definition} begins with a
{\em pattern-term} of the form:
\begin{center}
\{ \TT{a} $|$ \TT{an} \} ~ {\em type-name} ~ {\em bracketed-pattern}\STAR{}
\end{center}

When a constructor's {\em block} executes, it must not set the
`\TT{value}' variable.  At the end of the block excution, a description
of the given type will be created and returned as the value of the
block.  The variables of the block will be the components of the
description.  A big advantage of constructors over {\em description-expressions}
is that constructors can have arguments that are inherited by the block
that defines the description.

For updating descriptions, `\skey{method}s' can be defined by syntax
of the form:
\begin{center}
\begin{tabular}{l}
\TT{for every} ~ {\em type-name} ~ \TT{:} \\
\verb|    |\TT{on} ~ {\em expression-definition}
\end{tabular}
\end{center}

The {\em expression-definition} must have the evaluated syntax argument
\TT{THIS} in its {\em expression-\EOL de\-fi\-ni\-tion} {\em pattern}.  

The {\em expression-definition} defines a function, but differs from
the usual function definition as follows.  First, the definition
implicitly has the qualifier
\begin{center}
\TT{THIS is a} ~ {\em type-name}
\end{center}
Second, when the function {\em block} executes, it behaves as if it
were the block in a
\begin{center}
\TT{for} ~ {\em type-name}\TT{:} {\em block}
\end{center}
{\em description-update-expression}.  It inherits the components of
the \TT{THIS} argument description, and can compute `\TT{update} $v$'
variables that update these components.  A big advantage of
methods over {\em description-update-expressions} is that methods
can have arguments that are inherited by the block that updates
the description.

\subsection{Arrays}
\label{Arrays}

[TBD: Arrays are descriptions plus a vector;
array element names are syntactic sugar.]

\section{Side Effects}
\label{SIDE-EFFECTS}

A \key{side effect} is an action that changes memory, inputs information from
the outside world, or outputs information to the outside world.
When an expression is evaluated, it may or may not have side effects.

The order in which side effects are executed is determined by
{\em sequence-breaks} that divide a {\em block} into {\em groups}
further (\secref{BLOCK-EVALUATION}).  A programmer typically writes code
so there is at most one side effect per {\em group}, in order to
ensure side effects execute in the desired order.

TBD: could this last rule be enforced.

The \key{side effect mode} controls the execution of side effects.
It has three settings: \TT{execute}, \TT{delay}, and \TT{error}.
In \ttkey{execute mode} a side effect simply executes.  In
\ttkey{error mode} an attempt to execute a side effect raises an error,
and the side effect is not executed.

In \ttkey{delay mode} input and memory change side effects execute,
but put operations on an \TT{undo} list that can undo their effects,
while output side effects do not execute, but are instead put on a
\TT{todo} list.

There are two lists maintained that permit side effects to be delayed
or undone.  The \ttmkey{todo}{list} list is a list of delayed output
actions that have been delayed.  The \ttmkey{undo}{list} list is
a list of input and memory change actions that can be undone.
The position of these lists can be recorded and an undo
operation can be performed that backs up to previously recorded positions
by deleting actions from the end of the \TT{todo} list and undoing
actions on the end of the \TT{undo} list.

To control the side effect mode there is a \key{side effect mode stack}.
This contains items each of which contains a side effect mode and
positions in the \TT{todo} and \TT{undo} stacks.  The side effect mode
of the top item on the side effect mode stack is the effective side
effect mode for current execution.
Whenever an item is pushed to the side effect mode stack, the current
positions of the \TT{todo} and \TT{undo} lists are recorded in the
item.

The following statements operate on the side effect mode stack:

\begin{list}{}{}
\item[\ttlkey{begin executing}{side effects}]~~~Push a new item with side effect
execute mode onto the side effect mode stack.  Before the push the
stack must be empty or the top item in the stack must have execute or
error mode.

\item[\ttlkey{end executing}{side effects}]~~~Pop the top item from
the side effect mode stack.  This top item must have
execute mode.

\item[\ttlkey{begin forbidding}{side effects}]~~~Push
a new item with side effect
error mode onto the side effect mode stack.  Before the push the
stack must be empty or the top item in the stack must have execute or
error mode.

\item[\ttlkey{end forbidding}{side effects}]~~~Pop the top item from the
side effect mode stack.  This top item must have
error mode.

\item[\ttlkey{delay}{side effects}]~~~Push a new item with side effect
delay mode onto the side effect mode stack.

\item[\ttlkey{commit}{side effects}]~~~Pop the top item from the
side effect mode stack.  This top item must have
delay mode.  It the resulting stack has a new top item that is not
delay mode, discard the contents of the \TT{undo} stack, and execute
and then discard the contents of the \TT{todo} stack.

\item[\ttlkey{abort side}{effects}]~~~Pop the item from the
the side effect mode stack.  This top item must have
delay mode.  Consider the \TT{todo} and \TT{undo} list positions
of the new item at the top of the stack, or take these positions to be
the beginning of the lists if the stack has become empty.  Remove
elements from ends of the lists until these considered positions become
the current list positions.  When removing an element from the end of the
\TT{undo} list, perform the undo action specified by the element.

\end{list}

\section{Debugging}

Design:

Debugging is based on the notion that almost all
RECKON programs will run quickly.
Input checkpointing is used to record all inputs to a computation
so the computation can be deterministically rerun.  Detailed
traces can be generated which explain for each value how it was generated.
Values have a sequence number that identifies the point in the execution
where they were generated.  It is therefore possible to ask for a detailed
accounting of how any value was generated, provided the run is short enough
to be repeated once or a few times so the computer can turn the history
tracing on appropriately.

\section{Design Notes}

These are some detailed design rules to be incorporated in the language
definition later.

\begin{list}{}{}

\item
{\bf Blank Algebraic Operators}.
The blank, or missing operator, denotes \TT{*} when it precedes a word,
as in \TT{5x} being equivalent to \TT{5*x}.  When it is between a
preceding integer and a following ratio, it adds the ratio to the integer,
as in \TT{41 1/3}.

\end{list}

\section{To Do}

What about making a variable true if it has ANY value, for the
purposes of a {\em when-statement}?

Describe matrix expression scanning that has no separators.
Maybe it should not recognize operators outside parentheses?

Describe blank lines as paragraph operators in text parsing.

Should temporaries be full-fledged names.

Describe the quote evaluator.\label{QUOTE-EVALUATOR}

Why doesn't `\TT{define qualifier xxx}' mean define expressions equal
to `{qual\-i\-fier\EOL{} xxx}'.

\TT{missing(\#X)} is true if \TT{\#X} is a null node.
\TT{integer(\#X)} is true if \TT{\#X} is an integer.

Qualifier shortcuts should be conditioned on the first words of
the expression being qualified.  E.g., if these words are
`\TT{define operator}' the shortcut `\TT{left => }\TT{with
associativity [left]}' would be defined.

Expressions to be evaluated can have sets of possible values.

Imaginary Units\label{IMAGINARY-UNITS}

Visible Side Effects\label{VISIBLE-SIDE-EFFECTS}

List Objects\label{LIST}

Qualifier Definition\label{QUALIFIER-DEFINITION}

Qualifier Shortcut Definition\label{QUALIFIER-SHORTCUT-DEFINITION}

Automatic Optional Marks\label{AUTOMATIC-OPTIONAL-MARKS}

Describe Garbage Collection\label{GARBAGE-COLLECTION}

Manual Deletion\label{MANUAL-DELETION}, the stub is marked deleted,
and gc's make pointers to the stub either NULL or point them at
a standard deleted object so the deleted stub can be collected.

\bibliographystyle{plain}
\bibliography{reckon}

\printindex

\end{document}

